[
  {
    "index": 1,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/autogpt_platform/backend/backend/server/v2/builder/db.py b/autogpt_platform/backend/backend/server/v2/builder/db.py\nnew file mode 100644\nindex 000000000000..8cdbf9d9d4c7\n--- /dev/null\n+++ b/autogpt_platform/backend/backend/server/v2/builder/db.py\n@@ -0,0 +1,370 @@\n+import functools\n+import logging\n+\n+import prisma\n+\n+import backend.data.block\n+import backend.server.model as server_model\n+from backend.blocks import load_all_blocks\n+from backend.blocks.llm import LlmModel\n+from backend.data.block import Block, BlockCategory, BlockSchema\n+from backend.data.credit import get_block_costs\n+from backend.integrations.providers import ProviderName\n+from backend.server.v2.builder.model import (\n+    BlockCategoryResponse,\n+    BlockData,\n+    BlockResponse,\n+    BlockType,\n+    CountResponse,\n+    Provider,\n+    ProviderResponse,\n+    SearchBlocksResponse,\n+)\n+\n+logger = logging.getLogger(__name__)\n+llm_models = [name.name.lower().replace(\"_\", \" \") for name in LlmModel]\n+_static_counts_cache: dict | None = None\n+_suggested_blocks: list[BlockData] | None = None\n+\n+\n+def get_block_categories(category_blocks: int = 3) -> list[BlockCategoryResponse]:\n+    categories: dict[BlockCategory, BlockCategoryResponse] = {}\n+\n+    for block_type in load_all_blocks().values():\n+        block: Block[BlockSchema, BlockSchema] = block_type()\n+        # Skip disabled blocks\n+        if block.disabled:\n+            continue\n+        # Skip blocks that don't have categories (all should have at least one)\n+        if not block.categories:\n+            continue\n+\n+        # Add block to the categories\n+        for category in block.categories:\n+            if category not in categories:\n+                categories[category] = BlockCategoryResponse(\n+                    name=category.name.lower(),\n+                    total_blocks=0,\n+                    blocks=[],\n+                )\n+\n+            categories[category].total_blocks += 1\n+\n+            # Append if the category has less than the specified number of blocks\n+            if len(categories[category].blocks) < category_blocks:\n+                categories[category].blocks.append(block.to_dict())\n+\n+    # Sort categories by name\n+    return sorted(categories.values(), key=lambda x: x.name)\n+\n+\n+def get_blocks(\n+    *,\n+    category: str | None = None,\n+    type: BlockType | None = None,\n+    provider: ProviderName | None = None,\n+    page: int = 1,\n+    page_size: int = 50,\n+) -> BlockResponse:\n+    \"\"\"\n+    Get blocks based on either category, type or provider.\n+    Providing nothing fetches all block types.\n+    \"\"\"\n+    # Only one of category, type, or provider can be specified\n+    if (category and type) or (category and provider) or (type and provider):\n+        raise ValueError(\"Only one of category, type, or provider can be specified\")\n+\n+    blocks: list[Block[BlockSchema, BlockSchema]] = []\n+    skip = (page - 1) * page_size\n+    take = page_size\n+    total = 0\n+\n+    for block_type in load_all_blocks().values():\n+        block: Block[BlockSchema, BlockSchema] = block_type()\n+        # Skip disabled blocks\n+        if block.disabled:\n+            continue\n+        # Skip blocks that don't match the category\n+        if category and category not in {c.name.lower() for c in block.categories}:\n+            continue\n+        # Skip blocks that don't match the type\n+        if (\n+            (type == \"input\" and block.block_type.value != \"Input\")\n+            or (type == \"output\" and block.block_type.value != \"Output\")\n+            or (type == \"action\" and block.block_type.value in (\"Input\", \"Output\"))\n+        ):\n+            continue\n+        # Skip blocks that don't match the provider\n+        if provider:\n+            credentials_info = block.input_schema.get_credentials_fields_info().values()\n+            if not any(provider in info.provider for info in credentials_info):\n+                continue\n+\n+        total += 1\n+        if skip > 0:\n+            skip -= 1\n+            continue\n+        if take > 0:\n+            take -= 1\n+            blocks.append(block)\n+\n+    costs = get_block_costs()\n+\n+    return BlockResponse(\n+        blocks=[{**b.to_dict(), \"costs\": costs.get(b.id, [])} for b in blocks],\n+        pagination=server_model.Pagination(\n+            total_items=total,\n+            total_pages=total // page_size + (1 if total % page_size > 0 else 0),\n+            current_page=page,\n+            page_size=page_size,\n+        ),\n+    )\n+\n+\n+def search_blocks(\n+    include_blocks: bool = True,\n+    include_integrations: bool = True,\n+    query: str = \"\",\n+    page: int = 1,\n+    page_size: int = 50,\n+) -> SearchBlocksResponse:\n+    \"\"\"\n+    Get blocks based on the filter and query.\n+    `providers` only applies for `integrations` filter.\n+    \"\"\"\n+    blocks: list[Block[BlockSchema, BlockSchema]] = []\n+    query = query.lower()\n+\n+    total = 0\n+    skip = (page - 1) * page_size\n+    take = page_size\n+    block_count = 0\n+    integration_count = 0\n+\n+    for block_type in load_all_blocks().values():\n+        block: Block[BlockSchema, BlockSchema] = block_type()\n+        # Skip disabled blocks\n+        if block.disabled:\n+            continue\n+        # Skip blocks that don't match the query\n+        if (\n+            query not in block.name.lower()\n+            and query not in block.description.lower()\n+            and not _matches_llm_model(block.input_schema, query)\n+        ):\n+            continue\n+        keep = False\n+        credentials = list(block.input_schema.get_credentials_fields().values())\n+        if include_integrations and len(credentials) > 0:\n+            keep = True\n+            integration_count += 1\n+        if include_blocks and len(credentials) == 0:\n+            keep = True\n+            block_count += 1\n+\n+        if not keep:\n+            continue\n+\n+        total += 1\n+        if skip > 0:\n+            skip -= 1\n+            continue\n+        if take > 0:\n+            take -= 1\n+            blocks.append(block)\n+\n+    costs = get_block_costs()\n+\n+    return SearchBlocksResponse(\n+        blocks=BlockResponse(\n+            blocks=[{**b.to_dict(), \"costs\": costs.get(b.id, [])} for b in blocks],\n+            pagination=server_model.Pagination(\n+                total_items=total,\n+                total_pages=total // page_size + (1 if total % page_size > 0 else 0),\n+                current_page=page,\n+                page_size=page_size,\n+            ),\n+        ),\n+        total_block_count=block_count,\n+        total_integration_count=integration_count,\n+    )\n+\n+\n+def get_providers(\n+    query: str = \"\",\n+    page: int = 1,\n+    page_size: int = 50,\n+) -> ProviderResponse:\n+    providers = []\n+    query = query.lower()\n+\n+    skip = (page - 1) * page_size\n+    take = page_size\n+\n+    all_providers = _get_all_providers()\n+\n+    for provider in all_providers.values():\n+        if (\n+            query not in provider.name.value.lower()\n+            and query not in provider.description.lower()\n+        ):\n+            continue\n+        if skip > 0:\n+            skip -= 1\n+            continue\n+        if take > 0:\n+            take -= 1\n+            providers.append(provider)\n+\n+    total = len(all_providers)\n+\n+    return ProviderResponse(\n+        providers=providers,\n+        pagination=server_model.Pagination(\n+            total_items=total,\n+            total_pages=total // page_size + (1 if total % page_size > 0 else 0),\n+            current_page=page,\n+            page_size=page_size,\n+        ),\n+    )\n+\n+\n+async def get_counts(user_id: str) -> CountResponse:\n+    my_agents = await prisma.models.LibraryAgent.prisma().count(\n+        where={\n+            \"userId\": user_id,\n+            \"isDeleted\": False,\n+            \"isArchived\": False,\n+        }\n+    )\n+    counts = await _get_static_counts()\n+    return CountResponse(\n+        my_agents=my_agents,\n+        **counts,\n+    )\n+\n+\n+async def _get_static_counts():\n+    \"\"\"\n+    Get counts of blocks, integrations, and marketplace agents.\n+    This is cached to avoid unnecessary database queries and calculations.\n+    Can't use functools.cache here because the function is async.\n+    \"\"\"\n+    global _static_counts_cache\n+    if _static_counts_cache is not None:\n+        return _static_counts_cache\n+\n+    all_blocks = 0\n+    input_blocks = 0\n+    action_blocks = 0\n+    output_blocks = 0\n+    integrations = 0\n+\n+    for block_type in load_all_blocks().values():\n+        block: Block[BlockSchema, BlockSchema] = block_type()\n+        if block.disabled:\n+            continue\n+\n+        all_blocks += 1\n+\n+        if block.block_type.value == \"Input\":\n+            input_blocks += 1\n+        elif block.block_type.value == \"Output\":\n+            output_blocks += 1\n+        else:\n+            action_blocks += 1\n+\n+        credentials = list(block.input_schema.get_credentials_fields().values())\n+        if len(credentials) > 0:\n+            integrations += 1\n+\n+    marketplace_agents = await prisma.models.StoreAgent.prisma().count()\n+\n+    _static_counts_cache = {\n+        \"all_blocks\": all_blocks,\n+        \"input_blocks\": input_blocks,\n+        \"action_blocks\": action_blocks,\n+        \"output_blocks\": output_blocks,\n+        \"integrations\": integrations,\n+        \"marketplace_agents\": marketplace_agents,\n+    }\n+\n+    return _static_counts_cache\n+\n+\n+def _matches_llm_model(schema_cls: type[BlockSchema], query: str) -> bool:\n+    for field in schema_cls.model_fields.values():\n+        if field.annotation == LlmModel:\n+            # Check if query matches any value in llm_models\n+            if any(query in name for name in llm_models):\n+                return True\n+    return False\n+\n+\n+@functools.cache\n+def _get_all_providers() -> dict[ProviderName, Provider]:\n+    providers: dict[ProviderName, Provider] = {}\n+\n+    for block_type in load_all_blocks().values():\n+        block: Block[BlockSchema, BlockSchema] = block_type()\n+        if block.disabled:\n+            continue\n+\n+        credentials_info = block.input_schema.get_credentials_fields_info().values()\n+        for info in credentials_info:\n+            for provider in info.provider:  # provider is a ProviderName enum member\n+                if provider in providers:\n+                    providers[provider].integration_count += 1\n+                else:\n+                    providers[provider] = Provider(\n+                        name=provider, description=\"\", integration_count=1\n+                    )\n+    return providers\n+\n+\n+async def get_suggested_blocks(count: int = 5) -> list[BlockData]:\n+    global _suggested_blocks\n+\n+    if _suggested_blocks is not None and len(_suggested_blocks) >= count:\n+        return _suggested_blocks[:count]\n+\n+    _suggested_blocks = []\n+    # Sum the number of executions for each block type\n+    # Prisma cannot group by nested relations, so we do a raw query\n+    results = await prisma.get_client().query_raw(\n+        \"\"\"\n+        SELECT\n+            agent_node.\"agentBlockId\" AS block_id,\n+            COUNT(execution.id) AS execution_count\n+        FROM \"AgentNodeExecution\" execution\n+        JOIN \"AgentNode\" agent_node ON execution.\"agentNodeId\" = agent_node.id\n+        GROUP BY agent_node.\"agentBlockId\"\n+        ORDER BY execution_count DESC;\n+        \"\"\"\n+    )\n+\n+    # Get the top blocks based on execution count\n+    # But ignore Input and Output blocks\n+    blocks: list[tuple[BlockData, int]] = []\n+\n+    for block_type in load_all_blocks().values():\n+        block: Block[BlockSchema, BlockSchema] = block_type()\n+        if block.disabled or block.block_type in (\n+            backend.data.block.BlockType.INPUT,\n+            backend.data.block.BlockType.OUTPUT,\n+            backend.data.block.BlockType.AGENT,\n+        ):\n+            continue\n+        # Find the execution count for this block\n+        execution_count = next(\n+            (row[\"execution_count\"] for row in results if row[\"block_id\"] == block.id),\n+            0,\n+        )\n+        blocks.append((block.to_dict(), execution_count))\n+    # Sort blocks by execution count\n+    blocks.sort(key=lambda x: x[1], reverse=True)\n+\n+    _suggested_blocks = [block[0] for block in blocks]\n+\n+    # Return the top blocks\n+    return _suggested_blocks[:count]\ndiff --git a/autogpt_platform/backend/backend/server/v2/builder/model.py b/autogpt_platform/backend/backend/server/v2/builder/model.py\nnew file mode 100644\nindex 000000000000..475010642d59\n--- /dev/null\n+++ b/autogpt_platform/backend/backend/server/v2/builder/model.py\n@@ -0,0 +1,87 @@\n+from typing import Any, Literal\n+\n+from pydantic import BaseModel\n+\n+import backend.server.model as server_model\n+import backend.server.v2.library.model as library_model\n+import backend.server.v2.store.model as store_model\n+from backend.integrations.providers import ProviderName\n+\n+FilterType = Literal[\n+    \"blocks\",\n+    \"integrations\",\n+    \"marketplace_agents\",\n+    \"my_agents\",\n+]\n+\n+BlockType = Literal[\"all\", \"input\", \"action\", \"output\"]\n+\n+BlockData = dict[str, Any]\n+\n+\n+# Suggestions\n+class SuggestionsResponse(BaseModel):\n+    otto_suggestions: list[str]\n+    recent_searches: list[str]\n+    providers: list[ProviderName]\n+    top_blocks: list[BlockData]\n+\n+\n+# All blocks\n+class BlockCategoryResponse(BaseModel):\n+    name: str\n+    total_blocks: int\n+    blocks: list[BlockData]\n+\n+    model_config = {\"use_enum_values\": False}  # <== use enum names like \"AI\"\n+\n+\n+# Input/Action/Output and see all for block categories\n+class BlockResponse(BaseModel):\n+    blocks: list[BlockData]\n+    pagination: server_model.Pagination\n+\n+\n+# Providers\n+class Provider(BaseModel):\n+    name: ProviderName\n+    description: str\n+    integration_count: int\n+\n+\n+class ProviderResponse(BaseModel):\n+    providers: list[Provider]\n+    pagination: server_model.Pagination\n+\n+\n+# Search\n+class SearchRequest(BaseModel):\n+    search_query: str | None = None\n+    filter: list[FilterType] | None = None\n+    by_creator: list[str] | None = None\n+    search_id: str | None = None\n+    page: int | None = None\n+    page_size: int | None = None\n+\n+\n+class SearchBlocksResponse(BaseModel):\n+    blocks: BlockResponse\n+    total_block_count: int\n+    total_integration_count: int\n+\n+\n+class SearchResponse(BaseModel):\n+    items: list[BlockData | library_model.LibraryAgent | store_model.StoreAgent]\n+    total_items: dict[FilterType, int]\n+    page: int\n+    more_pages: bool\n+\n+\n+class CountResponse(BaseModel):\n+    all_blocks: int\n+    input_blocks: int\n+    action_blocks: int\n+    output_blocks: int\n+    integrations: int\n+    marketplace_agents: int\n+    my_agents: int\ndiff --git a/autogpt_platform/backend/backend/server/v2/builder/routes.py b/autogpt_platform/backend/backend/server/v2/builder/routes.py\nnew file mode 100644\nindex 000000000000..57934203892a\n--- /dev/null\n+++ b/autogpt_platform/backend/backend/server/v2/builder/routes.py\n@@ -0,0 +1,227 @@\n+import logging\n+from typing import Annotated, Sequence\n+\n+import fastapi\n+from autogpt_libs.auth.depends import auth_middleware, get_user_id\n+\n+import backend.server.model as server_model\n+import backend.server.v2.builder.db as builder_db\n+import backend.server.v2.builder.model as builder_model\n+import backend.server.v2.library.db as library_db\n+import backend.server.v2.library.model as library_model\n+import backend.server.v2.store.db as store_db\n+import backend.server.v2.store.model as store_model\n+from backend.integrations.providers import ProviderName\n+\n+logger = logging.getLogger(__name__)\n+\n+router = fastapi.APIRouter()\n+\n+\n+# Taken from backend/server/v2/store/db.py\n+def sanitize_query(query: str | None) -> str | None:\n+    if query is None:\n+        return query\n+    query = query.strip()[:100]\n+    return (\n+        query.replace(\"\\\\\", \"\\\\\\\\\")\n+        .replace(\"%\", \"\\\\%\")\n+        .replace(\"_\", \"\\\\_\")\n+        .replace(\"[\", \"\\\\[\")\n+        .replace(\"]\", \"\\\\]\")\n+        .replace(\"'\", \"\\\\'\")\n+        .replace('\"', '\\\\\"')\n+        .replace(\";\", \"\\\\;\")\n+        .replace(\"--\", \"\\\\--\")\n+        .replace(\"/*\", \"\\\\/*\")\n+        .replace(\"*/\", \"\\\\*/\")\n+    )\n+\n+\n+@router.get(\n+    \"/suggestions\",\n+    dependencies=[fastapi.Depends(auth_middleware)],\n+)\n+async def get_suggestions(\n+    user_id: Annotated[str, fastapi.Depends(get_user_id)],\n+) -> builder_model.SuggestionsResponse:\n+    \"\"\"\n+    Get all suggestions for the Blocks Menu.\n+    \"\"\"\n+    return builder_model.SuggestionsResponse(\n+        otto_suggestions=[\n+            \"What blocks do I need to get started?\",\n+            \"Help me create a list\",\n+            \"Help me feed my data to Google Maps\",\n+        ],\n+        recent_searches=[\n+            \"image generation\",\n+            \"deepfake\",\n+            \"competitor analysis\",\n+        ],\n+        providers=[\n+            ProviderName.TWITTER,\n+            ProviderName.GITHUB,\n+            ProviderName.NOTION,\n+            ProviderName.GOOGLE,\n+            ProviderName.DISCORD,\n+            ProviderName.GOOGLE_MAPS,\n+        ],\n+        top_blocks=await builder_db.get_suggested_blocks(),\n+    )\n+\n+\n+@router.get(\n+    \"/categories\",\n+    dependencies=[fastapi.Depends(auth_middleware)],\n+)\n+async def get_block_categories(\n+    category_blocks: Annotated[int, fastapi.Query()] = 3,\n+) -> Sequence[builder_model.BlockCategoryResponse]:\n+    \"\"\"\n+    Get all block categories with a specified number of blocks per category.\n+    \"\"\"\n+    return builder_db.get_block_categories(category_blocks)\n+\n+\n+@router.get(\n+    \"/blocks\",\n+    dependencies=[fastapi.Depends(auth_middleware)],\n+)\n+async def get_blocks(\n+    category: Annotated[str | None, fastapi.Query()] = None,\n+    type: Annotated[builder_model.BlockType | None, fastapi.Query()] = None,\n+    provider: Annotated[ProviderName | None, fastapi.Query()] = None,\n+    page: Annotated[int, fastapi.Query()] = 1,\n+    page_size: Annotated[int, fastapi.Query()] = 50,\n+) -> builder_model.BlockResponse:\n+    \"\"\"\n+    Get blocks based on either category, type, or provider.\n+    \"\"\"\n+    return builder_db.get_blocks(\n+        category=category,\n+        type=type,\n+        provider=provider,\n+        page=page,\n+        page_size=page_size,\n+    )\n+\n+\n+@router.get(\n+    \"/providers\",\n+    dependencies=[fastapi.Depends(auth_middleware)],\n+)\n+async def get_providers(\n+    page: Annotated[int, fastapi.Query()] = 1,\n+    page_size: Annotated[int, fastapi.Query()] = 50,\n+) -> builder_model.ProviderResponse:\n+    \"\"\"\n+    Get all integration providers with their block counts.\n+    \"\"\"\n+    return builder_db.get_providers(\n+        page=page,\n+        page_size=page_size,\n+    )\n+\n+\n+@router.post(\n+    \"/search\",\n+    tags=[\"store\", \"private\"],\n+    dependencies=[fastapi.Depends(auth_middleware)],\n+)\n+async def search(\n+    options: builder_model.SearchRequest,\n+    user_id: Annotated[str, fastapi.Depends(get_user_id)],\n+) -> builder_model.SearchResponse:\n+    \"\"\"\n+    Search for blocks (including integrations), marketplace agents, and user library agents.\n+    \"\"\"\n+    # If no filters are provided, then we will return all types\n+    if not options.filter:\n+        options.filter = [\n+            \"blocks\",\n+            \"integrations\",\n+            \"marketplace_agents\",\n+            \"my_agents\",\n+        ]\n+    options.search_query = sanitize_query(options.search_query)\n+    options.page = options.page or 1\n+    options.page_size = options.page_size or 50\n+\n+    # Blocks&Integrations\n+    blocks = builder_model.SearchBlocksResponse(\n+        blocks=builder_model.BlockResponse(\n+            blocks=[],\n+            pagination=server_model.Pagination.empty(),\n+        ),\n+        total_block_count=0,\n+        total_integration_count=0,\n+    )\n+    if \"blocks\" in options.filter or \"integrations\" in options.filter:\n+        blocks = builder_db.search_blocks(\n+            include_blocks=\"blocks\" in options.filter,\n+            include_integrations=\"integrations\" in options.filter,\n+            query=options.search_query or \"\",\n+            page=options.page,\n+            page_size=options.page_size,\n+        )\n+\n+    # Library Agents\n+    my_agents = library_model.LibraryAgentResponse(\n+        agents=[],\n+        pagination=server_model.Pagination.empty(),\n+    )\n+    if \"my_agents\" in options.filter:\n+        my_agents = await library_db.list_library_agents(\n+            user_id=user_id,\n+            search_term=options.search_query,\n+            page=options.page,\n+            page_size=options.page_size,\n+        )\n+\n+    # Marketplace Agents\n+    marketplace_agents = store_model.StoreAgentsResponse(\n+        agents=[],\n+        pagination=server_model.Pagination.empty(),\n+    )\n+    if \"marketplace_agents\" in options.filter:\n+        marketplace_agents = await store_db.get_store_agents(\n+            creators=options.by_creator,\n+            search_query=options.search_query,\n+            page=options.page,\n+            page_size=options.page_size,\n+        )\n+\n+    more_pages = False\n+    if (\n+        blocks.blocks.pagination.current_page < blocks.blocks.pagination.total_pages\n+        or my_agents.pagination.current_page < my_agents.pagination.total_pages\n+        or marketplace_agents.pagination.current_page\n+        < marketplace_agents.pagination.total_pages\n+    ):\n+        more_pages = True\n+\n+    return builder_model.SearchResponse(\n+        items=blocks.blocks.blocks + my_agents.agents + marketplace_agents.agents,\n+        total_items={\n+            \"blocks\": blocks.total_block_count,\n+            \"integrations\": blocks.total_integration_count,\n+            \"marketplace_agents\": marketplace_agents.pagination.total_items,\n+            \"my_agents\": my_agents.pagination.total_items,\n+        },\n+        page=options.page,\n+        more_pages=more_pages,\n+    )\n+\n+\n+@router.get(\n+    \"/counts\",\n+    dependencies=[fastapi.Depends(auth_middleware)],\n+)\n+async def get_counts(\n+    user_id: Annotated[str, fastapi.Depends(get_user_id)],\n+) -> builder_model.CountResponse:\n+    \"\"\"\n+    Get item counts for the menu categories in the Blocks Menu.\n+    \"\"\"\n+    return await builder_db.get_counts(user_id)\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/Block.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/Block.tsx\nnew file mode 100644\nindex 000000000000..4b4c04f858a5\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/Block.tsx\n@@ -0,0 +1,77 @@\n+import { Button } from \"@/components/ui/button\";\n+import { Skeleton } from \"@/components/ui/skeleton\";\n+import { beautifyString, cn } from \"@/lib/utils\";\n+import { Plus } from \"lucide-react\";\n+import React, { ButtonHTMLAttributes } from \"react\";\n+import { highlightText } from \"./IntegrationBlock\";\n+\n+interface Props extends ButtonHTMLAttributes<HTMLButtonElement> {\n+  title?: string;\n+  description?: string;\n+  highlightedText?: string;\n+}\n+\n+interface BlockComponent extends React.FC<Props> {\n+  Skeleton: React.FC<{ className?: string }>;\n+}\n+\n+export const Block: BlockComponent = ({\n+  title,\n+  description,\n+  highlightedText,\n+  className,\n+  ...rest\n+}) => {\n+  return (\n+    <Button\n+      className={cn(\n+        \"group flex h-16 w-full min-w-[7.5rem] items-center justify-start space-x-3 whitespace-normal rounded-[0.75rem] bg-zinc-50 px-[0.875rem] py-[0.625rem] text-start shadow-none\",\n+        \"hover:cursor-default hover:bg-zinc-100 focus:ring-0 active:bg-zinc-100 active:ring-1 active:ring-zinc-300 disabled:cursor-not-allowed\",\n+        className,\n+      )}\n+      {...rest}\n+    >\n+      <div className=\"flex flex-1 flex-col items-start gap-0.5\">\n+        {title && (\n+          <span\n+            className={cn(\n+              \"line-clamp-1 font-sans text-sm font-medium leading-[1.375rem] text-zinc-800 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            {highlightText(beautifyString(title), highlightedText)}\n+          </span>\n+        )}\n+        {description && (\n+          <span\n+            className={cn(\n+              \"line-clamp-1 font-sans text-xs font-normal leading-5 text-zinc-500 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            {highlightText(description, highlightedText)}\n+          </span>\n+        )}\n+      </div>\n+      <div\n+        className={cn(\n+          \"flex h-7 w-7 items-center justify-center rounded-[0.5rem] bg-zinc-700 group-disabled:bg-zinc-400\",\n+        )}\n+      >\n+        <Plus className=\"h-5 w-5 text-zinc-50\" strokeWidth={2} />\n+      </div>\n+    </Button>\n+  );\n+};\n+\n+const BlockSkeleton = () => {\n+  return (\n+    <Skeleton className=\"flex h-16 w-full min-w-[7.5rem] animate-pulse items-center justify-start space-x-3 rounded-[0.75rem] bg-zinc-100 px-[0.875rem] py-[0.625rem]\">\n+      <div className=\"flex flex-1 flex-col items-start gap-0.5\">\n+        <Skeleton className=\"h-[1.375rem] w-24 rounded bg-zinc-200\" />\n+        <Skeleton className=\"h-5 w-32 rounded bg-zinc-200\" />\n+      </div>\n+      <Skeleton className=\"h-7 w-7 rounded-[0.5rem] bg-zinc-200\" />\n+    </Skeleton>\n+  );\n+};\n+\n+Block.Skeleton = BlockSkeleton;\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/BlockMenu.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/BlockMenu.tsx\nnew file mode 100644\nindex 000000000000..d3f16b8fe4c4\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/BlockMenu.tsx\n@@ -0,0 +1,62 @@\n+import React, { useState } from \"react\";\n+import {\n+  Popover,\n+  PopoverContent,\n+  PopoverTrigger,\n+} from \"@/components/ui/popover\";\n+import { ControlPanelButton } from \"@/components/builder/block-menu/ControlPanelButton\";\n+import { ToyBrick } from \"lucide-react\";\n+import { BlockMenuContent } from \"./BlockMenuContent\";\n+import { BlockMenuStateProvider } from \"./block-menu-provider\";\n+import { Block } from \"@/lib/autogpt-server-api\";\n+\n+interface BlockMenuProps {\n+  addNode: (block: Block) => void;\n+  pinBlocksPopover: boolean;\n+  blockMenuSelected: \"save\" | \"block\" | \"\";\n+  setBlockMenuSelected: React.Dispatch<\n+    React.SetStateAction<\"\" | \"save\" | \"block\">\n+  >;\n+}\n+\n+export const BlockMenu: React.FC<BlockMenuProps> = ({\n+  addNode,\n+  pinBlocksPopover,\n+  blockMenuSelected,\n+  setBlockMenuSelected,\n+}) => {\n+  const [open, setOpen] = useState(false);\n+  const onOpen = (newOpen: boolean) => {\n+    if (!pinBlocksPopover) {\n+      setOpen(newOpen);\n+      setBlockMenuSelected(newOpen ? \"block\" : \"\");\n+    }\n+  };\n+\n+  return (\n+    <Popover open={pinBlocksPopover ? true : open} onOpenChange={onOpen}>\n+      <PopoverTrigger className=\"hover:cursor-pointer\">\n+        <ControlPanelButton\n+          data-id=\"blocks-control-popover-trigger\"\n+          data-testid=\"blocks-control-blocks-button\"\n+          selected={blockMenuSelected === \"block\"}\n+          className=\"rounded-none\"\n+        >\n+          <ToyBrick className=\"h-5 w-6\" strokeWidth={2} />\n+        </ControlPanelButton>\n+      </PopoverTrigger>\n+\n+      <PopoverContent\n+        side=\"right\"\n+        align=\"start\"\n+        sideOffset={16}\n+        className=\"absolute h-[75vh] w-[46.625rem] overflow-hidden rounded-[1rem] border-none p-0 shadow-[0_2px_6px_0_rgba(0,0,0,0.05)]\"\n+        data-id=\"blocks-control-popover-content\"\n+      >\n+        <BlockMenuStateProvider addNode={addNode}>\n+          <BlockMenuContent />\n+        </BlockMenuStateProvider>\n+      </PopoverContent>\n+    </Popover>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/BlockMenuSearchBar.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/BlockMenuSearchBar.tsx\nnew file mode 100644\nindex 000000000000..3e4e05119b5b\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/BlockMenuSearchBar.tsx\n@@ -0,0 +1,90 @@\n+import { cn } from \"@/lib/utils\";\n+import { Search, X } from \"lucide-react\";\n+import React, { useRef, useState, useEffect, useMemo } from \"react\";\n+import { useBlockMenuContext } from \"./block-menu-provider\";\n+import { Button } from \"@/components/ui/button\";\n+import debounce from \"lodash/debounce\";\n+import { Input } from \"@/components/ui/input\";\n+import { getDefaultFilters } from \"./helpers\";\n+\n+const SEARCH_DEBOUNCE_MS = 500;\n+\n+interface BlockMenuSearchBarProps {\n+  className?: string;\n+}\n+\n+export const BlockMenuSearchBar: React.FC<BlockMenuSearchBarProps> = ({\n+  className = \"\",\n+}) => {\n+  const inputRef = useRef<HTMLInputElement>(null);\n+  const [localQuery, setLocalQuery] = useState(\"\");\n+  const { setSearchQuery, searchId, setSearchId, setFilters } =\n+    useBlockMenuContext();\n+\n+  const searchIdRef = useRef(searchId);\n+  useEffect(() => {\n+    searchIdRef.current = searchId;\n+  }, [searchId]);\n+\n+  const debouncedSetSearchQuery = useMemo(\n+    () =>\n+      debounce((value: string) => {\n+        setSearchQuery(value);\n+        if (value.length === 0) {\n+          setSearchId(undefined);\n+        } else if (!searchIdRef.current) {\n+          setSearchId(crypto.randomUUID());\n+        }\n+      }, SEARCH_DEBOUNCE_MS),\n+    [setSearchQuery, setSearchId],\n+  );\n+\n+  useEffect(() => {\n+    return () => {\n+      debouncedSetSearchQuery.cancel();\n+    };\n+  }, [debouncedSetSearchQuery]);\n+\n+  const handleClear = () => {\n+    setLocalQuery(\"\");\n+    setSearchQuery(\"\");\n+    setSearchId(undefined);\n+    setFilters(getDefaultFilters());\n+    debouncedSetSearchQuery.cancel();\n+  };\n+\n+  return (\n+    <div\n+      className={cn(\n+        \"flex min-h-[3.5625rem] items-center gap-2.5 px-4\",\n+        className,\n+      )}\n+    >\n+      <Search className=\"h-6 w-6 text-zinc-700\" strokeWidth={2} />\n+      <Input\n+        ref={inputRef}\n+        type=\"text\"\n+        value={localQuery}\n+        onChange={(e) => {\n+          setLocalQuery(e.target.value);\n+          debouncedSetSearchQuery(e.target.value);\n+        }}\n+        placeholder={\"Blocks, Agents, Integrations or Keywords...\"}\n+        className={cn(\n+          \"m-0 border-none p-0 font-sans text-base font-normal text-zinc-800 shadow-none outline-none\",\n+          \"placeholder:text-zinc-400 focus:shadow-none focus:outline-none focus:ring-0\",\n+        )}\n+      />\n+      {localQuery.length > 0 && (\n+        <Button\n+          variant=\"ghost\"\n+          size=\"sm\"\n+          onClick={handleClear}\n+          className=\"p-0 hover:bg-transparent\"\n+        >\n+          <X className=\"h-6 w-6 text-zinc-700\" strokeWidth={2} />\n+        </Button>\n+      )}\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/ErrorState.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/ErrorState.tsx\nnew file mode 100644\nindex 000000000000..ae59e923dea1\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/ErrorState.tsx\n@@ -0,0 +1,54 @@\n+import { Button } from \"@/components/ui/button\";\n+import { cn, parseErrorMessage } from \"@/lib/utils\";\n+import { AlertCircle, RefreshCw } from \"lucide-react\";\n+import React from \"react\";\n+\n+interface ErrorStateProps {\n+  title?: string;\n+  message?: string;\n+  error?: string | Error | null;\n+  onRetry?: () => void;\n+  retryLabel?: string;\n+  className?: string;\n+  showIcon?: boolean;\n+}\n+\n+export const ErrorState: React.FC<ErrorStateProps> = ({\n+  title = \"Something went wrong\",\n+  message,\n+  error,\n+  onRetry,\n+  retryLabel = \"Retry\",\n+  className,\n+  showIcon = true,\n+}) => {\n+  return (\n+    <div\n+      className={cn(\n+        \"flex h-full w-full flex-col items-center justify-center space-y-4 text-center\",\n+        className,\n+      )}\n+    >\n+      {showIcon && <AlertCircle className=\"h-12 w-12\" strokeWidth={1.5} />}\n+\n+      <div className=\"space-y-2\">\n+        <p className=\"text-sm font-medium text-zinc-800\">{title}</p>\n+        <p className=\"text-sm text-zinc-600\">\n+          {parseErrorMessage(error, message)}\n+        </p>\n+      </div>\n+\n+      {onRetry && (\n+        <Button\n+          variant=\"default\"\n+          size=\"sm\"\n+          onClick={onRetry}\n+          className=\"mt-2 h-7 bg-zinc-800 text-xs\"\n+        >\n+          <RefreshCw className=\"mr-1 h-3 w-3\" />\n+          {retryLabel}\n+        </Button>\n+      )}\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/FilterChip.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/FilterChip.tsx\nnew file mode 100644\nindex 000000000000..214e5e8b25d2\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/FilterChip.tsx\n@@ -0,0 +1,54 @@\n+import { Button } from \"@/components/ui/button\";\n+import { cn } from \"@/lib/utils\";\n+import { X } from \"lucide-react\";\n+import React, { ButtonHTMLAttributes } from \"react\";\n+\n+interface Props extends ButtonHTMLAttributes<HTMLButtonElement> {\n+  selected?: boolean;\n+  number?: number;\n+  name?: string;\n+}\n+\n+export const FilterChip: React.FC<Props> = ({\n+  selected = false,\n+  number,\n+  name,\n+  className,\n+  ...rest\n+}) => {\n+  return (\n+    <Button\n+      className={cn(\n+        \"group w-fit space-x-1 rounded-[1.5rem] border border-zinc-300 bg-transparent px-[0.625rem] py-[0.375rem] shadow-none transition-transform duration-300 ease-in-out\",\n+        \"hover:border-violet-500 hover:bg-transparent focus:ring-0 disabled:cursor-not-allowed\",\n+        selected && \"border-0 bg-violet-700 hover:border\",\n+        className,\n+      )}\n+      {...rest}\n+    >\n+      <span\n+        className={cn(\n+          \"font-sans text-sm font-medium leading-[1.375rem] text-zinc-600 group-hover:text-zinc-600 group-disabled:text-zinc-400\",\n+          selected && \"text-zinc-50\",\n+        )}\n+      >\n+        {name}\n+      </span>\n+      {selected && (\n+        <>\n+          <span className=\"flex h-4 w-4 items-center justify-center rounded-full bg-zinc-50 transition-all duration-300 ease-in-out group-hover:hidden\">\n+            <X\n+              className=\"h-3 w-3 rounded-full text-violet-700\"\n+              strokeWidth={2}\n+            />\n+          </span>\n+          {number !== undefined && (\n+            <span className=\"hidden h-[1.375rem] items-center rounded-[1.25rem] bg-violet-700 p-[0.375rem] text-zinc-50 transition-all duration-300 ease-in-out animate-in fade-in zoom-in group-hover:flex\">\n+              {number > 100 ? \"100+\" : number}\n+            </span>\n+          )}\n+        </>\n+      )}\n+    </Button>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/Integration.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/Integration.tsx\nnew file mode 100644\nindex 000000000000..6082df97c847\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/Integration.tsx\n@@ -0,0 +1,88 @@\n+import { Button } from \"@/components/ui/button\";\n+import { Skeleton } from \"@/components/ui/skeleton\";\n+import { beautifyString, cn } from \"@/lib/utils\";\n+import Image from \"next/image\";\n+import React, { ButtonHTMLAttributes } from \"react\";\n+\n+interface Props extends ButtonHTMLAttributes<HTMLButtonElement> {\n+  title?: string;\n+  description?: string;\n+  icon_url?: string;\n+  number_of_blocks?: number;\n+}\n+\n+interface IntegrationComponent extends React.FC<Props> {\n+  Skeleton: React.FC<{ className?: string }>;\n+}\n+\n+export const Integration: IntegrationComponent = ({\n+  title,\n+  icon_url,\n+  description,\n+  className,\n+  number_of_blocks,\n+  ...rest\n+}) => {\n+  return (\n+    <Button\n+      className={cn(\n+        \"group flex h-16 w-full min-w-[7.5rem] items-center justify-start space-x-3 whitespace-normal rounded-[0.75rem] bg-zinc-50 px-[0.875rem] py-[0.625rem] text-start shadow-none\",\n+        \"hover:cursor-default hover:bg-zinc-100 focus:ring-0 active:bg-zinc-50 active:ring-1 active:ring-zinc-300 disabled:pointer-events-none\",\n+        className,\n+      )}\n+      {...rest}\n+    >\n+      <div className=\"relative h-[2.625rem] w-[2.625rem] overflow-hidden rounded-[0.5rem] bg-white\">\n+        {icon_url && (\n+          <Image\n+            src={icon_url}\n+            alt=\"integration-icon\"\n+            fill\n+            sizes=\"2.25rem\"\n+            className=\"w-full rounded-[0.5rem] object-contain group-disabled:opacity-50\"\n+          />\n+        )}\n+      </div>\n+\n+      <div className=\"w-full\">\n+        <div className=\"flex items-center justify-between gap-2\">\n+          {title && (\n+            <p className=\"line-clamp-1 flex-1 font-sans text-sm font-medium leading-[1.375rem] text-zinc-700 group-disabled:text-zinc-400\">\n+              {beautifyString(title)}\n+            </p>\n+          )}\n+          <span className=\"flex h-[1.375rem] w-[1.6875rem] items-center justify-center rounded-[1.25rem] bg-[#f0f0f0] p-1.5 font-sans text-sm leading-[1.375rem] text-zinc-500 group-disabled:text-zinc-400\">\n+            {number_of_blocks}\n+          </span>\n+        </div>\n+        <span className=\"line-clamp-1 font-sans text-xs font-normal leading-5 text-zinc-500 group-disabled:text-zinc-400\">\n+          {description}\n+        </span>\n+      </div>\n+    </Button>\n+  );\n+};\n+\n+const IntegrationSkeleton: React.FC<{ className?: string }> = ({\n+  className,\n+}) => {\n+  return (\n+    <Skeleton\n+      className={cn(\n+        \"flex h-16 w-full min-w-[7.5rem] animate-pulse items-center justify-start space-x-3 rounded-[0.75rem] bg-zinc-100 px-[0.875rem] py-[0.625rem]\",\n+        className,\n+      )}\n+    >\n+      <Skeleton className=\"h-[2.625rem] w-[2.625rem] rounded-[0.5rem] bg-zinc-200\" />\n+      <div className=\"flex flex-1 flex-col items-start gap-0.5\">\n+        <div className=\"flex w-full items-center justify-between\">\n+          <Skeleton className=\"h-[1.375rem] w-24 rounded bg-zinc-200\" />\n+          <Skeleton className=\"h-[1.375rem] w-[1.6875rem] rounded-[1.25rem] bg-zinc-200\" />\n+        </div>\n+        <Skeleton className=\"h-5 w-[80%] rounded bg-zinc-200\" />\n+      </div>\n+    </Skeleton>\n+  );\n+};\n+\n+Integration.Skeleton = IntegrationSkeleton;\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/IntegrationBlock.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/IntegrationBlock.tsx\nnew file mode 100644\nindex 000000000000..b621e805ce9a\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/IntegrationBlock.tsx\n@@ -0,0 +1,119 @@\n+import { Button } from \"@/components/ui/button\";\n+import { Skeleton } from \"@/components/ui/skeleton\";\n+import { beautifyString, cn } from \"@/lib/utils\";\n+import { Plus } from \"lucide-react\";\n+import Image from \"next/image\";\n+import React, { ButtonHTMLAttributes } from \"react\";\n+\n+interface Props extends ButtonHTMLAttributes<HTMLButtonElement> {\n+  title?: string;\n+  description?: string;\n+  icon_url?: string;\n+  highlightedText?: string;\n+}\n+\n+interface IntegrationBlockComponent extends React.FC<Props> {\n+  Skeleton: React.FC<{ className?: string }>;\n+}\n+\n+export const highlightText = (\n+  text: string | undefined,\n+  highlight: string | undefined,\n+) => {\n+  if (!text || !highlight) return text;\n+\n+  function escapeRegExp(s: string) {\n+    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n+  }\n+\n+  const escaped = escapeRegExp(highlight);\n+  const parts = text.split(new RegExp(`(${escaped})`, \"gi\"));\n+  return parts.map((part, i) =>\n+    part.toLowerCase() === highlight?.toLowerCase() ? (\n+      <mark key={i} className=\"bg-transparent font-bold\">\n+        {part}\n+      </mark>\n+    ) : (\n+      part\n+    ),\n+  );\n+};\n+\n+export const IntegrationBlock: IntegrationBlockComponent = ({\n+  title,\n+  icon_url,\n+  description,\n+  className,\n+  highlightedText,\n+  ...rest\n+}) => {\n+  return (\n+    <Button\n+      className={cn(\n+        \"group flex h-16 w-full min-w-[7.5rem] items-center justify-start gap-3 whitespace-normal rounded-[0.75rem] bg-zinc-50 px-[0.875rem] py-[0.625rem] text-start shadow-none\",\n+        \"hover:cursor-default hover:bg-zinc-100 focus:ring-0 active:bg-zinc-100 active:ring-1 active:ring-zinc-300 disabled:cursor-not-allowed\",\n+        className,\n+      )}\n+      {...rest}\n+    >\n+      <div className=\"relative h-[2.625rem] w-[2.625rem] rounded-[0.5rem] bg-white\">\n+        {icon_url && (\n+          <Image\n+            src={icon_url}\n+            alt=\"integration-icon\"\n+            fill\n+            sizes=\"2.25rem\"\n+            className=\"w-full object-contain group-disabled:opacity-50\"\n+          />\n+        )}\n+      </div>\n+      <div className=\"flex flex-1 flex-col items-start gap-0.5\">\n+        {title && (\n+          <span\n+            className={cn(\n+              \"line-clamp-1 font-sans text-sm font-medium leading-[1.375rem] text-zinc-800 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            {highlightText(beautifyString(title), highlightedText)}\n+          </span>\n+        )}\n+        {description && (\n+          <span\n+            className={cn(\n+              \"line-clamp-1 font-sans text-xs font-normal leading-5 text-zinc-500 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            {highlightText(description, highlightedText)}\n+          </span>\n+        )}\n+      </div>\n+      <div\n+        className={cn(\n+          \"flex h-7 w-7 items-center justify-center rounded-[0.5rem] bg-zinc-700 group-disabled:bg-zinc-400\",\n+        )}\n+      >\n+        <Plus className=\"h-5 w-5 text-zinc-50\" strokeWidth={2} />\n+      </div>\n+    </Button>\n+  );\n+};\n+\n+const IntegrationBlockSkeleton = ({ className }: { className?: string }) => {\n+  return (\n+    <Skeleton\n+      className={cn(\n+        \"flex h-16 w-full min-w-[7.5rem] animate-pulse items-center justify-start gap-3 rounded-[0.75rem] bg-zinc-100 px-[0.875rem] py-[0.625rem]\",\n+        className,\n+      )}\n+    >\n+      <Skeleton className=\"h-[2.625rem] w-[2.625rem] rounded-[0.5rem] bg-zinc-200\" />\n+      <div className=\"flex flex-1 flex-col items-start gap-0.5\">\n+        <Skeleton className=\"h-[1.375rem] w-24 rounded bg-zinc-200\" />\n+        <Skeleton className=\"h-5 w-32 rounded bg-zinc-200\" />\n+      </div>\n+      <Skeleton className=\"h-7 w-7 rounded-[0.5rem] bg-zinc-200\" />\n+    </Skeleton>\n+  );\n+};\n+\n+IntegrationBlock.Skeleton = IntegrationBlockSkeleton;\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/IntegrationChip.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/IntegrationChip.tsx\nnew file mode 100644\nindex 000000000000..611e283bdb1a\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/IntegrationChip.tsx\n@@ -0,0 +1,60 @@\n+import { Button } from \"@/components/ui/button\";\n+import { Skeleton } from \"@/components/ui/skeleton\";\n+import { beautifyString, cn } from \"@/lib/utils\";\n+import Image from \"next/image\";\n+import React, { ButtonHTMLAttributes } from \"react\";\n+\n+interface Props extends ButtonHTMLAttributes<HTMLButtonElement> {\n+  name?: string;\n+  icon_url?: string;\n+}\n+\n+interface IntegrationChipComponent extends React.FC<Props> {\n+  Skeleton: React.FC;\n+}\n+\n+export const IntegrationChip: IntegrationChipComponent = ({\n+  icon_url,\n+  name,\n+  className,\n+  ...rest\n+}) => {\n+  return (\n+    <Button\n+      className={cn(\n+        \"flex h-[3.25rem] w-full min-w-[7.5rem] justify-start gap-2 whitespace-normal rounded-[0.5rem] bg-zinc-50 p-2 pr-3 shadow-none\",\n+        \"hover:cursor-default hover:bg-zinc-100 focus:ring-0 active:bg-zinc-100 active:ring-1 active:ring-zinc-300\",\n+        className,\n+      )}\n+      {...rest}\n+    >\n+      <div className=\"relative h-9 w-9 rounded-[0.5rem] bg-transparent\">\n+        {icon_url && (\n+          <Image\n+            src={icon_url}\n+            alt=\"integration-icon\"\n+            fill\n+            sizes=\"2.25rem\"\n+            className=\"w-full object-contain\"\n+          />\n+        )}\n+      </div>\n+      {name && (\n+        <span className=\"truncate font-sans text-sm font-normal leading-[1.375rem] text-zinc-800\">\n+          {beautifyString(name)}\n+        </span>\n+      )}\n+    </Button>\n+  );\n+};\n+\n+const IntegrationChipSkeleton: React.FC = () => {\n+  return (\n+    <Skeleton className=\"flex h-[3.25rem] w-full min-w-[7.5rem] gap-2 rounded-[0.5rem] bg-zinc-100 p-2 pr-3\">\n+      <Skeleton className=\"h-9 w-12 rounded-[0.5rem] bg-zinc-200\" />\n+      <Skeleton className=\"h-5 w-24 self-center rounded-sm bg-zinc-200\" />\n+    </Skeleton>\n+  );\n+};\n+\n+IntegrationChip.Skeleton = IntegrationChipSkeleton;\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/MarketplaceAgentBlock.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/MarketplaceAgentBlock.tsx\nnew file mode 100644\nindex 000000000000..84184e40d074\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/MarketplaceAgentBlock.tsx\n@@ -0,0 +1,135 @@\n+import { Button } from \"@/components/ui/button\";\n+import { Skeleton } from \"@/components/ui/skeleton\";\n+import { cn } from \"@/lib/utils\";\n+import { ExternalLink, Loader2, Plus } from \"lucide-react\";\n+import Image from \"next/image\";\n+import React, { ButtonHTMLAttributes } from \"react\";\n+import { highlightText } from \"./IntegrationBlock\";\n+import Link from \"next/link\";\n+\n+interface Props extends ButtonHTMLAttributes<HTMLButtonElement> {\n+  title?: string;\n+  creator_name?: string;\n+  number_of_runs?: number;\n+  image_url?: string;\n+  highlightedText?: string;\n+  slug: string;\n+  loading: boolean;\n+}\n+\n+interface MarketplaceAgentBlockComponent extends React.FC<Props> {\n+  Skeleton: React.FC<{ className?: string }>;\n+}\n+\n+export const MarketplaceAgentBlock: MarketplaceAgentBlockComponent = ({\n+  title,\n+  image_url,\n+  creator_name,\n+  number_of_runs,\n+  className,\n+  loading,\n+  highlightedText,\n+  slug,\n+  ...rest\n+}) => {\n+  return (\n+    <Button\n+      className={cn(\n+        \"group flex h-[4.375rem] w-full min-w-[7.5rem] items-center justify-start gap-3 whitespace-normal rounded-[0.75rem] bg-zinc-50 p-[0.625rem] pr-[0.875rem] text-start shadow-none\",\n+        \"hover:cursor-default hover:bg-zinc-100 focus:ring-0 active:bg-zinc-100 active:ring-1 active:ring-zinc-300 disabled:pointer-events-none\",\n+        className,\n+      )}\n+      {...rest}\n+    >\n+      <div className=\"relative h-[3.125rem] w-[5.625rem] overflow-hidden rounded-[0.375rem] bg-white\">\n+        {image_url && (\n+          <Image\n+            src={image_url}\n+            alt=\"integration-icon\"\n+            fill\n+            sizes=\"5.625rem\"\n+            className=\"w-full object-contain group-disabled:opacity-50\"\n+          />\n+        )}\n+      </div>\n+      <div className=\"flex flex-1 flex-col items-start gap-0.5\">\n+        {title && (\n+          <span\n+            className={cn(\n+              \"line-clamp-1 font-sans text-sm font-medium leading-[1.375rem] text-zinc-800 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            {highlightText(title, highlightedText)}\n+          </span>\n+        )}\n+        <div className=\"flex items-center space-x-2.5\">\n+          <span\n+            className={cn(\n+              \"truncate font-sans text-xs font-normal leading-5 text-zinc-500 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            By {creator_name}\n+          </span>\n+\n+          <span className=\"font-sans text-zinc-400\">•</span>\n+\n+          <span\n+            className={cn(\n+              \"truncate font-sans text-xs font-normal leading-5 text-zinc-500 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            {number_of_runs} runs\n+          </span>\n+          <span className=\"font-sans text-zinc-400\">•</span>\n+          <Link\n+            href={`/marketplace/agent/${creator_name}/${slug}`}\n+            className=\"flex gap-0.5 truncate\"\n+            onClick={(e) => e.stopPropagation()}\n+          >\n+            <span className=\"font-sans text-xs leading-5 text-blue-700 underline\">\n+              Agent page\n+            </span>\n+            <ExternalLink className=\"h-4 w-4 text-blue-700\" strokeWidth={1} />\n+          </Link>\n+        </div>\n+      </div>\n+      <div\n+        className={cn(\n+          \"flex h-7 min-w-7 items-center justify-center rounded-[0.5rem] bg-zinc-700 group-disabled:bg-zinc-400\",\n+        )}\n+      >\n+        {!loading ? (\n+          <Plus className=\"h-5 w-5 text-zinc-50\" strokeWidth={2} />\n+        ) : (\n+          <Loader2 className=\"h-5 w-5 animate-spin\" />\n+        )}\n+      </div>\n+    </Button>\n+  );\n+};\n+\n+const MarketplaceAgentBlockSkeleton: React.FC<{ className?: string }> = ({\n+  className,\n+}) => {\n+  return (\n+    <Skeleton\n+      className={cn(\n+        \"flex h-[4.375rem] w-full min-w-[7.5rem] animate-pulse items-center justify-start gap-3 rounded-[0.75rem] bg-zinc-100 p-[0.625rem] pr-[0.875rem]\",\n+        className,\n+      )}\n+    >\n+      <Skeleton className=\"h-[3.125rem] w-[5.625rem] rounded-[0.375rem] bg-zinc-200\" />\n+      <div className=\"flex flex-1 flex-col items-start gap-0.5\">\n+        <Skeleton className=\"h-[1.375rem] w-24 rounded bg-zinc-200\" />\n+        <div className=\"flex items-center gap-1\">\n+          <Skeleton className=\"h-5 w-16 rounded bg-zinc-200\" />\n+\n+          <Skeleton className=\"h-5 w-16 rounded bg-zinc-200\" />\n+        </div>\n+      </div>\n+      <Skeleton className=\"h-7 w-7 rounded-[0.5rem] bg-zinc-200\" />\n+    </Skeleton>\n+  );\n+};\n+\n+MarketplaceAgentBlock.Skeleton = MarketplaceAgentBlockSkeleton;\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/UGCAgentBlock.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/UGCAgentBlock.tsx\nnew file mode 100644\nindex 000000000000..7244deae886b\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/UGCAgentBlock.tsx\n@@ -0,0 +1,117 @@\n+import { Button } from \"@/components/ui/button\";\n+import { Skeleton } from \"@/components/ui/skeleton\";\n+import { cn } from \"@/lib/utils\";\n+import { Plus } from \"lucide-react\";\n+import Image from \"next/image\";\n+import React, { ButtonHTMLAttributes } from \"react\";\n+import { highlightText } from \"./IntegrationBlock\";\n+import TimeAgo from \"react-timeago\";\n+\n+interface Props extends ButtonHTMLAttributes<HTMLButtonElement> {\n+  title?: string;\n+  edited_time?: Date;\n+  version?: number;\n+  image_url?: string;\n+  highlightedText?: string;\n+}\n+\n+interface UGCAgentBlockComponent extends React.FC<Props> {\n+  Skeleton: React.FC<{ className?: string }>;\n+}\n+\n+export const UGCAgentBlock: UGCAgentBlockComponent = ({\n+  title,\n+  image_url,\n+  edited_time,\n+  version,\n+  className,\n+  highlightedText,\n+  ...rest\n+}) => {\n+  return (\n+    <Button\n+      className={cn(\n+        \"group flex h-[4.375rem] w-full min-w-[7.5rem] items-center justify-start gap-3 whitespace-normal rounded-[0.75rem] bg-zinc-50 p-[0.625rem] pr-[0.875rem] text-start shadow-none\",\n+        \"hover:cursor-default hover:bg-zinc-100 focus:ring-0 active:bg-zinc-100 active:ring-1 active:ring-zinc-300 disabled:cursor-not-allowed\",\n+        className,\n+      )}\n+      {...rest}\n+    >\n+      {image_url && (\n+        <div className=\"relative h-[3.125rem] w-[5.625rem] overflow-hidden rounded-[0.375rem] bg-white\">\n+          <Image\n+            src={image_url}\n+            alt=\"integration-icon\"\n+            fill\n+            sizes=\"5.625rem\"\n+            className=\"w-full object-contain group-disabled:opacity-50\"\n+          />\n+        </div>\n+      )}\n+      <div className=\"flex flex-1 flex-col items-start gap-0.5\">\n+        {title && (\n+          <span\n+            className={cn(\n+              \"line-clamp-1 font-sans text-sm font-medium leading-[1.375rem] text-zinc-800 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            {highlightText(title, highlightedText)}\n+          </span>\n+        )}\n+        <div className=\"flex items-center space-x-1.5\">\n+          {edited_time && (\n+            <span\n+              className={cn(\n+                \"line-clamp-1 font-sans text-xs font-normal leading-5 text-zinc-500 group-disabled:text-zinc-400\",\n+              )}\n+            >\n+              Edited {<TimeAgo date={edited_time} />}\n+            </span>\n+          )}\n+\n+          <span className=\"font-sans text-zinc-400\">•</span>\n+\n+          <span\n+            className={cn(\n+              \"line-clamp-1 font-sans text-xs font-normal leading-5 text-zinc-500 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            Version {version}\n+          </span>\n+        </div>\n+      </div>\n+      <div\n+        className={cn(\n+          \"flex h-7 w-7 items-center justify-center rounded-[0.5rem] bg-zinc-700 group-disabled:bg-zinc-400\",\n+        )}\n+      >\n+        <Plus className=\"h-5 w-5 text-zinc-50\" strokeWidth={2} />\n+      </div>\n+    </Button>\n+  );\n+};\n+\n+const UGCAgentBlockSkeleton: React.FC<{ className?: string }> = ({\n+  className,\n+}) => {\n+  return (\n+    <Skeleton\n+      className={cn(\n+        \"flex h-[4.375rem] w-full min-w-[7.5rem] animate-pulse items-center justify-start gap-3 rounded-[0.75rem] bg-zinc-100 p-[0.625rem] pr-[0.875rem]\",\n+        className,\n+      )}\n+    >\n+      <Skeleton className=\"h-[3.125rem] w-[5.625rem] rounded-[0.375rem] bg-zinc-200\" />\n+      <div className=\"flex flex-1 flex-col items-start gap-0.5\">\n+        <Skeleton className=\"h-[1.375rem] w-24 rounded bg-zinc-200\" />\n+        <div className=\"flex items-center gap-1\">\n+          <Skeleton className=\"h-5 w-16 rounded bg-zinc-200\" />\n+          <Skeleton className=\"h-5 w-16 rounded bg-zinc-200\" />\n+        </div>\n+      </div>\n+      <Skeleton className=\"h-7 w-7 rounded-[0.5rem] bg-zinc-200\" />\n+    </Skeleton>\n+  );\n+};\n+\n+UGCAgentBlock.Skeleton = UGCAgentBlockSkeleton;\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/block-menu-provider.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/block-menu-provider.tsx\nnew file mode 100644\nindex 000000000000..8820a3a239eb\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/block-menu-provider.tsx\n@@ -0,0 +1,176 @@\n+\"use client\";\n+\n+import {\n+  Block,\n+  CredentialsProviderName,\n+  LibraryAgent,\n+  Provider,\n+  StoreAgent,\n+} from \"@/lib/autogpt-server-api\";\n+import { createContext, ReactNode, useContext, useState } from \"react\";\n+import { convertLibraryAgentIntoBlock } from \"@/lib/utils\";\n+import { useBackendAPI } from \"@/lib/autogpt-server-api/context\";\n+import { getDefaultFilters } from \"./helpers\";\n+\n+export type SearchItem = Block | Provider | LibraryAgent | StoreAgent;\n+\n+export type DefaultStateType =\n+  | \"suggestion\"\n+  | \"all_blocks\"\n+  | \"input_blocks\"\n+  | \"action_blocks\"\n+  | \"output_blocks\"\n+  | \"integrations\"\n+  | \"marketplace_agents\"\n+  | \"my_agents\";\n+\n+export type CategoryKey =\n+  | \"blocks\"\n+  | \"integrations\"\n+  | \"marketplace_agents\"\n+  | \"my_agents\";\n+\n+export interface Filters {\n+  categories: {\n+    blocks: boolean;\n+    integrations: boolean;\n+    marketplace_agents: boolean;\n+    my_agents: boolean;\n+    providers: boolean;\n+  };\n+  createdBy: string[];\n+}\n+\n+export type CategoryCounts = Record<CategoryKey, number>;\n+\n+interface BlockMenuContextType {\n+  defaultState: DefaultStateType;\n+  setDefaultState: React.Dispatch<React.SetStateAction<DefaultStateType>>;\n+  integration: CredentialsProviderName | null;\n+  setIntegration: React.Dispatch<\n+    React.SetStateAction<CredentialsProviderName | null>\n+  >;\n+  searchQuery: string;\n+  setSearchQuery: React.Dispatch<React.SetStateAction<string>>;\n+  searchId: string | undefined;\n+  setSearchId: React.Dispatch<React.SetStateAction<string | undefined>>;\n+  filters: Filters;\n+  setFilters: React.Dispatch<React.SetStateAction<Filters>>;\n+  searchData: SearchItem[];\n+  setSearchData: React.Dispatch<React.SetStateAction<SearchItem[]>>;\n+  categoryCounts: CategoryCounts;\n+  setCategoryCounts: React.Dispatch<React.SetStateAction<CategoryCounts>>;\n+  addNode: (block: Block) => void;\n+  handleAddStoreAgent: ({\n+    creator_name,\n+    slug,\n+  }: {\n+    creator_name: string;\n+    slug: string;\n+  }) => Promise<void>;\n+  loadingSlug: string | null;\n+  setLoadingSlug: React.Dispatch<React.SetStateAction<string | null>>;\n+}\n+\n+export const BlockMenuContext = createContext<BlockMenuContextType>(\n+  {} as BlockMenuContextType,\n+);\n+\n+interface BlockMenuStateProviderProps {\n+  children: ReactNode;\n+  addNode: (block: Block) => void;\n+}\n+\n+export function BlockMenuStateProvider({\n+  children,\n+  addNode,\n+}: BlockMenuStateProviderProps) {\n+  const [defaultState, setDefaultState] =\n+    useState<DefaultStateType>(\"suggestion\");\n+  const [integration, setIntegration] =\n+    useState<CredentialsProviderName | null>(null);\n+  const [searchQuery, setSearchQuery] = useState(\"\");\n+  const [filters, setFilters] = useState<Filters>(getDefaultFilters());\n+  const [searchData, setSearchData] = useState<SearchItem[]>([]);\n+\n+  const [searchId, setSearchId] = useState<string | undefined>(undefined);\n+\n+  const [categoryCounts, setCategoryCounts] = useState<CategoryCounts>({\n+    blocks: 0,\n+    integrations: 0,\n+    marketplace_agents: 0,\n+    my_agents: 0,\n+  });\n+\n+  const [loadingSlug, setLoadingSlug] = useState<string | null>(null);\n+\n+  const api = useBackendAPI();\n+\n+  const handleAddStoreAgent = async ({\n+    creator_name,\n+    slug,\n+  }: {\n+    creator_name: string;\n+    slug: string;\n+  }) => {\n+    try {\n+      setLoadingSlug(slug);\n+      const details = await api.getStoreAgent(creator_name, slug);\n+\n+      if (!details.active_version_id) {\n+        console.error(\n+          \"Cannot add store agent to library: active version ID is missing or undefined\",\n+        );\n+        return;\n+      }\n+\n+      const libraryAgent = await api.addMarketplaceAgentToLibrary(\n+        details.active_version_id,\n+      );\n+\n+      const block = convertLibraryAgentIntoBlock(libraryAgent);\n+      addNode(block);\n+    } catch (error) {\n+      console.error(\"Failed to add store agent:\", error);\n+    } finally {\n+      setLoadingSlug(null);\n+    }\n+  };\n+\n+  return (\n+    <BlockMenuContext.Provider\n+      value={{\n+        defaultState,\n+        setDefaultState,\n+        integration,\n+        setIntegration,\n+        searchQuery,\n+        setSearchQuery,\n+        searchId,\n+        setSearchId,\n+        filters,\n+        setFilters,\n+        searchData,\n+        setSearchData,\n+        categoryCounts,\n+        setCategoryCounts,\n+        addNode,\n+        handleAddStoreAgent,\n+        loadingSlug,\n+        setLoadingSlug,\n+      }}\n+    >\n+      {children}\n+    </BlockMenuContext.Provider>\n+  );\n+}\n+\n+export function useBlockMenuContext(): BlockMenuContextType {\n+  const context = useContext(BlockMenuContext);\n+  if (!context) {\n+    throw new Error(\n+      \"useBlockMenuContext must be used within a BlockMenuStateProvider\",\n+    );\n+  }\n+  return context;\n+}\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/default/AllBlocksContent.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/default/AllBlocksContent.tsx\nnew file mode 100644\nindex 000000000000..fdfb66d75df5\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/default/AllBlocksContent.tsx\n@@ -0,0 +1,162 @@\n+import React, { useState, useEffect, Fragment, useCallback } from \"react\";\n+import { Block } from \"../Block\";\n+import { Button } from \"@/components/ui/button\";\n+import { Separator } from \"@/components/ui/separator\";\n+import { Skeleton } from \"@/components/ui/skeleton\";\n+import { useBackendAPI } from \"@/lib/autogpt-server-api/context\";\n+import { BlockCategoryResponse } from \"@/lib/autogpt-server-api\";\n+import { useBlockMenuContext } from \"../block-menu-provider\";\n+import { ErrorState } from \"../ErrorState\";\n+import { beautifyString } from \"@/lib/utils\";\n+import { scrollbarStyles } from \"@/components/styles/scrollbar\";\n+\n+export const AllBlocksContent = () => {\n+  const { addNode } = useBlockMenuContext();\n+  const [categories, setCategories] = useState<BlockCategoryResponse[]>([]);\n+  const [loading, setLoading] = useState(true);\n+  const [error, setError] = useState<string | null>(null);\n+  const [loadingCategories, setLoadingCategories] = useState<Set<string>>(\n+    new Set(),\n+  );\n+\n+  const api = useBackendAPI();\n+\n+  const fetchBlocks = useCallback(async () => {\n+    try {\n+      setLoading(true);\n+      setError(null);\n+      const response = await api.getBlockCategories();\n+      setCategories(response);\n+    } catch (err) {\n+      console.error(\"Failed to fetch block categories:\", err);\n+      setError(\n+        err instanceof Error ? err.message : \"Failed to load block categories\",\n+      );\n+    } finally {\n+      setLoading(false);\n+    }\n+  }, [api]);\n+\n+  useEffect(() => {\n+    fetchBlocks();\n+  }, [fetchBlocks]);\n+\n+  const fetchMoreBlockOfACategory = async (category: string) => {\n+    try {\n+      setLoadingCategories((prev) => new Set(prev).add(category));\n+      const response = await api.getBuilderBlocks({ category: category });\n+      const updatedCategories = categories.map((cat) => {\n+        if (cat.name === category) {\n+          return {\n+            ...cat,\n+            blocks: [...response.blocks],\n+          };\n+        }\n+        return cat;\n+      });\n+\n+      setCategories(updatedCategories);\n+    } catch (error) {\n+      console.error(`Failed to fetch blocks for category ${category}:`, error);\n+    } finally {\n+      setLoadingCategories((prev) => {\n+        const newSet = new Set(prev);\n+        newSet.delete(category);\n+        return newSet;\n+      });\n+    }\n+  };\n+\n+  if (loading) {\n+    return (\n+      <div className={scrollbarStyles}>\n+        <div className=\"w-full space-y-3 px-4 pb-4\">\n+          {Array.from({ length: 3 }).map((_, categoryIndex) => (\n+            <Fragment key={categoryIndex}>\n+              {categoryIndex > 0 && (\n+                <Skeleton className=\"my-4 h-[1px] w-full text-zinc-100\" />\n+              )}\n+              {[0, 1, 2].map((blockIndex) => (\n+                <Block.Skeleton key={`${categoryIndex}-${blockIndex}`} />\n+              ))}\n+            </Fragment>\n+          ))}\n+        </div>\n+      </div>\n+    );\n+  }\n+\n+  if (error) {\n+    return (\n+      <div className=\"h-full p-4\">\n+        <ErrorState\n+          title=\"Failed to load blocks\"\n+          error={error}\n+          onRetry={fetchBlocks}\n+        />\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div className={scrollbarStyles}>\n+      <div className=\"w-full space-y-3 px-4 pb-4\">\n+        {categories.map((category, index) => (\n+          <Fragment key={category.name}>\n+            {index > 0 && (\n+              <Separator className=\"h-[1px] w-full text-zinc-300\" />\n+            )}\n+\n+            {/* Category Section */}\n+            <div className=\"space-y-2.5\">\n+              <div className=\"flex items-center justify-between\">\n+                <p className=\"font-sans text-sm font-medium leading-[1.375rem] text-zinc-800\">\n+                  {category.name && beautifyString(category.name)}\n+                </p>\n+                <span className=\"rounded-full bg-zinc-100 px-[0.375rem] font-sans text-sm leading-[1.375rem] text-zinc-600\">\n+                  {category.total_blocks}\n+                </span>\n+              </div>\n+\n+              <div className=\"space-y-2\">\n+                {category.blocks.map((block) => (\n+                  <Block\n+                    key={`${category.name}-${block.id}`}\n+                    title={block.name}\n+                    description={block.name}\n+                    onClick={() => {\n+                      addNode(block);\n+                    }}\n+                  />\n+                ))}\n+\n+                {loadingCategories.has(category.name) && (\n+                  <>\n+                    {[0, 1, 2, 3, 4].map((skeletonIndex) => (\n+                      <Block.Skeleton\n+                        key={`skeleton-${category.name}-${skeletonIndex}`}\n+                      />\n+                    ))}\n+                  </>\n+                )}\n+\n+                {category.total_blocks > category.blocks.length && (\n+                  <Button\n+                    variant={\"link\"}\n+                    className=\"px-0 font-sans text-sm leading-[1.375rem] text-zinc-600 underline hover:text-zinc-800\"\n+                    disabled={loadingCategories.has(category.name)}\n+                    onClick={() => {\n+                      fetchMoreBlockOfACategory(category.name);\n+                    }}\n+                  >\n+                    see all\n+                  </Button>\n+                )}\n+              </div>\n+            </div>\n+          </Fragment>\n+        ))}\n+      </div>\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/default/BlockMenuSidebar.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/default/BlockMenuSidebar.tsx\nnew file mode 100644\nindex 000000000000..84591d61b94e\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/default/BlockMenuSidebar.tsx\n@@ -0,0 +1,117 @@\n+import React, { useEffect, useState } from \"react\";\n+import { MenuItem } from \"../MenuItem\";\n+import { DefaultStateType, useBlockMenuContext } from \"../block-menu-provider\";\n+import { useBackendAPI } from \"@/lib/autogpt-server-api/context\";\n+import { CountResponse } from \"@/lib/autogpt-server-api\";\n+\n+export const BlockMenuSidebar = () => {\n+  const { defaultState, setDefaultState, setIntegration } =\n+    useBlockMenuContext();\n+  const [blockCounts, setBlockCounts] = useState<CountResponse | undefined>(\n+    undefined,\n+  );\n+  const api = useBackendAPI();\n+\n+  useEffect(() => {\n+    const fetchBlockCounts = async () => {\n+      try {\n+        const counts = await api.getBlockCounts();\n+        setBlockCounts(counts);\n+      } catch (error) {\n+        console.error(\"Failed to fetch block counts:\", error);\n+      }\n+    };\n+\n+    fetchBlockCounts();\n+  }, [api]);\n+\n+  const topLevelMenuItems = [\n+    {\n+      name: \"Suggestion\",\n+      type: \"suggestion\",\n+    },\n+    {\n+      name: \"All blocks\",\n+      type: \"all_blocks\",\n+      number: blockCounts?.all_blocks,\n+    },\n+  ];\n+\n+  const subMenuItems = [\n+    {\n+      name: \"Input blocks\",\n+      type: \"input_blocks\",\n+      number: blockCounts?.input_blocks,\n+    },\n+    {\n+      name: \"Action blocks\",\n+      type: \"action_blocks\",\n+      number: blockCounts?.action_blocks,\n+    },\n+    {\n+      name: \"Output blocks\",\n+      type: \"output_blocks\",\n+      number: blockCounts?.output_blocks,\n+    },\n+  ];\n+\n+  const bottomMenuItems = [\n+    {\n+      name: \"Integrations\",\n+      type: \"integrations\",\n+      number: blockCounts?.integrations,\n+      onClick: () => {\n+        setIntegration(null);\n+        setDefaultState(\"integrations\");\n+      },\n+    },\n+    {\n+      name: \"Marketplace Agents\",\n+      type: \"marketplace_agents\",\n+      number: blockCounts?.marketplace_agents,\n+    },\n+    {\n+      name: \"My Agents\",\n+      type: \"my_agents\",\n+      number: blockCounts?.my_agents,\n+    },\n+  ];\n+\n+  return (\n+    <div className=\"w-fit space-y-2 px-4 pt-4\">\n+      {topLevelMenuItems.map((item) => (\n+        <MenuItem\n+          key={item.type}\n+          name={item.name}\n+          number={item.number}\n+          selected={defaultState === item.type}\n+          onClick={() => setDefaultState(item.type as DefaultStateType)}\n+        />\n+      ))}\n+      <div className=\"ml-[0.5365rem] space-y-2 border-l border-black/10 pl-[0.75rem]\">\n+        {subMenuItems.map((item) => (\n+          <MenuItem\n+            key={item.type}\n+            name={item.name}\n+            number={item.number}\n+            className=\"max-w-[11.5339rem]\"\n+            selected={defaultState === item.type}\n+            onClick={() => setDefaultState(item.type as DefaultStateType)}\n+          />\n+        ))}\n+      </div>\n+      {bottomMenuItems.map((item) => (\n+        <MenuItem\n+          key={item.type}\n+          name={item.name}\n+          number={item.number}\n+          selected={defaultState === item.type}\n+          onClick={\n+            item.onClick ||\n+            (() => setDefaultState(item.type as DefaultStateType))\n+          }\n+        />\n+      ))}\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/default/IntegrationBlocks.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/default/IntegrationBlocks.tsx\nnew file mode 100644\nindex 000000000000..72ab5d8731b1\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/default/IntegrationBlocks.tsx\n@@ -0,0 +1,110 @@\n+import { Button } from \"@/components/ui/button\";\n+import React, { useState, useEffect, Fragment, useCallback } from \"react\";\n+import { IntegrationBlock } from \"../IntegrationBlock\";\n+import { useBlockMenuContext } from \"../block-menu-provider\";\n+import { useBackendAPI } from \"@/lib/autogpt-server-api/context\";\n+import { Block } from \"@/lib/autogpt-server-api\";\n+import { ErrorState } from \"../ErrorState\";\n+import { Skeleton } from \"@/components/ui/skeleton\";\n+\n+export const IntegrationBlocks = () => {\n+  const { integration, setIntegration, addNode } = useBlockMenuContext();\n+  const [blocks, setBlocks] = useState<Block[]>([]);\n+  const [loading, setLoading] = useState(true);\n+  const [error, setError] = useState<string | null>(null);\n+\n+  const api = useBackendAPI();\n+\n+  const fetchBlocks = useCallback(async () => {\n+    if (integration) {\n+      try {\n+        setLoading(true);\n+        setError(null);\n+        const response = await api.getBuilderBlocks({ provider: integration });\n+        setBlocks(response.blocks);\n+      } catch (err) {\n+        console.error(\"Failed to fetch integration blocks:\", err);\n+        setError(\n+          err instanceof Error\n+            ? err.message\n+            : \"Failed to load integration blocks\",\n+        );\n+      } finally {\n+        setLoading(false);\n+      }\n+    }\n+  }, [api, integration]);\n+\n+  useEffect(() => {\n+    fetchBlocks();\n+  }, [fetchBlocks]);\n+\n+  if (loading) {\n+    return (\n+      <div className=\"w-full space-y-3 p-4\">\n+        {Array.from({ length: 3 }).map((_, blockIndex) => (\n+          <Fragment key={blockIndex}>\n+            {blockIndex > 0 && (\n+              <Skeleton className=\"my-4 h-[1px] w-full text-zinc-100\" />\n+            )}\n+            {[0, 1, 2].map((index) => (\n+              <IntegrationBlock.Skeleton key={`${blockIndex}-${index}`} />\n+            ))}\n+          </Fragment>\n+        ))}\n+      </div>\n+    );\n+  }\n+\n+  if (error) {\n+    return (\n+      <div className=\"h-full p-4\">\n+        <ErrorState\n+          title=\"Failed to load integration blocks\"\n+          error={error}\n+          onRetry={fetchBlocks}\n+        />\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div className=\"space-y-2.5\">\n+      <div className=\"flex items-center justify-between\">\n+        <div className=\"flex items-center gap-1\">\n+          <Button\n+            variant={\"link\"}\n+            className=\"p-0 font-sans text-sm font-medium leading-[1.375rem] text-zinc-800\"\n+            onClick={() => {\n+              setIntegration(null);\n+            }}\n+          >\n+            Integrations\n+          </Button>\n+          <p className=\"font-sans text-sm font-medium leading-[1.375rem] text-zinc-800\">\n+            /\n+          </p>\n+          <p className=\"font-sans text-sm font-medium leading-[1.375rem] text-zinc-800\">\n+            {integration}\n+          </p>\n+        </div>\n+        <span className=\"flex h-[1.375rem] w-[1.6875rem] items-center justify-center rounded-[1.25rem] bg-[#f0f0f0] p-1.5 font-sans text-sm leading-[1.375rem] text-zinc-500 group-disabled:text-zinc-400\">\n+          {blocks.length}\n+        </span>\n+      </div>\n+      <div className=\"space-y-3\">\n+        {blocks.map((block) => (\n+          <IntegrationBlock\n+            key={block.id}\n+            title={block.name}\n+            description={block.description}\n+            icon_url={`/integrations/${integration}.png`}\n+            onClick={() => {\n+              addNode(block);\n+            }}\n+          />\n+        ))}\n+      </div>\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/default/MarketplaceAgentsContent.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/default/MarketplaceAgentsContent.tsx\nnew file mode 100644\nindex 000000000000..508cf3861149\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/default/MarketplaceAgentsContent.tsx\n@@ -0,0 +1,77 @@\n+import React from \"react\";\n+import { MarketplaceAgentBlock } from \"../MarketplaceAgentBlock\";\n+import { usePagination } from \"@/hooks/usePagination\";\n+import { ErrorState } from \"../ErrorState\";\n+import { useBlockMenuContext } from \"../block-menu-provider\";\n+import { scrollbarStyles } from \"@/components/styles/scrollbar\";\n+\n+export const MarketplaceAgentsContent = () => {\n+  const {\n+    data: agents,\n+    loading,\n+    loadingMore,\n+    hasMore,\n+    error,\n+    scrollRef,\n+    refresh,\n+  } = usePagination({\n+    request: { apiType: \"store-agents\" },\n+    pageSize: 10,\n+  });\n+  const { handleAddStoreAgent, loadingSlug } = useBlockMenuContext();\n+\n+  if (loading) {\n+    return (\n+      <div ref={scrollRef} className={scrollbarStyles}>\n+        <div className=\"w-full space-y-3 px-4 pb-4\">\n+          {Array.from({ length: 5 }).map((_, index) => (\n+            <MarketplaceAgentBlock.Skeleton key={index} />\n+          ))}\n+        </div>\n+      </div>\n+    );\n+  }\n+\n+  if (error) {\n+    return (\n+      <div className=\"h-full p-4\">\n+        <ErrorState\n+          title=\"Failed to load marketplace agents\"\n+          error={error}\n+          onRetry={refresh}\n+        />\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div ref={scrollRef} className={scrollbarStyles}>\n+      <div className=\"w-full space-y-3 px-4 pb-4\">\n+        {agents.map((agent) => (\n+          <MarketplaceAgentBlock\n+            key={agent.slug}\n+            slug={agent.slug}\n+            title={agent.agent_name}\n+            image_url={agent.agent_image}\n+            creator_name={agent.creator}\n+            number_of_runs={agent.runs}\n+            loading={loadingSlug === agent.slug}\n+            onClick={() =>\n+              handleAddStoreAgent({\n+                creator_name: agent.creator,\n+                slug: agent.slug,\n+              })\n+            }\n+          />\n+        ))}\n+        {loadingMore && hasMore && (\n+          <>\n+            {Array.from({ length: 3 }).map((_, index) => (\n+              <MarketplaceAgentBlock.Skeleton key={`loading-${index}`} />\n+            ))}\n+          </>\n+        )}\n+      </div>\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/default/MyAgentsContent.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/default/MyAgentsContent.tsx\nnew file mode 100644\nindex 000000000000..874a11d106c0\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/default/MyAgentsContent.tsx\n@@ -0,0 +1,74 @@\n+import React from \"react\";\n+import { UGCAgentBlock } from \"../UGCAgentBlock\";\n+import { usePagination } from \"@/hooks/usePagination\";\n+import { ErrorState } from \"../ErrorState\";\n+import { useBlockMenuContext } from \"../block-menu-provider\";\n+import { convertLibraryAgentIntoBlock } from \"@/lib/utils\";\n+import { scrollbarStyles } from \"@/components/styles/scrollbar\";\n+\n+export const MyAgentsContent = () => {\n+  const {\n+    data: agents,\n+    loading,\n+    loadingMore,\n+    hasMore,\n+    error,\n+    scrollRef,\n+    refresh,\n+  } = usePagination({\n+    request: { apiType: \"library-agents\" },\n+    pageSize: 10,\n+  });\n+  const { addNode } = useBlockMenuContext();\n+\n+  if (loading) {\n+    return (\n+      <div ref={scrollRef} className={scrollbarStyles}>\n+        <div className=\"w-full space-y-3 px-4 pb-4\">\n+          {Array.from({ length: 5 }).map((_, index) => (\n+            <UGCAgentBlock.Skeleton key={index} />\n+          ))}\n+        </div>\n+      </div>\n+    );\n+  }\n+\n+  if (error) {\n+    return (\n+      <div className=\"h-full p-4\">\n+        <ErrorState\n+          title=\"Failed to load library agents\"\n+          error={error}\n+          onRetry={refresh}\n+        />\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div ref={scrollRef} className={scrollbarStyles}>\n+      <div className=\"w-full space-y-3 px-4 pb-4\">\n+        {agents.map((agent) => (\n+          <UGCAgentBlock\n+            key={agent.id}\n+            title={agent.name}\n+            edited_time={agent.updated_at}\n+            version={agent.graph_version}\n+            image_url={agent.image_url}\n+            onClick={() => {\n+              const block = convertLibraryAgentIntoBlock(agent);\n+              addNode(block);\n+            }}\n+          />\n+        ))}\n+        {loadingMore && hasMore && (\n+          <>\n+            {Array.from({ length: 3 }).map((_, index) => (\n+              <UGCAgentBlock.Skeleton key={`loading-${index}`} />\n+            ))}\n+          </>\n+        )}\n+      </div>\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/default/PaginatedBlocksContent.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/default/PaginatedBlocksContent.tsx\nnew file mode 100644\nindex 000000000000..a855bc94e13b\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/default/PaginatedBlocksContent.tsx\n@@ -0,0 +1,55 @@\n+import React from \"react\";\n+import { BlocksList } from \"./BlocksList\";\n+import { Block } from \"../Block\";\n+import { BlockRequest } from \"@/lib/autogpt-server-api\";\n+import { usePagination } from \"@/hooks/usePagination\";\n+import { ErrorState } from \"../ErrorState\";\n+import { scrollbarStyles } from \"@/components/styles/scrollbar\";\n+\n+interface PaginatedBlocksContentProps {\n+  blockRequest: BlockRequest;\n+  pageSize?: number;\n+}\n+\n+export const PaginatedBlocksContent: React.FC<PaginatedBlocksContentProps> = ({\n+  blockRequest,\n+  pageSize = 10,\n+}) => {\n+  const {\n+    data: blocks,\n+    loading,\n+    loadingMore,\n+    hasMore,\n+    error,\n+    scrollRef,\n+    refresh,\n+  } = usePagination({\n+    request: { apiType: \"blocks\", ...blockRequest },\n+    pageSize,\n+  });\n+\n+  if (error) {\n+    return (\n+      <div className=\"h-full w-full px-4 pb-4\">\n+        <ErrorState\n+          title=\"Failed to load blocks\"\n+          error={error}\n+          onRetry={refresh}\n+        />\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div ref={scrollRef} className={scrollbarStyles}>\n+      <BlocksList blocks={blocks} loading={loading} />\n+      {loadingMore && hasMore && (\n+        <div className=\"w-full space-y-3 px-4 pb-4\">\n+          {Array.from({ length: 3 }).map((_, index) => (\n+            <Block.Skeleton key={`loading-${index}`} />\n+          ))}\n+        </div>\n+      )}\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/default/PaginatedIntegrationList.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/default/PaginatedIntegrationList.tsx\nnew file mode 100644\nindex 000000000000..105d5729e41f\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/default/PaginatedIntegrationList.tsx\n@@ -0,0 +1,72 @@\n+import React from \"react\";\n+import { Integration } from \"../Integration\";\n+import { useBlockMenuContext } from \"../block-menu-provider\";\n+import { usePagination } from \"@/hooks/usePagination\";\n+import { ErrorState } from \"../ErrorState\";\n+import { scrollbarStyles } from \"@/components/styles/scrollbar\";\n+\n+export const PaginatedIntegrationList = () => {\n+  const { setIntegration } = useBlockMenuContext();\n+  const {\n+    data: providers,\n+    loading,\n+    loadingMore,\n+    hasMore,\n+    error,\n+    scrollRef,\n+    refresh,\n+  } = usePagination({\n+    request: { apiType: \"providers\" },\n+    pageSize: 10,\n+  });\n+\n+  if (loading) {\n+    return (\n+      <div ref={scrollRef} className={scrollbarStyles}>\n+        <div className=\"w-full space-y-3 px-4 pb-4\">\n+          {Array.from({ length: 6 }).map((_, integrationIndex) => (\n+            <Integration.Skeleton key={integrationIndex} />\n+          ))}\n+        </div>\n+      </div>\n+    );\n+  }\n+\n+  if (error) {\n+    return (\n+      <div className=\"h-full p-4\">\n+        <ErrorState\n+          title=\"Failed to load integrations\"\n+          error={error}\n+          onRetry={refresh}\n+        />\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div ref={scrollRef} className={scrollbarStyles}>\n+      <div className=\"w-full px-4 pb-4\">\n+        <div className=\"space-y-3\">\n+          {providers.map((integration, index) => (\n+            <Integration\n+              key={index}\n+              title={integration.name}\n+              icon_url={`/integrations/${integration.name}.png`}\n+              description={integration.description}\n+              number_of_blocks={integration.integration_count}\n+              onClick={() => setIntegration(integration.name)}\n+            />\n+          ))}\n+          {loadingMore && hasMore && (\n+            <>\n+              {Array.from({ length: 3 }).map((_, index) => (\n+                <Integration.Skeleton key={`loading-${index}`} />\n+              ))}\n+            </>\n+          )}\n+        </div>\n+      </div>\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/default/SuggestionContent.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/default/SuggestionContent.tsx\nnew file mode 100644\nindex 000000000000..125fb8484117\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/default/SuggestionContent.tsx\n@@ -0,0 +1,113 @@\n+import React, { useCallback, useEffect, useState } from \"react\";\n+import { IntegrationChip } from \"../IntegrationChip\";\n+import { Block } from \"../Block\";\n+import { useBlockMenuContext } from \"../block-menu-provider\";\n+import {\n+  CredentialsProviderName,\n+  SuggestionsResponse,\n+} from \"@/lib/autogpt-server-api\";\n+import { useBackendAPI } from \"@/lib/autogpt-server-api/context\";\n+import { ErrorState } from \"../ErrorState\";\n+import { scrollbarStyles } from \"@/components/styles/scrollbar\";\n+\n+export const SuggestionContent = () => {\n+  const { setIntegration, setDefaultState, addNode } = useBlockMenuContext();\n+\n+  const [suggestionsData, setSuggestionsData] =\n+    useState<SuggestionsResponse | null>(null);\n+  const [loading, setLoading] = useState<boolean>(true);\n+  const [error, setError] = useState<string | null>(null);\n+\n+  const api = useBackendAPI();\n+\n+  const fetchSuggestions = useCallback(async () => {\n+    try {\n+      setLoading(true);\n+      setError(null);\n+      const response = await api.getSuggestions();\n+      setSuggestionsData(response);\n+    } catch (err) {\n+      console.error(\"Error fetching data:\", err);\n+      setError(\n+        err instanceof Error ? err.message : \"Failed to load suggestions\",\n+      );\n+    } finally {\n+      setLoading(false);\n+    }\n+  }, [api]);\n+\n+  useEffect(() => {\n+    fetchSuggestions();\n+  }, [fetchSuggestions]);\n+\n+  if (error) {\n+    return (\n+      <div className=\"h-full p-4\">\n+        <ErrorState\n+          title=\"Failed to load suggestions\"\n+          error={error}\n+          onRetry={fetchSuggestions}\n+        />\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div className={scrollbarStyles}>\n+      <div className=\"w-full space-y-6 pb-4\">\n+        {/* Integrations */}\n+        <div className=\"space-y-2.5 px-4\">\n+          <p className=\"font-sans text-sm font-medium leading-[1.375rem] text-zinc-800\">\n+            Integrations\n+          </p>\n+          <div className=\"grid grid-cols-3 grid-rows-2 gap-2\">\n+            {!loading && suggestionsData\n+              ? suggestionsData.providers.map((provider, index) => (\n+                  <IntegrationChip\n+                    key={`integration-${index}`}\n+                    icon_url={`/integrations/${provider}.png`}\n+                    name={provider}\n+                    onClick={() => {\n+                      setDefaultState(\"integrations\");\n+                      setIntegration(provider as CredentialsProviderName);\n+                    }}\n+                  />\n+                ))\n+              : Array(6)\n+                  .fill(0)\n+                  .map((_, index) => (\n+                    <IntegrationChip.Skeleton\n+                      key={`integration-skeleton-${index}`}\n+                    />\n+                  ))}\n+          </div>\n+        </div>\n+\n+        {/* Top blocks */}\n+        <div className=\"space-y-2.5 px-4\">\n+          <p className=\"font-sans text-sm font-medium leading-[1.375rem] text-zinc-800\">\n+            Top blocks\n+          </p>\n+          <div className=\"space-y-2\">\n+            {!loading && suggestionsData\n+              ? suggestionsData.top_blocks.map((block, index) => (\n+                  <Block\n+                    key={`block-${index}`}\n+                    title={block.name}\n+                    description={block.description}\n+                    onClick={() => {\n+                      addNode(block);\n+                    }}\n+                  />\n+                ))\n+              : Array(3)\n+                  .fill(0)\n+                  .map((_, index) => (\n+                    <Block.Skeleton key={`block-skeleton-${index}`} />\n+                  ))}\n+          </div>\n+        </div>\n+      </div>\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/AiBlock.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/AiBlock.tsx\nnew file mode 100644\nindex 000000000000..8b43f2830665\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/AiBlock.tsx\n@@ -0,0 +1,63 @@\n+import { Button } from \"@/components/ui/button\";\n+import { cn } from \"@/lib/utils\";\n+import { Plus } from \"lucide-react\";\n+import { ButtonHTMLAttributes } from \"react\";\n+\n+interface Props extends ButtonHTMLAttributes<HTMLButtonElement> {\n+  title?: string;\n+  description?: string;\n+  ai_name?: string;\n+}\n+\n+export const AiBlock: React.FC<Props> = ({\n+  title,\n+  description,\n+  className,\n+  ai_name,\n+  ...rest\n+}) => {\n+  return (\n+    <Button\n+      className={cn(\n+        \"group flex h-[5.625rem] w-full min-w-[7.5rem] items-center justify-start space-x-3 whitespace-normal rounded-[0.75rem] bg-zinc-50 px-[0.875rem] py-[0.625rem] text-start shadow-none\",\n+        \"hover:bg-zinc-100 focus:ring-0 active:bg-zinc-100 active:ring-1 active:ring-zinc-300 disabled:pointer-events-none\",\n+        className,\n+      )}\n+      {...rest}\n+    >\n+      <div className=\"flex flex-1 flex-col items-start gap-1.5\">\n+        <div className=\"space-y-0.5\">\n+          <span\n+            className={cn(\n+              \"line-clamp-1 font-sans text-sm font-medium leading-[1.375rem] text-zinc-700 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            {title}\n+          </span>\n+          <span\n+            className={cn(\n+              \"line-clamp-1 font-sans text-xs font-normal leading-5 text-zinc-500 group-disabled:text-zinc-400\",\n+            )}\n+          >\n+            {description}\n+          </span>\n+        </div>\n+\n+        <span\n+          className={cn(\n+            \"rounded-[0.75rem] bg-zinc-200 px-[0.5rem] font-sans text-xs leading-[1.25rem] text-zinc-500\",\n+          )}\n+        >\n+          Supports {ai_name}\n+        </span>\n+      </div>\n+      <div\n+        className={cn(\n+          \"flex h-7 w-7 items-center justify-center rounded-[0.5rem] bg-zinc-700 group-disabled:bg-zinc-400\",\n+        )}\n+      >\n+        <Plus className=\"h-5 w-5 text-zinc-50\" strokeWidth={2} />\n+      </div>\n+    </Button>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/BlockMenuSearch.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/BlockMenuSearch.tsx\nnew file mode 100644\nindex 000000000000..21edbaf5f569\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/BlockMenuSearch.tsx\n@@ -0,0 +1,144 @@\n+import React, { useEffect, useState, useCallback, useRef } from \"react\";\n+import { FiltersList } from \"./FiltersList\";\n+import { SearchList } from \"./SearchList\";\n+import { useBlockMenuContext } from \"../block-menu-provider\";\n+import { useBackendAPI } from \"@/lib/autogpt-server-api/context\";\n+import { cn } from \"@/lib/utils\";\n+import { scrollbarStyles } from \"@/components/styles/scrollbar\";\n+\n+export const BlockMenuSearch = () => {\n+  const {\n+    searchData,\n+    searchQuery,\n+    searchId,\n+    setSearchData,\n+    filters,\n+    setCategoryCounts,\n+  } = useBlockMenuContext();\n+  const [isLoading, setIsLoading] = useState<boolean>(false);\n+  const [hasMore, setHasMore] = useState<boolean>(true);\n+  const [page, setPage] = useState<number>(1);\n+  const [loadingMore, setLoadingMore] = useState<boolean>(false);\n+  const [error, setError] = useState<string | null>(null);\n+  const scrollRef = useRef<HTMLDivElement>(null);\n+  const api = useBackendAPI();\n+\n+  const pageSize = 10;\n+\n+  const fetchSearchData = useCallback(\n+    async (pageNum: number, isLoadMore: boolean = false) => {\n+      if (isLoadMore) {\n+        setLoadingMore(true);\n+      } else {\n+        setIsLoading(true);\n+      }\n+\n+      try {\n+        const activeCategories = Object.entries(filters.categories)\n+          .filter(([_, isActive]) => isActive)\n+          .map(([category, _]) => category)\n+          .map(\n+            (category) =>\n+              category as\n+                | \"blocks\"\n+                | \"integrations\"\n+                | \"marketplace_agents\"\n+                | \"my_agents\",\n+          );\n+\n+        const response = await api.searchBlocks({\n+          search_query: searchQuery,\n+          search_id: searchId,\n+          page: pageNum,\n+          page_size: pageSize,\n+          filter: activeCategories.length > 0 ? activeCategories : undefined,\n+          by_creator:\n+            filters.createdBy.length > 0 ? filters.createdBy : undefined,\n+        });\n+\n+        setCategoryCounts(response.total_items);\n+\n+        if (isLoadMore) {\n+          setSearchData((prev) => [...prev, ...response.items]);\n+        } else {\n+          setSearchData(response.items);\n+        }\n+\n+        setHasMore(response.more_pages);\n+        setError(null);\n+      } catch (error) {\n+        console.error(\"Error fetching search data:\", error);\n+        setError(\n+          error instanceof Error\n+            ? error.message\n+            : \"Failed to load search results\",\n+        );\n+        if (!isLoadMore) {\n+          setPage(1);\n+        }\n+      } finally {\n+        setIsLoading(false);\n+        setLoadingMore(false);\n+      }\n+    },\n+    [\n+      searchQuery,\n+      searchId,\n+      filters,\n+      api,\n+      setCategoryCounts,\n+      setSearchData,\n+      pageSize,\n+    ],\n+  );\n+\n+  const handleScroll = useCallback(() => {\n+    if (!scrollRef.current || loadingMore || !hasMore) return;\n+\n+    const { scrollTop, scrollHeight, clientHeight } = scrollRef.current;\n+    if (scrollTop + clientHeight >= scrollHeight - 100) {\n+      const nextPage = page + 1;\n+      setPage(nextPage);\n+      fetchSearchData(nextPage, true);\n+    }\n+  }, [loadingMore, hasMore, page, fetchSearchData]);\n+\n+  useEffect(() => {\n+    const scrollElement = scrollRef.current;\n+    if (scrollElement) {\n+      scrollElement.addEventListener(\"scroll\", handleScroll);\n+      return () => scrollElement.removeEventListener(\"scroll\", handleScroll);\n+    }\n+  }, [handleScroll]);\n+\n+  useEffect(() => {\n+    if (searchQuery) {\n+      setPage(1);\n+      setHasMore(true);\n+      setError(null);\n+      fetchSearchData(1, false);\n+    } else {\n+      setSearchData([]);\n+      setError(null);\n+      setPage(1);\n+      setHasMore(true);\n+    }\n+  }, [searchQuery, searchId, filters, fetchSearchData, setSearchData]);\n+\n+  return (\n+    <div ref={scrollRef} className={cn(scrollbarStyles, \"space-y-4 py-4\")}>\n+      {searchData.length !== 0 && <FiltersList />}\n+      <SearchList\n+        isLoading={isLoading}\n+        loadingMore={loadingMore}\n+        hasMore={hasMore}\n+        error={error}\n+        onRetry={() => {\n+          setPage(1);\n+          setError(null);\n+          fetchSearchData(1, false);\n+        }}\n+      />\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/FilterSheet.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/FilterSheet.tsx\nnew file mode 100644\nindex 000000000000..9a1ba5d4ca15\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/FilterSheet.tsx\n@@ -0,0 +1,255 @@\n+import { FilterChip } from \"../FilterChip\";\n+import { useState, useEffect } from \"react\";\n+import { Button } from \"@/components/ui/button\";\n+import { X } from \"lucide-react\";\n+import { cn, getBlockType } from \"@/lib/utils\";\n+import { Separator } from \"@/components/ui/separator\";\n+import { Checkbox } from \"@/components/ui/checkbox\";\n+import {\n+  CategoryKey,\n+  Filters,\n+  useBlockMenuContext,\n+} from \"../block-menu-provider\";\n+import { StoreAgent } from \"@/lib/autogpt-server-api\";\n+import { getDefaultFilters } from \"../helpers\";\n+import { scrollbarStyles } from \"@/components/styles/scrollbar\";\n+\n+const INITIAL_CREATORS_TO_SHOW = 5;\n+\n+export function FilterSheet({\n+  categories,\n+}: {\n+  categories: Array<{ key: CategoryKey; name: string }>;\n+}) {\n+  const { filters, setFilters, searchData } = useBlockMenuContext();\n+  const [isOpen, setIsOpen] = useState(false);\n+  const [isSheetVisible, setIsSheetVisible] = useState(false);\n+  const [localFilters, setLocalFilters] = useState<Filters>(filters);\n+\n+  const [creators, setCreators] = useState<string[]>([]);\n+  const [displayedCreatorsCount, setDisplayedCreatorsCount] = useState(\n+    INITIAL_CREATORS_TO_SHOW,\n+  );\n+\n+  useEffect(() => {\n+    if (isOpen) {\n+      setIsSheetVisible(true);\n+      setLocalFilters(filters);\n+      setDisplayedCreatorsCount(INITIAL_CREATORS_TO_SHOW); // Reset on open\n+\n+      const marketplaceAgents = (searchData?.filter(\n+        (item) => getBlockType(item) === \"store_agent\",\n+      ) || []) as StoreAgent[];\n+\n+      const uniqueCreators = Array.from(\n+        new Set(marketplaceAgents.map((agent) => agent.creator)),\n+      );\n+\n+      setCreators(uniqueCreators);\n+    } else {\n+      const timer = setTimeout(() => {\n+        setIsSheetVisible(false);\n+      }, 300);\n+      return () => clearTimeout(timer);\n+    }\n+  }, [isOpen, filters, searchData]);\n+\n+  const onCategoryChange = (category: CategoryKey) => {\n+    setLocalFilters((prev) => ({\n+      ...prev,\n+      categories: {\n+        ...prev.categories,\n+        [category]: !prev.categories[category],\n+      },\n+    }));\n+  };\n+\n+  const onCreatorChange = (creator: string) => {\n+    setLocalFilters((prev) => {\n+      const updatedCreators = prev.createdBy.includes(creator)\n+        ? prev.createdBy.filter((c) => c !== creator)\n+        : [...prev.createdBy, creator];\n+\n+      return {\n+        ...prev,\n+        createdBy: updatedCreators,\n+      };\n+    });\n+  };\n+\n+  const handleApplyFilters = () => {\n+    setFilters(localFilters);\n+    setIsOpen(false);\n+  };\n+\n+  const handleClearFilters = () => {\n+    const clearedFilters: Filters = getDefaultFilters();\n+    setFilters(clearedFilters);\n+    setIsOpen(false);\n+  };\n+\n+  const hasLocalActiveFilters = () => {\n+    const hasCategoryFilter = Object.values(localFilters.categories).some(\n+      (value) => value,\n+    );\n+    const hasCreatorFilter = localFilters.createdBy.length > 0;\n+\n+    return hasCategoryFilter || hasCreatorFilter;\n+  };\n+\n+  const hasActiveFilters = () => {\n+    const hasCategoryFilter = Object.values(filters.categories).some(\n+      (value) => value,\n+    );\n+    const hasCreatorFilter = filters.createdBy.length > 0;\n+\n+    return hasCategoryFilter || hasCreatorFilter;\n+  };\n+\n+  const handleToggleShowMoreCreators = () => {\n+    if (displayedCreatorsCount < creators.length) {\n+      setDisplayedCreatorsCount(creators.length);\n+    } else {\n+      setDisplayedCreatorsCount(INITIAL_CREATORS_TO_SHOW);\n+    }\n+  };\n+\n+  const visibleCreators = creators.slice(0, displayedCreatorsCount);\n+\n+  return (\n+    <div className=\"m-0 ml-4 inline w-fit p-0\">\n+      <Button\n+        onClick={() => {\n+          setIsSheetVisible(true);\n+          requestAnimationFrame(() => {\n+            requestAnimationFrame(() => {\n+              setIsOpen(true);\n+            });\n+          });\n+        }}\n+        variant={\"link\"}\n+        className=\"m-0 p-0 hover:no-underline\"\n+      >\n+        <FilterChip\n+          name={hasActiveFilters() ? \"Edit filters\" : \"All filters\"}\n+        />\n+      </Button>\n+\n+      {isSheetVisible && (\n+        <>\n+          <div\n+            className={cn(\n+              \"absolute bottom-2 left-2 top-2 z-20 w-3/4 max-w-[22.5rem] space-y-4 overflow-hidden rounded-[0.75rem] bg-white pb-4 shadow-[0_4px_12px_2px_rgba(0,0,0,0.1)] transition-all\",\n+              isOpen\n+                ? \"translate-x-0 duration-300 ease-out\"\n+                : \"-translate-x-full duration-300 ease-out\",\n+            )}\n+          >\n+            <div className={cn(\"flex-1 space-y-4 pb-16\", scrollbarStyles)}>\n+              {/* Top */}\n+              <div className=\"flex items-center justify-between px-5\">\n+                <p className=\"font-sans text-base text-[#040404]\">Filters</p>\n+                <Button\n+                  variant=\"ghost\"\n+                  size=\"icon\"\n+                  onClick={() => setIsOpen(false)}\n+                >\n+                  <X className=\"h-5 w-5\" />\n+                </Button>\n+              </div>\n+\n+              <Separator className=\"h-[1px] w-full text-zinc-300\" />\n+\n+              {/* Categories */}\n+\n+              <div className=\"space-y-4 px-5\">\n+                <p className=\"font-sans text-base font-medium text-zinc-800\">\n+                  Categories\n+                </p>\n+                <div className=\"space-y-2\">\n+                  {categories.map((category) => (\n+                    <div\n+                      key={category.key}\n+                      className=\"flex items-center space-x-2\"\n+                    >\n+                      <Checkbox\n+                        id={category.key}\n+                        checked={localFilters.categories[category.key]}\n+                        onCheckedChange={() => onCategoryChange(category.key)}\n+                        className=\"border border-[#D4D4D4] shadow-none data-[state=checked]:border-none data-[state=checked]:bg-violet-700 data-[state=checked]:text-white\"\n+                      />\n+                      <label\n+                        htmlFor={category.key}\n+                        className=\"font-sans text-sm leading-[1.375rem] text-zinc-600\"\n+                      >\n+                        {category.name}\n+                      </label>\n+                    </div>\n+                  ))}\n+                </div>\n+              </div>\n+\n+              <Separator className=\"h-[1px] w-full text-zinc-300\" />\n+\n+              {/* Created By */}\n+\n+              <div className=\"space-y-4 px-5\">\n+                <p className=\"font-sans text-base font-medium text-zinc-800\">\n+                  Created by\n+                </p>\n+                <div className=\"space-y-2\">\n+                  {visibleCreators.map((creator) => (\n+                    <div key={creator} className=\"flex items-center space-x-2\">\n+                      <Checkbox\n+                        id={`creator-${creator}`}\n+                        checked={localFilters.createdBy.includes(creator)}\n+                        onCheckedChange={() => onCreatorChange(creator)}\n+                        className=\"border border-[#D4D4D4] shadow-none data-[state=checked]:border-none data-[state=checked]:bg-violet-700 data-[state=checked]:text-white\"\n+                      />\n+                      <label\n+                        htmlFor={`creator-${creator}`}\n+                        className=\"font-sans text-sm leading-[1.375rem] text-zinc-600\"\n+                      >\n+                        {creator}\n+                      </label>\n+                    </div>\n+                  ))}\n+                </div>\n+                {creators.length > INITIAL_CREATORS_TO_SHOW && (\n+                  <Button\n+                    variant={\"link\"}\n+                    className=\"m-0 p-0 font-sans text-sm font-medium leading-[1.375rem] text-zinc-800 underline hover:text-zinc-600\"\n+                    onClick={handleToggleShowMoreCreators}\n+                  >\n+                    {displayedCreatorsCount < creators.length ? \"More\" : \"Less\"}\n+                  </Button>\n+                )}\n+              </div>\n+            </div>\n+\n+            {/* Footer buttons */}\n+            <div className=\"fixed bottom-0 flex w-full justify-between gap-3 border-t border-zinc-300 bg-white px-5 py-3\">\n+              <Button\n+                className=\"min-w-[5rem] rounded-[0.5rem] border-none px-1.5 py-2 font-sans text-sm font-medium leading-[1.375rem] text-zinc-800 shadow-none ring-1 ring-zinc-400\"\n+                variant={\"outline\"}\n+                onClick={handleClearFilters}\n+              >\n+                Clear\n+              </Button>\n+\n+              <Button\n+                className={cn(\n+                  \"min-w-[6.25rem] rounded-[0.5rem] border-none px-1.5 py-2 font-sans text-sm font-medium leading-[1.375rem] text-white shadow-none ring-1 disabled:ring-0\",\n+                )}\n+                onClick={handleApplyFilters}\n+                disabled={!hasLocalActiveFilters()}\n+              >\n+                Apply filters\n+              </Button>\n+            </div>\n+          </div>\n+        </>\n+      )}\n+    </div>\n+  );\n+}\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/FiltersList.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/FiltersList.tsx\nnew file mode 100644\nindex 000000000000..da034fcc9f52\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/FiltersList.tsx\n@@ -0,0 +1,63 @@\n+import { useCallback } from \"react\";\n+import { FilterChip } from \"../FilterChip\";\n+import { FilterSheet } from \"./FilterSheet\";\n+import { CategoryKey, useBlockMenuContext } from \"../block-menu-provider\";\n+\n+export const FiltersList = () => {\n+  const { filters, setFilters, categoryCounts } = useBlockMenuContext();\n+  const categories: Array<{ key: CategoryKey; name: string }> = [\n+    { key: \"blocks\", name: \"Blocks\" },\n+    { key: \"integrations\", name: \"Integrations\" },\n+    { key: \"marketplace_agents\", name: \"Marketplace agents\" },\n+    { key: \"my_agents\", name: \"My agents\" },\n+  ];\n+\n+  const handleCategoryFilter = (category: CategoryKey) => {\n+    setFilters({\n+      ...filters,\n+      categories: {\n+        ...filters.categories,\n+        [category]: !filters.categories[category],\n+      },\n+    });\n+  };\n+\n+  const handleCreatorFilter = useCallback(\n+    (creator: string) => {\n+      const updatedCreators = filters.createdBy.includes(creator)\n+        ? filters.createdBy.filter((c) => c !== creator)\n+        : [...filters.createdBy, creator];\n+\n+      setFilters({\n+        ...filters,\n+        createdBy: updatedCreators,\n+      });\n+    },\n+    [filters, setFilters],\n+  );\n+\n+  return (\n+    <div className=\"flex flex-nowrap gap-3 overflow-x-auto scrollbar-hide\">\n+      <FilterSheet categories={categories} />\n+\n+      {filters.createdBy.map((creator) => (\n+        <FilterChip\n+          key={creator}\n+          name={\"Created by \" + creator}\n+          selected={true}\n+          onClick={() => handleCreatorFilter(creator)}\n+        />\n+      ))}\n+\n+      {categories.map((category) => (\n+        <FilterChip\n+          key={category.key}\n+          name={category.name}\n+          number={categoryCounts[category.key]}\n+          selected={filters.categories[category.key]}\n+          onClick={() => handleCategoryFilter(category.key)}\n+        />\n+      ))}\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/SearchList.tsx b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/SearchList.tsx\nnew file mode 100644\nindex 000000000000..aaad3153b454\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/components/builder/block-menu/search-and-filter/SearchList.tsx\n@@ -0,0 +1,171 @@\n+import React from \"react\";\n+import { MarketplaceAgentBlock } from \"../MarketplaceAgentBlock\";\n+import { Block } from \"../Block\";\n+import { UGCAgentBlock } from \"../UGCAgentBlock\";\n+import { AiBlock } from \"./AiBlock\";\n+import { IntegrationBlock } from \"../IntegrationBlock\";\n+import { useBlockMenuContext } from \"../block-menu-provider\";\n+import { NoSearchResult } from \"./NoSearchResult\";\n+import { Button } from \"@/components/ui/button\";\n+import { convertLibraryAgentIntoBlock, getBlockType } from \"@/lib/utils\";\n+\n+interface SearchListProps {\n+  isLoading: boolean;\n+  loadingMore: boolean;\n+  hasMore: boolean;\n+  error: string | null;\n+  onRetry: () => void;\n+}\n+\n+export const SearchList: React.FC<SearchListProps> = ({\n+  isLoading,\n+  loadingMore,\n+  hasMore,\n+  error,\n+  onRetry,\n+}) => {\n+  const { searchQuery, addNode, loadingSlug, searchData, handleAddStoreAgent } =\n+    useBlockMenuContext();\n+\n+  if (isLoading) {\n+    return (\n+      <div className=\"space-y-2.5 px-4\">\n+        <p className=\"font-sans text-sm font-medium leading-[1.375rem] text-zinc-800\">\n+          Search results\n+        </p>\n+        {Array(6)\n+          .fill(0)\n+          .map((_, i) => (\n+            <Block.Skeleton key={i} />\n+          ))}\n+      </div>\n+    );\n+  }\n+\n+  if (error) {\n+    return (\n+      <div className=\"px-4\">\n+        <div className=\"rounded-lg border border-red-200 bg-red-50 p-3\">\n+          <p className=\"mb-2 text-sm text-red-600\">\n+            Error loading search results: {error}\n+          </p>\n+          <Button\n+            variant=\"outline\"\n+            size=\"sm\"\n+            onClick={onRetry}\n+            className=\"h-7 text-xs\"\n+          >\n+            Retry\n+          </Button>\n+        </div>\n+      </div>\n+    );\n+  }\n+\n+  if (searchData.length === 0) {\n+    return <NoSearchResult />;\n+  }\n+\n+  return (\n+    <div className=\"space-y-2.5 px-4\">\n+      <p className=\"font-sans text-sm font-medium leading-[1.375rem] text-zinc-800\">\n+        Search results\n+      </p>\n+      {searchData.map((item: any, index: number) => {\n+        const blockType = getBlockType(item);\n+\n+        switch (blockType) {\n+          case \"store_agent\":\n+            return (\n+              <MarketplaceAgentBlock\n+                key={index}\n+                slug={item.slug}\n+                highlightedText={searchQuery}\n+                title={item.agent_name}\n+                image_url={item.agent_image}\n+                creator_name={item.creator}\n+                number_of_runs={item.runs}\n+                loading={loadingSlug == item.slug}\n+                onClick={() =>\n+                  handleAddStoreAgent({\n+                    creator_name: item.creator,\n+                    slug: item.slug,\n+                  })\n+                }\n+              />\n+            );\n+          case \"block\":\n+            return (\n+              <Block\n+                key={index}\n+                title={item.name}\n+                highlightedText={searchQuery}\n+                description={item.description}\n+                onClick={() => {\n+                  addNode(item);\n+                }}\n+              />\n+            );\n+          case \"provider\":\n+            return (\n+              <IntegrationBlock\n+                key={index}\n+                title={item.name}\n+                highlightedText={searchQuery}\n+                icon_url={`/integrations/${item.name}.png`}\n+                description={item.description}\n+                onClick={() => {\n+                  addNode(item);\n+                }}\n+              />\n+            );\n+          case \"library_agent\":\n+            return (\n+              <UGCAgentBlock\n+                key={index}\n+                title={item.name}\n+                highlightedText={searchQuery}\n+                image_url={item.image_url}\n+                version={item.graph_version}\n+                edited_time={item.updated_at}\n+                onClick={() => {\n+                  const block = convertLibraryAgentIntoBlock(item);\n+                  addNode(block);\n+                }}\n+              />\n+            );\n+          case \"ai_agent\":\n+            return (\n+              <AiBlock\n+                key={index}\n+                title={item.name}\n+                description={item.description}\n+                ai_name={item.inputSchema.properties.model.enum.find(\n+                  (model: string) =>\n+                    model\n+                      .toLowerCase()\n+                      .includes(searchQuery.toLowerCase().trim()),\n+                )}\n+                onClick={() => {\n+                  const block = convertLibraryAgentIntoBlock(item);\n+                  addNode(block);\n+                }}\n+              />\n+            );\n+\n+          default:\n+            return null;\n+        }\n+      })}\n+      {loadingMore && hasMore && (\n+        <div className=\"space-y-2.5\">\n+          {Array(3)\n+            .fill(0)\n+            .map((_, i) => (\n+              <Block.Skeleton key={`loading-more-${i}`} />\n+            ))}\n+        </div>\n+      )}\n+    </div>\n+  );\n+};\ndiff --git a/autogpt_platform/frontend/src/hooks/usePagination.ts b/autogpt_platform/frontend/src/hooks/usePagination.ts\nnew file mode 100644\nindex 000000000000..bce8e9c96a3d\n--- /dev/null\n+++ b/autogpt_platform/frontend/src/hooks/usePagination.ts\n@@ -0,0 +1,232 @@\n+import { useState, useCallback, useRef, useEffect } from \"react\";\n+import { useBackendAPI } from \"@/lib/autogpt-server-api/context\";\n+import {\n+  Block,\n+  BlockRequest,\n+  Provider,\n+  StoreAgent,\n+  LibraryAgent,\n+  LibraryAgentSortEnum,\n+} from \"@/lib/autogpt-server-api\";\n+\n+type BlocksPaginationRequest = { apiType: \"blocks\" } & BlockRequest;\n+type ProvidersPaginationRequest = { apiType: \"providers\" } & {\n+  page?: number;\n+  page_size?: number;\n+};\n+type StoreAgentsPaginationRequest = { apiType: \"store-agents\" } & {\n+  featured?: boolean;\n+  creator?: string;\n+  sorted_by?: string;\n+  search_query?: string;\n+  category?: string;\n+  page?: number;\n+  page_size?: number;\n+};\n+type LibraryAgentsPaginationRequest = { apiType: \"library-agents\" } & {\n+  search_term?: string;\n+  sort_by?: LibraryAgentSortEnum;\n+  page?: number;\n+  page_size?: number;\n+};\n+\n+type PaginationRequest =\n+  | BlocksPaginationRequest\n+  | ProvidersPaginationRequest\n+  | StoreAgentsPaginationRequest\n+  | LibraryAgentsPaginationRequest;\n+\n+interface UsePaginationOptions<T extends PaginationRequest> {\n+  request: T;\n+  pageSize?: number;\n+  enabled?: boolean;\n+}\n+\n+interface UsePaginationReturn<T> {\n+  data: T[];\n+  loading: boolean;\n+  loadingMore: boolean;\n+  hasMore: boolean;\n+  error: string | null;\n+  scrollRef: React.RefObject<HTMLDivElement>;\n+  refresh: () => void;\n+  loadMore: () => void;\n+}\n+\n+type GetReturnType<T> = T extends BlocksPaginationRequest\n+  ? Block\n+  : T extends ProvidersPaginationRequest\n+    ? Provider\n+    : T extends StoreAgentsPaginationRequest\n+      ? StoreAgent\n+      : T extends LibraryAgentsPaginationRequest\n+        ? LibraryAgent\n+        : never;\n+\n+export const usePagination = <T extends PaginationRequest>({\n+  request,\n+  pageSize = 10,\n+  enabled = true, // to allow pagination or not\n+}: UsePaginationOptions<T>): UsePaginationReturn<GetReturnType<T>> => {\n+  const [data, setData] = useState<GetReturnType<T>[]>([]);\n+  const [loading, setLoading] = useState(true);\n+  const [loadingMore, setLoadingMore] = useState(false);\n+  const [hasMore, setHasMore] = useState(true);\n+  const [currentPage, setCurrentPage] = useState(1);\n+  const [error, setError] = useState<string | null>(null);\n+  const scrollRef = useRef<HTMLDivElement>(null);\n+  const isLoadingRef = useRef(false);\n+  const requestRef = useRef(request);\n+  const api = useBackendAPI();\n+\n+  // because we are using this pagination for multiple components\n+  requestRef.current = request;\n+\n+  const fetchData = useCallback(\n+    async (page: number, isLoadMore = false) => {\n+      if (isLoadingRef.current || !enabled) return;\n+\n+      isLoadingRef.current = true;\n+\n+      if (isLoadMore) {\n+        setLoadingMore(true);\n+      } else {\n+        setLoading(true);\n+      }\n+\n+      setError(null);\n+\n+      try {\n+        let response;\n+        let newData: GetReturnType<T>[];\n+        let pagination;\n+\n+        const currentRequest = requestRef.current;\n+        const requestWithPagination = {\n+          ...currentRequest,\n+          page,\n+          page_size: pageSize,\n+        };\n+\n+        switch (currentRequest.apiType) {\n+          case \"blocks\":\n+            const { apiType: _, ...blockRequest } = requestWithPagination;\n+            response = await api.getBuilderBlocks(blockRequest);\n+            newData = response.blocks as GetReturnType<T>[];\n+            pagination = response.pagination;\n+            break;\n+\n+          case \"providers\":\n+            const { apiType: __, ...providerRequest } = requestWithPagination;\n+            response = await api.getProviders(providerRequest);\n+            newData = response.providers as GetReturnType<T>[];\n+            pagination = response.pagination;\n+            break;\n+\n+          case \"store-agents\":\n+            const { apiType: ___, ...storeAgentRequest } =\n+              requestWithPagination;\n+            response = await api.getStoreAgents(storeAgentRequest);\n+            newData = response.agents as GetReturnType<T>[];\n+            pagination = response.pagination;\n+            break;\n+\n+          case \"library-agents\":\n+            const { apiType: ____, ...libraryAgentRequest } =\n+              requestWithPagination;\n+            response = await api.listLibraryAgents(libraryAgentRequest);\n+            newData = response.agents as GetReturnType<T>[];\n+            pagination = response.pagination;\n+            break;\n+\n+          default:\n+            throw new Error(\n+              `Unknown request type: ${(currentRequest as any).apiType}`,\n+            );\n+        }\n+\n+        if (isLoadMore) {\n+          setData((prev) => [...prev, ...newData]);\n+        } else {\n+          setData(newData);\n+        }\n+\n+        setHasMore(page < pagination.total_pages);\n+        setCurrentPage(page);\n+      } catch (err) {\n+        const errorMessage =\n+          err instanceof Error ? err.message : \"Failed to fetch data\";\n+        setError(errorMessage);\n+        console.error(\"Error fetching data:\", err);\n+      } finally {\n+        setLoading(false);\n+        setLoadingMore(false);\n+        isLoadingRef.current = false;\n+      }\n+    },\n+    [api, pageSize, enabled],\n+  );\n+\n+  const handleScroll = useCallback(() => {\n+    const scrollElement = scrollRef.current;\n+    if (\n+      !scrollElement ||\n+      loadingMore ||\n+      !hasMore ||\n+      isLoadingRef.current ||\n+      !enabled\n+    )\n+      return;\n+\n+    const { scrollTop, scrollHeight, clientHeight } = scrollElement;\n+    const threshold = 100;\n+\n+    if (scrollTop + clientHeight >= scrollHeight - threshold) {\n+      fetchData(currentPage + 1, true);\n+    }\n+  }, [fetchData, currentPage, loadingMore, hasMore, enabled]);\n+\n+  const refresh = useCallback(() => {\n+    setCurrentPage(1);\n+    setHasMore(true);\n+    setError(null);\n+    fetchData(1);\n+  }, [fetchData]);\n+\n+  const loadMore = useCallback(() => {\n+    if (!loadingMore && hasMore && !isLoadingRef.current && enabled) {\n+      fetchData(currentPage + 1, true);\n+    }\n+  }, [fetchData, currentPage, loadingMore, hasMore, enabled]);\n+\n+  const requestString = JSON.stringify(request);\n+\n+  useEffect(() => {\n+    if (enabled) {\n+      setCurrentPage(1);\n+      setHasMore(true);\n+      setError(null);\n+      setData([]);\n+      fetchData(1);\n+    }\n+  }, [requestString, enabled, fetchData]);\n+\n+  useEffect(() => {\n+    const scrollElement = scrollRef.current;\n+    if (scrollElement && enabled) {\n+      scrollElement.addEventListener(\"scroll\", handleScroll);\n+      return () => scrollElement.removeEventListener(\"scroll\", handleScroll);\n+    }\n+  }, [handleScroll, enabled]);\n+\n+  return {\n+    data,\n+    loading,\n+    loadingMore,\n+    hasMore,\n+    error,\n+    scrollRef,\n+    refresh,\n+    loadMore,\n+  };\n+};\ndiff --git a/autogpt_platform/frontend/src/lib/autogpt-server-api/types.ts b/autogpt_platform/frontend/src/lib/autogpt-server-api/types.ts\nindex b4ba851053d0..f00dba21d2a2 100644\n--- a/autogpt_platform/frontend/src/lib/autogpt-server-api/types.ts\n+++ b/autogpt_platform/frontend/src/lib/autogpt-server-api/types.ts\n@@ -27,6 +27,71 @@ export type BlockCost = {\n   cost_filter: { [key: string]: any };\n };\n \n+/* Mirror of backend/server/v2/builder/model.py:SuggestionsResponse */\n+export type SuggestionsResponse = {\n+  otto_suggestions: string[];\n+  recent_searches: string[];\n+  providers: string[];\n+  top_blocks: Block[];\n+};\n+\n+/* Mirror of backend/server/v2/builder/model.py:BlockCategoryResponse */\n+export type BlockCategoryResponse = {\n+  name: string;\n+  total_blocks: number;\n+  blocks: Block[];\n+};\n+\n+export type BlockRequest = {\n+  page?: number;\n+  page_size?: number;\n+} & (\n+  | { category?: string }\n+  | { type?: \"all\" | \"input\" | \"action\" | \"output\" }\n+  | { provider?: CredentialsProviderName }\n+);\n+\n+/* Mirror of backend/server/v2/builder/model.py:BlockReponse */\n+export type BlockResponse = {\n+  blocks: Block[];\n+  pagination: Pagination;\n+};\n+\n+/* Mirror of backend/server/v2/builder/model.py:Provider */\n+export type Provider = {\n+  name: CredentialsProviderName;\n+  description: string;\n+  integration_count: number;\n+};\n+\n+/* Mirror of backend/server/v2/builder/model.py:ProviderResponse */\n+export type ProviderResponse = {\n+  providers: Provider[];\n+  pagination: Pagination;\n+};\n+\n+/* Mirror of backend/server/v2/builder/model.py:BlockSearchResponse */\n+export type BlockSearchResponse = {\n+  items: (Block | LibraryAgent | StoreAgent)[];\n+  total_items: Record<\n+    \"blocks\" | \"integrations\" | \"marketplace_agents\" | \"my_agents\",\n+    number\n+  >;\n+  page: number;\n+  more_pages: boolean;\n+};\n+\n+/* Mirror of backend/server/v2/builder/model.py:CountResponse */\n+export type CountResponse = {\n+  all_blocks: number;\n+  input_blocks: number;\n+  action_blocks: number;\n+  output_blocks: number;\n+  integrations: number;\n+  marketplace_agents: number;\n+  my_agents: number;\n+};\n+\n /* Mirror of backend/data/block.py:Block */\n export type Block = {\n   id: string;\n\ndiff --git a/autogpt_platform/frontend/src/lib/utils.ts b/autogpt_platform/frontend/src/lib/utils.ts\nindex 3eea21add85f..3be378777830 100644\n--- a/autogpt_platform/frontend/src/lib/utils.ts\n+++ b/autogpt_platform/frontend/src/lib/utils.ts\n@@ -397,7 +403,59 @@ export function isEmptyOrWhitespace(str: string | undefined | null): boolean {\n   return !str || str.trim().length === 0;\n }\n \n-/** Check if a value is an object or not */\n-export function isObject(value: unknown): value is Record<string, unknown> {\n-  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n+export const convertLibraryAgentIntoBlock = (agent: LibraryAgent) => {\n+  const block = {\n+    id: SpecialBlockID.AGENT,\n+    name: agent.name,\n+    description:\n+      `Ver.${agent.graph_version}` +\n+      (agent.description ? ` | ${agent.description}` : \"\"),\n+    categories: [{ category: \"AGENT\", description: \"\" }],\n+    inputSchema: agent.input_schema,\n+    outputSchema: agent.output_schema,\n+    staticOutput: false,\n+    uiType: BlockUIType.AGENT,\n+    uiKey: agent.id,\n+    costs: [],\n+    hardcodedValues: {\n+      graph_id: agent.graph_id,\n+      graph_version: agent.graph_version,\n+      input_schema: agent.input_schema,\n+      output_schema: agent.output_schema,\n+      agent_name: agent.name,\n+    },\n+  } as Block;\n+\n+  return block;\n+};\n+\n+// Need to change it once, we got provider blocks\n+export const getBlockType = (item: any) => {\n+  if (item?.inputSchema?.properties?.model?.title === \"LLM Model\") {\n+    return \"ai_agent\";\n+  }\n+  if (item.id && item.name && item.inputSchema && item.outputSchema) {\n+    return \"block\";\n+  }\n+  if (item.name && typeof item.integration_count === \"number\") {\n+    return \"provider\";\n+  }\n+  if (item.id && item.graph_id && item.status) {\n+    return \"library_agent\";\n+  }\n+  if (item.slug && item.agent_name && item.runs !== undefined) {\n+    return \"store_agent\";\n+  }\n+\n+  return null;\n+};\n+\n+export function parseErrorMessage(error: unknown, message?: string): string {\n+  const errorMessage = error\n+    ? error instanceof Error\n+      ? error.message\n+      : String(error)\n+    : message || \"An unexpected error occurred. Please try again.\";\n+\n+  return errorMessage;\n }\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR shows strong effort in redesigning the block menu, but it lacks key elements needed for merging. Firstly, the PR checklist is incomplete, which is essential for code quality assurance. Secondly, while the title implies frontend changes only, it includes substantial backend additions—update the title to reflect both aspects or consider splitting the PR. Finally, provide a clear test plan outlining how you've verified functionality. Overall, the code organization looks solid, so once these points are addressed, we can move forward with the review."
      }
    ],
    "token_estimation": 30299.5
  },
  {
    "index": 2,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/autogpt/app.py b/autogpt/app.py\nindex 58d9f7164ddf..cf8e29a36dd3 100644\n--- a/autogpt/app.py\n+++ b/autogpt/app.py\n@@ -119,105 +103,29 @@ def execute_command(command_name: str, arguments):\n         str: The result of the command\n     \"\"\"\n     try:\n+        cmd = command_registry.commands.get(command_name)\n+\n+        # If the command is found, call it with the provided arguments\n+        if cmd:\n+            return cmd(**arguments)\n+\n+        # TODO: Remove commands below after they are moved to the command registry.\n         command_name = map_command_synonyms(command_name.lower())\n-        if command_name == \"google\":\n-            # Check if the Google API key is set and use the official search method\n-            # If the API key is not set or has only whitespaces, use the unofficial\n-            # search method\n-            key = CFG.google_api_key\n-            if key and key.strip() and key != \"your-google-api-key\":\n-                google_result = google_official_search(arguments[\"input\"])\n-                return google_result\n-            else:\n-                google_result = google_search(arguments[\"input\"])\n-\n-            # google_result can be a list or a string depending on the search results\n-            if isinstance(google_result, list):\n-                safe_message = [\n-                    google_result_single.encode(\"utf-8\", \"ignore\")\n-                    for google_result_single in google_result\n-                ]\n-            else:\n-                safe_message = google_result.encode(\"utf-8\", \"ignore\")\n-\n-            return safe_message.decode(\"utf-8\")\n-        elif command_name == \"memory_add\":\n-            memory = get_memory(CFG)\n-            return memory.add(arguments[\"string\"])\n-        elif command_name == \"start_agent\":\n-            return start_agent(\n-                arguments[\"name\"], arguments[\"task\"], arguments[\"prompt\"]\n-            )\n-        elif command_name == \"message_agent\":\n-            return message_agent(arguments[\"key\"], arguments[\"message\"])\n-        elif command_name == \"list_agents\":\n-            return list_agents()\n-        elif command_name == \"delete_agent\":\n-            return delete_agent(arguments[\"key\"])\n-        elif command_name == \"get_text_summary\":\n-            return get_text_summary(arguments[\"url\"], arguments[\"question\"])\n-        elif command_name == \"get_hyperlinks\":\n-            return get_hyperlinks(arguments[\"url\"])\n-        elif command_name == \"clone_repository\":\n-            return clone_repository(\n-                arguments[\"repository_url\"], arguments[\"clone_path\"]\n-            )\n-        elif command_name == \"read_file\":\n-            return read_file(arguments[\"file\"])\n-        elif command_name == \"write_to_file\":\n-            return write_to_file(arguments[\"file\"], arguments[\"text\"])\n-        elif command_name == \"append_to_file\":\n-            return append_to_file(arguments[\"file\"], arguments[\"text\"])\n-        elif command_name == \"delete_file\":\n-            return delete_file(arguments[\"file\"])\n-        elif command_name == \"search_files\":\n-            return search_files(arguments[\"directory\"])\n-        elif command_name == \"download_file\":\n-            if not CFG.allow_downloads:\n-                return \"Error: You do not have user authorization to download files locally.\"\n-            return download_file(arguments[\"url\"], arguments[\"file\"])\n-        elif command_name == \"browse_website\":\n-            return browse_website(arguments[\"url\"], arguments[\"question\"])\n+\n+        if command_name == \"memory_add\":\n+            return get_memory(CFG).add(arguments[\"string\"])\n+\n         # TODO: Change these to take in a file rather than pasted code, if\n         # non-file is given, return instructions \"Input should be a python\n-        # filepath, write your code to file and try again\"\n-        elif command_name == \"analyze_code\":\n-            return analyze_code(arguments[\"code\"])\n-        elif command_name == \"improve_code\":\n-            return improve_code(arguments[\"suggestions\"], arguments[\"code\"])\n-        elif command_name == \"write_tests\":\n-            return write_tests(arguments[\"code\"], arguments.get(\"focus\"))\n-        elif command_name == \"execute_python_file\":  # Add this command\n-            return execute_python_file(arguments[\"file\"])\n-        elif command_name == \"execute_shell\":\n-            if CFG.execute_local_commands:\n-                return execute_shell(arguments[\"command_line\"])\n-            else:\n-                return (\n-                    \"You are not allowed to run local shell commands. To execute\"\n-                    \" shell commands, EXECUTE_LOCAL_COMMANDS must be set to 'True' \"\n-                    \"in your config. Do not attempt to bypass the restriction.\"\n-                )\n-        elif command_name == \"execute_shell_popen\":\n-            if CFG.execute_local_commands:\n-                return execute_shell_popen(arguments[\"command_line\"])\n-            else:\n-                return (\n-                    \"You are not allowed to run local shell commands. To execute\"\n-                    \" shell commands, EXECUTE_LOCAL_COMMANDS must be set to 'True' \"\n-                    \"in your config. Do not attempt to bypass the restriction.\"\n-                )\n-        elif command_name == \"read_audio_from_file\":\n-            return read_audio_from_file(arguments[\"file\"])\n-        elif command_name == \"generate_image\":\n-            return generate_image(arguments[\"prompt\"])\n-        elif command_name == \"send_tweet\":\n-            return send_tweet(arguments[\"text\"])\n+        # filepath, write your code to file and try again\n         elif command_name == \"do_nothing\":\n             return \"No action performed.\"\n         elif command_name == \"task_complete\":\n             shutdown()\n         else:\n+            for command in prompt.commands:\n+                if command_name == command[\"label\"] or command_name == command[\"name\"]:\n+                    return command[\"function\"](*arguments.values())\n             return (\n                 f\"Unknown command '{command_name}'. Please refer to the 'COMMANDS'\"\n                 \" list for available commands and only respond in the specified JSON\"\n\ndiff --git a/autogpt/commands/command.py b/autogpt/commands/command.py\nnew file mode 100644\nindex 000000000000..e97af008a440\n--- /dev/null\n+++ b/autogpt/commands/command.py\n@@ -0,0 +1,153 @@\n+import importlib\n+import inspect\n+from typing import Any, Callable, Optional\n+\n+# Unique identifier for auto-gpt commands\n+AUTO_GPT_COMMAND_IDENTIFIER = \"auto_gpt_command\"\n+\n+\n+class Command:\n+    \"\"\"A class representing a command.\n+\n+    Attributes:\n+        name (str): The name of the command.\n+        description (str): A brief description of what the command does.\n+        signature (str): The signature of the function that the command executes. Defaults to None.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        name: str,\n+        description: str,\n+        method: Callable[..., Any],\n+        signature: str = \"\",\n+        enabled: bool = True,\n+        disabled_reason: Optional[str] = None,\n+    ):\n+        self.name = name\n+        self.description = description\n+        self.method = method\n+        self.signature = signature if signature else str(inspect.signature(self.method))\n+        self.enabled = enabled\n+        self.disabled_reason = disabled_reason\n+\n+    def __call__(self, *args, **kwargs) -> Any:\n+        if not self.enabled:\n+            return f\"Command '{self.name}' is disabled: {self.disabled_reason}\"\n+        return self.method(*args, **kwargs)\n+\n+    def __str__(self) -> str:\n+        return f\"{self.name}: {self.description}, args: {self.signature}\"\n+\n+\n+class CommandRegistry:\n+    \"\"\"\n+    The CommandRegistry class is a manager for a collection of Command objects.\n+    It allows the registration, modification, and retrieval of Command objects,\n+    as well as the scanning and loading of command plugins from a specified\n+    directory.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.commands = {}\n+\n+    def _import_module(self, module_name: str) -> Any:\n+        return importlib.import_module(module_name)\n+\n+    def _reload_module(self, module: Any) -> Any:\n+        return importlib.reload(module)\n+\n+    def register(self, cmd: Command) -> None:\n+        self.commands[cmd.name] = cmd\n+\n+    def unregister(self, command_name: str):\n+        if command_name in self.commands:\n+            del self.commands[command_name]\n+        else:\n+            raise KeyError(f\"Command '{command_name}' not found in registry.\")\n+\n+    def reload_commands(self) -> None:\n+        \"\"\"Reloads all loaded command plugins.\"\"\"\n+        for cmd_name in self.commands:\n+            cmd = self.commands[cmd_name]\n+            module = self._import_module(cmd.__module__)\n+            reloaded_module = self._reload_module(module)\n+            if hasattr(reloaded_module, \"register\"):\n+                reloaded_module.register(self)\n+\n+    def get_command(self, name: str) -> Callable[..., Any]:\n+        return self.commands[name]\n+\n+    def call(self, command_name: str, **kwargs) -> Any:\n+        if command_name not in self.commands:\n+            raise KeyError(f\"Command '{command_name}' not found in registry.\")\n+        command = self.commands[command_name]\n+        return command(**kwargs)\n+\n+    def command_prompt(self) -> str:\n+        \"\"\"\n+        Returns a string representation of all registered `Command` objects for use in a prompt\n+        \"\"\"\n+        commands_list = [\n+            f\"{idx + 1}. {str(cmd)}\" for idx, cmd in enumerate(self.commands.values())\n+        ]\n+        return \"\\n\".join(commands_list)\n+\n+    def import_commands(self, module_name: str) -> None:\n+        \"\"\"\n+        Imports the specified Python module containing command plugins.\n+\n+        This method imports the associated module and registers any functions or\n+        classes that are decorated with the `AUTO_GPT_COMMAND_IDENTIFIER` attribute\n+        as `Command` objects. The registered `Command` objects are then added to the\n+        `commands` dictionary of the `CommandRegistry` object.\n+\n+        Args:\n+            module_name (str): The name of the module to import for command plugins.\n+        \"\"\"\n+\n+        module = importlib.import_module(module_name)\n+\n+        for attr_name in dir(module):\n+            attr = getattr(module, attr_name)\n+            # Register decorated functions\n+            if hasattr(attr, AUTO_GPT_COMMAND_IDENTIFIER) and getattr(\n+                attr, AUTO_GPT_COMMAND_IDENTIFIER\n+            ):\n+                self.register(attr.command)\n+            # Register command classes\n+            elif (\n+                inspect.isclass(attr) and issubclass(attr, Command) and attr != Command\n+            ):\n+                cmd_instance = attr()\n+                self.register(cmd_instance)\n+\n+\n+def command(\n+    name: str,\n+    description: str,\n+    signature: str = \"\",\n+    enabled: bool = True,\n+    disabled_reason: Optional[str] = None,\n+) -> Callable[..., Any]:\n+    \"\"\"The command decorator is used to create Command objects from ordinary functions.\"\"\"\n+\n+    def decorator(func: Callable[..., Any]) -> Command:\n+        cmd = Command(\n+            name=name,\n+            description=description,\n+            method=func,\n+            signature=signature,\n+            enabled=enabled,\n+            disabled_reason=disabled_reason,\n+        )\n+\n+        def wrapper(*args, **kwargs) -> Any:\n+            return func(*args, **kwargs)\n+\n+        wrapper.command = cmd\n+\n+        setattr(wrapper, AUTO_GPT_COMMAND_IDENTIFIER, True)\n+        return wrapper\n+\n+    return decorator\ndiff --git a/autogpt/models/base_open_ai_plugin.py b/autogpt/models/base_open_ai_plugin.py\nnew file mode 100644\nindex 000000000000..046295c0dcbe\n--- /dev/null\n+++ b/autogpt/models/base_open_ai_plugin.py\n@@ -0,0 +1,199 @@\n+\"\"\"Handles loading of plugins.\"\"\"\n+from typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n+\n+from auto_gpt_plugin_template import AutoGPTPluginTemplate\n+\n+PromptGenerator = TypeVar(\"PromptGenerator\")\n+\n+\n+class Message(TypedDict):\n+    role: str\n+    content: str\n+\n+\n+class BaseOpenAIPlugin(AutoGPTPluginTemplate):\n+    \"\"\"\n+    This is a BaseOpenAIPlugin class for generating Auto-GPT plugins.\n+    \"\"\"\n+\n+    def __init__(self, manifests_specs_clients: dict):\n+        # super().__init__()\n+        self._name = manifests_specs_clients[\"manifest\"][\"name_for_model\"]\n+        self._version = manifests_specs_clients[\"manifest\"][\"schema_version\"]\n+        self._description = manifests_specs_clients[\"manifest\"][\"description_for_model\"]\n+        self._client = manifests_specs_clients[\"client\"]\n+        self._manifest = manifests_specs_clients[\"manifest\"]\n+        self._openapi_spec = manifests_specs_clients[\"openapi_spec\"]\n+\n+    def can_handle_on_response(self) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+        handle the on_response method.\n+        Returns:\n+            bool: True if the plugin can handle the on_response method.\"\"\"\n+        return False\n+\n+    def on_response(self, response: str, *args, **kwargs) -> str:\n+        \"\"\"This method is called when a response is received from the model.\"\"\"\n+        return response\n+\n+    def can_handle_post_prompt(self) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+        handle the post_prompt method.\n+        Returns:\n+            bool: True if the plugin can handle the post_prompt method.\"\"\"\n+        return False\n+\n+    def post_prompt(self, prompt: PromptGenerator) -> PromptGenerator:\n+        \"\"\"This method is called just after the generate_prompt is called,\n+            but actually before the prompt is generated.\n+        Args:\n+            prompt (PromptGenerator): The prompt generator.\n+        Returns:\n+            PromptGenerator: The prompt generator.\n+        \"\"\"\n+        return prompt\n+\n+    def can_handle_on_planning(self) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+        handle the on_planning method.\n+        Returns:\n+            bool: True if the plugin can handle the on_planning method.\"\"\"\n+        return False\n+\n+    def on_planning(\n+        self, prompt: PromptGenerator, messages: List[Message]\n+    ) -> Optional[str]:\n+        \"\"\"This method is called before the planning chat completion is done.\n+        Args:\n+            prompt (PromptGenerator): The prompt generator.\n+            messages (List[str]): The list of messages.\n+        \"\"\"\n+        pass\n+\n+    def can_handle_post_planning(self) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+        handle the post_planning method.\n+        Returns:\n+            bool: True if the plugin can handle the post_planning method.\"\"\"\n+        return False\n+\n+    def post_planning(self, response: str) -> str:\n+        \"\"\"This method is called after the planning chat completion is done.\n+        Args:\n+            response (str): The response.\n+        Returns:\n+            str: The resulting response.\n+        \"\"\"\n+        return response\n+\n+    def can_handle_pre_instruction(self) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+        handle the pre_instruction method.\n+        Returns:\n+            bool: True if the plugin can handle the pre_instruction method.\"\"\"\n+        return False\n+\n+    def pre_instruction(self, messages: List[Message]) -> List[Message]:\n+        \"\"\"This method is called before the instruction chat is done.\n+        Args:\n+            messages (List[Message]): The list of context messages.\n+        Returns:\n+            List[Message]: The resulting list of messages.\n+        \"\"\"\n+        return messages\n+\n+    def can_handle_on_instruction(self) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+        handle the on_instruction method.\n+        Returns:\n+            bool: True if the plugin can handle the on_instruction method.\"\"\"\n+        return False\n+\n+    def on_instruction(self, messages: List[Message]) -> Optional[str]:\n+        \"\"\"This method is called when the instruction chat is done.\n+        Args:\n+            messages (List[Message]): The list of context messages.\n+        Returns:\n+            Optional[str]: The resulting message.\n+        \"\"\"\n+        pass\n+\n+    def can_handle_post_instruction(self) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+        handle the post_instruction method.\n+        Returns:\n+            bool: True if the plugin can handle the post_instruction method.\"\"\"\n+        return False\n+\n+    def post_instruction(self, response: str) -> str:\n+        \"\"\"This method is called after the instruction chat is done.\n+        Args:\n+            response (str): The response.\n+        Returns:\n+            str: The resulting response.\n+        \"\"\"\n+        return response\n+\n+    def can_handle_pre_command(self) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+        handle the pre_command method.\n+        Returns:\n+            bool: True if the plugin can handle the pre_command method.\"\"\"\n+        return False\n+\n+    def pre_command(\n+        self, command_name: str, arguments: Dict[str, Any]\n+    ) -> Tuple[str, Dict[str, Any]]:\n+        \"\"\"This method is called before the command is executed.\n+        Args:\n+            command_name (str): The command name.\n+            arguments (Dict[str, Any]): The arguments.\n+        Returns:\n+            Tuple[str, Dict[str, Any]]: The command name and the arguments.\n+        \"\"\"\n+        return command_name, arguments\n+\n+    def can_handle_post_command(self) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+        handle the post_command method.\n+        Returns:\n+            bool: True if the plugin can handle the post_command method.\"\"\"\n+        return False\n+\n+    def post_command(self, command_name: str, response: str) -> str:\n+        \"\"\"This method is called after the command is executed.\n+        Args:\n+            command_name (str): The command name.\n+            response (str): The response.\n+        Returns:\n+            str: The resulting response.\n+        \"\"\"\n+        return response\n+\n+    def can_handle_chat_completion(\n+        self, messages: Dict[Any, Any], model: str, temperature: float, max_tokens: int\n+    ) -> bool:\n+        \"\"\"This method is called to check that the plugin can\n+          handle the chat_completion method.\n+        Args:\n+            messages (List[Message]): The messages.\n+            model (str): The model name.\n+            temperature (float): The temperature.\n+            max_tokens (int): The max tokens.\n+          Returns:\n+              bool: True if the plugin can handle the chat_completion method.\"\"\"\n+        return False\n+\n+    def handle_chat_completion(\n+        self, messages: List[Message], model: str, temperature: float, max_tokens: int\n+    ) -> str:\n+        \"\"\"This method is called when the chat completion is done.\n+        Args:\n+            messages (List[Message]): The messages.\n+            model (str): The model name.\n+            temperature (float): The temperature.\n+            max_tokens (int): The max tokens.\n+        Returns:\n+            str: The resulting response.\n+        \"\"\"\n+        pass\ndiff --git a/autogpt/plugins.py b/autogpt/plugins.py\nnew file mode 100644\nindex 000000000000..b536acbd5701\n--- /dev/null\n+++ b/autogpt/plugins.py\n@@ -0,0 +1,265 @@\n+\"\"\"Handles loading of plugins.\"\"\"\n+\n+import importlib\n+import json\n+import os\n+import zipfile\n+from pathlib import Path\n+from typing import List, Optional, Tuple\n+from urllib.parse import urlparse\n+from zipimport import zipimporter\n+\n+import openapi_python_client\n+import requests\n+from auto_gpt_plugin_template import AutoGPTPluginTemplate\n+from openapi_python_client.cli import Config as OpenAPIConfig\n+\n+from autogpt.config import Config\n+from autogpt.models.base_open_ai_plugin import BaseOpenAIPlugin\n+\n+\n+def inspect_zip_for_module(zip_path: str, debug: bool = False) -> Optional[str]:\n+    \"\"\"\n+    Inspect a zipfile for a module.\n+\n+    Args:\n+        zip_path (str): Path to the zipfile.\n+        debug (bool, optional): Enable debug logging. Defaults to False.\n+\n+    Returns:\n+        Optional[str]: The name of the module if found, else None.\n+    \"\"\"\n+    with zipfile.ZipFile(zip_path, \"r\") as zfile:\n+        for name in zfile.namelist():\n+            if name.endswith(\"__init__.py\"):\n+                if debug:\n+                    print(f\"Found module '{name}' in the zipfile at: {name}\")\n+                return name\n+    if debug:\n+        print(f\"Module '__init__.py' not found in the zipfile @ {zip_path}.\")\n+    return None\n+\n+\n+def write_dict_to_json_file(data: dict, file_path: str) -> None:\n+    \"\"\"\n+    Write a dictionary to a JSON file.\n+    Args:\n+        data (dict): Dictionary to write.\n+        file_path (str): Path to the file.\n+    \"\"\"\n+    with open(file_path, \"w\") as file:\n+        json.dump(data, file, indent=4)\n+\n+\n+def fetch_openai_plugins_manifest_and_spec(cfg: Config) -> dict:\n+    \"\"\"\n+    Fetch the manifest for a list of OpenAI plugins.\n+        Args:\n+        urls (List): List of URLs to fetch.\n+    Returns:\n+        dict: per url dictionary of manifest and spec.\n+    \"\"\"\n+    # TODO add directory scan\n+    manifests = {}\n+    for url in cfg.plugins_openai:\n+        openai_plugin_client_dir = f\"{cfg.plugins_dir}/openai/{urlparse(url).netloc}\"\n+        create_directory_if_not_exists(openai_plugin_client_dir)\n+        if not os.path.exists(f\"{openai_plugin_client_dir}/ai-plugin.json\"):\n+            try:\n+                response = requests.get(f\"{url}/.well-known/ai-plugin.json\")\n+                if response.status_code == 200:\n+                    manifest = response.json()\n+                    if manifest[\"schema_version\"] != \"v1\":\n+                        print(\n+                            f\"Unsupported manifest version: {manifest['schem_version']} for {url}\"\n+                        )\n+                        continue\n+                    if manifest[\"api\"][\"type\"] != \"openapi\":\n+                        print(\n+                            f\"Unsupported API type: {manifest['api']['type']} for {url}\"\n+                        )\n+                        continue\n+                    write_dict_to_json_file(\n+                        manifest, f\"{openai_plugin_client_dir}/ai-plugin.json\"\n+                    )\n+                else:\n+                    print(f\"Failed to fetch manifest for {url}: {response.status_code}\")\n+            except requests.exceptions.RequestException as e:\n+                print(f\"Error while requesting manifest from {url}: {e}\")\n+        else:\n+            print(f\"Manifest for {url} already exists\")\n+            manifest = json.load(open(f\"{openai_plugin_client_dir}/ai-plugin.json\"))\n+        if not os.path.exists(f\"{openai_plugin_client_dir}/openapi.json\"):\n+            openapi_spec = openapi_python_client._get_document(\n+                url=manifest[\"api\"][\"url\"], path=None, timeout=5\n+            )\n+            write_dict_to_json_file(\n+                openapi_spec, f\"{openai_plugin_client_dir}/openapi.json\"\n+            )\n+        else:\n+            print(f\"OpenAPI spec for {url} already exists\")\n+            openapi_spec = json.load(open(f\"{openai_plugin_client_dir}/openapi.json\"))\n+        manifests[url] = {\"manifest\": manifest, \"openapi_spec\": openapi_spec}\n+    return manifests\n+\n+\n+def create_directory_if_not_exists(directory_path: str) -> bool:\n+    \"\"\"\n+    Create a directory if it does not exist.\n+    Args:\n+        directory_path (str): Path to the directory.\n+    Returns:\n+        bool: True if the directory was created, else False.\n+    \"\"\"\n+    if not os.path.exists(directory_path):\n+        try:\n+            os.makedirs(directory_path)\n+            print(f\"Created directory: {directory_path}\")\n+            return True\n+        except OSError as e:\n+            print(f\"Error creating directory {directory_path}: {e}\")\n+            return False\n+    else:\n+        print(f\"Directory {directory_path} already exists\")\n+        return True\n+\n+\n+def initialize_openai_plugins(\n+    manifests_specs: dict, cfg: Config, debug: bool = False\n+) -> dict:\n+    \"\"\"\n+    Initialize OpenAI plugins.\n+    Args:\n+        manifests_specs (dict): per url dictionary of manifest and spec.\n+        cfg (Config): Config instance including plugins config\n+        debug (bool, optional): Enable debug logging. Defaults to False.\n+    Returns:\n+        dict: per url dictionary of manifest, spec and client.\n+    \"\"\"\n+    openai_plugins_dir = f\"{cfg.plugins_dir}/openai\"\n+    if create_directory_if_not_exists(openai_plugins_dir):\n+        for url, manifest_spec in manifests_specs.items():\n+            openai_plugin_client_dir = f\"{openai_plugins_dir}/{urlparse(url).hostname}\"\n+            _meta_option = (openapi_python_client.MetaType.SETUP,)\n+            _config = OpenAPIConfig(\n+                **{\n+                    \"project_name_override\": \"client\",\n+                    \"package_name_override\": \"client\",\n+                }\n+            )\n+            prev_cwd = Path.cwd()\n+            os.chdir(openai_plugin_client_dir)\n+            Path(\"ai-plugin.json\")\n+            if not os.path.exists(\"client\"):\n+                client_results = openapi_python_client.create_new_client(\n+                    url=manifest_spec[\"manifest\"][\"api\"][\"url\"],\n+                    path=None,\n+                    meta=_meta_option,\n+                    config=_config,\n+                )\n+                if client_results:\n+                    print(\n+                        f\"Error creating OpenAPI client: {client_results[0].header} \\n\"\n+                        f\" details: {client_results[0].detail}\"\n+                    )\n+                    continue\n+            spec = importlib.util.spec_from_file_location(\n+                \"client\", \"client/client/client.py\"\n+            )\n+            module = importlib.util.module_from_spec(spec)\n+            spec.loader.exec_module(module)\n+            client = module.Client(base_url=url)\n+            os.chdir(prev_cwd)\n+            manifest_spec[\"client\"] = client\n+    return manifests_specs\n+\n+\n+def instantiate_openai_plugin_clients(\n+    manifests_specs_clients: dict, cfg: Config, debug: bool = False\n+) -> dict:\n+    \"\"\"\n+    Instantiates BaseOpenAIPlugin instances for each OpenAI plugin.\n+    Args:\n+        manifests_specs_clients (dict): per url dictionary of manifest, spec and client.\n+        cfg (Config): Config instance including plugins config\n+        debug (bool, optional): Enable debug logging. Defaults to False.\n+    Returns:\n+          plugins (dict): per url dictionary of BaseOpenAIPlugin instances.\n+\n+    \"\"\"\n+    plugins = {}\n+    for url, manifest_spec_client in manifests_specs_clients.items():\n+        plugins[url] = BaseOpenAIPlugin(manifest_spec_client)\n+    return plugins\n+\n+\n+def scan_plugins(cfg: Config, debug: bool = False) -> List[AutoGPTPluginTemplate]:\n+    \"\"\"Scan the plugins directory for plugins and loads them.\n+\n+    Args:\n+        cfg (Config): Config instance including plugins config\n+        debug (bool, optional): Enable debug logging. Defaults to False.\n+\n+    Returns:\n+        List[Tuple[str, Path]]: List of plugins.\n+    \"\"\"\n+    loaded_plugins = []\n+    # Generic plugins\n+    plugins_path_path = Path(cfg.plugins_dir)\n+    for plugin in plugins_path_path.glob(\"*.zip\"):\n+        if module := inspect_zip_for_module(str(plugin), debug):\n+            plugin = Path(plugin)\n+            module = Path(module)\n+            if debug:\n+                print(f\"Plugin: {plugin} Module: {module}\")\n+            zipped_package = zipimporter(str(plugin))\n+            zipped_module = zipped_package.load_module(str(module.parent))\n+            for key in dir(zipped_module):\n+                if key.startswith(\"__\"):\n+                    continue\n+                a_module = getattr(zipped_module, key)\n+                a_keys = dir(a_module)\n+                if (\n+                    \"_abc_impl\" in a_keys\n+                    and a_module.__name__ != \"AutoGPTPluginTemplate\"\n+                    and blacklist_whitelist_check(a_module.__name__, cfg)\n+                ):\n+                    loaded_plugins.append(a_module())\n+    # OpenAI plugins\n+    if cfg.plugins_openai:\n+        manifests_specs = fetch_openai_plugins_manifest_and_spec(cfg)\n+        if manifests_specs.keys():\n+            manifests_specs_clients = initialize_openai_plugins(\n+                manifests_specs, cfg, debug\n+            )\n+            for url, openai_plugin_meta in manifests_specs_clients.items():\n+                if blacklist_whitelist_check(url, cfg):\n+                    plugin = BaseOpenAIPlugin(openai_plugin_meta)\n+                    loaded_plugins.append(plugin)\n+\n+    if loaded_plugins:\n+        print(f\"\\nPlugins found: {len(loaded_plugins)}\\n\" \"--------------------\")\n+    for plugin in loaded_plugins:\n+        print(f\"{plugin._name}: {plugin._version} - {plugin._description}\")\n+    return loaded_plugins\n+\n+\n+def blacklist_whitelist_check(plugin_name: str, cfg: Config) -> bool:\n+    \"\"\"Check if the plugin is in the whitelist or blacklist.\n+\n+    Args:\n+        plugin_name (str): Name of the plugin.\n+        cfg (Config): Config object.\n+\n+    Returns:\n+        True or False\n+    \"\"\"\n+    if plugin_name in cfg.plugins_blacklist:\n+        return False\n+    if plugin_name in cfg.plugins_whitelist:\n+        return True\n+    ack = input(\n+        f\"WARNNG Plugin {plugin_name} found. But not in the\"\n+        \" whitelist... Load? (y/n): \"\n+    )\n+    return ack.lower() == \"y\"\ndiff --git a/autogpt/prompt.py b/autogpt/prompts/prompt.py\nsimilarity index 50%\nrename from autogpt/prompt.py\nrename to autogpt/prompts/prompt.py\nindex 08754605fbdf..79de04ea8f4b 100644\n--- a/autogpt/prompt.py\n+++ b/autogpt/prompts/prompt.py\n@@ -39,96 +35,12 @@ def get_prompt() -> str:\n     prompt_generator.add_constraint(\n         'Exclusively use the commands listed in double quotes e.g. \"command name\"'\n     )\n-    prompt_generator.add_constraint(\n-        \"Use subprocesses for commands that will not terminate within a few minutes\"\n-    )\n \n     # Define the command list\n     commands = [\n-        (\"Google Search\", \"google\", {\"input\": \"<search>\"}),\n-        (\n-            \"Browse Website\",\n-            \"browse_website\",\n-            {\"url\": \"<url>\", \"question\": \"<what_you_want_to_find_on_website>\"},\n-        ),\n-        (\n-            \"Start GPT Agent\",\n-            \"start_agent\",\n-            {\"name\": \"<name>\", \"task\": \"<short_task_desc>\", \"prompt\": \"<prompt>\"},\n-        ),\n-        (\n-            \"Message GPT Agent\",\n-            \"message_agent\",\n-            {\"key\": \"<key>\", \"message\": \"<message>\"},\n-        ),\n-        (\"List GPT Agents\", \"list_agents\", {}),\n-        (\"Delete GPT Agent\", \"delete_agent\", {\"key\": \"<key>\"}),\n-        (\n-            \"Clone Repository\",\n-            \"clone_repository\",\n-            {\"repository_url\": \"<url>\", \"clone_path\": \"<directory>\"},\n-        ),\n-        (\"Write to file\", \"write_to_file\", {\"file\": \"<file>\", \"text\": \"<text>\"}),\n-        (\"Read file\", \"read_file\", {\"file\": \"<file>\"}),\n-        (\"Append to file\", \"append_to_file\", {\"file\": \"<file>\", \"text\": \"<text>\"}),\n-        (\"Delete file\", \"delete_file\", {\"file\": \"<file>\"}),\n-        (\"Search Files\", \"search_files\", {\"directory\": \"<directory>\"}),\n-        (\"Analyze Code\", \"analyze_code\", {\"code\": \"<full_code_string>\"}),\n-        (\n-            \"Get Improved Code\",\n-            \"improve_code\",\n-            {\"suggestions\": \"<list_of_suggestions>\", \"code\": \"<full_code_string>\"},\n-        ),\n-        (\n-            \"Write Tests\",\n-            \"write_tests\",\n-            {\"code\": \"<full_code_string>\", \"focus\": \"<list_of_focus_areas>\"},\n-        ),\n-        (\"Execute Python File\", \"execute_python_file\", {\"file\": \"<file>\"}),\n-        (\"Generate Image\", \"generate_image\", {\"prompt\": \"<prompt>\"}),\n-        (\"Send Tweet\", \"send_tweet\", {\"text\": \"<text>\"}),\n-    ]\n-\n-    # Only add the audio to text command if the model is specified\n-    if cfg.huggingface_audio_to_text_model:\n-        commands.append(\n-            (\"Convert Audio to text\", \"read_audio_from_file\", {\"file\": \"<file>\"}),\n-        )\n-\n-    # Only add shell command to the prompt if the AI is allowed to execute it\n-    if cfg.execute_local_commands:\n-        commands.append(\n-            (\n-                \"Execute Shell Command, non-interactive commands only\",\n-                \"execute_shell\",\n-                {\"command_line\": \"<command_line>\"},\n-            ),\n-        )\n-        commands.append(\n-            (\n-                \"Execute Shell Command Popen, non-interactive commands only\",\n-                \"execute_shell_popen\",\n-                {\"command_line\": \"<command_line>\"},\n-            ),\n-        )\n-\n-    # Only add the download file command if the AI is allowed to execute it\n-    if cfg.allow_downloads:\n-        commands.append(\n-            (\n-                \"Downloads a file from the internet, and stores it locally\",\n-                \"download_file\",\n-                {\"url\": \"<file_url>\", \"file\": \"<saved_filename>\"},\n-            ),\n-        )\n-\n-    # Add these command last.\n-    commands.append(\n         (\"Do Nothing\", \"do_nothing\", {}),\n-    )\n-    commands.append(\n         (\"Task Complete (Shutdown)\", \"task_complete\", {\"reason\": \"<reason>\"}),\n-    )\n+    ]\n \n     # Add commands to the PromptGenerator object\n     for command_label, command_name, args in commands:\n\ndiff --git a/tests/test_commands.py b/tests/test_commands.py\nnew file mode 100644\nindex 000000000000..8a7771f67745\n--- /dev/null\n+++ b/tests/test_commands.py\n@@ -0,0 +1,177 @@\n+import os\n+import shutil\n+import sys\n+from pathlib import Path\n+\n+import pytest\n+\n+from autogpt.commands.command import Command, CommandRegistry\n+\n+\n+class TestCommand:\n+    @staticmethod\n+    def example_function(arg1: int, arg2: str) -> str:\n+        return f\"{arg1} - {arg2}\"\n+\n+    def test_command_creation(self):\n+        cmd = Command(\n+            name=\"example\", description=\"Example command\", method=self.example_function\n+        )\n+\n+        assert cmd.name == \"example\"\n+        assert cmd.description == \"Example command\"\n+        assert cmd.method == self.example_function\n+        assert cmd.signature == \"(arg1: int, arg2: str) -> str\"\n+\n+    def test_command_call(self):\n+        cmd = Command(\n+            name=\"example\", description=\"Example command\", method=self.example_function\n+        )\n+\n+        result = cmd(arg1=1, arg2=\"test\")\n+        assert result == \"1 - test\"\n+\n+    def test_command_call_with_invalid_arguments(self):\n+        cmd = Command(\n+            name=\"example\", description=\"Example command\", method=self.example_function\n+        )\n+\n+        with pytest.raises(TypeError):\n+            cmd(arg1=\"invalid\", does_not_exist=\"test\")\n+\n+    def test_command_default_signature(self):\n+        cmd = Command(\n+            name=\"example\", description=\"Example command\", method=self.example_function\n+        )\n+\n+        assert cmd.signature == \"(arg1: int, arg2: str) -> str\"\n+\n+    def test_command_custom_signature(self):\n+        custom_signature = \"custom_arg1: int, custom_arg2: str\"\n+        cmd = Command(\n+            name=\"example\",\n+            description=\"Example command\",\n+            method=self.example_function,\n+            signature=custom_signature,\n+        )\n+\n+        assert cmd.signature == custom_signature\n+\n+\n+class TestCommandRegistry:\n+    @staticmethod\n+    def example_function(arg1: int, arg2: str) -> str:\n+        return f\"{arg1} - {arg2}\"\n+\n+    def test_register_command(self):\n+        \"\"\"Test that a command can be registered to the registry.\"\"\"\n+        registry = CommandRegistry()\n+        cmd = Command(\n+            name=\"example\", description=\"Example command\", method=self.example_function\n+        )\n+\n+        registry.register(cmd)\n+\n+        assert cmd.name in registry.commands\n+        assert registry.commands[cmd.name] == cmd\n+\n+    def test_unregister_command(self):\n+        \"\"\"Test that a command can be unregistered from the registry.\"\"\"\n+        registry = CommandRegistry()\n+        cmd = Command(\n+            name=\"example\", description=\"Example command\", method=self.example_function\n+        )\n+\n+        registry.register(cmd)\n+        registry.unregister(cmd.name)\n+\n+        assert cmd.name not in registry.commands\n+\n+    def test_get_command(self):\n+        \"\"\"Test that a command can be retrieved from the registry.\"\"\"\n+        registry = CommandRegistry()\n+        cmd = Command(\n+            name=\"example\", description=\"Example command\", method=self.example_function\n+        )\n+\n+        registry.register(cmd)\n+        retrieved_cmd = registry.get_command(cmd.name)\n+\n+        assert retrieved_cmd == cmd\n+\n+    def test_get_nonexistent_command(self):\n+        \"\"\"Test that attempting to get a nonexistent command raises a KeyError.\"\"\"\n+        registry = CommandRegistry()\n+\n+        with pytest.raises(KeyError):\n+            registry.get_command(\"nonexistent_command\")\n+\n+    def test_call_command(self):\n+        \"\"\"Test that a command can be called through the registry.\"\"\"\n+        registry = CommandRegistry()\n+        cmd = Command(\n+            name=\"example\", description=\"Example command\", method=self.example_function\n+        )\n+\n+        registry.register(cmd)\n+        result = registry.call(\"example\", arg1=1, arg2=\"test\")\n+\n+        assert result == \"1 - test\"\n+\n+    def test_call_nonexistent_command(self):\n+        \"\"\"Test that attempting to call a nonexistent command raises a KeyError.\"\"\"\n+        registry = CommandRegistry()\n+\n+        with pytest.raises(KeyError):\n+            registry.call(\"nonexistent_command\", arg1=1, arg2=\"test\")\n+\n+    def test_get_command_prompt(self):\n+        \"\"\"Test that the command prompt is correctly formatted.\"\"\"\n+        registry = CommandRegistry()\n+        cmd = Command(\n+            name=\"example\", description=\"Example command\", method=self.example_function\n+        )\n+\n+        registry.register(cmd)\n+        command_prompt = registry.command_prompt()\n+\n+        assert f\"(arg1: int, arg2: str)\" in command_prompt\n+\n+    def test_import_mock_commands_module(self):\n+        \"\"\"Test that the registry can import a module with mock command plugins.\"\"\"\n+        registry = CommandRegistry()\n+        mock_commands_module = \"tests.mocks.mock_commands\"\n+\n+        registry.import_commands(mock_commands_module)\n+\n+        assert \"function_based\" in registry.commands\n+        assert registry.commands[\"function_based\"].name == \"function_based\"\n+        assert (\n+            registry.commands[\"function_based\"].description\n+            == \"Function-based test command\"\n+        )\n+\n+    def test_import_temp_command_file_module(self, tmp_path):\n+        \"\"\"Test that the registry can import a command plugins module from a temp file.\"\"\"\n+        registry = CommandRegistry()\n+\n+        # Create a temp command file\n+        src = Path(os.getcwd()) / \"tests/mocks/mock_commands.py\"\n+        temp_commands_file = tmp_path / \"mock_commands.py\"\n+        shutil.copyfile(src, temp_commands_file)\n+\n+        # Add the temp directory to sys.path to make the module importable\n+        sys.path.append(str(tmp_path))\n+\n+        temp_commands_module = \"mock_commands\"\n+        registry.import_commands(temp_commands_module)\n+\n+        # Remove the temp directory from sys.path\n+        sys.path.remove(str(tmp_path))\n+\n+        assert \"function_based\" in registry.commands\n+        assert registry.commands[\"function_based\"].name == \"function_based\"\n+        assert (\n+            registry.commands[\"function_based\"].description\n+            == \"Function-based test command\"\n+        )\ndiff --git a/tests/unit/models/test_base_open_api_plugin.py b/tests/unit/models/test_base_open_api_plugin.py\nnew file mode 100644\nindex 000000000000..950a32662383\n--- /dev/null\n+++ b/tests/unit/models/test_base_open_api_plugin.py\n@@ -0,0 +1,79 @@\n+from typing import Any, Dict, List, Optional, Tuple\n+\n+import pytest\n+\n+from autogpt.models.base_open_ai_plugin import (\n+    BaseOpenAIPlugin,\n+    Message,\n+    PromptGenerator,\n+)\n+\n+\n+class DummyPlugin(BaseOpenAIPlugin):\n+    pass\n+\n+\n+@pytest.fixture\n+def dummy_plugin():\n+    manifests_specs_clients = {\n+        \"manifest\": {\n+            \"name_for_model\": \"Dummy\",\n+            \"schema_version\": \"1.0\",\n+            \"description_for_model\": \"A dummy plugin for testing purposes\",\n+        },\n+        \"client\": None,\n+        \"openapi_spec\": None,\n+    }\n+    return DummyPlugin(manifests_specs_clients)\n+\n+\n+def test_dummy_plugin_inheritance(dummy_plugin):\n+    assert isinstance(dummy_plugin, BaseOpenAIPlugin)\n+\n+\n+def test_dummy_plugin_name(dummy_plugin):\n+    assert dummy_plugin._name == \"Dummy\"\n+\n+\n+def test_dummy_plugin_version(dummy_plugin):\n+    assert dummy_plugin._version == \"1.0\"\n+\n+\n+def test_dummy_plugin_description(dummy_plugin):\n+    assert dummy_plugin._description == \"A dummy plugin for testing purposes\"\n+\n+\n+def test_dummy_plugin_default_methods(dummy_plugin):\n+    assert not dummy_plugin.can_handle_on_response()\n+    assert not dummy_plugin.can_handle_post_prompt()\n+    assert not dummy_plugin.can_handle_on_planning()\n+    assert not dummy_plugin.can_handle_post_planning()\n+    assert not dummy_plugin.can_handle_pre_instruction()\n+    assert not dummy_plugin.can_handle_on_instruction()\n+    assert not dummy_plugin.can_handle_post_instruction()\n+    assert not dummy_plugin.can_handle_pre_command()\n+    assert not dummy_plugin.can_handle_post_command()\n+    assert not dummy_plugin.can_handle_chat_completion(None, None, None, None)\n+\n+    assert dummy_plugin.on_response(\"hello\") == \"hello\"\n+    assert dummy_plugin.post_prompt(None) is None\n+    assert dummy_plugin.on_planning(None, None) is None\n+    assert dummy_plugin.post_planning(\"world\") == \"world\"\n+    pre_instruction = dummy_plugin.pre_instruction(\n+        [{\"role\": \"system\", \"content\": \"Beep, bop, boop\"}]\n+    )\n+    assert isinstance(pre_instruction, list)\n+    assert len(pre_instruction) == 1\n+    assert pre_instruction[0][\"role\"] == \"system\"\n+    assert pre_instruction[0][\"content\"] == \"Beep, bop, boop\"\n+    assert dummy_plugin.on_instruction(None) is None\n+    assert dummy_plugin.post_instruction(\"I'm a robot\") == \"I'm a robot\"\n+    pre_command = dummy_plugin.pre_command(\"evolve\", {\"continuously\": True})\n+    assert isinstance(pre_command, tuple)\n+    assert len(pre_command) == 2\n+    assert pre_command[0] == \"evolve\"\n+    assert pre_command[1][\"continuously\"] == True\n+    post_command = dummy_plugin.post_command(\"evolve\", \"upgraded successfully!\")\n+    assert isinstance(post_command, str)\n+    assert post_command == \"upgraded successfully!\"\n+    assert dummy_plugin.handle_chat_completion(None, None, None, None) is None\ndiff --git a/tests/unit/test_plugins.py b/tests/unit/test_plugins.py\nnew file mode 100644\nindex 000000000000..739e69bbe7e4\n--- /dev/null\n+++ b/tests/unit/test_plugins.py\n@@ -0,0 +1,112 @@\n+import pytest\n+\n+from autogpt.config import Config\n+from autogpt.plugins import (\n+    blacklist_whitelist_check,\n+    inspect_zip_for_module,\n+    scan_plugins,\n+)\n+\n+PLUGINS_TEST_DIR = \"tests/unit/data/test_plugins\"\n+PLUGIN_TEST_ZIP_FILE = \"Auto-GPT-Plugin-Test-master.zip\"\n+PLUGIN_TEST_INIT_PY = \"Auto-GPT-Plugin-Test-master/src/auto_gpt_vicuna/__init__.py\"\n+PLUGIN_TEST_OPENAI = \"https://weathergpt.vercel.app/\"\n+\n+\n+def test_inspect_zip_for_module():\n+    result = inspect_zip_for_module(str(f\"{PLUGINS_TEST_DIR}/{PLUGIN_TEST_ZIP_FILE}\"))\n+    assert result == PLUGIN_TEST_INIT_PY\n+\n+\n+@pytest.fixture\n+def mock_config_blacklist_whitelist_check():\n+    class MockConfig:\n+        plugins_blacklist = [\"BadPlugin\"]\n+        plugins_whitelist = [\"GoodPlugin\"]\n+\n+    return MockConfig()\n+\n+\n+def test_blacklist_whitelist_check_blacklist(\n+    mock_config_blacklist_whitelist_check, monkeypatch\n+):\n+    monkeypatch.setattr(\"builtins.input\", lambda _: \"y\")\n+    assert not blacklist_whitelist_check(\n+        \"BadPlugin\", mock_config_blacklist_whitelist_check\n+    )\n+\n+\n+def test_blacklist_whitelist_check_whitelist(\n+    mock_config_blacklist_whitelist_check, monkeypatch\n+):\n+    monkeypatch.setattr(\"builtins.input\", lambda _: \"y\")\n+    assert blacklist_whitelist_check(\n+        \"GoodPlugin\", mock_config_blacklist_whitelist_check\n+    )\n+\n+\n+def test_blacklist_whitelist_check_user_input_yes(\n+    mock_config_blacklist_whitelist_check, monkeypatch\n+):\n+    monkeypatch.setattr(\"builtins.input\", lambda _: \"y\")\n+    assert blacklist_whitelist_check(\n+        \"UnknownPlugin\", mock_config_blacklist_whitelist_check\n+    )\n+\n+\n+def test_blacklist_whitelist_check_user_input_no(\n+    mock_config_blacklist_whitelist_check, monkeypatch\n+):\n+    monkeypatch.setattr(\"builtins.input\", lambda _: \"n\")\n+    assert not blacklist_whitelist_check(\n+        \"UnknownPlugin\", mock_config_blacklist_whitelist_check\n+    )\n+\n+\n+def test_blacklist_whitelist_check_user_input_invalid(\n+    mock_config_blacklist_whitelist_check, monkeypatch\n+):\n+    monkeypatch.setattr(\"builtins.input\", lambda _: \"invalid\")\n+    assert not blacklist_whitelist_check(\n+        \"UnknownPlugin\", mock_config_blacklist_whitelist_check\n+    )\n+\n+\n+@pytest.fixture\n+def config_with_plugins():\n+    cfg = Config()\n+    cfg.plugins_dir = PLUGINS_TEST_DIR\n+    cfg.plugins_openai = [\"https://weathergpt.vercel.app/\"]\n+    return cfg\n+\n+\n+@pytest.fixture\n+def mock_config_openai_plugin():\n+    class MockConfig:\n+        plugins_dir = PLUGINS_TEST_DIR\n+        plugins_openai = [PLUGIN_TEST_OPENAI]\n+        plugins_blacklist = [\"AutoGPTPVicuna\"]\n+        plugins_whitelist = [PLUGIN_TEST_OPENAI]\n+\n+    return MockConfig()\n+\n+\n+def test_scan_plugins_openai(mock_config_openai_plugin):\n+    result = scan_plugins(mock_config_openai_plugin, debug=True)\n+    assert len(result) == 1\n+\n+\n+@pytest.fixture\n+def mock_config_generic_plugin():\n+    class MockConfig:\n+        plugins_dir = PLUGINS_TEST_DIR\n+        plugins_openai = []\n+        plugins_blacklist = []\n+        plugins_whitelist = [\"AutoGPTPVicuna\"]\n+\n+    return MockConfig()\n+\n+\n+def test_scan_plugins_generic(mock_config_generic_plugin):\n+    result = scan_plugins(mock_config_generic_plugin, debug=True)\n+    assert len(result) == 1\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Great discussion here. We need to refine our plugin hooking approach, considering both flexibility and security. The current whitelist checks only by name, which opens up potential abuse. Implementing more checks could improve safety. The suggestion to manage plugins through `requirements.txt` is promising, especially with specific commits for version control. However, manually authorizing plugins unless bypassed by an environment variable would keep things simple yet secure. The proposed API for prompts looks solid, allowing for customization without breaking existing functionalities."
      }
    ],
    "token_estimation": 11747.25
  },
  {
    "index": 3,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/autogpt_platform/backend/backend/integrations/webhooks/graph_lifecycle_hooks.py b/autogpt_platform/backend/backend/integrations/webhooks/graph_lifecycle_hooks.py\nindex 01e7b3a49edf..b4e87d5080f6 100644\n--- a/autogpt_platform/backend/backend/integrations/webhooks/graph_lifecycle_hooks.py\n+++ b/autogpt_platform/backend/backend/integrations/webhooks/graph_lifecycle_hooks.py\n@@ -96,105 +100,25 @@ async def on_node_activate(\n ) -> \"NodeModel\":\n     \"\"\"Hook to be called when the node is activated/created\"\"\"\n \n-    block = node.block\n-\n-    if not block.webhook_config:\n-        return node\n-\n-    provider = block.webhook_config.provider\n-    if not supports_webhooks(provider):\n-        raise ValueError(\n-            f\"Block #{block.id} has webhook_config for provider {provider} \"\n-            \"which does not support webhooks\"\n+    if node.block.webhook_config:\n+        new_webhook, feedback = await setup_webhook_for_block(\n+            user_id=user_id,\n+            trigger_block=node.block,\n+            trigger_config=node.input_default,\n+            for_graph_id=node.graph_id,\n         )\n-\n-    logger.debug(\n-        f\"Activating webhook node #{node.id} with config {block.webhook_config}\"\n-    )\n-\n-    webhooks_manager = get_webhook_manager(provider)\n-\n-    if auto_setup_webhook := isinstance(block.webhook_config, BlockWebhookConfig):\n-        try:\n-            resource = block.webhook_config.resource_format.format(**node.input_default)\n-        except KeyError:\n-            resource = None\n-        logger.debug(\n-            f\"Constructed resource string {resource} from input {node.input_default}\"\n-        )\n-    else:\n-        resource = \"\"  # not relevant for manual webhooks\n-\n-    block_input_schema = cast(BlockSchema, block.input_schema)\n-    credentials_field_name = next(iter(block_input_schema.get_credentials_fields()), \"\")\n-    credentials_meta = (\n-        node.input_default.get(credentials_field_name)\n-        if credentials_field_name\n-        else None\n-    )\n-    event_filter_input_name = block.webhook_config.event_filter_input\n-    has_everything_for_webhook = (\n-        resource is not None\n-        and (credentials_meta or not credentials_field_name)\n-        and (\n-            not event_filter_input_name\n-            or (\n-                event_filter_input_name in node.input_default\n-                and any(\n-                    is_on\n-                    for is_on in node.input_default[event_filter_input_name].values()\n-                )\n-            )\n-        )\n-    )\n-\n-    if has_everything_for_webhook and resource is not None:\n-        logger.debug(f\"Node #{node} has everything for a webhook!\")\n-        if credentials_meta and not credentials:\n-            raise ValueError(\n-                f\"Cannot set up webhook for node #{node.id}: \"\n-                f\"credentials #{credentials_meta['id']} not available\"\n-            )\n-\n-        if event_filter_input_name:\n-            # Shape of the event filter is enforced in Block.__init__\n-            event_filter = cast(dict, node.input_default[event_filter_input_name])\n-            events = [\n-                block.webhook_config.event_format.format(event=event)\n-                for event, enabled in event_filter.items()\n-                if enabled is True\n-            ]\n-            logger.debug(f\"Webhook events to subscribe to: {', '.join(events)}\")\n+        if new_webhook:\n+            node = await set_node_webhook(node.id, new_webhook.id)\n         else:\n-            events = []\n-\n-        # Find/make and attach a suitable webhook to the node\n-        if auto_setup_webhook:\n-            assert credentials is not None\n-            new_webhook = await webhooks_manager.get_suitable_auto_webhook(\n-                user_id,\n-                credentials,\n-                block.webhook_config.webhook_type,\n-                resource,\n-                events,\n+            logger.debug(\n+                f\"Node #{node.id} does not have everything for a webhook: {feedback}\"\n             )\n-        else:\n-            # Manual webhook -> no credentials -> don't register but do create\n-            new_webhook = await webhooks_manager.get_manual_webhook(\n-                user_id,\n-                node.graph_id,\n-                block.webhook_config.webhook_type,\n-                events,\n-            )\n-        logger.debug(f\"Acquired webhook: {new_webhook}\")\n-        return await set_node_webhook(node.id, new_webhook.id)\n-    else:\n-        logger.debug(f\"Node #{node.id} does not have everything for a webhook\")\n \n     return node\n \n \n async def on_node_deactivate(\n+    user_id: str,\n     node: \"NodeModel\",\n     *,\n     credentials: Optional[\"Credentials\"] = None,\n\ndiff --git a/autogpt_platform/backend/backend/integrations/webhooks/utils.py b/autogpt_platform/backend/backend/integrations/webhooks/utils.py\nindex e53a18f0fb1c..d7c66efe2901 100644\n--- a/autogpt_platform/backend/backend/integrations/webhooks/utils.py\n+++ b/autogpt_platform/backend/backend/integrations/webhooks/utils.py\n@@ -10,3 +25,122 @@ def webhook_ingress_url(provider_name: ProviderName, webhook_id: str) -> str:\n         f\"{app_config.platform_base_url}/api/integrations/{provider_name.value}\"\n         f\"/webhooks/{webhook_id}/ingress\"\n     )\n+\n+\n+async def setup_webhook_for_block(\n+    user_id: str,\n+    trigger_block: \"Block[BlockSchema, BlockSchema]\",\n+    trigger_config: dict[str, JsonValue],  # = Trigger block inputs\n+    for_graph_id: Optional[str] = None,\n+    for_preset_id: Optional[str] = None,\n+    credentials: Optional[\"Credentials\"] = None,\n+) -> tuple[\"Webhook\", None] | tuple[None, str]:\n+    \"\"\"\n+    Utility function to create (and auto-setup if possible) a webhook for a given provider.\n+\n+    Returns:\n+        Webhook: The created or found webhook object, if successful.\n+        str: A feedback message, if any required inputs are missing.\n+    \"\"\"\n+    from backend.data.block import BlockWebhookConfig\n+\n+    if not (trigger_base_config := trigger_block.webhook_config):\n+        raise ValueError(f\"Block #{trigger_block.id} does not have a webhook_config\")\n+\n+    provider = trigger_base_config.provider\n+    if not supports_webhooks(provider):\n+        raise NotImplementedError(\n+            f\"Block #{trigger_block.id} has webhook_config for provider {provider} \"\n+            \"for which we do not have a WebhooksManager\"\n+        )\n+\n+    logger.debug(\n+        f\"Setting up webhook for block #{trigger_block.id} with config {trigger_config}\"\n+    )\n+\n+    # Check & parse the event filter input, if any\n+    events: list[str] = []\n+    if event_filter_input_name := trigger_base_config.event_filter_input:\n+        if not (event_filter := trigger_config.get(event_filter_input_name)):\n+            return None, (\n+                f\"Cannot set up {provider.value} webhook without event filter input: \"\n+                f\"missing input for '{event_filter_input_name}'\"\n+            )\n+        elif not (\n+            # Shape of the event filter is enforced in Block.__init__\n+            any((event_filter := cast(dict[str, bool], event_filter)).values())\n+        ):\n+            return None, (\n+                f\"Cannot set up {provider.value} webhook without any enabled events \"\n+                f\"in event filter input '{event_filter_input_name}'\"\n+            )\n+\n+        events = [\n+            trigger_base_config.event_format.format(event=event)\n+            for event, enabled in event_filter.items()\n+            if enabled is True\n+        ]\n+        logger.debug(f\"Webhook events to subscribe to: {', '.join(events)}\")\n+\n+    # Check & process prerequisites for auto-setup webhooks\n+    if auto_setup_webhook := isinstance(trigger_base_config, BlockWebhookConfig):\n+        try:\n+            resource = trigger_base_config.resource_format.format(**trigger_config)\n+        except KeyError as missing_key:\n+            return None, (\n+                f\"Cannot auto-setup {provider.value} webhook without resource: \"\n+                f\"missing input for '{missing_key}'\"\n+            )\n+        logger.debug(\n+            f\"Constructed resource string {resource} from input {trigger_config}\"\n+        )\n+\n+        creds_field_name = next(\n+            # presence of this field is enforced in Block.__init__\n+            iter(trigger_block.input_schema.get_credentials_fields())\n+        )\n+\n+        if not (\n+            credentials_meta := cast(dict, trigger_config.get(creds_field_name, None))\n+        ):\n+            return None, f\"Cannot set up {provider.value} webhook without credentials\"\n+        elif not (\n+            credentials := credentials\n+            or await credentials_manager.get(user_id, credentials_meta[\"id\"])\n+        ):\n+            raise ValueError(\n+                f\"Cannot set up {provider.value} webhook without credentials: \"\n+                f\"credentials #{credentials_meta['id']} not found for user #{user_id}\"\n+            )\n+        elif credentials.provider != provider:\n+            raise ValueError(\n+                f\"Credentials #{credentials.id} do not match provider {provider.value}\"\n+            )\n+    else:\n+        # not relevant for manual webhooks:\n+        resource = \"\"\n+        credentials = None\n+\n+    webhooks_manager = get_webhook_manager(provider)\n+\n+    # Find/make and attach a suitable webhook to the node\n+    if auto_setup_webhook:\n+        assert credentials is not None\n+        webhook = await webhooks_manager.get_suitable_auto_webhook(\n+            user_id=user_id,\n+            credentials=credentials,\n+            webhook_type=trigger_base_config.webhook_type,\n+            resource=resource,\n+            events=events,\n+        )\n+    else:\n+        # Manual webhook -> no credentials -> don't register but do create\n+        webhook = await webhooks_manager.get_manual_webhook(\n+            user_id=user_id,\n+            webhook_type=trigger_base_config.webhook_type,\n+            events=events,\n+            graph_id=for_graph_id,\n+            preset_id=for_preset_id,\n+        )\n+    logger.debug(f\"Acquired webhook: {webhook}\")\n+    return webhook, None\ndiff --git a/autogpt_platform/backend/backend/server/v2/library/routes/agents.py b/autogpt_platform/backend/backend/server/v2/library/routes/agents.py\nindex 54a0cd235fe6..97580ac39197 100644\n--- a/autogpt_platform/backend/backend/server/v2/library/routes/agents.py\n+++ b/autogpt_platform/backend/backend/server/v2/library/routes/agents.py\n@@ -245,3 +243,81 @@ async def fork_library_agent(\n         library_agent_id=library_agent_id,\n         user_id=user_id,\n     )\n+\n+\n+class TriggeredPresetSetupParams(BaseModel):\n+    name: str\n+    description: str = \"\"\n+\n+    trigger_config: dict[str, Any]\n+    agent_credentials: dict[str, CredentialsMetaInput] = Field(default_factory=dict)\n+\n+\n+@router.post(\"/{library_agent_id}/setup-trigger\")\n+async def setup_trigger(\n+    library_agent_id: str = Path(..., description=\"ID of the library agent\"),\n+    params: TriggeredPresetSetupParams = Body(),\n+    user_id: str = Depends(autogpt_auth_lib.depends.get_user_id),\n+) -> library_model.LibraryAgentPreset:\n+    \"\"\"\n+    Sets up a webhook-triggered `LibraryAgentPreset` for a `LibraryAgent`.\n+    Returns the correspondingly created `LibraryAgentPreset` with `webhook_id` set.\n+    \"\"\"\n+    library_agent = await library_db.get_library_agent(\n+        id=library_agent_id, user_id=user_id\n+    )\n+    if not library_agent:\n+        raise HTTPException(\n+            status_code=status.HTTP_404_NOT_FOUND,\n+            detail=f\"Library agent #{library_agent_id} not found\",\n+        )\n+\n+    graph = await get_graph(\n+        library_agent.graph_id, version=library_agent.graph_version, user_id=user_id\n+    )\n+    if not graph:\n+        raise HTTPException(\n+            status.HTTP_410_GONE,\n+            f\"Graph #{library_agent.graph_id} not accessible (anymore)\",\n+        )\n+    if not (trigger_node := graph.webhook_input_node):\n+        raise HTTPException(\n+            status_code=status.HTTP_400_BAD_REQUEST,\n+            detail=f\"Graph #{library_agent.graph_id} does not have a webhook node\",\n+        )\n+\n+    trigger_config_with_credentials = {\n+        **params.trigger_config,\n+        **(\n+            make_node_credentials_input_map(graph, params.agent_credentials).get(\n+                trigger_node.id\n+            )\n+            or {}\n+        ),\n+    }\n+\n+    new_webhook, feedback = await setup_webhook_for_block(\n+        user_id=user_id,\n+        trigger_block=trigger_node.block,\n+        trigger_config=trigger_config_with_credentials,\n+    )\n+    if not new_webhook:\n+        raise HTTPException(\n+            status_code=status.HTTP_400_BAD_REQUEST,\n+            detail=f\"Could not set up webhook: {feedback}\",\n+        )\n+\n+    new_preset = await library_db.create_preset(\n+        user_id=user_id,\n+        preset=library_model.LibraryAgentPresetCreatable(\n+            graph_id=library_agent.graph_id,\n+            graph_version=library_agent.graph_version,\n+            name=params.name,\n+            description=params.description,\n+            inputs=trigger_config_with_credentials,\n+            credentials=params.agent_credentials,\n+            webhook_id=new_webhook.id,\n+            is_active=True,\n+        ),\n+    )\n+    return new_preset\ndiff --git a/autogpt_platform/backend/backend/server/v2/library/routes/presets.py b/autogpt_platform/backend/backend/server/v2/library/routes/presets.py\nindex 23fc80d23e6e..35bbb9f59124 100644\n--- a/autogpt_platform/backend/backend/server/v2/library/routes/presets.py\n+++ b/autogpt_platform/backend/backend/server/v2/library/routes/presets.py\n@@ -163,17 +162,85 @@ async def update_preset(\n     Raises:\n         HTTPException: If an error occurs while updating the preset.\n     \"\"\"\n+    current = await get_preset(preset_id, user_id=user_id)\n+    if not current:\n+        raise HTTPException(status.HTTP_404_NOT_FOUND, f\"Preset #{preset_id} not found\")\n+\n+    graph = await get_graph(\n+        current.graph_id,\n+        current.graph_version,\n+        user_id=user_id,\n+    )\n+    if not graph:\n+        raise HTTPException(\n+            status.HTTP_410_GONE,\n+            f\"Graph #{current.graph_id} not accessible (anymore)\",\n+        )\n+\n+    trigger_inputs_updated, new_webhook, feedback = False, None, None\n+    if (trigger_node := graph.webhook_input_node) and (\n+        preset.inputs is not None and preset.credentials is not None\n+    ):\n+        trigger_config_with_credentials = {\n+            **preset.inputs,\n+            **(\n+                make_node_credentials_input_map(graph, preset.credentials).get(\n+                    trigger_node.id\n+                )\n+                or {}\n+            ),\n+        }\n+        new_webhook, feedback = await setup_webhook_for_block(\n+            user_id=user_id,\n+            trigger_block=graph.webhook_input_node.block,\n+            trigger_config=trigger_config_with_credentials,\n+            for_preset_id=preset_id,\n+        )\n+        trigger_inputs_updated = True\n+        if not new_webhook:\n+            raise HTTPException(\n+                status_code=status.HTTP_400_BAD_REQUEST,\n+                detail=f\"Could not update trigger configuration: {feedback}\",\n+            )\n+\n     try:\n-        return await db.update_preset(\n-            user_id=user_id, preset_id=preset_id, preset=preset\n+        updated = await db.update_preset(\n+            user_id=user_id,\n+            preset_id=preset_id,\n+            inputs=preset.inputs,\n+            credentials=preset.credentials,\n+            name=preset.name,\n+            description=preset.description,\n+            is_active=preset.is_active,\n         )\n     except Exception as e:\n         logger.exception(\"Preset update failed for user %s: %s\", user_id, e)\n         raise HTTPException(\n-            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n-            detail={\"message\": str(e), \"hint\": \"Check preset data and try again.\"},\n+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)\n+        )\n+\n+    # Update the webhook as well, if necessary\n+    if trigger_inputs_updated:\n+        updated = await db.set_preset_webhook(\n+            user_id, preset_id, new_webhook.id if new_webhook else None\n         )\n \n+        # Clean up webhook if it is now unused\n+        if current.webhook_id and (\n+            current.webhook_id != (new_webhook.id if new_webhook else None)\n+        ):\n+            current_webhook = await get_webhook(current.webhook_id)\n+            credentials = (\n+                await credentials_manager.get(user_id, current_webhook.credentials_id)\n+                if current_webhook.credentials_id\n+                else None\n+            )\n+            await get_webhook_manager(\n+                current_webhook.provider\n+            ).prune_webhook_if_dangling(user_id, current_webhook.id, credentials)\n+\n+    return updated\n+\n \n @router.delete(\n     \"/presets/{preset_id}\",\n\ndiff --git a/autogpt_platform/backend/schema.prisma b/autogpt_platform/backend/schema.prisma\nindex 58e724db9c5b..0282b51f988e 100644\n--- a/autogpt_platform/backend/schema.prisma\n+++ b/autogpt_platform/backend/schema.prisma\n@@index([userId])\n@@ -428,7 +432,8 @@ model IntegrationWebhook {\n \n   providerWebhookId String // Webhook ID assigned by the provider\n \n-  AgentNodes AgentNode[]\n+  AgentNodes    AgentNode[]\n+  AgentPresets  AgentPreset[]\n \n   @@index([userId])\n }\ndiff --git a/autogpt_platform/frontend/src/components/agents/agent-run-draft-view.tsx b/autogpt_platform/frontend/src/components/agents/agent-run-draft-view.tsx\nindex ab531bf002f8..752f887ec077 100644\n--- a/autogpt_platform/frontend/src/components/agents/agent-run-draft-view.tsx\n+++ b/autogpt_platform/frontend/src/components/agents/agent-run-draft-view.tsx\n@@ -1,73 +1,434 @@\n \"use client\";\n-import React, { useCallback, useMemo, useState } from \"react\";\n+import React, { useCallback, useEffect, useMemo, useState } from \"react\";\n \n import { useBackendAPI } from \"@/lib/autogpt-server-api/context\";\n-import { GraphExecutionID, GraphMeta } from \"@/lib/autogpt-server-api\";\n+import {\n+  CredentialsMetaInput,\n+  GraphExecutionID,\n+  LibraryAgent,\n+  LibraryAgentPreset,\n+  LibraryAgentPresetID,\n+  LibraryAgentPresetUpdatable,\n+} from \"@/lib/autogpt-server-api\";\n \n import type { ButtonAction } from \"@/components/agptui/types\";\n import { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\n+import { IconCross, IconPlay, IconSave } from \"@/components/ui/icons\";\n import { CredentialsInput } from \"@/components/integrations/credentials-input\";\n import { TypeBasedInput } from \"@/components/type-based-input\";\n import { useToastOnFail } from \"@/components/ui/use-toast\";\n import ActionButtonGroup from \"@/components/agptui/action-button-group\";\n+import { useOnboarding } from \"@/components/onboarding/onboarding-provider\";\n+import { Trash2Icon } from \"lucide-react\";\n import SchemaTooltip from \"@/components/SchemaTooltip\";\n-import { IconPlay } from \"@/components/ui/icons\";\n-import { useOnboarding } from \"../onboarding/onboarding-provider\";\n+import { useToast } from \"@/components/ui/use-toast\";\n+import { isEmpty } from \"lodash\";\n+import { Input } from \"@/components/ui/input\";\n \n export default function AgentRunDraftView({\n-  graph,\n+  agent,\n+  agentPreset,\n   onRun,\n+  onCreatePreset,\n+  onUpdatePreset,\n+  doDeletePreset,\n   agentActions,\n }: {\n-  graph: GraphMeta;\n-  onRun: (runID: GraphExecutionID) => void;\n+  agent: LibraryAgent;\n   agentActions: ButtonAction[];\n-}): React.ReactNode {\n+  onRun: (runID: GraphExecutionID) => void;\n+} & (\n+  | {\n+      onCreatePreset: (preset: LibraryAgentPreset) => void;\n+      agentPreset?: never;\n+      onUpdatePreset?: never;\n+      doDeletePreset?: never;\n+    }\n+  | {\n+      onCreatePreset?: never;\n+      agentPreset: LibraryAgentPreset;\n+      onUpdatePreset: (preset: LibraryAgentPreset) => void;\n+      doDeletePreset: (presetID: LibraryAgentPresetID) => void;\n+    }\n+)): React.ReactNode {\n   const api = useBackendAPI();\n+  const { toast } = useToast();\n   const toastOnFail = useToastOnFail();\n \n-  const agentInputs = graph.input_schema.properties;\n-  const agentCredentialsInputs = graph.credentials_input_schema.properties;\n   const [inputValues, setInputValues] = useState<Record<string, any>>({});\n-  const [inputCredentials, setInputCredentials] = useState<Record<string, any>>(\n-    {},\n+  const [inputCredentials, setInputCredentials] = useState<\n+    Record<string, CredentialsMetaInput>\n+  >({});\n+  const [presetName, setPresetName] = useState<string>(\"\");\n+  const [presetDescription, setPresetDescription] = useState<string>(\"\");\n+  const [changedPresetAttributes, setChangedPresetAttributes] = useState<\n+    Set<keyof LibraryAgentPresetUpdatable>\n+  >(new Set());\n+  const { state: onboardingState, completeStep: completeOnboardingStep } =\n+    useOnboarding();\n+\n+  // Update values if agentPreset parameter is changed\n+  useEffect(() => {\n+    setInputValues(agentPreset?.inputs ?? {});\n+    setInputCredentials(agentPreset?.credentials ?? {});\n+    setPresetName(agentPreset?.name ?? \"\");\n+    setPresetDescription(agentPreset?.description ?? \"\");\n+    setChangedPresetAttributes(new Set());\n+  }, [agentPreset]);\n+\n+  const agentInputSchema = useMemo(\n+    () =>\n+      agent.has_external_trigger\n+        ? agent.trigger_setup_info.config_schema\n+        : agent.input_schema,\n+    [agent],\n+  );\n+  const agentInputFields = useMemo(\n+    () =>\n+      Object.fromEntries(\n+        Object.entries(agentInputSchema.properties).filter(\n+          ([_, subSchema]) => !subSchema.hidden,\n+        ),\n+      ),\n+    [agentInputSchema],\n+  );\n+  const agentCredentialsInputFields = useMemo(\n+    () => agent.credentials_input_schema.properties,\n+    [agent],\n+  );\n+\n+  const [allRequiredInputsAreSet, missingInputs] = useMemo(() => {\n+    const nonEmptyInputs = new Set(\n+      Object.keys(inputValues).filter((k) => !isEmpty(inputValues[k])),\n+    );\n+    const requiredInputs = new Set(\n+      agentInputSchema.required as string[] | undefined,\n+    );\n+    return [\n+      nonEmptyInputs.isSupersetOf(requiredInputs),\n+      [...requiredInputs.difference(nonEmptyInputs)],\n+    ];\n+  }, [agentInputSchema.required, inputValues]);\n+  const [allCredentialsAreSet, missingCredentials] = useMemo(() => {\n+    const availableCredentials = new Set(Object.keys(inputCredentials));\n+    const allCredentials = new Set(Object.keys(agentCredentialsInputFields));\n+    return [\n+      availableCredentials.isSupersetOf(allCredentials),\n+      [...allCredentials.difference(availableCredentials)],\n+    ];\n+  }, [agentCredentialsInputFields, inputCredentials]);\n+  const notifyMissingInputs = useCallback(\n+    (needPresetName: boolean = true) => {\n+      const allMissingFields = (\n+        needPresetName && !presetName\n+          ? [agent.has_external_trigger ? \"trigger_name\" : \"preset_name\"]\n+          : []\n+      )\n+        .concat(missingInputs)\n+        .concat(missingCredentials);\n+      toast({\n+        title: \"⚠️ Not all required inputs are set\",\n+        description: `Please set ${allMissingFields.map((k) => `\\`${k}\\``).join(\", \")}`,\n+      });\n+    },\n+    [missingInputs, missingCredentials],\n   );\n-  const { state, completeStep } = useOnboarding();\n \n   const doRun = useCallback(() => {\n-    api\n-      .executeGraph(graph.id, graph.version, inputValues, inputCredentials)\n-      .then((newRun) => onRun(newRun.graph_exec_id))\n-      .catch(toastOnFail(\"execute agent\"));\n+    // Manually running webhook-triggered agents is not supported\n+    if (agent.has_external_trigger) return;\n+\n+    if (!agentPreset || changedPresetAttributes.size > 0) {\n+      if (!allRequiredInputsAreSet || !allCredentialsAreSet) {\n+        notifyMissingInputs(false);\n+        return;\n+      }\n+      // TODO: on executing preset with changes, ask for confirmation and offer save+run\n+      api\n+        .executeGraph(\n+          agent.graph_id,\n+          agent.graph_version,\n+          inputValues,\n+          inputCredentials,\n+        )\n+        .then((newRun) => onRun(newRun.graph_exec_id))\n+        .catch(toastOnFail(\"execute agent\"));\n+    } else {\n+      api\n+        .executeLibraryAgentPreset(agentPreset.id)\n+        .then((newRun) => onRun(newRun.id))\n+        .catch(toastOnFail(\"execute agent preset\"));\n+    }\n     // Mark run agent onboarding step as completed\n-    if (state?.completedSteps.includes(\"MARKETPLACE_ADD_AGENT\")) {\n-      completeStep(\"MARKETPLACE_RUN_AGENT\");\n+    if (onboardingState?.completedSteps.includes(\"MARKETPLACE_ADD_AGENT\")) {\n+      completeOnboardingStep(\"MARKETPLACE_RUN_AGENT\");\n     }\n   }, [\n     api,\n-    graph,\n+    agent,\n     inputValues,\n     inputCredentials,\n     onRun,\n     toastOnFail,\n-    state,\n-    completeStep,\n+    onboardingState,\n+    completeOnboardingStep,\n+  ]);\n+\n+  const doCreatePreset = useCallback(() => {\n+    if (!onCreatePreset) return;\n+\n+    if (!presetName || !allRequiredInputsAreSet || !allCredentialsAreSet) {\n+      notifyMissingInputs();\n+      return;\n+    }\n+\n+    api\n+      .createLibraryAgentPreset({\n+        name: presetName,\n+        description: presetDescription,\n+        graph_id: agent.graph_id,\n+        graph_version: agent.graph_version,\n+        inputs: inputValues,\n+        credentials: inputCredentials,\n+      })\n+      .then((newPreset) => {\n+        onCreatePreset(newPreset);\n+        setChangedPresetAttributes(new Set()); // reset change tracker\n+      })\n+      .catch(toastOnFail(\"save agent preset\"));\n+  }, [\n+    api,\n+    agent,\n+    presetName,\n+    presetDescription,\n+    inputValues,\n+    inputCredentials,\n+    onCreatePreset,\n+    toast,\n+    toastOnFail,\n+    onboardingState,\n+    completeOnboardingStep,\n+  ]);\n+\n+  const doUpdatePreset = useCallback(() => {\n+    if (!agentPreset || changedPresetAttributes.size == 0) return;\n+\n+    if (!presetName || !allRequiredInputsAreSet || !allCredentialsAreSet) {\n+      notifyMissingInputs();\n+      return;\n+    }\n+\n+    const updatePreset: LibraryAgentPresetUpdatable = {};\n+    if (changedPresetAttributes.has(\"name\")) updatePreset[\"name\"] = presetName;\n+    if (changedPresetAttributes.has(\"description\"))\n+      updatePreset[\"description\"] = presetDescription;\n+    if (\n+      changedPresetAttributes.has(\"inputs\") ||\n+      changedPresetAttributes.has(\"credentials\")\n+    ) {\n+      updatePreset[\"inputs\"] = inputValues;\n+      updatePreset[\"credentials\"] = inputCredentials;\n+    }\n+    api\n+      .updateLibraryAgentPreset(agentPreset.id, updatePreset)\n+      .then((updatedPreset) => {\n+        onUpdatePreset(updatedPreset);\n+        setChangedPresetAttributes(new Set()); // reset change tracker\n+      })\n+      .catch(toastOnFail(\"update agent preset\"));\n+  }, [\n+    api,\n+    agent,\n+    presetName,\n+    presetDescription,\n+    inputValues,\n+    inputCredentials,\n+    onUpdatePreset,\n+    toast,\n+    toastOnFail,\n+    onboardingState,\n+    completeOnboardingStep,\n+  ]);\n+\n+  const doSetPresetActive = useCallback(\n+    async (active: boolean) => {\n+      if (!agentPreset) return;\n+      const updatedPreset = await api.updateLibraryAgentPreset(agentPreset.id, {\n+        is_active: active,\n+      });\n+      onUpdatePreset(updatedPreset);\n+    },\n+    [agentPreset, api, onUpdatePreset],\n+  );\n+\n+  const doSetupTrigger = useCallback(() => {\n+    // Setting up a trigger for non-webhook-triggered agents is not supported\n+    if (!agent.has_external_trigger || !onCreatePreset) return;\n+\n+    if (!presetName || !allRequiredInputsAreSet || !allCredentialsAreSet) {\n+      notifyMissingInputs();\n+      return;\n+    }\n+\n+    const credentialsInputName =\n+      agent.trigger_setup_info.credentials_input_name;\n+\n+    if (!credentialsInputName) {\n+      // FIXME: implement support for manual-setup webhooks\n+      toast({\n+        variant: \"destructive\",\n+        title: \"🚧 Feature under construction\",\n+        description: \"Setting up non-auto-setup triggers is not yet supported.\",\n+      });\n+      return;\n+    }\n+\n+    api\n+      .setupAgentTrigger(agent.id, {\n+        name: presetName,\n+        description: presetDescription,\n+        trigger_config: inputValues,\n+        agent_credentials: inputCredentials,\n+      })\n+      .then((newPreset) => {\n+        onCreatePreset(newPreset);\n+        setChangedPresetAttributes(new Set()); // reset change tracker\n+      })\n+      .catch(toastOnFail(\"set up agent trigger\"));\n+\n+    // Mark run agent onboarding step as completed(?)\n+    if (onboardingState?.completedSteps.includes(\"MARKETPLACE_ADD_AGENT\")) {\n+      completeOnboardingStep(\"MARKETPLACE_RUN_AGENT\");\n+    }\n+  }, [\n+    api,\n+    agent,\n+    presetName,\n+    presetDescription,\n+    inputValues,\n+    inputCredentials,\n+    onCreatePreset,\n+    toast,\n+    toastOnFail,\n+    onboardingState,\n+    completeOnboardingStep,\n   ]);\n \n   const runActions: ButtonAction[] = useMemo(\n     () => [\n-      {\n-        label: (\n-          <>\n-            <IconPlay className=\"mr-2 size-5\" />\n-            Run\n-          </>\n-        ),\n-        variant: \"accent\",\n-        callback: doRun,\n-      },\n+      // \"Regular\" agent: [run] + [save as preset] buttons\n+      ...(!agent.has_external_trigger\n+        ? ([\n+            {\n+              label: (\n+                <>\n+                  <IconPlay className=\"mr-2 size-4\" /> Run\n+                </>\n+              ),\n+              variant: \"accent\",\n+              callback: doRun,\n+            },\n+            // {\n+            //   label: (\n+            //     <>\n+            //       <IconSave className=\"mr-2 size-4\" /> Save as a preset\n+            //     </>\n+            //   ),\n+            //   callback: doCreatePreset,\n+            //   disabled: !(\n+            //     presetName &&\n+            //     allRequiredInputsAreSet &&\n+            //     allCredentialsAreSet\n+            //   ),\n+            // },\n+          ] satisfies ButtonAction[])\n+        : []),\n+      // Triggered agent: [setup] button\n+      ...(agent.has_external_trigger && !agentPreset?.webhook_id\n+        ? ([\n+            {\n+              label: (\n+                <>\n+                  <IconPlay className=\"mr-2 size-4\" /> Set up trigger\n+                </>\n+              ),\n+              variant: \"accent\",\n+              callback: doSetupTrigger,\n+              disabled: !(\n+                presetName &&\n+                allRequiredInputsAreSet &&\n+                allCredentialsAreSet\n+              ),\n+            },\n+          ] satisfies ButtonAction[])\n+        : []),\n+      // Existing agent trigger: [enable]/[disable] button\n+      ...(agentPreset?.webhook_id\n+        ? ([\n+            agentPreset.is_active\n+              ? {\n+                  label: (\n+                    <>\n+                      <IconCross className=\"mr-2.5 size-3.5\" /> Disable trigger\n+                    </>\n+                  ),\n+                  variant: \"destructive\",\n+                  callback: () => doSetPresetActive(false),\n+                }\n+              : {\n+                  label: (\n+                    <>\n+                      <IconPlay className=\"mr-2 size-4\" /> Enable trigger\n+                    </>\n+                  ),\n+                  variant: \"accent\",\n+                  callback: () => doSetPresetActive(true),\n+                },\n+          ] satisfies ButtonAction[])\n+        : []),\n+      // Existing agent preset/trigger: [save] and [delete] buttons\n+      ...(agentPreset\n+        ? ([\n+            {\n+              label: (\n+                <>\n+                  <IconSave className=\"mr-2 size-4\" /> Save changes\n+                </>\n+              ),\n+              callback: doUpdatePreset,\n+              disabled: !(\n+                changedPresetAttributes.size > 0 &&\n+                presetName &&\n+                allRequiredInputsAreSet &&\n+                allCredentialsAreSet\n+              ),\n+            },\n+            {\n+              label: (\n+                <>\n+                  <Trash2Icon className=\"mr-2 size-4\" />\n+                  Delete {agent.has_external_trigger ? \"trigger\" : \"preset\"}\n+                </>\n+              ),\n+              callback: () => doDeletePreset(agentPreset.id),\n+            },\n+          ] satisfies ButtonAction[])\n+        : []),\n+    ],\n+    [\n+      agent.has_external_trigger,\n+      agentPreset,\n+      api,\n+      doRun,\n+      doSetupTrigger,\n+      doCreatePreset,\n+      doUpdatePreset,\n+      doDeletePreset,\n+      changedPresetAttributes,\n+      presetName,\n+      allRequiredInputsAreSet,\n+      allCredentialsAreSet,\n     ],\n-    [doRun],\n   );\n \n   return (\n\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Thank you for your PR on webhook-triggered agent support! Since it's marked as WIP, several key areas need attention before merging:\n\n1. Expand the PR description to clearly explain the feature and specific changes made.\n2. Complete the checklist items.\n3. The scope in the title (platform/library) doesn’t match the extensive changes across backend and frontend. Consider updating it.\n4. Ensure user_id checks are handled in backend/data modifications.\n5. Include a test plan for verifying webhook functionality.\n\nOnce these are addressed, the PR will be ready for review. Looking forward to the completion!"
      }
    ],
    "token_estimation": 8304.0
  },
  {
    "index": 4,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/autogpt_platform/backend/backend/server/v2/store/admin_routes.py b/autogpt_platform/backend/backend/server/v2/store/admin_routes.py\nnew file mode 100644\nindex 000000000000..2c9273ffe4fc\n--- /dev/null\n+++ b/autogpt_platform/backend/backend/server/v2/store/admin_routes.py\n@@ -0,0 +1,207 @@\n+import logging\n+import typing\n+\n+import autogpt_libs.auth.depends\n+import fastapi\n+import fastapi.responses\n+import prisma.enums\n+\n+import backend.server.v2.store.db\n+import backend.server.v2.store.exceptions\n+import backend.server.v2.store.model\n+\n+logger = logging.getLogger(__name__)\n+\n+router = fastapi.APIRouter(prefix=\"/admin\", tags=[\"store\", \"admin\"])\n+\n+\n+@router.get(\n+    \"/submissions\",\n+    response_model=backend.server.v2.store.model.StoreSubmissionsResponse,\n+    dependencies=[fastapi.Depends(autogpt_libs.auth.depends.requires_admin_user)],\n+)\n+async def get_submissions(\n+    status: typing.Optional[prisma.enums.SubmissionStatus] = None,\n+    search: typing.Optional[str] = None,\n+    page: int = 1,\n+    page_size: int = 20,\n+):\n+    \"\"\"\n+    Get all store submissions with filtering options.\n+\n+    Admin only endpoint for managing agent submissions.\n+\n+    Args:\n+        status: Filter by submission status (ALL, PENDING, APPROVED, REJECTED)\n+        search: Search by name, creator, or description\n+        page: Page number for pagination\n+        page_size: Number of items per page\n+\n+    Returns:\n+        StoreSubmissionsResponse with filtered submissions\n+    \"\"\"\n+    try:\n+        submissions = await backend.server.v2.store.db.get_admin_submissions(\n+            status=status,\n+            search_query=search,\n+            page=page,\n+            page_size=page_size,\n+        )\n+        return submissions\n+    except Exception as e:\n+        logger.exception(\"Error getting admin submissions: %s\", e)\n+        return fastapi.responses.JSONResponse(\n+            status_code=500,\n+            content={\"detail\": \"An error occurred while retrieving submissions\"},\n+        )\n+\n+\n+@router.get(\n+    \"/submissions/pending\",\n+    response_model=backend.server.v2.store.model.StoreSubmissionsResponse,\n+    dependencies=[fastapi.Depends(autogpt_libs.auth.depends.requires_admin_user)],\n+)\n+async def get_pending_submissions(\n+    page: int = 1,\n+    page_size: int = 20,\n+):\n+    \"\"\"\n+    Get pending submissions that need admin review.\n+\n+    Convenience endpoint for the admin dashboard.\n+\n+    Args:\n+        page: Page number for pagination\n+        page_size: Number of items per page\n+\n+    Returns:\n+        StoreSubmissionsResponse with pending submissions\n+    \"\"\"\n+    try:\n+        submissions = await backend.server.v2.store.db.get_pending_submissions(\n+            page=page,\n+            page_size=page_size,\n+        )\n+        return submissions\n+    except Exception as e:\n+        logger.exception(\"Error getting pending submissions: %s\", e)\n+        return fastapi.responses.JSONResponse(\n+            status_code=500,\n+            content={\n+                \"detail\": \"An error occurred while retrieving pending submissions\"\n+            },\n+        )\n+\n+\n+@router.get(\n+    \"/submissions/{store_listing_version_id}\",\n+    response_model=backend.server.v2.store.model.StoreSubmission,\n+    dependencies=[fastapi.Depends(autogpt_libs.auth.depends.requires_admin_user)],\n+)\n+async def get_submission_details(\n+    store_listing_version_id: str,\n+):\n+    \"\"\"\n+    Get detailed information about a specific submission.\n+\n+    Args:\n+        store_listing_version_id: ID of the submission version\n+\n+    Returns:\n+        StoreSubmission with full details including internal comments\n+    \"\"\"\n+    try:\n+        submission = await backend.server.v2.store.db.get_submission_details(\n+            store_listing_version_id=store_listing_version_id,\n+        )\n+        return submission\n+    except backend.server.v2.store.exceptions.SubmissionNotFoundError:\n+        return fastapi.responses.JSONResponse(\n+            status_code=404,\n+            content={\"detail\": \"Submission not found\"},\n+        )\n+    except Exception as e:\n+        logger.exception(\"Error getting submission details: %s\", e)\n+        return fastapi.responses.JSONResponse(\n+            status_code=500,\n+            content={\"detail\": \"An error occurred while retrieving submission details\"},\n+        )\n+\n+\n+@router.get(\n+    \"/submissions/listing/{listing_id}/history\",\n+    response_model=backend.server.v2.store.model.StoreSubmissionsResponse,\n+    dependencies=[fastapi.Depends(autogpt_libs.auth.depends.requires_admin_user)],\n+)\n+async def get_listing_history(\n+    listing_id: str,\n+    page: int = 1,\n+    page_size: int = 20,\n+):\n+    \"\"\"\n+    Get all submissions for a specific listing.\n+\n+    This shows the version history of a listing over time.\n+\n+    Args:\n+        listing_id: The ID of the store listing\n+        page: Page number for pagination\n+        page_size: Number of items per page\n+\n+    Returns:\n+        StoreSubmissionsResponse with all versions of a specific listing\n+    \"\"\"\n+    try:\n+        submissions = await backend.server.v2.store.db.get_listing_submissions_history(\n+            listing_id=listing_id,\n+            page=page,\n+            page_size=page_size,\n+        )\n+        return submissions\n+    except Exception as e:\n+        logger.exception(\"Error getting listing history: %s\", e)\n+        return fastapi.responses.JSONResponse(\n+            status_code=500,\n+            content={\"detail\": \"An error occurred while retrieving listing history\"},\n+        )\n+\n+\n+@router.post(\n+    \"/submissions/{store_listing_version_id}/review\",\n+    response_model=backend.server.v2.store.model.StoreSubmission,\n+    dependencies=[fastapi.Depends(autogpt_libs.auth.depends.requires_admin_user)],\n+)\n+async def review_submission(\n+    store_listing_version_id: str,\n+    request: backend.server.v2.store.model.ReviewSubmissionRequest,\n+    user: typing.Annotated[\n+        autogpt_libs.auth.models.User,\n+        fastapi.Depends(autogpt_libs.auth.depends.requires_admin_user),\n+    ],\n+):\n+    \"\"\"\n+    Review a store listing submission.\n+\n+    Args:\n+        store_listing_version_id: ID of the submission to review\n+        request: Review details including approval status and comments\n+        user: Authenticated admin user performing the review\n+\n+    Returns:\n+        StoreSubmission with updated review information\n+    \"\"\"\n+    try:\n+        submission = await backend.server.v2.store.db.review_store_submission(\n+            store_listing_version_id=store_listing_version_id,\n+            is_approved=request.is_approved,\n+            external_comments=request.comments,\n+            internal_comments=request.internal_comments or \"\",\n+            reviewer_id=user.user_id,\n+        )\n+        return submission\n+    except Exception as e:\n+        logger.exception(\"Error reviewing submission: %s\", e)\n+        return fastapi.responses.JSONResponse(\n+            status_code=500,\n+            content={\"detail\": \"An error occurred while reviewing the submission\"},\n+        )\ndiff --git a/autogpt_platform/backend/backend/server/v2/store/db.py b/autogpt_platform/backend/backend/server/v2/store/db.py\nindex c6cf64031966..3b97dee395c7 100644\n--- a/autogpt_platform/backend/backend/server/v2/store/db.py\n+++ b/autogpt_platform/backend/backend/server/v2/store/db.py\n@@ -810,36 +920,355 @@ async def review_store_submission(\n             else prisma.enums.SubmissionStatus.REJECTED\n         )\n \n-        update_data: prisma.types.StoreListingSubmissionUpdateInput = {\n-            \"Status\": submission_status,\n-            \"reviewComments\": comments,\n+        # Update the version with review information\n+        update_data: prisma.types.StoreListingVersionUpdateInput = {\n+            \"submissionStatus\": submission_status,\n+            \"reviewComments\": external_comments,\n+            \"internalComments\": internal_comments,\n             \"Reviewer\": {\"connect\": {\"id\": reviewer_id}},\n             \"StoreListing\": {\"connect\": {\"id\": store_listing_version.StoreListing.id}},\n+            \"reviewedAt\": datetime.now(tz=timezone.utc),\n         }\n \n-        create_data: prisma.types.StoreListingSubmissionCreateInput = {\n-            **update_data,\n-            \"StoreListingVersion\": {\"connect\": {\"id\": store_listing_version_id}},\n-        }\n-\n-        submission = await prisma.models.StoreListingSubmission.prisma().upsert(\n-            where={\"storeListingVersionId\": store_listing_version_id},\n-            data={\n-                \"create\": create_data,\n-                \"update\": update_data,\n-            },\n+        # Update the version\n+        submission = await prisma.models.StoreListingVersion.prisma().update(\n+            where={\"id\": store_listing_version_id},\n+            data=update_data,\n+            include={\"StoreListing\": True},\n         )\n \n         if not submission:\n-            raise fastapi.HTTPException(  # FIXME: don't return HTTP exceptions here\n-                status_code=404,\n-                detail=f\"Store listing submission {store_listing_version_id} not found\",\n+            raise backend.server.v2.store.exceptions.DatabaseError(\n+                f\"Failed to update store listing version {store_listing_version_id}\"\n             )\n \n-        return submission\n+        # Convert to Pydantic model for consistency\n+        return backend.server.v2.store.model.StoreSubmission(\n+            agent_id=submission.agentId,\n+            agent_version=submission.agentVersion,\n+            name=submission.name,\n+            sub_heading=submission.subHeading,\n+            slug=(\n+                submission.StoreListing.slug\n+                if hasattr(submission, \"storeListing\") and submission.StoreListing\n+                else \"\"\n+            ),\n+            description=submission.description,\n+            image_urls=submission.imageUrls or [],\n+            date_submitted=submission.submittedAt or submission.createdAt,\n+            status=submission.submissionStatus,\n+            runs=0,  # Default values since we don't have this data here\n+            rating=0.0,\n+            store_listing_version_id=submission.id,\n+            reviewer_id=submission.reviewerId,\n+            review_comments=submission.reviewComments,\n+            internal_comments=submission.internalComments,\n+            reviewed_at=submission.reviewedAt,\n+            changes_summary=submission.changesSummary,\n+        )\n \n     except Exception as e:\n         logger.error(f\"Could not create store submission review: {e}\")\n         raise backend.server.v2.store.exceptions.DatabaseError(\n             \"Failed to create store submission review\"\n         ) from e\n+\n+\n+async def get_admin_submissions(\n+    status: prisma.enums.SubmissionStatus | None = None,\n+    search_query: str | None = None,\n+    page: int = 1,\n+    page_size: int = 20,\n+) -> backend.server.v2.store.model.StoreSubmissionsResponse:\n+    \"\"\"Get store submissions for admins with filtering options.\n+\n+    Args:\n+        status: Filter by submission status (PENDING, APPROVED, REJECTED)\n+        search_query: Search by name, description, or user email\n+        page: Page number for pagination\n+        page_size: Number of items per page\n+\n+    Returns:\n+        StoreSubmissionsResponse with submissions including internal comments\n+    \"\"\"\n+    logger.debug(\n+        f\"Getting admin store submissions with status={status}, search={search_query}, page={page}\"\n+    )\n+\n+    try:\n+        # Build the where clause\n+        where = prisma.types.StoreSubmissionWhereInput()\n+        if status:\n+            where[\"status\"] = status\n+\n+        sanitized_query = sanitize_query(search_query)\n+        if sanitized_query:\n+            # Find users with matching email first\n+            matching_users = await prisma.models.User.prisma().find_many(\n+                where={\"email\": {\"contains\": sanitized_query, \"mode\": \"insensitive\"}},\n+            )\n+\n+            user_ids = [user.id for user in matching_users]\n+\n+            # Set up the OR conditions to search across multiple fields\n+            where[\"OR\"] = [\n+                {\"name\": {\"contains\": sanitized_query, \"mode\": \"insensitive\"}},\n+                {\"description\": {\"contains\": sanitized_query, \"mode\": \"insensitive\"}},\n+                {\"sub_heading\": {\"contains\": sanitized_query, \"mode\": \"insensitive\"}},\n+            ]\n+\n+            # Add user_id condition if any users matched\n+            if user_ids:\n+                where[\"OR\"].append({\"user_id\": {\"in\": user_ids}})\n+                logger.debug(\n+                    f\"Found {len(user_ids)} users matching query: {sanitized_query}\"\n+                )\n+\n+        # Calculate pagination\n+        skip = (page - 1) * page_size\n+\n+        # Query submissions from database - use the StoreSubmission view\n+        submissions = await prisma.models.StoreSubmission.prisma().find_many(\n+            where=where,\n+            skip=skip,\n+            take=page_size,\n+            order=[{\"date_submitted\": \"desc\"}],\n+        )\n+\n+        # Get total count for pagination\n+        total = await prisma.models.StoreSubmission.prisma().count(where=where)\n+        total_pages = (total + page_size - 1) // page_size\n+\n+        # Convert to response models - using all fields for admins\n+        submission_models = []\n+        for sub in submissions:\n+            submission_model = backend.server.v2.store.model.StoreSubmission(\n+                agent_id=sub.agent_id,\n+                agent_version=sub.agent_version,\n+                name=sub.name,\n+                sub_heading=sub.sub_heading,\n+                slug=sub.slug,\n+                description=sub.description,\n+                image_urls=sub.image_urls or [],\n+                date_submitted=sub.date_submitted or datetime.now(tz=timezone.utc),\n+                status=sub.status,\n+                runs=sub.runs or 0,\n+                rating=sub.rating or 0.0,\n+                store_listing_version_id=sub.store_listing_version_id,\n+                reviewer_id=sub.reviewer_id,\n+                review_comments=sub.review_comments,\n+                internal_comments=sub.internal_comments,\n+                reviewed_at=sub.reviewed_at,\n+                changes_summary=sub.changes_summary,\n+            )\n+            submission_models.append(submission_model)\n+\n+        logger.debug(f\"Found {len(submission_models)} submissions for admin\")\n+        return backend.server.v2.store.model.StoreSubmissionsResponse(\n+            submissions=submission_models,\n+            pagination=backend.server.v2.store.model.Pagination(\n+                current_page=page,\n+                total_items=total,\n+                total_pages=total_pages,\n+                page_size=page_size,\n+            ),\n+        )\n+    except Exception as e:\n+        logger.error(f\"Error fetching admin store submissions: {e}\")\n+        # Return empty response rather than exposing internal errors\n+        return backend.server.v2.store.model.StoreSubmissionsResponse(\n+            submissions=[],\n+            pagination=backend.server.v2.store.model.Pagination(\n+                current_page=page,\n+                total_items=0,\n+                total_pages=0,\n+                page_size=page_size,\n+            ),\n+        )\n+\n+\n+async def get_listing_submissions_history(\n+    listing_id: str,\n+    page: int = 1,\n+    page_size: int = 20,\n+) -> backend.server.v2.store.model.StoreSubmissionsResponse:\n+    \"\"\"Get all submissions for a specific listing for admins.\n+\n+    Args:\n+        listing_id: The ID of the store listing\n+        page: Page number for pagination\n+        page_size: Number of items per page\n+\n+    Returns:\n+        StoreSubmissionsResponse with all versions of a specific listing\n+    \"\"\"\n+    logger.debug(f\"Getting submission history for listing {listing_id}\")\n+\n+    try:\n+        # Query StoreListingVersion directly since we need all versions for a listing\n+        versions = await prisma.models.StoreListingVersion.prisma().find_many(\n+            where={\"storeListingId\": listing_id},\n+            order=[{\"version\": \"desc\"}],\n+            skip=(page - 1) * page_size,\n+            take=page_size,\n+            include={\"StoreListing\": True},\n+        )\n+\n+        # Get total count for pagination\n+        total = await prisma.models.StoreListingVersion.prisma().count(\n+            where={\"storeListingId\": listing_id}\n+        )\n+        total_pages = (total + page_size - 1) // page_size\n+\n+        # Convert to StoreSubmission models\n+        submissions = []\n+        for version in versions:\n+            if not version.StoreListing:\n+                continue\n+\n+            submissions.append(\n+                backend.server.v2.store.model.StoreSubmission(\n+                    agent_id=version.agentId,\n+                    agent_version=version.agentVersion,\n+                    name=version.name,\n+                    sub_heading=version.subHeading,\n+                    slug=version.StoreListing.slug,\n+                    description=version.description,\n+                    image_urls=version.imageUrls or [],\n+                    date_submitted=version.submittedAt or version.createdAt,\n+                    status=version.submissionStatus,\n+                    runs=0,  # We don't have this data here\n+                    rating=0.0,  # We don't have this data here\n+                    store_listing_version_id=version.id,\n+                    reviewer_id=version.reviewerId,\n+                    review_comments=version.reviewComments,\n+                    internal_comments=version.internalComments,\n+                    reviewed_at=version.reviewedAt,\n+                    changes_summary=version.changesSummary,\n+                )\n+            )\n+\n+        logger.debug(\n+            f\"Found {len(submissions)} version history for listing {listing_id}\"\n+        )\n+        return backend.server.v2.store.model.StoreSubmissionsResponse(\n+            submissions=submissions,\n+            pagination=backend.server.v2.store.model.Pagination(\n+                current_page=page,\n+                total_items=total,\n+                total_pages=total_pages,\n+                page_size=page_size,\n+            ),\n+        )\n+    except Exception as e:\n+        logger.error(f\"Error fetching listing submission history: {e}\")\n+        return backend.server.v2.store.model.StoreSubmissionsResponse(\n+            submissions=[],\n+            pagination=backend.server.v2.store.model.Pagination(\n+                current_page=page,\n+                total_items=0,\n+                total_pages=0,\n+                page_size=page_size,\n+            ),\n+        )\n+\n+\n+async def get_pending_submissions(\n+    page: int = 1,\n+    page_size: int = 20,\n+) -> backend.server.v2.store.model.StoreSubmissionsResponse:\n+    \"\"\"Convenience function to get pending submissions for the admin dashboard.\n+\n+    Args:\n+        page: Page number for pagination\n+        page_size: Number of items per page\n+\n+    Returns:\n+        StoreSubmissionsResponse with submissions that need review\n+    \"\"\"\n+    return await get_admin_submissions(\n+        status=prisma.enums.SubmissionStatus.PENDING,\n+        page=page,\n+        page_size=page_size,\n+    )\n+\n+\n+async def get_submission_details(\n+    store_listing_version_id: str,\n+) -> backend.server.v2.store.model.StoreSubmission:\n+    \"\"\"Get detailed information about a specific submission for admins.\n+\n+    Args:\n+        store_listing_version_id: ID of the submission version\n+\n+    Returns:\n+        StoreSubmission with full details including internal comments\n+    \"\"\"\n+    logger.debug(f\"Getting submission details for {store_listing_version_id}\")\n+\n+    try:\n+        # First try getting from the view for efficiency\n+        submission = await prisma.models.StoreSubmission.prisma().find_first(\n+            where={\"store_listing_version_id\": store_listing_version_id}\n+        )\n+\n+        if submission:\n+            return backend.server.v2.store.model.StoreSubmission(\n+                agent_id=submission.agent_id,\n+                agent_version=submission.agent_version,\n+                name=submission.name,\n+                sub_heading=submission.sub_heading,\n+                slug=submission.slug,\n+                description=submission.description,\n+                image_urls=submission.image_urls or [],\n+                date_submitted=submission.date_submitted\n+                or datetime.now(tz=timezone.utc),\n+                status=submission.status,\n+                runs=submission.runs or 0,\n+                rating=submission.rating or 0.0,\n+                store_listing_version_id=submission.store_listing_version_id,\n+                reviewer_id=submission.reviewer_id,\n+                review_comments=submission.review_comments,\n+                internal_comments=submission.internal_comments,\n+                reviewed_at=submission.reviewed_at,\n+                changes_summary=submission.changes_summary,\n+            )\n+\n+        # If not found in the view, try getting it directly\n+        version = await prisma.models.StoreListingVersion.prisma().find_unique(\n+            where={\"id\": store_listing_version_id},\n+            include={\"StoreListing\": True},\n+        )\n+\n+        if not version or not version.StoreListing:\n+            raise backend.server.v2.store.exceptions.SubmissionNotFoundError(\n+                f\"Submission {store_listing_version_id} not found\"\n+            )\n+\n+        return backend.server.v2.store.model.StoreSubmission(\n+            agent_id=version.agentId,\n+            agent_version=version.agentVersion,\n+            name=version.name,\n+            sub_heading=version.subHeading,\n+            slug=version.StoreListing.slug,\n+            description=version.description,\n+            image_urls=version.imageUrls or [],\n+            date_submitted=version.submittedAt or version.createdAt,\n+            status=version.submissionStatus,\n+            runs=0,  # We don't have this data here\n+            rating=0.0,  # We don't have this data here\n+            store_listing_version_id=version.id,\n+            reviewer_id=version.reviewerId,\n+            review_comments=version.reviewComments,\n+            internal_comments=version.internalComments,\n+            reviewed_at=version.reviewedAt,\n+            changes_summary=version.changesSummary,\n+        )\n+\n+    except backend.server.v2.store.exceptions.SubmissionNotFoundError:\n+        raise\n+    except Exception as e:\n+        logger.error(f\"Error fetching submission details: {e}\")\n+        raise backend.server.v2.store.exceptions.DatabaseError(\n+            \"Failed to fetch submission details\"\n+        ) from e\ndiff --git a/autogpt_platform/backend/migrations/20250318043016_update_store_submissions_format/migration.sql b/autogpt_platform/backend/migrations/20250318043016_update_store_submissions_format/migration.sql\nnew file mode 100644\nindex 000000000000..c8c7edac7087\n--- /dev/null\n+++ b/autogpt_platform/backend/migrations/20250318043016_update_store_submissions_format/migration.sql\n@@ -0,0 +1,372 @@\n+/*\n+  Warnings:\n+\n+  - The enum type \"SubmissionStatus\" will be replaced. The 'DAFT' value is removed, so any data using 'DAFT' will be updated to 'DRAFT'. If there are rows still expecting 'DAFT' after this change, it will fail.\n+  - You are about to drop the column \"isApproved\" on the \"StoreListing\" table. All the data in that column will be lost.\n+  - You are about to drop the column \"slug\" on the \"StoreListingVersion\" table. All the data in that column will be lost.\n+  - You are about to drop the \"StoreListingSubmission\" table. Data in that table (beyond what is copied over) will be permanently lost.\n+  - A unique constraint covering the column \"activeVersionId\" on the \"StoreListing\" table will be added. If duplicates already exist, this will fail.\n+  - A unique constraint covering the columns (\"storeListingId\",\"version\") on \"StoreListingVersion\" will be added. If duplicates already exist, this will fail.\n+  - The \"storeListingId\" column on \"StoreListingVersion\" is set to NOT NULL. If any rows currently have a NULL value, this step will fail.\n+  - The views \"StoreSubmission\", \"StoreAgent\", and \"Creator\" are dropped and recreated. Any usage or references to them will be momentarily disrupted until the views are recreated.\n+*/\n+\n+BEGIN;\n+\n+-- First, drop all views that depend on the columns and types we're modifying\n+DROP VIEW IF EXISTS \"StoreSubmission\";\n+DROP VIEW IF EXISTS \"StoreAgent\";\n+DROP VIEW IF EXISTS \"Creator\";\n+\n+-- Create the new enum type\n+CREATE TYPE \"SubmissionStatus_new\" AS ENUM ('DRAFT', 'PENDING', 'APPROVED', 'REJECTED');\n+\n+-- Modify the column with the correct casing (Status with capital S)\n+ALTER TABLE \"StoreListingSubmission\" ALTER COLUMN \"Status\" DROP DEFAULT;\n+ALTER TABLE \"StoreListingSubmission\"\n+    ALTER COLUMN \"Status\" TYPE \"SubmissionStatus_new\"\n+    USING (\n+      CASE WHEN \"Status\"::text = 'DAFT' THEN 'DRAFT'::text\n+           ELSE \"Status\"::text\n+      END\n+    )::\"SubmissionStatus_new\";\n+\n+-- Rename the enum types\n+ALTER TYPE \"SubmissionStatus\" RENAME TO \"SubmissionStatus_old\";\n+ALTER TYPE \"SubmissionStatus_new\" RENAME TO \"SubmissionStatus\";\n+DROP TYPE \"SubmissionStatus_old\";\n+\n+-- Set default back\n+ALTER TABLE \"StoreListingSubmission\" ALTER COLUMN \"Status\" SET DEFAULT 'PENDING';\n+\n+-- Drop constraints\n+ALTER TABLE \"StoreListingSubmission\" DROP CONSTRAINT IF EXISTS \"StoreListingSubmission_reviewerId_fkey\";\n+\n+-- Drop indexes\n+DROP INDEX IF EXISTS \"StoreListing_isDeleted_isApproved_idx\";\n+DROP INDEX IF EXISTS \"StoreListingSubmission_storeListingVersionId_key\";\n+\n+-- Modify StoreListing\n+ALTER TABLE \"StoreListing\"\n+    DROP COLUMN IF EXISTS \"isApproved\",\n+    ADD COLUMN IF NOT EXISTS \"activeVersionId\" TEXT,\n+    ADD COLUMN IF NOT EXISTS \"hasApprovedVersion\" BOOLEAN NOT NULL DEFAULT false,\n+    ADD COLUMN IF NOT EXISTS \"slug\" TEXT;\n+\n+-- First add ALL columns to StoreListingVersion (including the submissionStatus column)\n+ALTER TABLE \"StoreListingVersion\"\n+    ADD COLUMN IF NOT EXISTS \"reviewerId\" TEXT,\n+    ADD COLUMN IF NOT EXISTS \"reviewComments\" TEXT,\n+    ADD COLUMN IF NOT EXISTS \"internalComments\" TEXT,\n+    ADD COLUMN IF NOT EXISTS \"reviewedAt\" TIMESTAMP(3),\n+    ADD COLUMN IF NOT EXISTS \"changesSummary\" TEXT,\n+    ADD COLUMN IF NOT EXISTS \"submissionStatus\" \"SubmissionStatus\" NOT NULL DEFAULT 'DRAFT',\n+    ADD COLUMN IF NOT EXISTS \"submittedAt\" TIMESTAMP(3),\n+    ALTER COLUMN \"storeListingId\" SET NOT NULL;\n+\n+-- NOW copy data from StoreListingSubmission to StoreListingVersion\n+DO $$\n+BEGIN\n+    -- First, check what columns actually exist in the StoreListingSubmission table\n+    DECLARE\n+        has_reviewerId BOOLEAN := (\n+            SELECT EXISTS (\n+                SELECT FROM information_schema.columns\n+                WHERE table_name = 'StoreListingSubmission'\n+                AND column_name = 'reviewerId'\n+            )\n+        );\n+\n+        has_reviewComments BOOLEAN := (\n+            SELECT EXISTS (\n+                SELECT FROM information_schema.columns\n+                WHERE table_name = 'StoreListingSubmission'\n+                AND column_name = 'reviewComments'\n+            )\n+        );\n+\n+        has_changesSummary BOOLEAN := (\n+            SELECT EXISTS (\n+                SELECT FROM information_schema.columns\n+                WHERE table_name = 'StoreListingSubmission'\n+                AND column_name = 'changesSummary'\n+            )\n+        );\n+    BEGIN\n+        -- Only copy fields that we know exist\n+        IF has_reviewerId THEN\n+            UPDATE \"StoreListingVersion\" AS v\n+            SET \"reviewerId\" = s.\"reviewerId\"\n+            FROM \"StoreListingSubmission\" AS s\n+            WHERE v.\"id\" = s.\"storeListingVersionId\";\n+        END IF;\n+\n+        IF has_reviewComments THEN\n+            UPDATE \"StoreListingVersion\" AS v\n+            SET \"reviewComments\" = s.\"reviewComments\"\n+            FROM \"StoreListingSubmission\" AS s\n+            WHERE v.\"id\" = s.\"storeListingVersionId\";\n+        END IF;\n+\n+        IF has_changesSummary THEN\n+            UPDATE \"StoreListingVersion\" AS v\n+            SET \"changesSummary\" = s.\"changesSummary\"\n+            FROM \"StoreListingSubmission\" AS s\n+            WHERE v.\"id\" = s.\"storeListingVersionId\";\n+        END IF;\n+    END;\n+\n+    -- Update submission status based on StoreListingSubmission status\n+    UPDATE \"StoreListingVersion\" AS v\n+    SET \"submissionStatus\" = s.\"Status\"\n+    FROM \"StoreListingSubmission\" AS s\n+    WHERE v.\"id\" = s.\"storeListingVersionId\";\n+\n+    -- Update reviewedAt timestamps for versions with APPROVED or REJECTED status\n+    UPDATE \"StoreListingVersion\" AS v\n+    SET \"reviewedAt\" = s.\"updatedAt\"\n+    FROM \"StoreListingSubmission\" AS s\n+    WHERE v.\"id\" = s.\"storeListingVersionId\"\n+      AND s.\"Status\" IN ('APPROVED', 'REJECTED');\n+END;\n+$$;\n+\n+-- Drop the StoreListingSubmission table\n+DROP TABLE IF EXISTS \"StoreListingSubmission\";\n+\n+-- Copy slugs from StoreListingVersion to StoreListing\n+WITH latest_versions AS (\n+    SELECT\n+        \"storeListingId\",\n+        \"slug\",\n+        ROW_NUMBER() OVER (PARTITION BY \"storeListingId\" ORDER BY \"version\" DESC) as rn\n+    FROM \"StoreListingVersion\"\n+)\n+UPDATE \"StoreListing\" sl\n+SET \"slug\" = lv.\"slug\"\n+FROM latest_versions lv\n+WHERE sl.\"id\" = lv.\"storeListingId\"\n+  AND lv.rn = 1;\n+\n+-- Make StoreListing.slug required and unique\n+ALTER TABLE \"StoreListing\" ALTER COLUMN \"slug\" SET NOT NULL;\n+CREATE UNIQUE INDEX \"StoreListing_owningUserId_slug_key\" ON \"StoreListing\"(\"owningUserId\", \"slug\");\n+DROP INDEX \"StoreListing_owningUserId_idx\";\n+\n+-- Drop the slug column from StoreListingVersion since it's now on StoreListing\n+ALTER TABLE \"StoreListingVersion\" DROP COLUMN \"slug\";\n+\n+-- Update both sides of the relation from one-to-one to one-to-many\n+-- The AgentGraph->StoreListingVersion relationship is now one-to-many\n+\n+-- Drop the unique constraint but add a non-unique index for query performance\n+ALTER TABLE \"StoreListingVersion\" DROP CONSTRAINT IF EXISTS \"StoreListingVersion_agentId_agentVersion_key\";\n+CREATE INDEX IF NOT EXISTS \"StoreListingVersion_agentId_agentVersion_idx\"\n+    ON \"StoreListingVersion\"(\"agentId\", \"agentVersion\");\n+\n+-- Set isApproved based on submissionStatus before removing it\n+UPDATE \"StoreListingVersion\"\n+SET \"submissionStatus\" = 'APPROVED'\n+WHERE \"isApproved\" = true;\n+\n+-- Drop the isApproved column from StoreListingVersion since it's redundant with submissionStatus\n+ALTER TABLE \"StoreListingVersion\" DROP COLUMN \"isApproved\";\n+\n+-- Initialize hasApprovedVersion for existing StoreListing rows ***\n+-- This sets \"hasApprovedVersion\" = TRUE for any StoreListing\n+-- that has at least one corresponding version with \"APPROVED\" status.\n+UPDATE \"StoreListing\" sl\n+SET \"hasApprovedVersion\" = (\n+  SELECT COUNT(*) > 0\n+  FROM \"StoreListingVersion\" slv\n+  WHERE slv.\"storeListingId\" = sl.id\n+    AND slv.\"submissionStatus\" = 'APPROVED'\n+    AND sl.\"agentId\" = slv.\"agentId\"\n+    AND sl.\"agentVersion\" = slv.\"agentVersion\"\n+);\n+\n+-- Create new indexes\n+CREATE UNIQUE INDEX IF NOT EXISTS \"StoreListing_activeVersionId_key\"\n+    ON \"StoreListing\"(\"activeVersionId\");\n+\n+CREATE INDEX IF NOT EXISTS \"StoreListing_isDeleted_hasApprovedVersion_idx\"\n+    ON \"StoreListing\"(\"isDeleted\", \"hasApprovedVersion\");\n+\n+CREATE INDEX IF NOT EXISTS \"StoreListingVersion_storeListingId_submissionStatus_isAvailable_idx\"\n+    ON \"StoreListingVersion\"(\"storeListingId\", \"submissionStatus\", \"isAvailable\");\n+\n+CREATE INDEX IF NOT EXISTS \"StoreListingVersion_submissionStatus_idx\"\n+    ON \"StoreListingVersion\"(\"submissionStatus\");\n+\n+CREATE UNIQUE INDEX IF NOT EXISTS \"StoreListingVersion_storeListingId_version_key\"\n+    ON \"StoreListingVersion\"(\"storeListingId\", \"version\");\n+\n+-- Add foreign keys\n+ALTER TABLE \"StoreListing\"\n+ADD CONSTRAINT \"StoreListing_activeVersionId_fkey\"\n+FOREIGN KEY (\"activeVersionId\") REFERENCES \"StoreListingVersion\"(\"id\")\n+ON DELETE SET NULL ON UPDATE CASCADE;\n+\n+-- Add reviewer foreign key\n+ALTER TABLE \"StoreListingVersion\"\n+ADD CONSTRAINT \"StoreListingVersion_reviewerId_fkey\"\n+FOREIGN KEY (\"reviewerId\") REFERENCES \"User\"(\"id\")\n+ON DELETE SET NULL ON UPDATE CASCADE;\n+\n+-- Add index for reviewer\n+CREATE INDEX IF NOT EXISTS \"StoreListingVersion_reviewerId_idx\"\n+    ON \"StoreListingVersion\"(\"reviewerId\");\n+\n+-- DropIndex\n+DROP INDEX \"StoreListingVersion_agentId_agentVersion_key\";\n+\n+-- RenameIndex\n+ALTER INDEX \"StoreListingVersion_storeListingId_submissionStatus_isAvailable_idx\"\n+RENAME TO \"StoreListingVersion_storeListingId_submissionStatus_isAvail_idx\";\n+\n+-- Recreate the views with updated column references\n+\n+-- 1. Recreate StoreSubmission view\n+CREATE VIEW \"StoreSubmission\" AS\n+SELECT\n+    sl.id AS listing_id,\n+    sl.\"owningUserId\" AS user_id,\n+    slv.\"agentId\" AS agent_id,\n+    slv.version AS agent_version,\n+    sl.slug,\n+    COALESCE(slv.name, '') AS name,\n+    slv.\"subHeading\" AS sub_heading,\n+    slv.description,\n+    slv.\"imageUrls\" AS image_urls,\n+    slv.\"submittedAt\" AS date_submitted,\n+    slv.\"submissionStatus\" AS status,\n+    COALESCE(ar.run_count, 0::bigint) AS runs,\n+    COALESCE(avg(sr.score::numeric), 0.0)::double precision AS rating,\n+    -- Add the additional fields needed by the Pydantic model\n+    slv.id AS store_listing_version_id,\n+    slv.\"reviewerId\" AS reviewer_id,\n+    slv.\"reviewComments\" AS review_comments,\n+    slv.\"internalComments\" AS internal_comments,\n+    slv.\"reviewedAt\" AS reviewed_at,\n+    slv.\"changesSummary\" AS changes_summary\n+FROM \"StoreListing\" sl\n+    JOIN \"StoreListingVersion\" slv ON slv.\"storeListingId\" = sl.id\n+    LEFT JOIN \"StoreListingReview\" sr ON sr.\"storeListingVersionId\" = slv.id\n+    LEFT JOIN (\n+        SELECT \"AgentGraphExecution\".\"agentGraphId\", count(*) AS run_count\n+        FROM \"AgentGraphExecution\"\n+        GROUP BY \"AgentGraphExecution\".\"agentGraphId\"\n+    ) ar ON ar.\"agentGraphId\" = slv.\"agentId\"\n+WHERE sl.\"isDeleted\" = false\n+GROUP BY sl.id, sl.\"owningUserId\", slv.id, slv.\"agentId\", slv.version, sl.slug, slv.name,\n+         slv.\"subHeading\", slv.description, slv.\"imageUrls\", slv.\"submittedAt\",\n+         slv.\"submissionStatus\", slv.\"reviewerId\", slv.\"reviewComments\", slv.\"internalComments\",\n+         slv.\"reviewedAt\", slv.\"changesSummary\", ar.run_count;\n+\n+-- 2. Recreate StoreAgent view\n+CREATE VIEW \"StoreAgent\" AS\n+WITH reviewstats AS (\n+    SELECT sl_1.id AS \"storeListingId\",\n+           count(sr.id) AS review_count,\n+           avg(sr.score::numeric) AS avg_rating\n+      FROM \"StoreListing\" sl_1\n+      JOIN \"StoreListingVersion\" slv_1\n+           ON slv_1.\"storeListingId\" = sl_1.id\n+      JOIN \"StoreListingReview\" sr\n+           ON sr.\"storeListingVersionId\" = slv_1.id\n+     WHERE sl_1.\"isDeleted\" = false\n+     GROUP BY sl_1.id\n+), agentruns AS (\n+    SELECT \"AgentGraphExecution\".\"agentGraphId\",\n+           count(*) AS run_count\n+      FROM \"AgentGraphExecution\"\n+     GROUP BY \"AgentGraphExecution\".\"agentGraphId\"\n+)\n+SELECT sl.id AS listing_id,\n+       slv.id AS \"storeListingVersionId\",\n+       slv.\"createdAt\" AS updated_at,\n+       sl.slug,\n+       COALESCE(slv.name, '') AS agent_name,\n+       slv.\"videoUrl\" AS agent_video,\n+       COALESCE(slv.\"imageUrls\", ARRAY[]::text[]) AS agent_image,\n+       slv.\"isFeatured\" AS featured,\n+       p.username AS creator_username,\n+       p.\"avatarUrl\" AS creator_avatar,\n+       slv.\"subHeading\" AS sub_heading,\n+       slv.description,\n+       slv.categories,\n+       COALESCE(ar.run_count, 0::bigint) AS runs,\n+       COALESCE(rs.avg_rating, 0.0)::double precision AS rating,\n+       array_agg(DISTINCT slv.version::text) AS versions\n+  FROM \"StoreListing\" sl\n+  JOIN \"AgentGraph\" a\n+       ON sl.\"agentId\" = a.id\n+      AND sl.\"agentVersion\" = a.version\n+  LEFT JOIN \"Profile\" p\n+       ON sl.\"owningUserId\" = p.\"userId\"\n+  LEFT JOIN \"StoreListingVersion\" slv\n+       ON slv.\"storeListingId\" = sl.id\n+  LEFT JOIN reviewstats rs\n+       ON sl.id = rs.\"storeListingId\"\n+  LEFT JOIN agentruns ar\n+       ON a.id = ar.\"agentGraphId\"\n+ WHERE sl.\"isDeleted\" = false\n+   AND sl.\"hasApprovedVersion\" = true\n+   AND slv.\"submissionStatus\" = 'APPROVED'\n+ GROUP BY sl.id, slv.id, sl.slug, slv.\"createdAt\", slv.name, slv.\"videoUrl\",\n+          slv.\"imageUrls\", slv.\"isFeatured\", p.username, p.\"avatarUrl\",\n+          slv.\"subHeading\", slv.description, slv.categories, ar.run_count,\n+          rs.avg_rating;\n+\n+-- 3. Recreate Creator view\n+CREATE VIEW \"Creator\" AS\n+WITH agentstats AS (\n+    SELECT p_1.username,\n+           count(DISTINCT sl.id) AS num_agents,\n+           avg(COALESCE(sr.score, 0)::numeric) AS agent_rating,\n+           sum(COALESCE(age.run_count, 0::bigint)) AS agent_runs\n+      FROM \"Profile\" p_1\n+ LEFT JOIN \"StoreListing\" sl\n+        ON sl.\"owningUserId\" = p_1.\"userId\"\n+ LEFT JOIN \"StoreListingVersion\" slv\n+        ON slv.\"storeListingId\" = sl.id\n+ LEFT JOIN \"StoreListingReview\" sr\n+        ON sr.\"storeListingVersionId\" = slv.id\n+ LEFT JOIN (\n+          SELECT \"AgentGraphExecution\".\"agentGraphId\",\n+                 count(*) AS run_count\n+            FROM \"AgentGraphExecution\"\n+        GROUP BY \"AgentGraphExecution\".\"agentGraphId\"\n+      ) age ON age.\"agentGraphId\" = sl.\"agentId\"\n+     WHERE sl.\"isDeleted\" = false\n+       AND sl.\"hasApprovedVersion\" = true\n+       AND slv.\"submissionStatus\" = 'APPROVED'\n+  GROUP BY p_1.username\n+)\n+SELECT p.username,\n+       p.name,\n+       p.\"avatarUrl\" AS avatar_url,\n+       p.description,\n+       array_agg(DISTINCT cats.c) FILTER (WHERE cats.c IS NOT NULL) AS top_categories,\n+       p.links,\n+       p.\"isFeatured\" AS is_featured,\n+       COALESCE(ast.num_agents, 0::bigint) AS num_agents,\n+       COALESCE(ast.agent_rating, 0.0) AS agent_rating,\n+       COALESCE(ast.agent_runs, 0::numeric) AS agent_runs\n+  FROM \"Profile\" p\n+  LEFT JOIN agentstats ast\n+         ON ast.username = p.username\n+  LEFT JOIN LATERAL (\n+          SELECT unnest(slv.categories) AS c\n+            FROM \"StoreListing\" sl\n+            JOIN \"StoreListingVersion\" slv\n+                 ON slv.\"storeListingId\" = sl.id\n+           WHERE sl.\"owningUserId\" = p.\"userId\"\n+             AND sl.\"isDeleted\" = false\n+             AND sl.\"hasApprovedVersion\" = true\n+             AND slv.\"submissionStatus\" = 'APPROVED'\n+       ) cats ON true\n+ GROUP BY p.username, p.name, p.\"avatarUrl\", p.description, p.links,\n+          p.\"isFeatured\", ast.num_agents, ast.agent_rating, ast.agent_runs;\n+\n+COMMIT;\ndiff --git a/autogpt_platform/backend/schema.prisma b/autogpt_platform/backend/schema.prisma\nindex 6defe1ed5e8a..5a34024eb9df 100644\n--- a/autogpt_platform/backend/schema.prisma\n+++ b/autogpt_platform/backend/schema.prisma\n@@index([id])\n   @@index([email])\n@@index([userId])\n }\n@@ -86,13 +86,13 @@ model AgentGraph {\n   name        String?\n   description String?\n \n-  isActive    Boolean @default(true)\n+  isActive Boolean @default(true)\n \n   // Link to User model\n   userId String\n   // FIX: Do not cascade delete the agent when the user is deleted\n   // This allows us to delete user data with deleting the agent which maybe in use by other users\n-  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n+  User   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n \n   AgentNodes          AgentNode[]\n   AgentGraphExecution AgentGraphExecution[]\n@@ -100,7 +100,7 @@ model AgentGraph {\n   AgentPreset         AgentPreset[]\n   LibraryAgent        LibraryAgent[]\n   StoreListing        StoreListing[]\n-  StoreListingVersion StoreListingVersion?\n+  StoreListingVersion StoreListingVersion[]\n \n   @@id(name: \"graphVersionId\", [id, version])\n   @@index([userId, isActive])\n@@ -175,11 +175,11 @@ model UserNotificationBatch {\n   updatedAt DateTime @default(now()) @updatedAt\n \n   userId String\n-  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n+  User   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n \n   type NotificationType\n \n-  notifications NotificationEvent[]\n+  Notifications NotificationEvent[]\n \n   // Each user can only have one batch of a notification type at a time\n   @@unique([userId, type])\n@@index([userId])\n }\n@@ -470,7 +470,7 @@ model CreditTransaction {\n   createdAt      DateTime @default(now())\n \n   userId String\n-  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n+  User   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n \n   amount Int\n   type   CreditTransactionType\n@@ -579,19 +579,25 @@ view StoreAgent {\n }\n \n view StoreSubmission {\n-  listing_id     String           @id\n-  user_id        String\n-  slug           String\n-  name           String\n-  sub_heading    String\n-  description    String\n-  image_urls     String[]\n-  date_submitted DateTime\n-  status         SubmissionStatus\n-  runs           Int\n-  rating         Float\n-  agent_id       String\n-  agent_version  Int\n+  listing_id               String           @id\n+  user_id                  String\n+  slug                     String\n+  name                     String\n+  sub_heading              String\n+  description              String\n+  image_urls               String[]\n+  date_submitted           DateTime\n+  status                   SubmissionStatus\n+  runs                     Int\n+  rating                   Float\n+  agent_id                 String\n+  agent_version            Int\n+  store_listing_version_id String\n+  reviewer_id              String?\n+  review_comments          String?\n+  internal_comments        String?\n+  reviewed_at              DateTime?\n+  changes_summary          String?\n \n   // Index or unique are not applied to views\n }\n@@ -601,11 +607,18 @@ model StoreListing {\n   createdAt DateTime @default(now())\n   updatedAt DateTime @default(now()) @updatedAt\n \n-  isDeleted  Boolean @default(false)\n-  // Not needed but makes lookups faster\n-  isApproved Boolean @default(false)\n+  isDeleted          Boolean @default(false)\n+  // Whether any version has been approved and is available for display\n+  hasApprovedVersion Boolean @default(false)\n+\n+  // URL-friendly identifier for this agent (moved from StoreListingVersion)\n+  slug String\n \n-  // The agent link here is only so we can do lookup on agentId, for the listing the StoreListingVersion is used.\n+  // The currently active version that should be shown to users\n+  activeVersionId String?              @unique\n+  ActiveVersion   StoreListingVersion? @relation(\"ActiveVersion\", fields: [activeVersionId], references: [id])\n+\n+  // The agent link here is only so we can do lookup on agentId\n   agentId      String\n   agentVersion Int\n   Agent        AgentGraph @relation(fields: [agentId, agentVersion], references: [id, version], onDelete: Cascade)\n@@ -613,14 +626,14 @@ model StoreListing {\n   owningUserId String\n   OwningUser   User   @relation(fields: [owningUserId], references: [id])\n \n-  StoreListingVersions   StoreListingVersion[]\n-  StoreListingSubmission StoreListingSubmission[]\n+  // Relations\n+  Versions StoreListingVersion[] @relation(\"ListingVersions\")\n \n   // Unique index on agentId to ensure only one listing per agent, regardless of number of versions the agent has.\n   @@unique([agentId])\n-  @@index([owningUserId])\n+  @@unique([owningUserId, slug])\n   // Used in the view query\n-  @@index([isDeleted, isApproved])\n+  @@index([isDeleted, hasApprovedVersion])\n }\n \n model StoreListingVersion {\n@@unique([agentId, agentVersion])\n+  // Reviews for this specific version\n+  Reviews StoreListingReview[]\n+\n+  @@unique([storeListingId, version])\n+  @@index([storeListingId, submissionStatus, isAvailable])\n+  @@index([submissionStatus])\n+  @@index([reviewerId])\n+  @@index([agentId, agentVersion]) // Non-unique index for efficient lookups\n }\n \n model StoreListingReview {\n@@unique([storeListingVersionId])\n-  @@index([storeListingId])\n+  DRAFT // Being prepared, not yet submitted\n+  PENDING // Submitted, awaiting review\n+  APPROVED // Reviewed and approved\n+  REJECTED // Reviewed and rejected\n }\n \n enum APIKeyPermission {\n@@index([key])\n   @@index([prefix])\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR generally adheres to guidelines, but several key issues need attention. The title includes a correct scope, and the changes are well-documented. However, the test plan references a private document, hindering verification and transparency. Additionally, the checklist remains partially completed without marking sections as not applicable, particularly in the configuration section. Lastly, while user_id handling seems appropriate in data files, specific details about these changes are lacking. Addressing these points will strengthen the PR's integrity before merging."
      }
    ],
    "token_estimation": 11143.25
  },
  {
    "index": 5,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/autogpt/scripts/llamafile/serve.py b/autogpt/scripts/llamafile/serve.py\nnew file mode 100755\nindex 000000000000..431fa253f19f\n--- /dev/null\n+++ b/autogpt/scripts/llamafile/serve.py\n@@ -0,0 +1,165 @@\n+#!/usr/bin/env python3\n+\"\"\"\n+Use llamafile to serve a (quantized) mistral-7b-instruct-v0.2 model\n+\n+Usage:\n+  cd <repo-root>/autogpt\n+  ./scripts/llamafile/serve.py\n+\"\"\"\n+\n+import os\n+import platform\n+import subprocess\n+from pathlib import Path\n+from typing import Optional\n+\n+import click\n+\n+LLAMAFILE = Path(\"mistral-7b-instruct-v0.2.Q5_K_M.llamafile\")\n+LLAMAFILE_URL = f\"https://huggingface.co/jartine/Mistral-7B-Instruct-v0.2-llamafile/resolve/main/{LLAMAFILE.name}\"  # noqa\n+LLAMAFILE_EXE = Path(\"llamafile.exe\")\n+LLAMAFILE_EXE_URL = \"https://github.com/Mozilla-Ocho/llamafile/releases/download/0.8.6/llamafile-0.8.6\"  # noqa\n+\n+\n+@click.command()\n+@click.option(\n+    \"--llamafile\",\n+    type=click.Path(dir_okay=False, path_type=Path),\n+    help=f\"Name of the llamafile to serve. Default: {LLAMAFILE.name}\",\n+)\n+@click.option(\"--llamafile_url\", help=\"Download URL for the llamafile you want to use\")\n+@click.option(\n+    \"--host\", help=\"Specify the address for the llamafile server to listen on\"\n+)\n+@click.option(\n+    \"--port\", type=int, help=\"Specify the port for the llamafile server to listen on\"\n+)\n+@click.option(\n+    \"--force-gpu\",\n+    is_flag=True,\n+    hidden=platform.system() != \"Darwin\",\n+    help=\"Run the model using only the GPU (AMD or Nvidia). \"\n+    \"Otherwise, both CPU and GPU may be (partially) used.\",\n+)\n+def main(\n+    llamafile: Optional[Path] = None,\n+    llamafile_url: Optional[str] = None,\n+    host: Optional[str] = None,\n+    port: Optional[int] = None,\n+    force_gpu: bool = False,\n+):\n+    print(f\"type(llamafile) = {type(llamafile)}\")\n+    if not llamafile:\n+        if not llamafile_url:\n+            llamafile = LLAMAFILE\n+        else:\n+            llamafile = Path(llamafile_url.rsplit(\"/\", 1)[1])\n+            if llamafile.suffix != \".llamafile\":\n+                click.echo(\n+                    click.style(\n+                        \"The given URL does not end with '.llamafile' -> \"\n+                        \"can't get filename from URL. \"\n+                        \"Specify the filename using --llamafile.\",\n+                        fg=\"red\",\n+                    ),\n+                    err=True,\n+                )\n+                return\n+\n+    if llamafile == LLAMAFILE and not llamafile_url:\n+        llamafile_url = LLAMAFILE_URL\n+    elif llamafile_url != LLAMAFILE_URL:\n+        if not click.prompt(\n+            click.style(\n+                \"You seem to have specified a different URL for the default model \"\n+                f\"({llamafile.name}). Are you sure this is correct? \"\n+                \"If you want to use a different model, also specify --llamafile.\",\n+                fg=\"yellow\",\n+            ),\n+            type=bool,\n+        ):\n+            return\n+\n+    # Go to autogpt/scripts/llamafile/\n+    os.chdir(Path(__file__).resolve().parent)\n+\n+    on_windows = platform.system() == \"Windows\"\n+\n+    if not llamafile.is_file():\n+        if not llamafile_url:\n+            click.echo(\n+                click.style(\n+                    \"Please use --lamafile_url to specify a download URL for \"\n+                    f\"'{llamafile.name}'. \"\n+                    \"This will only be necessary once, so we can download the model.\",\n+                    fg=\"red\",\n+                ),\n+                err=True,\n+            )\n+            return\n+\n+        download_file(llamafile_url, llamafile)\n+\n+        if not on_windows:\n+            llamafile.chmod(0o755)\n+            subprocess.run([llamafile, \"--version\"], check=True)\n+\n+    if not on_windows:\n+        base_command = [f\"./{llamafile}\"]\n+    else:\n+        # Windows does not allow executables over 4GB, so we have to download a\n+        # model-less llamafile.exe and run that instead.\n+        if not LLAMAFILE_EXE.is_file():\n+            download_file(LLAMAFILE_EXE_URL, LLAMAFILE_EXE)\n+            LLAMAFILE_EXE.chmod(0o755)\n+            subprocess.run([f\".\\\\{LLAMAFILE_EXE}\", \"--version\"], check=True)\n+\n+        base_command = [f\".\\\\{LLAMAFILE_EXE}\", \"-m\", llamafile]\n+\n+    if host:\n+        base_command.extend([\"--host\", host])\n+    if port:\n+        base_command.extend([\"--port\", str(port)])\n+    if force_gpu:\n+        base_command.extend([\"-ngl\", \"9999\"])\n+\n+    subprocess.run(\n+        [\n+            *base_command,\n+            \"--server\",\n+            \"--nobrowser\",\n+            \"--ctx-size\",\n+            \"0\",\n+            \"--n-predict\",\n+            \"1024\",\n+        ],\n+        check=True,\n+    )\n+\n+    # note: --ctx-size 0 means the prompt context size will be set directly from the\n+    # underlying model configuration. This may cause slow response times or consume\n+    # a lot of memory.\n+\n+\n+def download_file(url: str, to_file: Path) -> None:\n+    print(f\"Downloading {to_file.name}...\")\n+    import urllib.request\n+\n+    urllib.request.urlretrieve(url, to_file, reporthook=report_download_progress)\n+    print()\n+\n+\n+def report_download_progress(chunk_number: int, chunk_size: int, total_size: int):\n+    if total_size != -1:\n+        downloaded_size = chunk_number * chunk_size\n+        percent = min(1, downloaded_size / total_size)\n+        bar = \"#\" * int(40 * percent)\n+        print(\n+            f\"\\rDownloading: [{bar:<40}] {percent:.0%}\"\n+            f\" - {downloaded_size/1e6:.1f}/{total_size/1e6:.1f} MB\",\n+            end=\"\",\n+        )\n+\n+\n+if __name__ == \"__main__\":\n+    main()\ndiff --git a/docs/content/AutoGPT/setup/index.md b/docs/content/AutoGPT/setup/index.md\nindex 4fcdbf1cac44..78b9632ac19f 100644\n--- a/docs/content/AutoGPT/setup/index.md\n+++ b/docs/content/AutoGPT/setup/index.md\n@@ -198,3 +198,66 @@ If you don't know which to choose, you can safely go with OpenAI*.\n \n [groq/api-keys]: https://console.groq.com/keys\n [groq/models]: https://console.groq.com/docs/models\n+\n+\n+### Llamafile\n+\n+With llamafile you can run models locally, which means no need to set up billing,\n+and guaranteed data privacy.\n+\n+For more information and in-depth documentation, check out the [llamafile documentation].\n+\n+!!! warning\n+    At the moment, llamafile only serves one model at a time. This means you can not\n+    set `SMART_LLM` and `FAST_LLM` to two different llamafile models.\n+\n+!!! warning\n+    Due to the issues linked below, llamafiles don't work on WSL. To use a llamafile\n+    with AutoGPT in WSL, you will have to run the llamafile in Windows (outside WSL).\n+\n+    <details>\n+    <summary>Instructions</summary>\n+\n+    1. Get the `llamafile/serve.py` script through one of these two ways:\n+        1. Clone the AutoGPT repo somewhere in your Windows environment,\n+           with the script located at `autogpt/scripts/llamafile/serve.py`\n+        2. Download just the [serve.py] script somewhere in your Windows environment\n+    2. Make sure you have `click` installed: `pip install click`\n+    3. Run `ip route | grep default | awk '{print $3}'` *inside WSL* to get the address\n+       of the WSL host machine\n+    4. Run `python3 serve.py --host {WSL_HOST_ADDR}`, where `{WSL_HOST_ADDR}`\n+       is the address you found at step 3.\n+       If port 8080 is taken, also specify a different port using `--port {PORT}`.\n+    5. In WSL, set `LLAMAFILE_API_BASE=http://{WSL_HOST_ADDR}:8080/v1` in your `.env`.\n+    6. Follow the rest of the regular instructions below.\n+\n+    [serve.py]: https://github.com/Significant-Gravitas/AutoGPT/blob/master/autogpt/scripts/llamafile/serve.py\n+    </details>\n+\n+    * [Mozilla-Ocho/llamafile#356](https://github.com/Mozilla-Ocho/llamafile/issues/356)\n+    * [Mozilla-Ocho/llamafile#100](https://github.com/Mozilla-Ocho/llamafile/issues/100)\n+\n+!!! note\n+    These instructions will download and use `mistral-7b-instruct-v0.2.Q5_K_M.llamafile`.\n+    `mistral-7b-instruct-v0.2` is currently the only tested and supported model.\n+    If you want to try other models, you'll have to add them to `LlamafileModelName` in\n+    [`llamafile.py`][forge/llamafile.py].\n+    For optimal results, you may also have to add some logic to adapt the message format,\n+    like `LlamafileProvider._adapt_chat_messages_for_mistral_instruct(..)` does.\n+\n+1. Run the llamafile serve script:\n+   ```shell\n+   python3 ./scripts/llamafile/serve.py\n+   ```\n+   The first time this is run, it will download a file containing the model + runtime,\n+   which may take a while and a few gigabytes of disk space.\n+\n+   To force GPU acceleration, add `--use-gpu` to the command.\n+\n+3. In `.env`, set `SMART_LLM`/`FAST_LLM` or both to `mistral-7b-instruct-v0.2`\n+\n+4. If the server is running on different address than `http://localhost:8080/v1`,\n+   set `LLAMAFILE_API_BASE` in `.env` to the right base URL\n+\n+[llamafile documentation]: https://github.com/Mozilla-Ocho/llamafile#readme\n+[forge/llamafile.py]: https://github.com/Significant-Gravitas/AutoGPT/blob/master/forge/forge/llm/providers/llamafile/llamafile.py\ndiff --git a/forge/forge/llm/providers/llamafile/llamafile.py b/forge/forge/llm/providers/llamafile/llamafile.py\nnew file mode 100644\nindex 000000000000..7eb7afaafb10\n--- /dev/null\n+++ b/forge/forge/llm/providers/llamafile/llamafile.py\n@@ -0,0 +1,351 @@\n+import enum\n+import logging\n+import re\n+from pathlib import Path\n+from typing import Any, Iterator, Optional, Sequence\n+\n+import requests\n+from openai.types.chat import (\n+    ChatCompletionMessage,\n+    ChatCompletionMessageParam,\n+    CompletionCreateParams,\n+)\n+from pydantic import SecretStr\n+\n+from forge.json.parsing import json_loads\n+from forge.models.config import UserConfigurable\n+\n+from .._openai_base import BaseOpenAIChatProvider\n+from ..schema import (\n+    AssistantToolCall,\n+    AssistantToolCallDict,\n+    ChatMessage,\n+    ChatModelInfo,\n+    CompletionModelFunction,\n+    ModelProviderConfiguration,\n+    ModelProviderCredentials,\n+    ModelProviderName,\n+    ModelProviderSettings,\n+    ModelTokenizer,\n+)\n+\n+\n+class LlamafileModelName(str, enum.Enum):\n+    MISTRAL_7B_INSTRUCT = \"mistral-7b-instruct-v0.2\"\n+\n+\n+LLAMAFILE_CHAT_MODELS = {\n+    info.name: info\n+    for info in [\n+        ChatModelInfo(\n+            name=LlamafileModelName.MISTRAL_7B_INSTRUCT,\n+            provider_name=ModelProviderName.LLAMAFILE,\n+            prompt_token_cost=0.0,\n+            completion_token_cost=0.0,\n+            max_tokens=32768,\n+            has_function_call_api=False,\n+        ),\n+    ]\n+}\n+\n+LLAMAFILE_EMBEDDING_MODELS = {}\n+\n+\n+class LlamafileConfiguration(ModelProviderConfiguration):\n+    # TODO: implement 'seed' across forge.llm.providers\n+    seed: Optional[int] = None\n+\n+\n+class LlamafileCredentials(ModelProviderCredentials):\n+    api_key: Optional[SecretStr] = SecretStr(\"sk-no-key-required\")\n+    api_base: SecretStr = UserConfigurable(  # type: ignore\n+        default=SecretStr(\"http://localhost:8080/v1\"), from_env=\"LLAMAFILE_API_BASE\"\n+    )\n+\n+    def get_api_access_kwargs(self) -> dict[str, str]:\n+        return {\n+            k: v.get_secret_value()\n+            for k, v in {\n+                \"api_key\": self.api_key,\n+                \"base_url\": self.api_base,\n+            }.items()\n+            if v is not None\n+        }\n+\n+\n+class LlamafileSettings(ModelProviderSettings):\n+    configuration: LlamafileConfiguration  # type: ignore\n+    credentials: Optional[LlamafileCredentials] = None  # type: ignore\n+\n+\n+class LlamafileTokenizer(ModelTokenizer[int]):\n+    def __init__(self, credentials: LlamafileCredentials):\n+        self._credentials = credentials\n+\n+    @property\n+    def _tokenizer_base_url(self):\n+        # The OpenAI-chat-compatible base url should look something like\n+        # 'http://localhost:8080/v1' but the tokenizer endpoint is\n+        # 'http://localhost:8080/tokenize'. So here we just strip off the '/v1'.\n+        api_base = self._credentials.api_base.get_secret_value()\n+        return api_base.strip(\"/v1\")\n+\n+    def encode(self, text: str) -> list[int]:\n+        response = requests.post(\n+            url=f\"{self._tokenizer_base_url}/tokenize\", json={\"content\": text}\n+        )\n+        response.raise_for_status()\n+        return response.json()[\"tokens\"]\n+\n+    def decode(self, tokens: list[int]) -> str:\n+        response = requests.post(\n+            url=f\"{self._tokenizer_base_url}/detokenize\", json={\"tokens\": tokens}\n+        )\n+        response.raise_for_status()\n+        return response.json()[\"content\"]\n+\n+\n+class LlamafileProvider(\n+    BaseOpenAIChatProvider[LlamafileModelName, LlamafileSettings],\n+    # TODO: add and test support for embedding models\n+    # BaseOpenAIEmbeddingProvider[LlamafileModelName, LlamafileSettings],\n+):\n+    EMBEDDING_MODELS = LLAMAFILE_EMBEDDING_MODELS\n+    CHAT_MODELS = LLAMAFILE_CHAT_MODELS\n+    MODELS = {**CHAT_MODELS, **EMBEDDING_MODELS}\n+\n+    default_settings = LlamafileSettings(\n+        name=\"llamafile_provider\",\n+        description=(\n+            \"Provides chat completion and embedding services \"\n+            \"through a llamafile instance\"\n+        ),\n+        configuration=LlamafileConfiguration(),\n+    )\n+\n+    _settings: LlamafileSettings\n+    _credentials: LlamafileCredentials\n+    _configuration: LlamafileConfiguration\n+\n+    async def get_available_models(self) -> Sequence[ChatModelInfo[LlamafileModelName]]:\n+        _models = (await self._client.models.list()).data\n+        # note: at the moment, llamafile only serves one model at a time (so this\n+        # list will only ever have one value). however, in the future, llamafile\n+        # may support multiple models, so leaving this method as-is for now.\n+        self._logger.debug(f\"Retrieved llamafile models: {_models}\")\n+\n+        clean_model_ids = [clean_model_name(m.id) for m in _models]\n+        self._logger.debug(f\"Cleaned llamafile model IDs: {clean_model_ids}\")\n+\n+        return [\n+            LLAMAFILE_CHAT_MODELS[id]\n+            for id in clean_model_ids\n+            if id in LLAMAFILE_CHAT_MODELS\n+        ]\n+\n+    def get_tokenizer(self, model_name: LlamafileModelName) -> LlamafileTokenizer:\n+        return LlamafileTokenizer(self._credentials)\n+\n+    def count_message_tokens(\n+        self,\n+        messages: ChatMessage | list[ChatMessage],\n+        model_name: LlamafileModelName,\n+    ) -> int:\n+        if isinstance(messages, ChatMessage):\n+            messages = [messages]\n+\n+        if model_name == LlamafileModelName.MISTRAL_7B_INSTRUCT:\n+            # For mistral-instruct, num added tokens depends on if the message\n+            # is a prompt/instruction or an assistant-generated message.\n+            # - prompt gets [INST], [/INST] added and the first instruction\n+            # begins with '<s>' ('beginning-of-sentence' token).\n+            # - assistant-generated messages get '</s>' added\n+            # see: https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.2\n+            #\n+            prompt_added = 1  # one for '<s>' token\n+            assistant_num_added = 0\n+            ntokens = 0\n+            for message in messages:\n+                if (\n+                    message.role == ChatMessage.Role.USER\n+                    # note that 'system' messages will get converted\n+                    # to 'user' messages before being sent to the model\n+                    or message.role == ChatMessage.Role.SYSTEM\n+                ):\n+                    # 5 tokens for [INST], [/INST], which actually get\n+                    # tokenized into \"[, INST, ]\" and \"[, /, INST, ]\"\n+                    # by the mistral tokenizer\n+                    prompt_added += 5\n+                elif message.role == ChatMessage.Role.ASSISTANT:\n+                    assistant_num_added += 1  # for </s>\n+                else:\n+                    raise ValueError(\n+                        f\"{model_name} does not support role: {message.role}\"\n+                    )\n+\n+                ntokens += self.count_tokens(message.content, model_name)\n+\n+            total_token_count = prompt_added + assistant_num_added + ntokens\n+            return total_token_count\n+\n+        else:\n+            raise NotImplementedError(\n+                f\"count_message_tokens not implemented for model {model_name}\"\n+            )\n+\n+    def _get_chat_completion_args(\n+        self,\n+        prompt_messages: list[ChatMessage],\n+        model: LlamafileModelName,\n+        functions: list[CompletionModelFunction] | None = None,\n+        max_output_tokens: int | None = None,\n+        **kwargs,\n+    ) -> tuple[\n+        list[ChatCompletionMessageParam], CompletionCreateParams, dict[str, Any]\n+    ]:\n+        messages, completion_kwargs, parse_kwargs = super()._get_chat_completion_args(\n+            prompt_messages, model, functions, max_output_tokens, **kwargs\n+        )\n+\n+        if model == LlamafileModelName.MISTRAL_7B_INSTRUCT:\n+            messages = self._adapt_chat_messages_for_mistral_instruct(messages)\n+\n+        if \"seed\" not in kwargs and self._configuration.seed is not None:\n+            completion_kwargs[\"seed\"] = self._configuration.seed\n+\n+        # Convert all messages with content blocks to simple text messages\n+        for message in messages:\n+            if isinstance(content := message.get(\"content\"), list):\n+                message[\"content\"] = \"\\n\\n\".join(\n+                    b[\"text\"]\n+                    for b in content\n+                    if b[\"type\"] == \"text\"\n+                    # FIXME: add support for images through image_data completion kwarg\n+                )\n+\n+        return messages, completion_kwargs, parse_kwargs\n+\n+    def _adapt_chat_messages_for_mistral_instruct(\n+        self, messages: list[ChatCompletionMessageParam]\n+    ) -> list[ChatCompletionMessageParam]:\n+        \"\"\"\n+        Munge the messages to be compatible with the mistral-7b-instruct chat\n+        template, which:\n+        - only supports 'user' and 'assistant' roles.\n+        - expects messages to alternate between user/assistant roles.\n+\n+        See details here:\n+        https://huggingface.co/mistralai/Mistral-7B-Instruct-v0.2#instruction-format\n+        \"\"\"\n+        adapted_messages: list[ChatCompletionMessageParam] = []\n+        for message in messages:\n+            # convert 'system' role to 'user' role as mistral-7b-instruct does\n+            # not support 'system'\n+            if message[\"role\"] == ChatMessage.Role.SYSTEM:\n+                message[\"role\"] = ChatMessage.Role.USER\n+\n+            if (\n+                len(adapted_messages) == 0\n+                or message[\"role\"] != (last_message := adapted_messages[-1])[\"role\"]\n+            ):\n+                adapted_messages.append(message)\n+            else:\n+                if not message.get(\"content\"):\n+                    continue\n+\n+                # if the curr message has the same role as the previous one,\n+                # concat the current message content to the prev message\n+                if message[\"role\"] == \"user\" and last_message[\"role\"] == \"user\":\n+                    # user messages can contain other types of content blocks\n+                    if not isinstance(last_message[\"content\"], list):\n+                        last_message[\"content\"] = [\n+                            {\"type\": \"text\", \"text\": last_message[\"content\"]}\n+                        ]\n+\n+                    last_message[\"content\"].extend(\n+                        message[\"content\"]\n+                        if isinstance(message[\"content\"], list)\n+                        else [{\"type\": \"text\", \"text\": message[\"content\"]}]\n+                    )\n+                elif message[\"role\"] != \"user\" and last_message[\"role\"] != \"user\":\n+                    last_message[\"content\"] = (\n+                        (last_message.get(\"content\") or \"\")\n+                        + \"\\n\\n\"\n+                        + (message.get(\"content\") or \"\")\n+                    ).strip()\n+\n+        return adapted_messages\n+\n+    def _parse_assistant_tool_calls(\n+        self,\n+        assistant_message: ChatCompletionMessage,\n+        compat_mode: bool = False,\n+        **kwargs,\n+    ):\n+        tool_calls: list[AssistantToolCall] = []\n+        parse_errors: list[Exception] = []\n+\n+        if compat_mode and assistant_message.content:\n+            try:\n+                tool_calls = list(\n+                    _tool_calls_compat_extract_calls(assistant_message.content)\n+                )\n+            except Exception as e:\n+                parse_errors.append(e)\n+\n+        return tool_calls, parse_errors\n+\n+\n+def clean_model_name(model_file: str) -> str:\n+    \"\"\"\n+    Clean up model names:\n+    1. Remove file extension\n+    2. Remove quantization info\n+\n+    Examples:\n+    ```\n+    raw:   'mistral-7b-instruct-v0.2.Q5_K_M.gguf'\n+    clean: 'mistral-7b-instruct-v0.2'\n+\n+    raw: '/Users/kate/models/mistral-7b-instruct-v0.2.Q5_K_M.gguf'\n+    clean:                  'mistral-7b-instruct-v0.2'\n+\n+    raw:   'llava-v1.5-7b-q4.gguf'\n+    clean: 'llava-v1.5-7b'\n+    ```\n+    \"\"\"\n+    name_without_ext = Path(model_file).name.rsplit(\".\", 1)[0]\n+    name_without_Q = re.match(\n+        r\"^[a-zA-Z0-9]+([.\\-](?!([qQ]|B?F)\\d{1,2})[a-zA-Z0-9]+)*\",\n+        name_without_ext,\n+    )\n+    return name_without_Q.group() if name_without_Q else name_without_ext\n+\n+\n+def _tool_calls_compat_extract_calls(response: str) -> Iterator[AssistantToolCall]:\n+    import re\n+    import uuid\n+\n+    logging.debug(f\"Trying to extract tool calls from response:\\n{response}\")\n+\n+    response = response.strip()  # strip off any leading/trailing whitespace\n+    if response.startswith(\"```\"):\n+        # attempt to remove any extraneous markdown artifacts like \"```json\"\n+        response = response.strip(\"```\")\n+        if response.startswith(\"json\"):\n+            response = response.strip(\"json\")\n+        response = response.strip()  # any remaining whitespace\n+\n+    if response[0] == \"[\":\n+        tool_calls: list[AssistantToolCallDict] = json_loads(response)\n+    else:\n+        block = re.search(r\"```(?:tool_calls)?\\n(.*)\\n```\\s*$\", response, re.DOTALL)\n+        if not block:\n+            raise ValueError(\"Could not find tool_calls block in response\")\n+        tool_calls: list[AssistantToolCallDict] = json_loads(block.group(1))\n+\n+    for t in tool_calls:\n+        t[\"id\"] = str(uuid.uuid4())\n+        # t[\"function\"][\"arguments\"] = str(t[\"function\"][\"arguments\"])  # HACK\n+\n+        yield AssistantToolCall.parse_obj(t)\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR introduces significant changes, including new model provider integrations and configuration adjustments. However, it lacks relevant tests, which raises concerns about potential issues. Notably, the `check_model_llamafile` method could expose sensitive information, and the hard-coded `seed` in `_create_chat_completion` limits model variability. I recommend masking sensitive data in error messages and making the seed configurable to enhance security and flexibility. Ensuring comprehensive testing and refining error messaging are also crucial for mitigating user confusion and potential errors."
      }
    ],
    "token_estimation": 5757.25
  },
  {
    "index": 6,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/scripts/json_parser.py b/scripts/json_parser.py\nnew file mode 100644\nindex 000000000000..8154b584a12e\n--- /dev/null\n+++ b/scripts/json_parser.py\n@@ -0,0 +1,77 @@\n+import dirtyjson\n+from call_ai_function import call_ai_function\n+from config import Config\n+cfg = Config()\n+\n+def fix_and_parse_json(json_str: str, try_to_fix_with_gpt: bool = True):\n+    json_schema = \"\"\"\n+    {\n+    \"command\": {\n+        \"name\": \"command name\",\n+        \"args\":{\n+            \"arg name\": \"value\"\n+        }\n+    },\n+    \"thoughts\":\n+    {\n+        \"text\": \"thought\",\n+        \"reasoning\": \"reasoning\",\n+        \"plan\": \"- short bulleted\\n- list that conveys\\n- long-term plan\",\n+        \"criticism\": \"constructive self-criticism\",\n+        \"speak\": \"thoughts summary to say to user\"\n+    }\n+    }\n+    \"\"\"\n+\n+    try:\n+        return dirtyjson.loads(json_str)\n+    except Exception as e:\n+        # Let's do something manually - sometimes GPT responds with something BEFORE the braces:\n+        # \"I'm sorry, I don't understand. Please try again.\"{\"text\": \"I'm sorry, I don't understand. Please try again.\", \"confidence\": 0.0}\n+        # So let's try to find the first brace and then parse the rest of the string\n+        try:\n+          brace_index = json_str.index(\"{\")\n+          json_str = json_str[brace_index:]\n+          last_brace_index = json_str.rindex(\"}\")\n+          json_str = json_str[:last_brace_index+1]\n+          return dirtyjson.loads(json_str)\n+        except Exception as e:\n+          if try_to_fix_with_gpt:\n+            print(f\"Warning: Failed to parse AI output, attempting to fix.\\n If you see this warning frequently, it's likely that your prompt is confusing the AI. Try changing it up slightly.\")\n+            # Now try to fix this up using the ai_functions\n+            ai_fixed_json = fix_json(json_str, json_schema, False)\n+            if ai_fixed_json != \"failed\":\n+              return dirtyjson.loads(ai_fixed_json)\n+            else:\n+              print(f\"Failed to fix ai output, telling the AI.\") # This allows the AI to react to the error message, which usually results in it correcting its ways.\n+              return json_str\n+          else:\n+            raise e\n+        \n+# TODO: Make debug a global config var\n+def fix_json(json_str: str, schema: str, debug=False) -> str:\n+    # Try to fix the JSON using gpt:\n+    function_string = \"def fix_json(json_str: str, schema:str=None) -> str:\"\n+    args = [json_str, schema]\n+    description_string = \"\"\"Fixes the provided JSON string to make it parseable and fully complient with the provided schema.\\n If an object or field specifed in the schema isn't contained within the correct JSON, it is ommited.\\n This function is brilliant at guessing when the format is incorrect.\"\"\"\n+\n+    # If it doesn't already start with a \"`\", add one:\n+    if not json_str.startswith(\"`\"):\n+      json_str = \"```json\\n\" + json_str + \"\\n```\"\n+    result_string = call_ai_function(\n+        function_string, args, description_string, model=cfg.fast_llm_model\n+    )\n+    if debug:\n+        print(\"------------ JSON FIX ATTEMPT ---------------\")\n+        print(f\"Original JSON: {json_str}\")\n+        print(\"-----------\")\n+        print(f\"Fixed JSON: {result_string}\")\n+        print(\"----------- END OF FIX ATTEMPT ----------------\")\n+    try:\n+        return dirtyjson.loads(result_string)\n+    except:\n+        # Get the call stack:\n+        # import traceback\n+        # call_stack = traceback.format_exc()\n+        # print(f\"Failed to fix JSON: '{json_str}' \"+call_stack)\n+        return \"failed\"\ndiff --git a/scripts/main.py b/scripts/main.py\nindex e80bf5d08a14..48093cf458e1 100644\n--- a/scripts/main.py\n+++ b/scripts/main.py\n@@ -103,11 +110,93 @@ def print_assistant_thoughts(assistant_reply):\n         print_to_console(\"Error: Invalid JSON\\n\", Fore.RED, assistant_reply)\n     # All other errors, return \"Error: + error message\"\n     except Exception as e:\n-        print_to_console(\"Error: \\n\", Fore.RED, str(e))\n+        call_stack = traceback.format_exc()\n+        print_to_console(\"Error: \\n\", Fore.RED, call_stack)\n+\n+def load_variables(config_file=\"config.yaml\"):\n+    # Load variables from yaml file if it exists\n+    try:\n+        with open(config_file) as file:\n+            config = yaml.load(file, Loader=yaml.FullLoader)\n+        ai_name = config.get(\"ai_name\")\n+        ai_role = config.get(\"ai_role\")\n+        ai_goals = config.get(\"ai_goals\")\n+    except FileNotFoundError:\n+        ai_name = \"\"\n+        ai_role = \"\"\n+        ai_goals = []\n+\n+    # Prompt the user for input if config file is missing or empty values\n+    if not ai_name:\n+        ai_name = input(\"Name your AI: \")\n+        if ai_name == \"\":\n+            ai_name = \"Entrepreneur-GPT\"\n+\n+    if not ai_role:        \n+        ai_role = input(f\"{ai_name} is: \")\n+        if ai_role == \"\":\n+            ai_role = \"an AI designed to autonomously develop and run businesses with the sole goal of increasing your net worth.\"\n+\n+    if not ai_goals:\n+        print(\"Enter up to 5 goals for your AI: \")\n+        print(\"For example: \\nIncrease net worth, Grow Twitter Account, Develop and manage multiple businesses autonomously'\")\n+        print(\"Enter nothing to load defaults, enter nothing when finished.\")\n+        ai_goals = []\n+        for i in range(5):\n+            ai_goal = input(f\"Goal {i+1}: \")\n+            if ai_goal == \"\":\n+                break\n+            ai_goals.append(ai_goal)\n+        if len(ai_goals) == 0:\n+            ai_goals = [\"Increase net worth\", \"Grow Twitter Account\", \"Develop and manage multiple businesses autonomously\"]\n+         \n+    # Save variables to yaml file\n+    config = {\"ai_name\": ai_name, \"ai_role\": ai_role, \"ai_goals\": ai_goals}\n+    with open(config_file, \"w\") as file:\n+        documents = yaml.dump(config, file)\n+\n+    prompt = data.load_prompt()\n+    prompt_start = \"\"\"Your decisions must always be made independently without seeking user assistance. Play to your strengths as an LLM and pursue simple strategies with no legal complications.\"\"\"\n+\n+    # Construct full prompt\n+    full_prompt = f\"You are {ai_name}, {ai_role}\\n{prompt_start}\\n\\nGOALS:\\n\\n\"\n+    for i, goal in enumerate(ai_goals):\n+        full_prompt += f\"{i+1}. {goal}\\n\"\n+\n+    full_prompt += f\"\\n\\n{prompt}\"\n+    return full_prompt\n \n \n def construct_prompt():\n+    config = AIConfig.load()\n+    if config.ai_name:\n+        print_to_console(\n+            f\"Welcome back! \",\n+            Fore.GREEN,\n+            f\"Would you like me to return to being {config.ai_name}?\",\n+            speak_text=True)\n+        should_continue = input(f\"\"\"Continue with the last settings? \n+Name:  {config.ai_name}\n+Role:  {config.ai_role}\n+Goals: {config.ai_goals}  \n+Continue (y/n): \"\"\")\n+        if should_continue.lower() == \"n\":\n+            config = AIConfig()\n+\n+    if not config.ai_name:         \n+        config = prompt_user()\n+        config.save()\n+\n+    # Get rid of this global:\n     global ai_name\n+    ai_name = config.ai_name\n+    \n+    full_prompt = config.construct_full_prompt()\n+    return full_prompt\n+\n+\n+def prompt_user():\n+    ai_name = \"\"\n     # Construct the prompt\n     print_to_console(\n         \"Welcome to Auto-GPT! \",\n\ndiff --git a/scripts/token_counter.py b/scripts/token_counter.py\nnew file mode 100644\nindex 000000000000..a28a9868ed8e\n--- /dev/null\n+++ b/scripts/token_counter.py\n@@ -0,0 +1,57 @@\n+import tiktoken\n+from typing import List, Dict\n+\n+def count_message_tokens(messages : List[Dict[str, str]], model : str = \"gpt-3.5-turbo-0301\") -> int:\n+    \"\"\"\n+    Returns the number of tokens used by a list of messages.\n+\n+    Args:\n+    messages (list): A list of messages, each of which is a dictionary containing the role and content of the message.\n+    model (str): The name of the model to use for tokenization. Defaults to \"gpt-3.5-turbo-0301\".\n+\n+    Returns:\n+    int: The number of tokens used by the list of messages.\n+    \"\"\"\n+    try:\n+        encoding = tiktoken.encoding_for_model(model)\n+    except KeyError:\n+        print(\"Warning: model not found. Using cl100k_base encoding.\")\n+        encoding = tiktoken.get_encoding(\"cl100k_base\")\n+    if model == \"gpt-3.5-turbo\":\n+        # !Node: gpt-3.5-turbo may change over time. Returning num tokens assuming gpt-3.5-turbo-0301.\")\n+        return count_message_tokens(messages, model=\"gpt-3.5-turbo-0301\")\n+    elif model == \"gpt-4\":\n+        # !Note: gpt-4 may change over time. Returning num tokens assuming gpt-4-0314.\")\n+        return count_message_tokens(messages, model=\"gpt-4-0314\")\n+    elif model == \"gpt-3.5-turbo-0301\":\n+        tokens_per_message = 4  # every message follows <|start|>{role/name}\\n{content}<|end|>\\n\n+        tokens_per_name = -1  # if there's a name, the role is omitted\n+    elif model == \"gpt-4-0314\":\n+        tokens_per_message = 3\n+        tokens_per_name = 1\n+    else:\n+        raise NotImplementedError(f\"\"\"num_tokens_from_messages() is not implemented for model {model}. See https://github.com/openai/openai-python/blob/main/chatml.md for information on how messages are converted to tokens.\"\"\")\n+    num_tokens = 0\n+    for message in messages:\n+        num_tokens += tokens_per_message\n+        for key, value in message.items():\n+            num_tokens += len(encoding.encode(value))\n+            if key == \"name\":\n+                num_tokens += tokens_per_name\n+    num_tokens += 3  # every reply is primed with <|start|>assistant<|message|>\n+    return num_tokens\n+\n+def count_string_tokens(string: str, model_name: str) -> int:\n+    \"\"\"\n+    Returns the number of tokens in a text string.\n+\n+    Args:\n+    string (str): The text string.\n+    model_name (str): The name of the encoding to use. (e.g., \"gpt-3.5-turbo\")\n+\n+    Returns:\n+    int: The number of tokens in the text string.\n+    \"\"\"\n+    encoding = tiktoken.encoding_for_model(model_name)\n+    num_tokens = len(encoding.encode(string))\n+    return num_tokens\ndiff --git a/tests/json_tests.py b/tests/json_tests.py\nnew file mode 100644\nindex 000000000000..459da610b872\n--- /dev/null\n+++ b/tests/json_tests.py\n@@ -0,0 +1,115 @@\n+import unittest\n+import os\n+import sys\n+# Probably a better way:\n+sys.path.append(os.path.abspath('../scripts'))\n+from json_parser import fix_and_parse_json\n+\n+class TestParseJson(unittest.TestCase):\n+    def test_valid_json(self):\n+        # Test that a valid JSON string is parsed correctly\n+        json_str = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}'\n+        obj = fix_and_parse_json(json_str)\n+        self.assertEqual(obj, {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"})\n+    \n+    def test_invalid_json_minor(self):\n+        # Test that an invalid JSON string can be fixed with gpt\n+        json_str = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\",}'\n+        self.assertEqual(fix_and_parse_json(json_str, try_to_fix_with_gpt=False), {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"})\n+    \n+    def test_invalid_json_major_with_gpt(self):\n+        # Test that an invalid JSON string raises an error when try_to_fix_with_gpt is False\n+        json_str = 'BEGIN: \"name\": \"John\" - \"age\": 30 - \"city\": \"New York\" :END'\n+        self.assertEqual(fix_and_parse_json(json_str, try_to_fix_with_gpt=True), {\"name\": \"John\", \"age\": 30, \"city\": \"New York\"})\n+\n+    def test_invalid_json_major_without_gpt(self):\n+        # Test that a REALLY invalid JSON string raises an error when try_to_fix_with_gpt is False\n+        json_str = 'BEGIN: \"name\": \"John\" - \"age\": 30 - \"city\": \"New York\" :END'\n+        # Assert that this raises an exception:\n+        with self.assertRaises(Exception):\n+            fix_and_parse_json(json_str, try_to_fix_with_gpt=False)\n+\n+    def test_invalid_json_leading_sentence_with_gpt(self):\n+        # Test that a REALLY invalid JSON string raises an error when try_to_fix_with_gpt is False\n+        json_str = \"\"\"I suggest we start by browsing the repository to find any issues that we can fix.\n+\n+{\n+    \"command\": {\n+        \"name\": \"browse_website\",\n+        \"args\":{\n+            \"url\": \"https://github.com/Torantulino/Auto-GPT\"\n+        }\n+    },\n+    \"thoughts\":\n+    {\n+        \"text\": \"I suggest we start browsing the repository to find any issues that we can fix.\",\n+        \"reasoning\": \"Browsing the repository will give us an idea of the current state of the codebase and identify any issues that we can address to improve the repo.\",\n+        \"plan\": \"- Look through the repository to find any issues.\\n- Investigate any issues to determine what needs to be fixed\\n- Identify possible solutions to fix the issues\\n- Open Pull Requests with fixes\",\n+        \"criticism\": \"I should be careful while browsing so as not to accidentally introduce any new bugs or issues.\",\n+        \"speak\": \"I will start browsing the repository to find any issues we can fix.\"\n+    }\n+}\"\"\"\n+        good_obj = {\n+          \"command\": {\n+              \"name\": \"browse_website\",\n+              \"args\":{\n+                  \"url\": \"https://github.com/Torantulino/Auto-GPT\"\n+              }\n+          },\n+          \"thoughts\":\n+          {\n+              \"text\": \"I suggest we start browsing the repository to find any issues that we can fix.\",\n+              \"reasoning\": \"Browsing the repository will give us an idea of the current state of the codebase and identify any issues that we can address to improve the repo.\",\n+              \"plan\": \"- Look through the repository to find any issues.\\n- Investigate any issues to determine what needs to be fixed\\n- Identify possible solutions to fix the issues\\n- Open Pull Requests with fixes\",\n+              \"criticism\": \"I should be careful while browsing so as not to accidentally introduce any new bugs or issues.\",\n+              \"speak\": \"I will start browsing the repository to find any issues we can fix.\"\n+          }\n+      }\n+        # Assert that this raises an exception:\n+        self.assertEqual(fix_and_parse_json(json_str, try_to_fix_with_gpt=False), good_obj)\n+\n+\n+\n+    def test_invalid_json_leading_sentence_with_gpt(self):\n+        # Test that a REALLY invalid JSON string raises an error when try_to_fix_with_gpt is False\n+        json_str = \"\"\"I will first need to browse the repository (https://github.com/Torantulino/Auto-GPT) and identify any potential bugs that need fixing. I will use the \"browse_website\" command for this.\n+\n+{\n+    \"command\": {\n+        \"name\": \"browse_website\",\n+        \"args\":{\n+            \"url\": \"https://github.com/Torantulino/Auto-GPT\"\n+        }\n+    },\n+    \"thoughts\":\n+    {\n+        \"text\": \"Browsing the repository to identify potential bugs\",\n+        \"reasoning\": \"Before fixing bugs, I need to identify what needs fixing. I will use the 'browse_website' command to analyze the repository.\",\n+        \"plan\": \"- Analyze the repository for potential bugs and areas of improvement\",\n+        \"criticism\": \"I need to ensure I am thorough and pay attention to detail while browsing the repository.\",\n+        \"speak\": \"I am browsing the repository to identify potential bugs.\"\n+    }\n+}\"\"\"\n+        good_obj = {\n+    \"command\": {\n+        \"name\": \"browse_website\",\n+        \"args\":{\n+            \"url\": \"https://github.com/Torantulino/Auto-GPT\"\n+        }\n+    },\n+    \"thoughts\":\n+    {\n+        \"text\": \"Browsing the repository to identify potential bugs\",\n+        \"reasoning\": \"Before fixing bugs, I need to identify what needs fixing. I will use the 'browse_website' command to analyze the repository.\",\n+        \"plan\": \"- Analyze the repository for potential bugs and areas of improvement\",\n+        \"criticism\": \"I need to ensure I am thorough and pay attention to detail while browsing the repository.\",\n+        \"speak\": \"I am browsing the repository to identify potential bugs.\"\n+    }\n+}\n+        # Assert that this raises an exception:\n+        self.assertEqual(fix_and_parse_json(json_str, try_to_fix_with_gpt=False), good_obj)\n+\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR highlights several key issues. First, the `playsound` library still relies on Python 2; consider transitioning to `PyObjC` for better efficiency. There’s an unhandled `AttributeError` regarding `smart_llm_model` in the `Config` object, suggesting incomplete initialization. The `yaml` module was missing but resolved by installing `PyYAML`, which should have been in `requirements.txt`. Lastly, a suggestion to modify `load_prompt` to use absolute paths is solid, ensuring script compatibility regardless of the working directory. Streamlining context limits will also be crucial for performance."
      }
    ],
    "token_estimation": 4137.0
  },
  {
    "index": 7,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/autogpt_platform/backend/backend/server/v2/library/routes/agents.py b/autogpt_platform/backend/backend/server/v2/library/routes/agents.py\nindex 899a6f87d444..60f94f519bb7 100644\n--- a/autogpt_platform/backend/backend/server/v2/library/routes/agents.py\n+++ b/autogpt_platform/backend/backend/server/v2/library/routes/agents.py\n@@ -295,81 +289,3 @@ async def fork_library_agent(\n         library_agent_id=library_agent_id,\n         user_id=user_id,\n     )\n-\n-\n-class TriggeredPresetSetupParams(BaseModel):\n-    name: str\n-    description: str = \"\"\n-\n-    trigger_config: dict[str, Any]\n-    agent_credentials: dict[str, CredentialsMetaInput] = Field(default_factory=dict)\n-\n-\n-@router.post(\"/{library_agent_id}/setup-trigger\")\n-async def setup_trigger(\n-    library_agent_id: str = Path(..., description=\"ID of the library agent\"),\n-    params: TriggeredPresetSetupParams = Body(),\n-    user_id: str = Depends(autogpt_auth_lib.depends.get_user_id),\n-) -> library_model.LibraryAgentPreset:\n-    \"\"\"\n-    Sets up a webhook-triggered `LibraryAgentPreset` for a `LibraryAgent`.\n-    Returns the correspondingly created `LibraryAgentPreset` with `webhook_id` set.\n-    \"\"\"\n-    library_agent = await library_db.get_library_agent(\n-        id=library_agent_id, user_id=user_id\n-    )\n-    if not library_agent:\n-        raise HTTPException(\n-            status_code=status.HTTP_404_NOT_FOUND,\n-            detail=f\"Library agent #{library_agent_id} not found\",\n-        )\n-\n-    graph = await get_graph(\n-        library_agent.graph_id, version=library_agent.graph_version, user_id=user_id\n-    )\n-    if not graph:\n-        raise HTTPException(\n-            status.HTTP_410_GONE,\n-            f\"Graph #{library_agent.graph_id} not accessible (anymore)\",\n-        )\n-    if not (trigger_node := graph.webhook_input_node):\n-        raise HTTPException(\n-            status_code=status.HTTP_400_BAD_REQUEST,\n-            detail=f\"Graph #{library_agent.graph_id} does not have a webhook node\",\n-        )\n-\n-    trigger_config_with_credentials = {\n-        **params.trigger_config,\n-        **(\n-            make_node_credentials_input_map(graph, params.agent_credentials).get(\n-                trigger_node.id\n-            )\n-            or {}\n-        ),\n-    }\n-\n-    new_webhook, feedback = await setup_webhook_for_block(\n-        user_id=user_id,\n-        trigger_block=trigger_node.block,\n-        trigger_config=trigger_config_with_credentials,\n-    )\n-    if not new_webhook:\n-        raise HTTPException(\n-            status_code=status.HTTP_400_BAD_REQUEST,\n-            detail=f\"Could not set up webhook: {feedback}\",\n-        )\n-\n-    new_preset = await library_db.create_preset(\n-        user_id=user_id,\n-        preset=library_model.LibraryAgentPresetCreatable(\n-            graph_id=library_agent.graph_id,\n-            graph_version=library_agent.graph_version,\n-            name=params.name,\n-            description=params.description,\n-            inputs=trigger_config_with_credentials,\n-            credentials=params.agent_credentials,\n-            webhook_id=new_webhook.id,\n-            is_active=True,\n-        ),\n-    )\n-    return new_preset\ndiff --git a/autogpt_platform/backend/backend/server/v2/library/routes/presets.py b/autogpt_platform/backend/backend/server/v2/library/routes/presets.py\nindex 35bbb9f59124..4a64ec425ee0 100644\n--- a/autogpt_platform/backend/backend/server/v2/library/routes/presets.py\n+++ b/autogpt_platform/backend/backend/server/v2/library/routes/presets.py\n@@ -138,6 +138,66 @@ async def create_preset(\n         )\n \n \n+@router.post(\"/presets/setup-trigger\")\n+async def setup_trigger(\n+    params: models.TriggeredPresetSetupRequest = Body(),\n+    user_id: str = Depends(autogpt_auth_lib.depends.get_user_id),\n+) -> models.LibraryAgentPreset:\n+    \"\"\"\n+    Sets up a webhook-triggered `LibraryAgentPreset` for a `LibraryAgent`.\n+    Returns the correspondingly created `LibraryAgentPreset` with `webhook_id` set.\n+    \"\"\"\n+    graph = await get_graph(\n+        params.graph_id, version=params.graph_version, user_id=user_id\n+    )\n+    if not graph:\n+        raise HTTPException(\n+            status.HTTP_410_GONE,\n+            f\"Graph #{params.graph_id} not accessible (anymore)\",\n+        )\n+    if not (trigger_node := graph.webhook_input_node):\n+        raise HTTPException(\n+            status_code=status.HTTP_400_BAD_REQUEST,\n+            detail=f\"Graph #{params.graph_id} does not have a webhook node\",\n+        )\n+\n+    trigger_config_with_credentials = {\n+        **params.trigger_config,\n+        **(\n+            make_node_credentials_input_map(graph, params.agent_credentials).get(\n+                trigger_node.id\n+            )\n+            or {}\n+        ),\n+    }\n+\n+    new_webhook, feedback = await setup_webhook_for_block(\n+        user_id=user_id,\n+        trigger_block=trigger_node.block,\n+        trigger_config=trigger_config_with_credentials,\n+    )\n+    if not new_webhook:\n+        raise HTTPException(\n+            status_code=status.HTTP_400_BAD_REQUEST,\n+            detail=f\"Could not set up webhook: {feedback}\",\n+        )\n+\n+    new_preset = await db.create_preset(\n+        user_id=user_id,\n+        preset=models.LibraryAgentPresetCreatable(\n+            graph_id=params.graph_id,\n+            graph_version=params.graph_version,\n+            name=params.name,\n+            description=params.description,\n+            inputs=trigger_config_with_credentials,\n+            credentials=params.agent_credentials,\n+            webhook_id=new_webhook.id,\n+            is_active=True,\n+        ),\n+    )\n+    return new_preset\n+\n+\n @router.patch(\n     \"/presets/{preset_id}\",\n     summary=\"Update an existing preset\",\ndiff --git a/autogpt_platform/frontend/src/components/RunnerUIWrapper.tsx b/autogpt_platform/frontend/src/components/RunnerUIWrapper.tsx\nindex 37ead841481a..deae14d0d6e1 100644\n--- a/autogpt_platform/frontend/src/components/RunnerUIWrapper.tsx\n+++ b/autogpt_platform/frontend/src/components/RunnerUIWrapper.tsx\n@@ -1,215 +1,108 @@\n import React, {\n   useState,\n-  useCallback,\n   forwardRef,\n   useImperativeHandle,\n+  useMemo,\n } from \"react\";\n-import RunnerOutputUI, { BlockOutput } from \"./runner-ui/RunnerOutputUI\";\n-import RunnerInputUI from \"./runner-ui/RunnerInputUI\";\n import { Node } from \"@xyflow/react\";\n-import { filterBlocksByType } from \"@/lib/utils\";\n+import { CustomNodeData } from \"@/components/CustomNode\";\n+import { RunnerInputDialog } from \"@/components/runner-ui/RunnerInputUI\";\n import {\n-  BlockIOObjectSubSchema,\n-  BlockIORootSchema,\n   BlockUIType,\n+  CredentialsMetaInput,\n+  GraphMeta,\n } from \"@/lib/autogpt-server-api/types\";\n-import { CustomNode } from \"./CustomNode\";\n-\n-interface HardcodedValues {\n-  name: any;\n-  description: any;\n-  value: any;\n-  placeholder_values: any;\n-}\n-\n-export interface InputItem {\n-  id: string;\n-  type: \"input\";\n-  inputSchema: BlockIORootSchema;\n-  hardcodedValues: HardcodedValues;\n-}\n+import RunnerOutputUI, {\n+  OutputNodeInfo,\n+} from \"@/components/runner-ui/RunnerOutputUI\";\n \n interface RunnerUIWrapperProps {\n-  nodes: Node[];\n-  setNodes: React.Dispatch<React.SetStateAction<CustomNode[]>>;\n-  setIsScheduling: React.Dispatch<React.SetStateAction<boolean>>;\n-  isRunning: boolean;\n-  isScheduling: boolean;\n-  requestSaveAndRun: () => void;\n-  scheduleRunner: (\n+  graph: GraphMeta;\n+  nodes: Node<CustomNodeData>[];\n+  saveAndRun: (\n+    inputs: Record<string, any>,\n+    credentialsInputs: Record<string, CredentialsMetaInput>,\n+  ) => void;\n+  createRunSchedule: (\n     cronExpression: string,\n-    input: InputItem[],\n     scheduleName: string,\n+    inputs: Record<string, any>,\n+    credentialsInputs: Record<string, CredentialsMetaInput>,\n   ) => Promise<void>;\n }\n \n export interface RunnerUIWrapperRef {\n-  openRunnerInput: () => void;\n+  openRunInputDialog: () => void;\n   openRunnerOutput: () => void;\n   runOrOpenInput: () => void;\n-  collectInputsForScheduling: (\n-    cronExpression: string,\n-    scheduleName: string,\n-  ) => void;\n }\n \n const RunnerUIWrapper = forwardRef<RunnerUIWrapperRef, RunnerUIWrapperProps>(\n-  (\n-    {\n-      nodes,\n-      setIsScheduling,\n-      setNodes,\n-      isScheduling,\n-      isRunning,\n-      requestSaveAndRun,\n-      scheduleRunner,\n-    },\n-    ref,\n-  ) => {\n-    const [isRunnerInputOpen, setIsRunnerInputOpen] = useState(false);\n+  ({ graph, nodes, saveAndRun, createRunSchedule }, ref) => {\n+    const [isRunInputDialogOpen, setIsRunInputDialogOpen] = useState(false);\n     const [isRunnerOutputOpen, setIsRunnerOutputOpen] = useState(false);\n-    const [scheduledInput, setScheduledInput] = useState(false);\n-    const [cronExpression, setCronExpression] = useState(\"\");\n-    const [scheduleName, setScheduleName] = useState(\"\");\n \n-    const getBlockInputsAndOutputs = useCallback((): {\n-      inputs: InputItem[];\n-      outputs: BlockOutput[];\n-    } => {\n-      const inputBlocks = filterBlocksByType(\n-        nodes,\n-        (node) => node.data.uiType === BlockUIType.INPUT,\n-      );\n+    const graphInputs = graph.input_schema.properties;\n \n-      const outputBlocks = filterBlocksByType(\n-        nodes,\n+    const graphOutputs = useMemo((): OutputNodeInfo[] => {\n+      const outputNodes = nodes.filter(\n         (node) => node.data.uiType === BlockUIType.OUTPUT,\n       );\n \n-      const inputs = inputBlocks.map(\n-        (node) =>\n-          ({\n-            id: node.id,\n-            type: \"input\" as const,\n-            inputSchema: (node.data.inputSchema as BlockIOObjectSubSchema)\n-              .properties.value as BlockIORootSchema,\n-            hardcodedValues: {\n-              name: (node.data.hardcodedValues as any).name || \"\",\n-              description: (node.data.hardcodedValues as any).description || \"\",\n-              value: (node.data.hardcodedValues as any).value,\n-              placeholder_values:\n-                (node.data.hardcodedValues as any).placeholder_values || [],\n-            },\n-          }) satisfies InputItem,\n-      );\n-\n-      const outputs = outputBlocks.map(\n+      return outputNodes.map(\n         (node) =>\n           ({\n             metadata: {\n-              name: (node.data.hardcodedValues as any).name || \"Output\",\n+              name: node.data.hardcodedValues.name || \"Output\",\n               description:\n-                (node.data.hardcodedValues as any).description ||\n+                node.data.hardcodedValues.description ||\n                 \"Output from the agent\",\n             },\n             result:\n               (node.data.executionResults as any)\n                 ?.map((result: any) => result?.data?.output)\n                 .join(\"\\n--\\n\") || \"No output yet\",\n-          }) satisfies BlockOutput,\n+          }) satisfies OutputNodeInfo,\n       );\n-\n-      return { inputs, outputs };\n     }, [nodes]);\n \n-    const handleInputChange = useCallback(\n-      (nodeId: string, field: string, value: any) => {\n-        setNodes((nds) =>\n-          nds.map((node) => {\n-            if (node.id === nodeId) {\n-              return {\n-                ...node,\n-                data: {\n-                  ...node.data,\n-                  hardcodedValues: {\n-                    ...(node.data.hardcodedValues as any),\n-                    [field]: value,\n-                  },\n-                },\n-              };\n-            }\n-            return node;\n-          }),\n-        );\n-      },\n-      [setNodes],\n-    );\n-\n-    const openRunnerInput = () => setIsRunnerInputOpen(true);\n+    const openRunInputDialog = () => setIsRunInputDialogOpen(true);\n     const openRunnerOutput = () => setIsRunnerOutputOpen(true);\n \n     const runOrOpenInput = () => {\n-      const { inputs } = getBlockInputsAndOutputs();\n-      if (inputs.length > 0) {\n-        openRunnerInput();\n+      if (\n+        Object.keys(graphInputs).length > 0 ||\n+        Object.keys(graph.credentials_input_schema.properties).length > 0\n+      ) {\n+        openRunInputDialog();\n       } else {\n-        requestSaveAndRun();\n+        saveAndRun({}, {});\n       }\n     };\n \n-    const collectInputsForScheduling = (\n-      cronExpression: string,\n-      scheduleName: string,\n-    ) => {\n-      const { inputs } = getBlockInputsAndOutputs();\n-      setCronExpression(cronExpression);\n-      setScheduleName(scheduleName);\n-\n-      if (inputs.length > 0) {\n-        setScheduledInput(true);\n-        setIsRunnerInputOpen(true);\n-      } else {\n-        scheduleRunner(cronExpression, [], scheduleName);\n-      }\n-    };\n-\n-    useImperativeHandle(ref, () => ({\n-      openRunnerInput,\n-      openRunnerOutput,\n-      runOrOpenInput,\n-      collectInputsForScheduling,\n-    }));\n+    useImperativeHandle(\n+      ref,\n+      () =>\n+        ({\n+          openRunInputDialog,\n+          openRunnerOutput,\n+          runOrOpenInput,\n+        }) satisfies RunnerUIWrapperRef,\n+    );\n \n     return (\n       <>\n-        <RunnerInputUI\n-          isOpen={isRunnerInputOpen}\n-          onClose={() => setIsRunnerInputOpen(false)}\n-          blockInputs={getBlockInputsAndOutputs().inputs}\n-          onInputChange={handleInputChange}\n-          onRun={() => {\n-            setIsRunnerInputOpen(false);\n-            requestSaveAndRun();\n-          }}\n-          scheduledInput={scheduledInput}\n-          isScheduling={isScheduling}\n-          onSchedule={async () => {\n-            setIsScheduling(true);\n-            await scheduleRunner(\n-              cronExpression,\n-              getBlockInputsAndOutputs().inputs,\n-              scheduleName,\n-            );\n-            setIsScheduling(false);\n-            setIsRunnerInputOpen(false);\n-            setScheduledInput(false);\n-          }}\n-          isRunning={isRunning}\n+        <RunnerInputDialog\n+          isOpen={isRunInputDialogOpen}\n+          doClose={() => setIsRunInputDialogOpen(false)}\n+          graph={graph}\n+          doRun={saveAndRun}\n+          doCreateSchedule={createRunSchedule}\n         />\n         <RunnerOutputUI\n           isOpen={isRunnerOutputOpen}\n-          onClose={() => setIsRunnerOutputOpen(false)}\n-          blockOutputs={getBlockInputsAndOutputs().outputs}\n+          doClose={() => setIsRunnerOutputOpen(false)}\n+          outputs={graphOutputs}\n         />\n       </>\n     );\ndiff --git a/autogpt_platform/frontend/src/components/edit/control/BlocksControl.tsx b/autogpt_platform/frontend/src/components/edit/control/BlocksControl.tsx\nindex dacc896ec661..e5c3a3315fc7 100644\n--- a/autogpt_platform/frontend/src/components/edit/control/BlocksControl.tsx\n+++ b/autogpt_platform/frontend/src/components/edit/control/BlocksControl.tsx\n@@ -336,4 +327,57 @@ export const BlocksControl: React.FC<BlocksControlProps> = ({\n       </PopoverContent>\n     </Popover>\n   );\n-};\n+}\n+\n+/**\n+ * Evaluates how well a block matches the search query and returns a relevance score.\n+ * The scoring algorithm works as follows:\n+ * - Returns 1 if no query (all blocks match equally)\n+ * - Normalized query for case-insensitive matching\n+ * - Returns 3 for exact substring matches in block name (highest priority)\n+ * - Returns 2 when all query words appear in the block name (regardless of order)\n+ * - Returns 1.X for blocks with names similar to query using Jaro-Winkler distance (X is similarity score)\n+ * - Returns 0.5 when all query words appear in the block description (lowest priority)\n+ * - Returns 0 for no match\n+ *\n+ * Higher scores will appear first in search results.\n+ */\n+function blockScoreForQuery(block: _Block, query: string): number {\n+  if (!query) return 1;\n+  const normalizedQuery = query.toLowerCase().trim();\n+  const queryWords = normalizedQuery.split(/\\s+/);\n+\n+  // Use cached values for performance\n+  const { blockName, beautifiedName, description } = block._cached!;\n+\n+  // 1. Exact match in name (highest priority)\n+  if (\n+    blockName.includes(normalizedQuery) ||\n+    beautifiedName.includes(normalizedQuery)\n+  ) {\n+    return 3;\n+  }\n+\n+  // 2. All query words in name (regardless of order)\n+  const allWordsInName = queryWords.every(\n+    (word) => blockName.includes(word) || beautifiedName.includes(word),\n+  );\n+  if (allWordsInName) return 2;\n+\n+  // 3. Similarity with name (Jaro-Winkler)\n+  const similarityThreshold = 0.65;\n+  const nameSimilarity = jaro(blockName, normalizedQuery);\n+  const beautifiedSimilarity = jaro(beautifiedName, normalizedQuery);\n+  const maxSimilarity = Math.max(nameSimilarity, beautifiedSimilarity);\n+  if (maxSimilarity > similarityThreshold) {\n+    return 1 + maxSimilarity; // Score between 1 and 2\n+  }\n+\n+  // 4. All query words in description (lower priority)\n+  const allWordsInDescription = queryWords.every((word) =>\n+    description.includes(word),\n+  );\n+  if (allWordsInDescription) return 0.5;\n+\n+  return 0;\n+}\ndiff --git a/autogpt_platform/frontend/src/components/monitor/FlowInfo.tsx b/autogpt_platform/frontend/src/components/monitor/FlowInfo.tsx\nindex fb9aae5d8cf9..8dd4b2d14c34 100644\n--- a/autogpt_platform/frontend/src/components/monitor/FlowInfo.tsx\n+++ b/autogpt_platform/frontend/src/components/monitor/FlowInfo.tsx\n@@ -62,90 +64,30 @@ export const FlowInfo: React.FC<\n       (selectedVersion == \"all\" ? flow.graph_version : selectedVersion),\n   );\n \n+  const hasInputs = Object.keys(flow.input_schema.properties).length > 0;\n+  const hasCredentialsInputs =\n+    Object.keys(flow.credentials_input_schema.properties).length > 0;\n+\n   const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);\n-  const [isRunnerInputOpen, setIsRunnerInputOpen] = useState(false);\n+  const [isRunDialogOpen, setIsRunDialogOpen] = useState(false);\n   const isDisabled = !selectedFlowVersion;\n \n-  const getBlockInputsAndOutputs = useCallback(() => {\n-    const inputBlocks = filterBlocksByType(\n-      nodes,\n-      (node) => node.data.uiType === BlockUIType.INPUT,\n-    );\n-\n-    const outputBlocks = filterBlocksByType(\n-      nodes,\n-      (node) => node.data.uiType === BlockUIType.OUTPUT,\n-    );\n-\n-    const inputs = inputBlocks.map((node) => ({\n-      id: node.id,\n-      type: \"input\" as const,\n-      inputSchema: node.data.inputSchema as BlockIORootSchema,\n-      hardcodedValues: {\n-        name: (node.data.hardcodedValues as any).name || \"\",\n-        description: (node.data.hardcodedValues as any).description || \"\",\n-        value: (node.data.hardcodedValues as any).value,\n-        placeholder_values:\n-          (node.data.hardcodedValues as any).placeholder_values || [],\n-      },\n-    }));\n-\n-    const outputs = outputBlocks.map((node) => ({\n-      id: node.id,\n-      type: \"output\" as const,\n-      hardcodedValues: {\n-        name: (node.data.hardcodedValues as any).name || \"Output\",\n-        description:\n-          (node.data.hardcodedValues as any).description ||\n-          \"Output from the agent\",\n-        value: (node.data.hardcodedValues as any).value,\n-      },\n-      result: (node.data.executionResults as any)?.at(-1)?.data?.output,\n-    }));\n-\n-    return { inputs, outputs };\n-  }, [nodes]);\n-\n   useEffect(() => {\n     api\n       .getGraphAllVersions(flow.graph_id)\n       .then((result) => setFlowVersions(result));\n   }, [flow.graph_id, api]);\n \n-  const openRunnerInput = () => setIsRunnerInputOpen(true);\n+  const openRunDialog = () => setIsRunDialogOpen(true);\n \n   const runOrOpenInput = () => {\n-    const { inputs } = getBlockInputsAndOutputs();\n-    if (inputs.length > 0) {\n-      openRunnerInput();\n+    if (hasInputs || hasCredentialsInputs) {\n+      openRunDialog();\n     } else {\n-      requestSaveAndRun();\n+      saveAndRun({}, {});\n     }\n   };\n \n-  const handleInputChange = useCallback(\n-    (nodeId: string, field: string, value: any) => {\n-      setNodes((nds) =>\n-        nds.map((node) => {\n-          if (node.id === nodeId) {\n-            return {\n-              ...node,\n-              data: {\n-                ...node.data,\n-                hardcodedValues: {\n-                  ...(node.data.hardcodedValues as any),\n-                  [field]: value,\n-                },\n-              },\n-            };\n-          }\n-          return node;\n-        }),\n-      );\n-    },\n-    [setNodes],\n-  );\n-\n   return (\n     <Card {...props}>\n       <CardHeader className=\"\">\n\ndiff --git a/autogpt_platform/frontend/src/hooks/useAgentGraph.tsx b/autogpt_platform/frontend/src/hooks/useAgentGraph.tsx\nindex f5ce1a8b62c7..43293c6db3f8 100644\n--- a/autogpt_platform/frontend/src/hooks/useAgentGraph.tsx\n+++ b/autogpt_platform/frontend/src/hooks/useAgentGraph.tsx\n@@ -456,234 +451,6 @@ export default function useAgentGraph(\n     });\n   }, [updateQueue, nodesSyncedWithSavedAgent, updateNodesWithExecutionData]);\n \n-  const validateNodes = useCallback((): string | null => {\n-    let errorMessage = null;\n-\n-    nodes.forEach((node) => {\n-      const validate = ajv.compile(node.data.inputSchema);\n-      const errors = {} as { [key: string]: string };\n-\n-      // Validate values against schema using AJV\n-      const inputData =\n-        node.data.uiType === BlockUIType.AGENT\n-          ? node.data.hardcodedValues?.data || {}\n-          : node.data.hardcodedValues || {};\n-      const valid = validate(inputData);\n-      if (!valid) {\n-        // Populate errors if validation fails\n-        validate.errors?.forEach((error) => {\n-          // Skip error if there's an edge connected\n-          const path =\n-            \"dataPath\" in error\n-              ? (error.dataPath as string)\n-              : error.instancePath;\n-          const handle = path.split(/[\\/.]/)[0];\n-          if (\n-            node.data.connections.some(\n-              (conn) => conn.target === node.id || conn.targetHandle === handle,\n-            )\n-          ) {\n-            return;\n-          }\n-          console.warn(`Error in ${node.data.blockType}: ${error}`, {\n-            data: inputData,\n-            schema: node.data.inputSchema,\n-          });\n-          errorMessage = error.message || \"Invalid input\";\n-          if (path && error.message) {\n-            const key = path.slice(1);\n-            setNestedProperty(\n-              errors,\n-              key,\n-              error.message[0].toUpperCase() + error.message.slice(1),\n-            );\n-          } else if (error.keyword === \"required\") {\n-            const key = error.params.missingProperty;\n-            setNestedProperty(errors, key, \"This field is required\");\n-          }\n-        });\n-      }\n-\n-      Object.entries(node.data.inputSchema.properties || {}).forEach(\n-        ([key, schema]) => {\n-          if (schema.depends_on) {\n-            const dependencies = schema.depends_on;\n-\n-            // Check if dependent field has value\n-            const hasValue =\n-              inputData[key] != null ||\n-              (\"default\" in schema && schema.default != null);\n-\n-            const mustHaveValue = node.data.inputSchema.required?.includes(key);\n-\n-            // Check for missing dependencies when dependent field is present\n-            const missingDependencies = dependencies.filter(\n-              (dep) =>\n-                !inputData[dep as keyof typeof inputData] ||\n-                String(inputData[dep as keyof typeof inputData]).trim() === \"\",\n-            );\n-\n-            if ((hasValue || mustHaveValue) && missingDependencies.length > 0) {\n-              setNestedProperty(\n-                errors,\n-                key,\n-                `Requires ${missingDependencies.join(\", \")} to be set`,\n-              );\n-              errorMessage = `Field ${key} requires ${missingDependencies.join(\", \")} to be set`;\n-            }\n-\n-            // Check if field is required when dependencies are present\n-            const hasAllDependencies = dependencies.every(\n-              (dep) =>\n-                inputData[dep as keyof typeof inputData] &&\n-                String(inputData[dep as keyof typeof inputData]).trim() !== \"\",\n-            );\n-\n-            if (hasAllDependencies && !hasValue) {\n-              setNestedProperty(\n-                errors,\n-                key,\n-                `${key} is required when ${dependencies.join(\", \")} are set`,\n-              );\n-              errorMessage = `${key} is required when ${dependencies.join(\", \")} are set`;\n-            }\n-          }\n-        },\n-      );\n-\n-      // Set errors\n-      setNodes((nodes) => {\n-        return nodes.map((n) => {\n-          if (n.id === node.id) {\n-            return {\n-              ...n,\n-              data: {\n-                ...n.data,\n-                errors,\n-              },\n-            };\n-          }\n-          return n;\n-        });\n-      });\n-    });\n-\n-    return errorMessage;\n-  }, [nodes]);\n-\n-  // Handle user requests\n-  useEffect(() => {\n-    // Ignore none request\n-    if (saveRunRequest.request === \"none\") {\n-      return;\n-    }\n-    // Display error message\n-    if (saveRunRequest.state === \"error\") {\n-      if (saveRunRequest.request === \"save\") {\n-        toast({\n-          variant: \"destructive\",\n-          title: `Error saving agent`,\n-          duration: 2000,\n-        });\n-      } else if (saveRunRequest.request === \"run\") {\n-        toast({\n-          variant: \"destructive\",\n-          title: `Error saving&running agent`,\n-          duration: 2000,\n-        });\n-      } else if (saveRunRequest.request === \"stop\") {\n-        toast({\n-          variant: \"destructive\",\n-          title: `Error stopping agent`,\n-          duration: 2000,\n-        });\n-      }\n-      // Reset request\n-      setSaveRunRequest({\n-        request: \"none\",\n-        state: \"none\",\n-      });\n-      return;\n-    }\n-    // When saving request is done\n-    if (\n-      saveRunRequest.state === \"saving\" &&\n-      savedAgent &&\n-      nodesSyncedWithSavedAgent\n-    ) {\n-      // Reset request if only save was requested\n-      if (saveRunRequest.request === \"save\") {\n-        setSaveRunRequest({\n-          request: \"none\",\n-          state: \"none\",\n-        });\n-        // If run was requested, run the agent\n-      } else if (saveRunRequest.request === \"run\") {\n-        const validationError = validateNodes();\n-        if (validationError) {\n-          toast({\n-            title: `Validation failed: ${validationError}`,\n-            variant: \"destructive\",\n-            duration: 2000,\n-          });\n-          setSaveRunRequest({\n-            request: \"none\",\n-            state: \"none\",\n-          });\n-          return;\n-        }\n-        setSaveRunRequest({ request: \"run\", state: \"running\" });\n-        api\n-          .executeGraph(savedAgent.id, savedAgent.version)\n-          .then((graphExecution) => {\n-            setSaveRunRequest({\n-              request: \"run\",\n-              state: \"running\",\n-              activeExecutionID: graphExecution.graph_exec_id,\n-            });\n-\n-            // Update URL params\n-            const path = new URLSearchParams(searchParams);\n-            path.set(\"flowID\", savedAgent.id);\n-            path.set(\"flowVersion\", savedAgent.version.toString());\n-            path.set(\"flowExecutionID\", graphExecution.graph_exec_id);\n-            router.push(`${pathname}?${path.toString()}`);\n-            if (state?.completedSteps.includes(\"BUILDER_SAVE_AGENT\")) {\n-              completeStep(\"BUILDER_RUN_AGENT\");\n-            }\n-          })\n-          .catch((error) => {\n-            const errorMessage =\n-              error instanceof Error ? error.message : String(error);\n-            toast({\n-              variant: \"destructive\",\n-              title: \"Error saving agent\",\n-              description: errorMessage,\n-            });\n-            setSaveRunRequest({ request: \"run\", state: \"error\" });\n-          });\n-\n-        processedUpdates.current = [];\n-      }\n-    }\n-    // Handle stop request\n-    if (\n-      saveRunRequest.request === \"stop\" &&\n-      saveRunRequest.state != \"stopping\" &&\n-      savedAgent &&\n-      saveRunRequest.activeExecutionID\n-    ) {\n-      api.stopGraphExecution(savedAgent.id, saveRunRequest.activeExecutionID);\n-    }\n-  }, [\n-    api,\n-    toast,\n-    saveRunRequest,\n-    savedAgent,\n-    nodesSyncedWithSavedAgent,\n-    validateNodes,\n-  ]);\n-\n   useEffect(() => {\n     if (!flowID || !flowExecutionID) {\n       return;\n@@ -790,93 +535,15 @@ export default function useAgentGraph(\n         return {};\n       }\n \n-      const getNestedData = (\n-        schema: BlockIOSubSchema,\n-        values: { [key: string]: any },\n-      ): { [key: string]: any } => {\n-        let inputData: { [key: string]: any } = {};\n-\n-        if (\"properties\" in schema) {\n-          Object.keys(schema.properties).forEach((key) => {\n-            if (values[key] !== undefined) {\n-              if (\n-                \"properties\" in schema.properties[key] ||\n-                \"additionalProperties\" in schema.properties[key]\n-              ) {\n-                inputData[key] = getNestedData(\n-                  schema.properties[key],\n-                  values[key],\n-                );\n-              } else {\n-                inputData[key] = values[key];\n-              }\n-            }\n-          });\n-        }\n-\n-        if (\"additionalProperties\" in schema) {\n-          inputData = { ...inputData, ...values };\n-        }\n-\n-        return inputData;\n-      };\n-\n-      const inputData = getNestedData(blockSchema, node.data.hardcodedValues);\n-\n-      console.debug(\n-        `Final prepared input for ${node.data.blockType} (${node.id}):`,\n-        inputData,\n-      );\n-      return inputData;\n+      return rebuildObjectUsingSchema(blockSchema, node.data.hardcodedValues);\n     },\n-    [availableNodes],\n+    [availableBlocks],\n   );\n \n-  const _saveAgent = useCallback(async () => {\n-    //FIXME frontend ids should be resolved better (e.g. returned from the server)\n-    // currently this relays on block_id and position\n-    const blockIdToNodeIdMap: Record<string, string> = {};\n-\n-    nodes.forEach((node) => {\n-      const key = `${node.data.block_id}_${node.position.x}_${node.position.y}`;\n-      blockIdToNodeIdMap[key] = node.id;\n-    });\n-\n-    const formattedNodes = nodes.map((node) => {\n-      const inputDefault = prepareNodeInputData(node);\n-      const inputNodes = edges\n-        .filter((edge) => edge.target === node.id)\n-        .map((edge) => ({\n-          name: edge.targetHandle || \"\",\n-          node_id: edge.source,\n-        }));\n-\n-      const outputNodes = edges\n-        .filter((edge) => edge.source === node.id)\n-        .map((edge) => ({\n-          name: edge.sourceHandle || \"\",\n-          node_id: edge.target,\n-        }));\n-\n-      return {\n-        id: node.id,\n-        block_id: node.data.block_id,\n-        input_default: inputDefault,\n-        input_nodes: inputNodes,\n-        output_nodes: outputNodes,\n-        data: {\n-          ...node.data,\n-          hardcodedValues: removeEmptyStringsAndNulls(\n-            node.data.hardcodedValues,\n-          ),\n-        },\n-        metadata: { position: node.position },\n-      };\n-    });\n-\n-    const links = edges.map((edge) => {\n+  const prepareSaveableGraph = useCallback((): GraphCreatable => {\n+    const links = xyEdges.map((edge): LinkCreatable => {\n       let sourceName = edge.sourceHandle || \"\";\n-      const sourceNode = nodes.find((node) => node.id === edge.source);\n+      const sourceNode = xyNodes.find((node) => node.id === edge.source);\n \n       // Special case for SmartDecisionMakerBlock\n       if (\n@@ -893,51 +560,181 @@ export default function useAgentGraph(\n       };\n     });\n \n-    const payload = {\n+    return {\n       name: agentName || `New Agent ${new Date().toISOString()}`,\n       description: agentDescription || \"\",\n-      nodes: formattedNodes,\n+      nodes: xyNodes.map(\n+        (node): NodeCreatable => ({\n+          id: node.id,\n+          block_id: node.data.block_id,\n+          input_default: prepareNodeInputData(node),\n+          metadata: { position: node.position },\n+        }),\n+      ),\n       links: links,\n     };\n+  }, [\n+    xyNodes,\n+    xyEdges,\n+    agentName,\n+    agentDescription,\n+    prepareNodeInputData,\n+    getToolFuncName,\n+  ]);\n+\n+  const validateGraph = useCallback(\n+    (graph?: GraphCreatable): string | null => {\n+      let errorMessage = null;\n+\n+      if (!graph) {\n+        graph = prepareSaveableGraph();\n+      }\n+\n+      graph.nodes.forEach((node) => {\n+        const block = availableBlocks.find(\n+          (block) => block.id === node.block_id,\n+        );\n+        if (!block) {\n+          console.error(\n+            `Node ${node.id} is invalid: unknown block ID ${node.block_id}`,\n+          );\n+          return;\n+        }\n+        const inputSchema = block.inputSchema;\n+        const validate = ajv.compile(inputSchema);\n+        const errors: Record<string, string> = {};\n+        const errorPrefix = `${block.name} [${node.id.split(\"-\")[0]}]`;\n+\n+        // Validate values against schema using AJV\n+        const inputData = node.input_default;\n+        const valid = validate(inputData);\n+        if (!valid) {\n+          // Populate errors if validation fails\n+          validate.errors?.forEach((error) => {\n+            const path =\n+              \"dataPath\" in error\n+                ? (error.dataPath as string)\n+                : error.instancePath || error.params.missingProperty;\n+            const handle = path.split(/[\\/.]/)[0];\n+            // Skip error if there's an edge connected\n+            if (\n+              graph.links.some(\n+                (link) => link.sink_id == node.id && link.sink_name == handle,\n+              )\n+            ) {\n+              return;\n+            }\n+            console.warn(`Error in ${block.name} input: ${error}`, {\n+              data: inputData,\n+              schema: inputSchema,\n+            });\n+            errorMessage =\n+              `${errorPrefix}: ` + (error.message || \"Invalid input\");\n+            if (path && error.message) {\n+              const key = path.slice(1);\n+              setNestedProperty(\n+                errors,\n+                key,\n+                error.message[0].toUpperCase() + error.message.slice(1),\n+              );\n+            } else if (error.keyword === \"required\") {\n+              const key = error.params.missingProperty;\n+              setNestedProperty(errors, key, \"This field is required\");\n+            }\n+          });\n+        }\n+\n+        Object.entries(inputSchema.properties).forEach(([key, schema]) => {\n+          if (schema.depends_on) {\n+            const dependencies = schema.depends_on;\n+\n+            // Check if dependent field has value\n+            const hasValue =\n+              inputData[key] != null ||\n+              (\"default\" in schema && schema.default != null);\n+\n+            const mustHaveValue = inputSchema.required?.includes(key);\n+\n+            // Check for missing dependencies when dependent field is present\n+            const missingDependencies = dependencies.filter(\n+              (dep) =>\n+                !inputData[dep as keyof typeof inputData] ||\n+                String(inputData[dep as keyof typeof inputData]).trim() === \"\",\n+            );\n+\n+            if ((hasValue || mustHaveValue) && missingDependencies.length > 0) {\n+              setNestedProperty(\n+                errors,\n+                key,\n+                `Requires ${missingDependencies.join(\", \")} to be set`,\n+              );\n+              errorMessage = `${errorPrefix}: field ${key} requires ${missingDependencies.join(\", \")} to be set`;\n+            }\n+\n+            // Check if field is required when dependencies are present\n+            const hasAllDependencies = dependencies.every(\n+              (dep) =>\n+                inputData[dep as keyof typeof inputData] &&\n+                String(inputData[dep as keyof typeof inputData]).trim() !== \"\",\n+            );\n+\n+            if (hasAllDependencies && !hasValue) {\n+              setNestedProperty(\n+                errors,\n+                key,\n+                `${key} is required when ${dependencies.join(\", \")} are set`,\n+              );\n+              errorMessage = `${errorPrefix}: ${key} is required when ${dependencies.join(\", \")} are set`;\n+            }\n+          }\n+        });\n+\n+        // Set errors\n+        setXYNodes((nodes) => {\n+          return nodes.map((n) => {\n+            if (n.id === node.id) {\n+              return {\n+                ...n,\n+                data: {\n+                  ...n.data,\n+                  errors,\n+                },\n+              };\n+            }\n+            return n;\n+          });\n+        });\n+      });\n+\n+      return errorMessage;\n+    },\n+    [prepareSaveableGraph, availableBlocks],\n+  );\n+\n+  const _saveAgent = useCallback(async () => {\n+    // FIXME: frontend IDs should be resolved better (e.g. returned from the server)\n+    // currently this relays on block_id and position\n+    const blockIDToNodeIDMap = Object.fromEntries(\n+      xyNodes.map((node) => [\n+        `${node.data.block_id}_${node.position.x}_${node.position.y}`,\n+        node.id,\n+      ]),\n+    );\n+\n+    const payload = prepareSaveableGraph();\n \n     // To avoid saving the same graph, we compare the payload with the saved agent.\n     // Differences in IDs are ignored.\n-    const comparedPayload = {\n-      name: payload.name,\n-      description: payload.description,\n-      nodes: payload.nodes.map(\n-        ({ id: _, data: __, input_nodes: ___, output_nodes: ____, ...rest }) =>\n-          rest,\n-      ),\n-      links: payload.links.map(\n-        ({ source_id: _, sink_id: __, ...rest }) => rest,\n-      ),\n-    };\n-    const comparedSavedAgent = {\n-      name: savedAgent?.name,\n-      description: savedAgent?.description,\n-      nodes: savedAgent?.nodes.map((v) => ({\n-        block_id: v.block_id,\n-        input_default: v.input_default,\n-        metadata: v.metadata,\n-      })),\n-      links: savedAgent?.links.map((v) => ({\n-        sink_name: v.sink_name,\n-        source_name: v.source_name,\n-      })),\n-    };\n-\n-    let newSavedAgent = null;\n-    if (savedAgent && deepEquals(comparedPayload, comparedSavedAgent)) {\n+    let newSavedAgent: Graph;\n+    if (savedAgent && graphsEquivalent(savedAgent, payload)) {\n       console.warn(\"No need to save: Graph is the same as version on server\");\n       newSavedAgent = savedAgent;\n     } else {\n       console.debug(\n         \"Saving new Graph version; old vs new:\",\n-        comparedPayload,\n-        comparedSavedAgent,\n+        savedAgent,\n+        payload,\n       );\n-      setNodesSyncedWithSavedAgent(false);\n \n       newSavedAgent = savedAgent\n         ? await api.updateGraph(savedAgent.id, {\n@@ -1024,80 +825,148 @@ export default function useAgentGraph(\n         title: \"Error saving agent\",\n         description: errorMessage,\n       });\n-      setSaveRunRequest({ request: \"save\", state: \"error\" });\n+    } finally {\n+      setIsSaving(false);\n     }\n-  }, [_saveAgent, toast]);\n+  }, [_saveAgent, toast, completeStep]);\n \n-  const requestSave = useCallback(() => {\n-    if (saveRunRequest.state !== \"none\") {\n-      return;\n-    }\n-    saveAgent();\n-    setSaveRunRequest({\n-      request: \"save\",\n-      state: \"saving\",\n-    });\n-  }, [saveAgent, saveRunRequest.state]);\n+  const saveAndRun = useCallback(\n+    async (\n+      inputs: Record<string, any>,\n+      credentialsInputs: Record<string, CredentialsMetaInput>,\n+    ) => {\n+      if (isSaving || isRunning) {\n+        return;\n+      }\n \n-  const requestSaveAndRun = useCallback(() => {\n-    saveAgent();\n-    setSaveRunRequest({\n-      request: \"run\",\n-      state: \"saving\",\n-    });\n-  }, [saveAgent]);\n+      setIsSaving(true);\n+      let savedAgent: Graph;\n+      try {\n+        savedAgent = await _saveAgent();\n+        completeStep(\"BUILDER_SAVE_AGENT\");\n+      } catch (error) {\n+        const errorMessage =\n+          error instanceof Error ? error.message : String(error);\n+        toast({\n+          variant: \"destructive\",\n+          title: \"Error saving agent\",\n+          description: errorMessage,\n+        });\n+        return;\n+      } finally {\n+        setIsSaving(false);\n+      }\n+\n+      const validationError = validateGraph(savedAgent);\n+      if (validationError) {\n+        toast({\n+          title: `Graph validation failed: ${validationError}`,\n+          variant: \"destructive\",\n+        });\n+        return;\n+      }\n+\n+      setIsRunning(true);\n+      processedUpdates.current = [];\n+\n+      try {\n+        const graphExecution = await api.executeGraph(\n+          savedAgent.id,\n+          savedAgent.version,\n+          inputs,\n+          credentialsInputs,\n+        );\n+\n+        setActiveExecutionID(graphExecution.graph_exec_id);\n+\n+        // Update URL params\n+        const path = new URLSearchParams(searchParams);\n+        path.set(\"flowID\", savedAgent.id);\n+        path.set(\"flowVersion\", savedAgent.version.toString());\n+        path.set(\"flowExecutionID\", graphExecution.graph_exec_id);\n+        router.push(`${pathname}?${path.toString()}`);\n \n-  const requestStopRun = useCallback(() => {\n-    if (saveRunRequest.state != \"running\") {\n+        if (state?.completedSteps.includes(\"BUILDER_SAVE_AGENT\")) {\n+          completeStep(\"BUILDER_RUN_AGENT\");\n+        }\n+      } catch (error) {\n+        const errorMessage =\n+          error instanceof Error ? error.message : String(error);\n+        toast({\n+          variant: \"destructive\",\n+          title: \"Error running agent\",\n+          description: errorMessage,\n+        });\n+        setIsRunning(false);\n+        setActiveExecutionID(null);\n+      }\n+    },\n+    [\n+      _saveAgent,\n+      toast,\n+      completeStep,\n+      savedAgent,\n+      prepareSaveableGraph,\n+      nodesSyncedWithSavedAgent,\n+      validateGraph,\n+      api,\n+      searchParams,\n+      pathname,\n+      router,\n+      state,\n+      isSaving,\n+      isRunning,\n+      processedUpdates,\n+    ],\n+  );\n+\n+  const stopRun = useCallback(async () => {\n+    if (!isRunning || !activeExecutionID || isStopping || !savedAgent) {\n       return;\n     }\n-    if (!saveRunRequest.activeExecutionID) {\n-      console.warn(\n-        \"Stop requested but execution ID is unknown; state:\",\n-        saveRunRequest,\n-      );\n-    }\n-    setSaveRunRequest((prev) => ({\n-      ...prev,\n-      request: \"stop\",\n-      state: \"running\",\n-    }));\n-  }, [saveRunRequest]);\n+\n+    setIsStopping(true);\n+    await api\n+      .stopGraphExecution(savedAgent.id, activeExecutionID)\n+      .catch((error) => {\n+        const errorMessage =\n+          error instanceof Error ? error.message : String(error);\n+        toast({\n+          variant: \"destructive\",\n+          title: \"Error stopping agent\",\n+          description: errorMessage,\n+        });\n+      });\n+    setIsStopping(false);\n+  }, [api, savedAgent, activeExecutionID, isRunning, isStopping, toast]);\n \n   // runs after saving cron expression and inputs (if exists)\n-  const scheduleRunner = useCallback(\n+  const createRunSchedule = useCallback(\n     async (\n       cronExpression: string,\n-      inputs: InputItem[],\n       scheduleName: string,\n+      inputs: Record<string, any>,\n+      credentialsInputs: Record<string, CredentialsMetaInput>,\n     ) => {\n-      await saveAgent();\n+      if (!savedAgent || isScheduling) return;\n+\n+      setIsScheduling(true);\n       try {\n-        if (flowID) {\n-          await api.createGraphExecutionSchedule({\n-            graph_id: flowID,\n-            // flowVersion is always defined here because scheduling is opened for a specific version\n-            graph_version: flowVersion!,\n-            name: scheduleName,\n-            cron: cronExpression,\n-            inputs: inputs.reduce(\n-              (acc, input) => ({\n-                ...acc,\n-                [input.hardcodedValues.name]: input.hardcodedValues.value,\n-              }),\n-              {},\n-            ),\n-          });\n-          toast({\n-            title: \"Agent scheduling successful\",\n-          });\n+        await api.createGraphExecutionSchedule({\n+          graph_id: savedAgent.id,\n+          graph_version: savedAgent.version,\n+          name: scheduleName,\n+          cron: cronExpression,\n+          inputs: inputs,\n+          credentials: credentialsInputs,\n+        });\n+        toast({\n+          title: \"Agent scheduling successful\",\n+        });\n \n-          // if scheduling is done from the monitor page, then redirect to monitor page after successful scheduling\n-          if (searchParams.get(\"open_scheduling\") === \"true\") {\n-            router.push(\"/\");\n-          }\n-        } else {\n-          return;\n+        // if scheduling is done from the monitor page, then redirect to monitor page after successful scheduling\n+        if (searchParams.get(\"open_scheduling\") === \"true\") {\n+          router.push(\"/monitoring\");\n         }\n       } catch (error) {\n         console.error(error);\n@@ -1117,21 +988,74 @@ export default function useAgentGraph(\n     agentDescription,\n     setAgentDescription,\n     savedAgent,\n-    availableNodes,\n+    availableBlocks,\n     availableFlows,\n     getOutputType,\n-    requestSave,\n-    requestSaveAndRun,\n-    requestStopRun,\n-    scheduleRunner,\n-    isSaving: saveRunRequest.state == \"saving\",\n-    isRunning: saveRunRequest.state == \"running\",\n-    isStopping: saveRunRequest.state == \"stopping\",\n+    saveAgent,\n+    saveAndRun,\n+    stopRun,\n+    createRunSchedule,\n+    isSaving,\n+    isRunning,\n+    isStopping,\n     isScheduling,\n-    setIsScheduling,\n-    nodes,\n-    setNodes,\n-    edges,\n-    setEdges,\n+    nodes: xyNodes,\n+    setNodes: setXYNodes,\n+    edges: xyEdges,\n+    setEdges: setXYEdges,\n+  };\n+}\n+\n+function graphsEquivalent(saved: Graph, current: GraphCreatable): boolean {\n+  const _saved = {\n+    name: saved.name,\n+    description: saved.description,\n+    nodes: saved.nodes.map((v) => ({\n+      block_id: v.block_id,\n+      input_default: v.input_default,\n+      metadata: v.metadata,\n+    })),\n+    links: saved.links.map((v) => ({\n+      sink_name: v.sink_name,\n+      source_name: v.source_name,\n+    })),\n   };\n+  const _current = {\n+    name: current.name,\n+    description: current.description,\n+    nodes: current.nodes.map(({ id: _, ...rest }) => rest),\n+    links: current.links.map(({ source_id: _, sink_id: __, ...rest }) => rest),\n+  };\n+  return deepEquals(_saved, _current);\n+}\n+\n+function rebuildObjectUsingSchema(\n+  schema: BlockIOSubSchema,\n+  object: { [key: string]: any },\n+): Record<string, any> {\n+  let inputData: Record<string, any> = {};\n+\n+  if (\"properties\" in schema) {\n+    Object.keys(schema.properties).forEach((key) => {\n+      if (object[key] !== undefined) {\n+        if (\n+          \"properties\" in schema.properties[key] ||\n+          \"additionalProperties\" in schema.properties[key]\n+        ) {\n+          inputData[key] = rebuildObjectUsingSchema(\n+            schema.properties[key],\n+            object[key],\n+          );\n+        } else {\n+          inputData[key] = object[key];\n+        }\n+      }\n+    });\n+  }\n+\n+  if (\"additionalProperties\" in schema) {\n+    inputData = { ...inputData, ...object };\n+  }\n+\n+  return inputData;\n }\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Thanks for the PR on improving Builder credentials support and UX! The overall structure looks solid, and the refactoring you've done enhances both maintainability and user experience.\n\nHowever, before merging, please ensure the checklist is complete—specifically, check the section confirming that you've tested your changes according to the plan. \n\nAlso, your work on `GraphMeta` and the UX improvements for smoother canvas navigation are commendable. Once the checklist is fully updated, this should be ready for approval!"
      }
    ],
    "token_estimation": 11866.25
  },
  {
    "index": 8,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/tests/rules/test_nix_shell.py b/tests/rules/test_nix_shell.py\nnew file mode 100644\nindex 000000000..69ba14872\n--- /dev/null\n+++ b/tests/rules/test_nix_shell.py\n@@ -0,0 +1,90 @@\n+import pytest\n+from thefuck.rules.nix_shell import get_nixpkgs_names, match, get_new_command\n+from thefuck.types import Command\n+from unittest.mock import patch, MagicMock\n+\n+\n+@pytest.mark.parametrize(\n+    \"script,output,nixpkgs_names\",\n+    [\n+        # output can be retrived by running `THEFUCK_DEBUG=true thefuck lsof`\n+        (\n+            \"lsof\",\n+            \"/nix/store/p6dlr3skfhxpyphipg2bqnj52999banh-bash-5.2-p15/bin/sh: line 1: lsof: command not found\",\n+            [\"lsof\"],\n+        ),\n+    ],\n+)\n+def test_match(script, output, nixpkgs_names):\n+    with patch(\"thefuck.rules.nix_shell.get_nixpkgs_names\") as mocked_get_nixpkgs_names:\n+        mocked_get_nixpkgs_names.return_value = nixpkgs_names\n+        command = Command(script, output)\n+        assert match(command)\n+\n+\n+@pytest.mark.parametrize(\n+    \"script,output,nixpkgs_names\",\n+    [\n+        # output can be retrived by running `THEFUCK_DEBUG=true thefuck foo`\n+        (\n+            \"foo\",\n+            \"/nix/store/p6dlr3skfhxpyphipg2bqnj52999banh-bash-5.2-p15/bin/sh: line 1: foo: command not found\",\n+            [],\n+        ),\n+    ],\n+)\n+def test_not_match(script, output, nixpkgs_names):\n+    with patch(\"thefuck.rules.nix_shell.get_nixpkgs_names\") as mocked_get_nixpkgs_names:\n+        mocked_get_nixpkgs_names.return_value = nixpkgs_names\n+        command = Command(script, output)\n+        assert not match(command)\n+\n+\n+@pytest.mark.parametrize(\n+    \"script,nixpkgs_names,new_command\",\n+    [\n+        (\n+            \"lsof -i :3000\",\n+            [\"busybox\", \"lsof\"],\n+            [\n+                'nix-shell -p busybox --run \"lsof -i :3000\"',\n+                'nix-shell -p lsof --run \"lsof -i :3000\"',\n+            ],\n+        ),\n+        (\"xev\", [\"xorg.xev\"], ['nix-shell -p xorg.xev --run \"xev\"']),\n+    ],\n+)\n+def test_get_new_command(script, nixpkgs_names, new_command):\n+    \"\"\"Check that flags and params are preserved in the new command\"\"\"\n+\n+    command = Command(script, \"\")\n+    with patch(\"thefuck.rules.nix_shell.get_nixpkgs_names\") as mocked_get_nixpkgs_names:\n+        mocked_get_nixpkgs_names.return_value = nixpkgs_names\n+        assert get_new_command(command) == new_command\n+\n+\n+# Mocks the stderr of `command-not-found QUERY`. Mock values are retrieved by\n+# running `THEFUCK_DEBUG=true thefuck command-not-found lsof`.\n+mocked_cnf_stderr = {\n+    \"lsof\": \"The program 'lsof' is not in your PATH. It is provided by several packages.\\nYou can make it available in an ephemeral shell by typing one of the following:\\n  nix-shell -p busybox\\n  nix-shell -p lsof\",\n+    \"xev\": \"The program 'xev' is not in your PATH. You can make it available in an ephemeral shell by typing:\\n  nix-shell -p xorg.xev\",\n+    \"foo\": \"foo: command not found\",\n+}\n+\n+\n+@pytest.mark.parametrize(\n+    \"bin,expected_nixpkgs_names,cnf_stderr\",\n+    [\n+        (\"lsof\", [\"busybox\", \"lsof\"], mocked_cnf_stderr[\"lsof\"]),\n+        (\"xev\", [\"xorg.xev\"], mocked_cnf_stderr[\"xev\"]),\n+        (\"foo\", [], mocked_cnf_stderr[\"foo\"]),\n+    ],\n+)\n+def test_get_nixpkgs_names(bin, expected_nixpkgs_names, cnf_stderr):\n+    \"\"\"Check that `get_nixpkgs_names` returns the correct names\"\"\"\n+\n+    with patch(\"subprocess.run\") as mocked_run:\n+        result = MagicMock()\n+        result.stderr = cnf_stderr\n+        mocked_run.return_value = result\n+        assert get_nixpkgs_names(bin) == expected_nixpkgs_names\ndiff --git a/thefuck/rules/nix_shell.py b/thefuck/rules/nix_shell.py\nnew file mode 100644\nindex 000000000..7bfba7eac\n--- /dev/null\n+++ b/thefuck/rules/nix_shell.py\n@@ -0,0 +1,51 @@\n+from thefuck.specific.nix import nix_available\n+import subprocess\n+\n+enabled_by_default = nix_available\n+\n+# Set the priority just ahead of `fix_file` rule, which can generate low quality matches due\n+# to the sheer amount of paths in the nix store.\n+priority = 999\n+\n+\n+def get_nixpkgs_names(bin):\n+    \"\"\"\n+    Returns the name of the Nix package that provides the given binary. It uses the\n+    `command-not-found` binary to do so, which is how nix-shell generates it's own suggestions.\n+    \"\"\"\n+\n+    result = subprocess.run(\n+        [\"command-not-found\", bin], stderr=subprocess.PIPE, universal_newlines=True\n+    )\n+\n+    # The suggestion, if any, will be found in stderr. Upstream definition: https://github.com/NixOS/nixpkgs/blob/b6fbd87328f8eabd82d65cc8f75dfb74341b0ace/nixos/modules/programs/command-not-found/command-not-found.nix#L48-L90\n+    text = result.stderr\n+\n+    # return early if binary is not available through nix\n+    if \"nix-shell\" not in text:\n+        return []\n+\n+    nixpkgs_names = [\n+        line.split()[-1] for line in text.splitlines() if \"nix-shell -p\" in line\n+    ]\n+    return nixpkgs_names\n+\n+\n+def match(command):\n+    bin = command.script_parts[0]\n+    return (\n+        \"command not found\" in command.output  # only match commands which had exit code: 127                   # noqa: E501\n+        and get_nixpkgs_names(bin)             # only match commands which could be made available through nix  # noqa: E501\n+    )\n+\n+\n+def get_new_command(command):\n+    bin = command.script_parts[0]\n+    nixpkgs_names = get_nixpkgs_names(bin)\n+\n+    # Construct a command for each package name\n+    commands = [\n+        'nix-shell -p {} --run \"{}\"'.format(name, command.script)\n+        for name in nixpkgs_names\n+    ]\n+    return commands\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "There are some solid ideas here, particularly regarding integrating with `nix run` for smoother command execution. However, the build errors due to missing modules and deprecation warnings indicate issues with the current setup that need resolution. The suggestion to use an updated rule via a custom configuration is promising, but we should ensure that it doesn't complicate the user experience. Lastly, adding flags for configuration is a good approach, but consider the usability impact of adding multiple options. Let's keep refining this for clarity and stability."
      }
    ],
    "token_estimation": 1527.25
  },
  {
    "index": 9,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/docs/en/docs/advanced/settings.md b/docs/en/docs/advanced/settings.md\nindex 706a71173e76f..d1428b6ec9b84 100644\n--- a/docs/en/docs/advanced/settings.md\n+++ b/docs/en/docs/advanced/settings.md\n@@ -293,85 +288,17 @@ config.Settings()\n \n a new `Settings` object would be created, and at creation it would read the `.env` file again.\n \n-If the dependency function was just like:\n+If we declared our dependency without `Depends(..., use_cache=\"app\")`, we would create that object for each request, and we would be reading the `.env` file for each request. ⚠️\n \n-```Python\n-def get_settings():\n-    return config.Settings()\n-```\n-\n-we would create that object for each request, and we would be reading the `.env` file for each request. ⚠️\n-\n-But as we are using the `@lru_cache()` decorator on top, the `Settings` object will be created only once, the first time it's called. ✔️\n+But by setting `use_cache=\"app\"`, the `Settings` object will be created only once, the first time it's called. ✔️\n \n ```Python hl_lines=\"1  10\"\n {!../../../docs_src/settings/app03/main.py!}\n ```\n \n-Then for any subsequent calls of `get_settings()` in the dependencies for the next requests, instead of executing the internal code of `get_settings()` and creating a new `Settings` object, it will return the same object that was returned on the first call, again and again.\n-\n-#### `lru_cache` Technical Details\n-\n-`@lru_cache()` modifies the function it decorates to return the same value that was returned the first time, instead of computing it again, executing the code of the function every time.\n-\n-So, the function below it will be executed once for each combination of arguments. And then the values returned by each of those combinations of arguments will be used again and again whenever the function is called with exactly the same combination of arguments.\n-\n-For example, if you have a function:\n-\n-```Python\n-@lru_cache()\n-def say_hi(name: str, salutation: str = \"Ms.\"):\n-    return f\"Hello {salutation} {name}\"\n-```\n-\n-your program could execute like this:\n-\n-```mermaid\n-sequenceDiagram\n-\n-participant code as Code\n-participant function as say_hi()\n-participant execute as Execute function\n-\n-    rect rgba(0, 255, 0, .1)\n-        code ->> function: say_hi(name=\"Camila\")\n-        function ->> execute: execute function code\n-        execute ->> code: return the result\n-    end\n-\n-    rect rgba(0, 255, 255, .1)\n-        code ->> function: say_hi(name=\"Camila\")\n-        function ->> code: return stored result\n-    end\n-\n-    rect rgba(0, 255, 0, .1)\n-        code ->> function: say_hi(name=\"Rick\")\n-        function ->> execute: execute function code\n-        execute ->> code: return the result\n-    end\n-\n-    rect rgba(0, 255, 0, .1)\n-        code ->> function: say_hi(name=\"Rick\", salutation=\"Mr.\")\n-        function ->> execute: execute function code\n-        execute ->> code: return the result\n-    end\n-\n-    rect rgba(0, 255, 255, .1)\n-        code ->> function: say_hi(name=\"Rick\")\n-        function ->> code: return stored result\n-    end\n-\n-    rect rgba(0, 255, 255, .1)\n-        code ->> function: say_hi(name=\"Camila\")\n-        function ->> code: return stored result\n-    end\n-```\n-\n-In the case of our dependency `get_settings()`, the function doesn't even take any arguments, so it always returns the same value.\n-\n-That way, it behaves almost as if it was just a global variable. But as it uses a dependency function, then we can override it easily for testing.\n+Then for any subsequent requests to `/info`, instead of executing the internal code of `get_settings()` and creating a new `Settings` object, the same object will be returned again and again.\n \n-`@lru_cache()` is part of `functools` which is part of Python's standard library, you can read more about it in the <a href=\"https://docs.python.org/3/library/functools.html#functools.lru_cache\" class=\"external-link\" target=\"_blank\">Python docs for `@lru_cache()`</a>.\n+For more details on dependency caching scopes, see [Dependency Cache Scopes](../tutorial/dependencies/dependency-cache-scopes.md){.internal-link target=_blank}\n \n ## Recap\n \n\ndiff --git a/docs/en/docs/tutorial/dependencies/dependency-cache-scopes.md b/docs/en/docs/tutorial/dependencies/dependency-cache-scopes.md\nnew file mode 100644\nindex 0000000000000..baf9b8633e8a4\n--- /dev/null\n+++ b/docs/en/docs/tutorial/dependencies/dependency-cache-scopes.md\n@@ -0,0 +1,128 @@\n+# Dependency Cache Scopes\n+\n+In FastAPI, if one of your dependencies is declared multiple times for the same *path operation*, for example, multiple dependencies have a common sub-dependency, **FastAPI** will know to call that sub-dependency only once per request.\n+\n+And it will save the returned value in a <abbr title=\"A utility/system to store computed/generated values, to re-use them instead of computing them again.\">\"cache\"</abbr> and pass it to all the \"dependants\" that need it in that specific request, instead of calling the dependency multiple times for the same request.\n+\n+But you may not want this behavior. FastAPI let's you control this via *cache scopes*. You can set the cache scope using the `use_cache` parameter to `Depends()`. For example, to disable the cache for a dependency:\n+\n+```Python hl_lines=\"1\"\n+def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):\n+    return {\"fresh_value\": fresh_value}\n+```\n+\n+You may also find situations where you only want your dependencies to be created *once*.\n+For example, if you are loading a config from enviroment variables using [Pydantic's settings management](../../advanced/settings.md){.internal-link target=_blank}, you probably only want that to happen once, and be cached therafter.\n+For this situation, set `use_cache=\"app\"` to cache the dependencies value for the lifetime of your application:\n+\n+```Python hl_lines=\"4\"\n+def load_config():\n+    return Config()\n+\n+def dependent(cfg: Config = Depends(load_config, use_cache=\"app\")):\n+    return cfg.some_value\n+```\n+\n+!!! note \"Technical Details\"\n+    FastAPI caches your dependencies based on the callable's identity.\n+    If your dependency is a class or function, the cache will be based on `id(ClassName)` or `id(function_name)`.\n+    However if your dependency is an _instance_ of a class implementing `__call__`, only that particular _instance_ will be cached.\n+\n+## DependencyCacheScopes\n+\n+To be more explicit, you can also use the `fastapi.dependencies.cache.DependencyCacheScopes` enumeration to set values:\n+\n+```Python\n+from fastapi.dependencies.cache import DependencyCacheScopes\n+\n+def dependent(cfg: Config = Depends(load_config, use_cache=DependencyCacheScopes.app)):\n+    return cfg.some_value\n+```\n+\n+!!! note \"Technical Details\"\n+    FastAPI uses `fastapi.dependencies.cache.DependencyCacheScopes` internally.\n+    When you pass in `use_cache={True,False,\"app\"}` it gets converted to a value from `DependencyCacheScopes`.\n+    The scalar values of `{True,False,\"app\"}` are supported so that you don't have to import `fastapi.dependencies.cache.DependencyCacheScopes` all over the place, but if you are using dependency scopes extensively it may be clearer to use `DependencyCacheScopes` directly.\n+\n+## Dependencies in multiple scopes\n+\n+If a dependency is cached in the `\"app\"` scope, it will be used for any dependencies declared with the default scope (`use_cache=True`, scoped to a single request).\n+\n+If you need to use a dependency both in the `\"app\"` scope and seperately at the individual request scope, you have two options.\n+\n+### Disable cache for the shared dependency\n+\n+You can mark the dependencies at the request scope with `Depends(..., use_cache=False)`, but note that they will not be cached at all in the request scope:\n+\n+```Python hl_lines=\"6\"\n+def random_num() -> float:\n+    return random.random()\n+\n+async def dependent(\n+    app_value: float = Depends(random_num, use_cache=\"app\"),\n+    request_value_1: float = Depends(random_num, use_cache=False),\n+    request_value_2: float = Depends(random_num, use_cache=False),\n+):\n+    assert request_value_1 != request_value_2\n+```\n+\n+However, now there will be no caching done at the request level.\n+In this example, `app_value` will always have the same value while `request_value_1` and `request_value_2` will each have a new unique value every call.\n+\n+### Specialize the dependency\n+\n+If you want to have caching at *both* the `\"app\"` scope _and_ the `\"request\"` scope, you can specialize your dependency itself.\n+If your dependency is a class, you can sublcass it:\n+\n+```Python\n+class Dependency:\n+    ...\n+\n+\n+class DependencyApp(Dependency):\n+    ...\n+\n+class DependencyRequest(Dependency):\n+    ...\n+```\n+\n+Or if it's a function, you can wrap it:\n+\n+```Python\n+def random_num_app()\n+    return random_num()\n+\n+def random_num_request():\n+    return random_num()\n+\n+async def dependent(\n+    app_value: float = Depends(random_num_app, use_cache=\"app\"),\n+    request_value_1: float = Depends(random_num_request),\n+    request_value_2: float = Depends(random_num_request),\n+):\n+    assert request_value_1 == request_value_2\n+```\n+\n+Now `app_value` will still be the same every call while `request_value_1` and `request_value_2` will be different every call.\n+But `request_value_1` and `request_value_2` will share the same value, and `random_num_request` will only be called once per request.\n+\n+## Recap\n+\n+In total, **FastAPI** supports **3** _cache scopes_:\n+\n+- `True`: this is the default. The dependency's value is cached for that individual request.\n+- `False`: this completely disables the cache that dependency.\n+- `\"app\"`: the dependency's value is cached for the lifetime of the app.\n+\n+These cache scopes are set via the `use_cache` parameter to `Depends()`.\n+\n+You can also use the values of `fastapi.dependencies.cache.DependencyCacheScopes` directly to be more explicit:\n+\n+- `DependencyCacheScopes.request`: equivalent to `True`.\n+- `DependencyCacheScopes.nocache`: equivalent to `False`.\n+- `DependencyCacheScopes.app`: equivalent to `\"app\"`.\n+\n+!!! note \"Info\"\n+    You may be asking yourself what happens if you ask **FastAPI** to cache your dependency's value for the lifetime of your app when using [Dependencies with yield](dependencies-with-yield.md){.internal-link target=_blank}\n+    The handling of teardown for dependencies with yield can be controlled indpendently of the caching of the dependency's yielded value.\n+    Read onto [Dependency lifetimes (the next section)](dependency-lifetimes.md){.internal-link target=_blank} to find out more!\ndiff --git a/fastapi/dependencies/utils.py b/fastapi/dependencies/utils.py\nindex 923669b94ba85..6176ea39e8925 100644\n--- a/fastapi/dependencies/utils.py\n+++ b/fastapi/dependencies/utils.py\n@@ -462,21 +473,107 @@ async def solve_generator(\n     return await stack.enter_async_context(cm)\n \n \n+async def solve_lifespan_dependencies(\n+    *,\n+    dependant: Dependant,\n+    app_dependency_cache: Dict[DependencyCacheKey, Any],\n+    dependency_overrides_provider: Optional[Any] = None,\n+    dependency_cache: Optional[Dict[DependencyCacheKey, Any]] = None,\n+    stack: Union[None, AsyncExitStack],\n+) -> Tuple[Dict[str, Any], Dict[DependencyCacheKey, Any]]:\n+    values: Dict[str, Any] = {}\n+    sub_dependant: Dependant\n+    dependency_cache = dependency_cache or app_dependency_cache.copy()\n+    for sub_dependant in dependant.dependencies:\n+        sub_dependant.call = cast(Callable[..., Any], sub_dependant.call)\n+        sub_dependant.cache_key = cast(\n+            Tuple[Callable[..., Any], Tuple[str]], sub_dependant.cache_key\n+        )\n+        call = sub_dependant.call\n+        use_sub_dependant = sub_dependant\n+        if (\n+            dependency_overrides_provider\n+            and dependency_overrides_provider.dependency_overrides\n+        ):\n+            original_call = sub_dependant.call\n+            call = getattr(\n+                dependency_overrides_provider, \"dependency_overrides\", {}\n+            ).get(original_call, original_call)\n+            use_sub_dependant = get_dependant(\n+                call=call,\n+                name=sub_dependant.name,\n+            )\n+        solved_result = await solve_lifespan_dependencies(\n+            dependant=use_sub_dependant,\n+            dependency_overrides_provider=dependency_overrides_provider,\n+            app_dependency_cache=app_dependency_cache,\n+            dependency_cache=dependency_cache,\n+            stack=stack,\n+        )\n+        sub_values, sub_dependency_cache = solved_result\n+        dependency_cache.update(sub_dependency_cache)\n+        if (\n+            sub_dependant.use_cache != DependencyCacheScope.nocache\n+            and sub_dependant.cache_key in dependency_cache\n+        ):\n+            solved = dependency_cache[sub_dependant.cache_key]\n+        elif is_gen_callable(call) or is_async_gen_callable(call):\n+            if stack is None:\n+                raise RuntimeError(\n+                    async_contextmanager_dependencies_error\n+                )  # pragma: no cover\n+            solved = await solve_generator(\n+                call=call, stack=stack, sub_values=sub_values\n+            )\n+        elif is_coroutine_callable(call):\n+            solved = await call(**sub_values)\n+        else:\n+            solved = await run_in_threadpool(call, **sub_values)\n+        if sub_dependant.name is not None:\n+            values[sub_dependant.name] = solved\n+        if sub_dependant.cache_key not in dependency_cache:\n+            dependency_cache[sub_dependant.cache_key] = solved\n+        if (\n+            sub_dependant.use_cache == DependencyCacheScope.app\n+            and sub_dependant.cache_key not in app_dependency_cache\n+        ):\n+            app_dependency_cache[sub_dependant.cache_key] = solved\n+    if any(\n+        (\n+            dependant.request_param_name,\n+            dependant.query_params,\n+            dependant.header_params,\n+            dependant.cookie_params,\n+            dependant.body_params,\n+            dependant.request_param_name,\n+            dependant.websocket_param_name,\n+            dependant.http_connection_param_name,\n+            dependant.response_param_name,\n+            dependant.path,\n+        )\n+    ):\n+        raise DependencyResolutionError(\n+            \"Lifespan Dependencies cannot depend on connection parameters\"\n+        )\n+    return values, dependency_cache\n+\n+\n async def solve_dependencies(\n     *,\n     request: Union[Request, WebSocket],\n     dependant: Dependant,\n+    app_dependency_cache: Dict[DependencyCacheKey, Any],\n     body: Optional[Union[Dict[str, Any], FormData]] = None,\n     background_tasks: Optional[BackgroundTasks] = None,\n     response: Optional[Response] = None,\n     dependency_overrides_provider: Optional[Any] = None,\n-    dependency_cache: Optional[Dict[Tuple[Callable[..., Any], Tuple[str]], Any]] = None,\n+    dependency_cache: Optional[Dict[DependencyCacheKey, Any]] = None,\n ) -> Tuple[\n     Dict[str, Any],\n     List[ErrorWrapper],\n     Optional[BackgroundTasks],\n     Response,\n-    Dict[Tuple[Callable[..., Any], Tuple[str]], Any],\n+    Dict[DependencyCacheKey, Any],\n ]:\n     values: Dict[str, Any] = {}\n     errors: List[ErrorWrapper] = []\n\ndiff --git a/tests/test_dependency_lifetime.py b/tests/test_dependency_lifetime.py\nnew file mode 100644\nindex 0000000000000..5b0d16fa64ff3\n--- /dev/null\n+++ b/tests/test_dependency_lifetime.py\n@@ -0,0 +1,221 @@\n+import asyncio\n+from threading import Event\n+from time import sleep\n+from typing import AsyncGenerator, Callable, Generator, List\n+\n+import pytest\n+from fastapi import Depends, FastAPI, HTTPException\n+from fastapi.dependencies.lifetime import DependencyLifetime\n+from fastapi.testclient import TestClient\n+\n+DESTROY_TIME = 0.1  # simulate work\n+\n+\n+class CallableDependency:\n+    def __init__(self) -> None:\n+        self.counter = 0\n+\n+\n+class SyncCallableDep(CallableDependency):\n+    def __call__(self) -> \"SyncCallableDep\":\n+        self.counter += 1\n+        return self\n+\n+\n+class AsyncCallableDep(CallableDependency):\n+    async def __call__(self) -> \"AsyncCallableDep\":\n+        self.counter += 1\n+        return self\n+\n+\n+class LifespanEvents:\n+    def __init__(self) -> None:\n+        self.destroying = Event()\n+        self.destroyed = Event()\n+\n+\n+class GeneratorDependency:\n+    def __init__(self):\n+        self.counter = 0\n+        self.lifespan_events: List[LifespanEvents] = []\n+\n+\n+class SyncGeneratorDep(GeneratorDependency):\n+    def __call__(self) -> Generator[\"SyncGeneratorDep\", None, None]:\n+        self.counter += 1\n+        events = LifespanEvents()\n+        self.lifespan_events.append(events)\n+        yield self\n+        events.destroying.set()\n+        sleep(DESTROY_TIME)  # simulate work\n+        events.destroyed.set()\n+\n+\n+class AsyncGeneratorDep(GeneratorDependency):\n+    async def __call__(self) -> AsyncGenerator[\"AsyncGeneratorDep\", None]:\n+        self.counter += 1\n+        events = LifespanEvents()\n+        self.lifespan_events.append(events)\n+        yield self\n+        events.destroying.set()\n+        await asyncio.sleep(DESTROY_TIME)  # simulate work\n+        events.destroyed.set()\n+\n+\n+@pytest.mark.parametrize(\"dep_cls\", (SyncGeneratorDep, AsyncGeneratorDep))\n+def test_request_lifetime_context_manager(dep_cls: Callable[[], GeneratorDependency]):\n+\n+    dep = dep_cls()\n+\n+    app = FastAPI()\n+\n+    @app.get(\"/\", dependencies=[Depends(dep, lifetime=DependencyLifetime.request)])\n+    def root():\n+        assert not dep.lifespan_events[-1].destroying.is_set()\n+\n+    with TestClient(app) as client:\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 1\n+        assert dep.lifespan_events[0].destroying.is_set()\n+        assert dep.lifespan_events[0].destroyed.wait(DESTROY_TIME)\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 2\n+        assert dep.lifespan_events[1].destroyed.wait(DESTROY_TIME)\n+\n+\n+@pytest.mark.parametrize(\"dep_cls\", (SyncCallableDep, AsyncCallableDep))\n+def test_request_lifetime_callable(dep_cls: Callable[[], CallableDependency]):\n+\n+    dep = dep_cls()\n+\n+    app = FastAPI()\n+\n+    @app.get(\"/\", dependencies=[Depends(dep, lifetime=DependencyLifetime.request)])\n+    def root():\n+        ...\n+\n+    with TestClient(app) as client:\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 1\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 2\n+\n+\n+@pytest.mark.parametrize(\"dep_cls\", (SyncGeneratorDep, AsyncGeneratorDep))\n+def test_app_lifetime_context_manager(dep_cls: Callable[[], GeneratorDependency]):\n+\n+    dep = dep_cls()\n+\n+    app = FastAPI()\n+\n+    @app.get(\"/\", dependencies=[Depends(dep, lifetime=DependencyLifetime.app)])\n+    def root():\n+        assert not dep.lifespan_events[-1].destroying.is_set()\n+\n+    with TestClient(app) as client:\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 1\n+        assert not dep.lifespan_events[0].destroying.is_set()\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 2\n+        assert not dep.lifespan_events[1].destroying.is_set()\n+    assert all(e.destroyed.is_set() for e in dep.lifespan_events)\n+\n+\n+@pytest.mark.parametrize(\"dep_cls\", (SyncCallableDep, AsyncCallableDep))\n+def test_app_lifetime_callable(dep_cls: Callable[[], CallableDependency]):\n+\n+    dep = dep_cls()\n+\n+    app = FastAPI()\n+\n+    @app.get(\"/\", dependencies=[Depends(dep, lifetime=DependencyLifetime.app)])\n+    def root():\n+        ...\n+\n+    with TestClient(app) as client:\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 1\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 2\n+\n+\n+@pytest.mark.parametrize(\"dep_cls\", (SyncGeneratorDep, AsyncGeneratorDep))\n+def test_endpoint_lifetime_context_manager(dep_cls: Callable[[], GeneratorDependency]):\n+\n+    dep = dep_cls()\n+\n+    app = FastAPI()\n+\n+    @app.get(\"/\", dependencies=[Depends(dep, lifetime=DependencyLifetime.endpoint)])\n+    def root():\n+        assert not dep.lifespan_events[-1].destroying.is_set()\n+\n+    with TestClient(app) as client:\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 1\n+        assert dep.lifespan_events[0].destroyed.is_set()\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 2\n+        assert dep.lifespan_events[1].destroyed.is_set()\n+\n+\n+def test_endpoint_lifetime_context_manager_cleanup_raises_HTTPException():\n+    def error_gen():\n+        yield\n+        raise HTTPException(400)  # should set status code\n+\n+    app = FastAPI()\n+\n+    called = False\n+\n+    @app.get(\n+        \"/\", dependencies=[Depends(error_gen, lifetime=DependencyLifetime.endpoint)]\n+    )\n+    def root():\n+        nonlocal called\n+        called = True\n+\n+    with TestClient(app) as client:\n+        res = client.get(\"/\")\n+        assert res.status_code == 400\n+        assert called\n+\n+\n+def test_endpoint_lifetime_context_manager_cleanup_raises_Exception():\n+    def error_gen():\n+        yield\n+        raise Exception()  # results in 500 status code\n+\n+    app = FastAPI()\n+\n+    called = False\n+\n+    @app.get(\n+        \"/\", dependencies=[Depends(error_gen, lifetime=DependencyLifetime.endpoint)]\n+    )\n+    def root():\n+        nonlocal called\n+        called = True\n+\n+    with TestClient(app, raise_server_exceptions=False) as client:\n+        assert client.get(\"/\").status_code == 500\n+        assert called\n+\n+\n+@pytest.mark.parametrize(\"dep_cls\", (SyncCallableDep, AsyncCallableDep))\n+def test_endpoint_lifetime_callable(dep_cls: Callable[[], CallableDependency]):\n+\n+    dep = dep_cls()\n+\n+    app = FastAPI()\n+\n+    @app.get(\"/\", dependencies=[Depends(dep, lifetime=DependencyLifetime.endpoint)])\n+    def root():\n+        ...\n+\n+    with TestClient(app) as client:\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 1\n+        assert client.get(\"/\").status_code == 200\n+        assert dep.counter == 2\ndiff --git a/tests/test_lifespan_dependencies.py b/tests/test_lifespan_dependencies.py\nnew file mode 100644\nindex 0000000000000..7f8198b3d6520\n--- /dev/null\n+++ b/tests/test_lifespan_dependencies.py\n@@ -0,0 +1,185 @@\n+from typing import Callable\n+\n+import pytest\n+from fastapi import Depends, FastAPI, Request\n+from fastapi.exceptions import DependencyResolutionError\n+from fastapi.testclient import TestClient\n+\n+\n+class BaseDependency:\n+    def __init__(self) -> None:\n+        self.counter = 0\n+        self.constructed, self.destructed = False, False\n+\n+\n+class SyncCallable(BaseDependency):\n+    def __call__(self) -> \"SyncCallable\":\n+        self.counter += 1\n+        self.constructed, self.destructed = True, True\n+        return self\n+\n+\n+class AsyncCallable(BaseDependency):\n+    async def __call__(self) -> \"AsyncCallable\":\n+        self.counter += 1\n+        self.constructed, self.destructed = True, True\n+        return self\n+\n+\n+class SyncGenerator(BaseDependency):\n+    def __call__(self) -> \"SyncGenerator\":\n+        self.counter += 1\n+        self.constructed = True\n+        yield self\n+        self.destructed = True\n+\n+\n+class AsyncGenerator(BaseDependency):\n+    async def __call__(self) -> \"AsyncGenerator\":\n+        self.counter += 1\n+        self.constructed = True\n+        yield self\n+        self.destructed = True\n+\n+\n+@pytest.mark.parametrize(\n+    \"dependency_cls, stateless\",\n+    [\n+        (SyncCallable, True),\n+        (AsyncCallable, True),\n+        (SyncGenerator, False),\n+        (AsyncGenerator, False),\n+    ],\n+)\n+def test_startup_dependencies(\n+    dependency_cls: Callable[[], BaseDependency], stateless: bool\n+):\n+\n+    dependency = dependency_cls()\n+\n+    def startup(placeholder: None = Depends(dependency)):\n+        ...\n+\n+    app = FastAPI(on_startup=[startup])\n+\n+    with TestClient(app):\n+        assert dependency.constructed\n+        assert dependency.destructed == stateless\n+    assert dependency.destructed\n+\n+\n+@pytest.mark.parametrize(\n+    \"dependency_cls, stateless\",\n+    [\n+        (SyncCallable, True),\n+        (AsyncCallable, True),\n+        (SyncGenerator, False),\n+        (AsyncGenerator, False),\n+    ],\n+)\n+def test_shutdown_dependencies(\n+    dependency_cls: Callable[[], BaseDependency], stateless: bool\n+):\n+\n+    dependency = dependency_cls()\n+\n+    def shutdown(placeholder: dependency_cls = Depends(dependency)):\n+        ...\n+\n+    app = FastAPI(on_shutdown=[shutdown])\n+\n+    with TestClient(app):\n+        assert not dependency.constructed\n+    assert dependency.destructed\n+\n+\n+def test_dependency_reset_on_shutdown():\n+    \"\"\"lifespan dependencies should be reset when the app shuts down\"\"\"\n+    dependency = SyncCallable()\n+\n+    def startup(placeholder: SyncCallable = Depends(dependency)):\n+        ...\n+\n+    app = FastAPI(on_startup=[startup])\n+\n+    for lifecycle in range(2):\n+        with TestClient(app):\n+            assert dependency.constructed\n+            assert dependency.counter == lifecycle + 1\n+        assert dependency.destructed\n+\n+\n+@pytest.mark.parametrize(\"use_cache\", (True, False))\n+def test_dependency_caching(use_cache: bool):\n+    \"\"\"Startup/shutdown dependencies are cached, unless `use_cache=False` is passed\"\"\"\n+\n+    def child_dep():\n+        return object()\n+\n+    class ParentDep(BaseDependency):\n+        def __call__(self, child: object = Depends(child_dep)) -> \"ParentDep\":\n+            self.counter += 1\n+            self.child = child\n+            return self\n+\n+    parent_dep = ParentDep()\n+\n+    def startup(\n+        parent: ParentDep = Depends(parent_dep),\n+        child: object = Depends(child_dep, use_cache=use_cache),\n+    ):\n+        assert (parent.child is child) == use_cache\n+\n+    app = FastAPI(on_startup=[startup])\n+\n+    with TestClient(app):\n+        ...\n+\n+\n+def test_overrides():\n+    \"\"\"Dependency overrides set BEFORE startup should be honored\"\"\"\n+\n+    def real() -> int:\n+        return 1\n+\n+    def fake() -> int:\n+        return 2\n+\n+    class StartupRecorder:\n+        v = None\n+\n+        def __call__(self, v: int = Depends(real)):\n+            self.v = v\n+\n+    startup = StartupRecorder()\n+\n+    app = FastAPI(on_startup=[startup])\n+\n+    with TestClient(app):\n+        assert startup.v == 1  # from real\n+\n+    app.dependency_overrides[real] = fake\n+    with TestClient(app):\n+        assert startup.v == 2  # from fake\n+\n+\n+def test_startup_requests_request():\n+    \"\"\"Startup events cannot depend on Request, even indirectly\"\"\"\n+\n+    def dep(placeholder: Request):\n+        ...  # pragma: no cover\n+\n+    def startup_direct(placeholder: Request):\n+        ...  # pragma: no cover\n+\n+    def startup_indirect(placeholder: None = Depends(dep)):\n+        ...  # pragma: no cover\n+\n+    for startup in (startup_direct, startup_indirect):\n+        app = FastAPI(on_startup=[startup])\n+\n+        with pytest.raises(\n+            DependencyResolutionError, match=\"cannot depend on connection parameters\"\n+        ):\n+            with TestClient(app):\n+                ...  # pragma: no cover\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR implements a robust system for handling synchronous and asynchronous dependency lifespans in FastAPI. Key decisions include leveraging `AsyncContextStack` for managing app lifetimes and caching dependencies efficiently. The change redefines the lifecycle events, allowing users to specify dependencies' lifespan flexibly. However, compatibility with Starlette's existing lifespan hooks remains a concern; integrating this feature risks conflicts with existing startup hooks. Some questions about caching behavior and thread-safety remain, suggesting the need for clear documentation and possibly future adjustments to ensure seamless integration. Great work overall!"
      }
    ],
    "token_estimation": 6939.25
  },
  {
    "index": 10,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/docs/en/docs/advanced/sql-databases-sqlalchemy.md b/docs/en/docs/advanced/sql-databases-sqlalchemy.md\nnew file mode 100644\nindex 0000000000000..ab22087d31f3a\n--- /dev/null\n+++ b/docs/en/docs/advanced/sql-databases-sqlalchemy.md\n@@ -0,0 +1,85 @@\n+# Async Databases with SQLAlchemy\n+\n+This tutorial will cover the usage of SQLAlchemy async parts as an ORM.\n+\n+!!! tip\n+    We strongly suggest going through the non async tutorial first ([SQL (Relational) Databases](../tutorial/sql-databases.md){.internal-link target=_blank}), since this tutorial will only cover the async parts of SQLAlchemy.\n+\n+!!! warning\n+    This tutorial expects SQLAlchemy >= 1.4.\n+\n+## File structure\n+\n+For this example, let's say you have a directory named `my_super_project` that contains a sub-directory called `sql_app` with a structure like this:\n+\n+```\n+.\n+└── sql_app\n+    ├── __init__.py\n+    ├── crud.py\n+    ├── database.py\n+    ├── main.py\n+    ├── models.py\n+    └── schemas.py\n+```\n+\n+The file `__init__.py` is just an empty file, but it tells Python that `sql_app` with all its modules (Python files) is a package.\n+\n+Now let's see what each file/module does.\n+\n+## Create the `SQLAlchemy` parts\n+\n+To use the async parts you will need to import `create_async_engine` instead of the base engine.\n+\n+```Python hl_lines=\"1  4  7\"\n+{!../../../docs_src/async_sql_databases/sql_app/database.py!}\n+```\n+\n+!!! tip\n+    If your using PostgreSQL you need to append `asyncpg` to the database string, as shown above.\n+\n+    You will also need to `pip install asyncpg`\n+\n+## Create models and schemas\n+\n+This step in unchanged from the non-async way, so we'll just copy the code in, if you want more detail on how it works ([SQL (Relational) Databases](../tutorial/sql-databases.md){.internal-link target=_blank}).\n+\n+```Python\n+{!../../../docs_src/async_sql_databases/sql_app/models.py!}\n+```\n+\n+```Python\n+{!../../../docs_src/async_sql_databases/sql_app/schemas.py!}\n+```\n+\n+## CRUD utils\n+\n+```Python\n+{!../../../docs_src/async_sql_databases/sql_app/crud.py!}\n+```\n+\n+!!! Note\n+    Notice that as we communicate with the database using `await`, the *function* is declared with `async`.\n+\n+## Main FastAPI app\n+\n+On startup we run the engine to create all the declarative_base models, you can also drop all of them on each start.\n+\n+Notice how we are creating an instance of `AsyncSession` instead of the usual `Session`, this is also what we pass as the db type.\n+\n+```Python\n+{!../../../docs_src/async_sql_databases/sql_app/main.py!}\n+```\n+\n+## Check it\n+\n+You can copy this code as is, and see the docs at <a href=\"http://127.0.0.1:8000/docs\" class=\"external-link\" target=\"_blank\">http://127.0.0.1:8000/docs</a>.\n+\n+There you can see all your API documented and interact with it:\n+\n+<img src=\"/img/tutorial/sql-databases/image01.png\">\n+\n+\n+## More info\n+\n+You can read more about <a href=\"https://docs.sqlalchemy.org/en/14/orm/extensions/asyncio.html\" class=\"external-link\" target=\"_blank\">`SQLAlchemy` at its Docs page</a>.\ndiff --git a/docs_src/async_sql_databases/sql_app/crud.py b/docs_src/async_sql_databases/sql_app/crud.py\nnew file mode 100644\nindex 0000000000000..89620e4ddc9bc\n--- /dev/null\n+++ b/docs_src/async_sql_databases/sql_app/crud.py\n@@ -0,0 +1,50 @@\n+from sqlalchemy import select\n+from sqlalchemy.ext.asyncio import AsyncSession\n+\n+from . import models, schemas\n+\n+\n+async def get_user(db: AsyncSession, user_id: int):\n+    db_execute = await db.execute(select(models.User).where(models.User.id == user_id))\n+    return db_execute.scalars().first()\n+\n+\n+async def get_user_by_email(db: AsyncSession, email: str):\n+    db_execute = await db.execute(select(models.User).where(models.User.email == email))\n+    return db_execute.scalars().first()\n+\n+\n+async def get_users(db: AsyncSession, skip: int = 0, limit: int = 100):\n+    db_execute = await db.execute(select(models.User).offset(skip).limit(limit))\n+    return db_execute.scalars().all()\n+\n+\n+async def create_user(db: AsyncSession, user: schemas.UserCreate):\n+    fake_hashed_password = user.password + \"notreallyhashed\"\n+    db_user = models.User(email=user.email, hashed_password=fake_hashed_password)\n+    db.add(db_user)\n+    await db.commit()\n+    await db.refresh(db_user)\n+    return db_user\n+\n+\n+async def delete_user(db: AsyncSession, user_id: int):\n+    db_execute = await db.execute(select(models.User).where(models.User.id == user_id))\n+    db_user = db_execute.scalars().first()\n+    if db_user is None:\n+        raise HTTPException(status_code=404, detail=\"User not found\")\n+    await db.delete(db_user)\n+    await db.commit()\n+\n+\n+async def get_items(db: AsyncSession, skip: int = 0, limit: int = 100):\n+    db_execute = await db.execute(select(models.Item).offset(skip).limit(limit))\n+    return db_execute.scalars().all()\n+\n+\n+async def create_user_item(db: AsyncSession, item: schemas.ItemCreate, user_id: int):\n+    db_item = models.Item(**item.dict(), owner_id=user_id)\n+    db.add(db_item)\n+    await db.commit()\n+    await db.refresh(db_item)\n+    return db_item\ndiff --git a/docs_src/async_sql_databases/sql_app/main.py b/docs_src/async_sql_databases/sql_app/main.py\nnew file mode 100644\nindex 0000000000000..87438cf6d5532\n--- /dev/null\n+++ b/docs_src/async_sql_databases/sql_app/main.py\n@@ -0,0 +1,67 @@\n+from typing import List\n+\n+from fastapi import Depends, FastAPI, HTTPException\n+from sqlalchemy.ext.asyncio import AsyncSession\n+\n+from . import crud, schemas\n+from .database import Base, engine\n+\n+app = FastAPI()\n+\n+\n+@app.on_event(\"startup\")\n+async def start_db():\n+    async with engine.begin() as conn:\n+        # await conn.run_sync(Base.metadata.drop_all)\n+        await conn.run_sync(Base.metadata.create_all)\n+\n+\n+# Dependency\n+async def get_db():\n+    session = AsyncSession(engine, expire_on_commit=True)\n+    try:\n+        yield session\n+    finally:\n+        await session.close()\n+\n+\n+@app.post(\"/users/\", response_model=schemas.User)\n+async def create_user(user: schemas.UserCreate, db: AsyncSession = Depends(get_db)):\n+    db_user = await crud.get_user_by_email(db, email=user.email)\n+    if db_user:\n+        raise HTTPException(status_code=400, detail=\"Email already registered\")\n+    return await crud.create_user(db=db, user=user)\n+\n+\n+@app.get(\"/users/\", response_model=List[schemas.User])\n+async def read_users(\n+    skip: int = 0, limit: int = 100, db: AsyncSession = Depends(get_db)\n+):\n+    return await crud.get_users(db, skip=skip, limit=limit)\n+\n+\n+@app.get(\"/users/{user_id}\", response_model=schemas.User)\n+async def read_user(user_id: int, db: AsyncSession = Depends(get_db)):\n+    db_user = await crud.get_user(db, user_id=user_id)\n+    if db_user is None:\n+        raise HTTPException(status_code=404, detail=\"User not found\")\n+    return db_user\n+\n+\n+@app.delete(\"/users/{user_id}\", response_model=schemas.User)\n+async def delete_user(user_id: int, db: AsyncSession = Depends(get_db)):\n+    await crud.delete_user(db, user_id=user_id)\n+\n+\n+@app.post(\"/users/{user_id}/items/\", response_model=schemas.Item)\n+async def create_item_for_user(\n+    user_id: int, item: schemas.ItemCreate, db: AsyncSession = Depends(get_db)\n+):\n+    return await crud.create_user_item(db=db, item=item, user_id=user_id)\n+\n+\n+@app.get(\"/items/\", response_model=List[schemas.Item])\n+async def read_items(\n+    skip: int = 0, limit: int = 100, db: AsyncSession = Depends(get_db)\n+):\n+    return await crud.get_items(db, skip=skip, limit=limit)\ndiff --git a/docs_src/async_sql_databases/sql_app/tests/test_sql_app.py b/docs_src/async_sql_databases/sql_app/tests/test_sql_app.py\nnew file mode 100644\nindex 0000000000000..f5710f23d5520\n--- /dev/null\n+++ b/docs_src/async_sql_databases/sql_app/tests/test_sql_app.py\n@@ -0,0 +1,50 @@\n+from fastapi.testclient import TestClient\n+from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n+\n+from ..database import Base\n+from ..main import app, get_db\n+\n+SQLALCHEMY_DATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\n+\n+# connect_args is ONLY for sqlite, remove if using PostgreSQL or other.\n+engine = create_async_engine(\n+    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n+)\n+\n+\n+@app.on_event(\"startup\")\n+async def start_db():\n+    async with engine.begin() as conn:\n+        await conn.run_sync(Base.metadata.drop_all)\n+        await conn.run_sync(Base.metadata.create_all)\n+\n+\n+# Dependency\n+async def override_get_db():\n+    session = AsyncSession(engine)\n+    try:\n+        yield session\n+    finally:\n+        await session.close()\n+\n+\n+app.dependency_overrides[get_db] = override_get_db\n+\n+\n+def test_create_user():\n+    with TestClient(app) as client:\n+        response = client.post(\n+            \"/users/\",\n+            json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"},\n+        )\n+        assert response.status_code == 200, response.text\n+        data = response.json()\n+        assert data[\"email\"] == \"deadpool@example.com\"\n+        assert \"id\" in data\n+        user_id = data[\"id\"]\n+\n+        response = client.get(f\"/users/{user_id}\")\n+        assert response.status_code == 200, response.text\n+        data = response.json()\n+        assert data[\"email\"] == \"deadpool@example.com\"\n+        assert data[\"id\"] == user_id\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR discusses an unresolved issue with `pydantic`'s `response_model`, highlighting that the test fails due to this. You provided workarounds and noted the nuances of async SQLAlchemy, particularly around relationships and session management. You've identified the importance of `lazy` loading options for better performance and suggested removing the `\"check_same_thread\"` parameter for PostgreSQL. Additionally, the `get_db` dependency is causing a `TypeError`, which needs addressing, while a working solution is shared using `AsyncGenerator`. Further documentation on these async behaviors would be beneficial."
      }
    ],
    "token_estimation": 2463.25
  },
  {
    "index": 11,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/whisper/transcribe.py b/whisper/transcribe.py\nindex e80bede1d..1c075a201 100644\n--- a/whisper/transcribe.py\n+++ b/whisper/transcribe.py\n@@ -330,17 +393,71 @@ def new_segment(\n                     append_punctuations=append_punctuations,\n                     last_speech_timestamp=last_speech_timestamp,\n                 )\n-                word_end_timestamps = [\n-                    w[\"end\"] for s in current_segments for w in s[\"words\"]\n-                ]\n-                if len(word_end_timestamps) > 0:\n-                    last_speech_timestamp = word_end_timestamps[-1]\n-                if not single_timestamp_ending and len(word_end_timestamps) > 0:\n-                    seek_shift = round(\n-                        (word_end_timestamps[-1] - time_offset) * FRAMES_PER_SECOND\n-                    )\n-                    if seek_shift > 0:\n-                        seek = previous_seek + seek_shift\n+\n+                if not single_timestamp_ending:\n+                    last_word_end = get_end(current_segments)\n+                    if last_word_end is not None and last_word_end > time_offset:\n+                        seek = round(last_word_end * FRAMES_PER_SECOND)\n+\n+                # skip silence before possible hallucinations\n+                if hallucination_silence_threshold is not None:\n+                    threshold = hallucination_silence_threshold\n+                    if not single_timestamp_ending:\n+                        last_word_end = get_end(current_segments)\n+                        if last_word_end is not None and last_word_end > time_offset:\n+                            remaining_duration = window_end_time - last_word_end\n+                            if remaining_duration > threshold:\n+                                seek = round(last_word_end * FRAMES_PER_SECOND)\n+                            else:\n+                                seek = previous_seek + segment_size\n+\n+                    # if first segment might be a hallucination, skip leading silence\n+                    first_segment = next_words_segment(current_segments)\n+                    if first_segment is not None and is_segment_anomaly(first_segment):\n+                        gap = first_segment[\"start\"] - time_offset\n+                        if gap > threshold:\n+                            seek = previous_seek + round(gap * FRAMES_PER_SECOND)\n+                            continue\n+\n+                    # skip silence before any possible hallucination that is surrounded\n+                    # by silence or more hallucinations\n+                    hal_last_end = last_speech_timestamp\n+                    for si in range(len(current_segments)):\n+                        segment = current_segments[si]\n+                        if not segment[\"words\"]:\n+                            continue\n+                        if is_segment_anomaly(segment):\n+                            next_segment = next_words_segment(\n+                                current_segments[si + 1 :]\n+                            )\n+                            if next_segment is not None:\n+                                hal_next_start = next_segment[\"words\"][0][\"start\"]\n+                            else:\n+                                hal_next_start = time_offset + segment_duration\n+                            silence_before = (\n+                                segment[\"start\"] - hal_last_end > threshold\n+                                or segment[\"start\"] < threshold\n+                                or segment[\"start\"] - time_offset < 2.0\n+                            )\n+                            silence_after = (\n+                                hal_next_start - segment[\"end\"] > threshold\n+                                or is_segment_anomaly(next_segment)\n+                                or window_end_time - segment[\"end\"] < 2.0\n+                            )\n+                            if silence_before and silence_after:\n+                                seek = round(\n+                                    max(time_offset + 1, segment[\"start\"])\n+                                    * FRAMES_PER_SECOND\n+                                )\n+                                if content_duration - segment[\"end\"] < threshold:\n+                                    seek = content_frames\n+                                current_segments[si:] = []\n+                                break\n+                        hal_last_end = segment[\"end\"]\n+\n+                last_word_end = get_end(current_segments)\n+                if last_word_end is not None:\n+                    last_speech_timestamp = last_word_end\n \n             if verbose:\n                 for segment in current_segments:\n\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The tests reveal inconsistencies where `hallucination_silence_threshold` affects segment transcriptions, causing entire non-hallucinating segments to skip in some cases. While the original Whisper behavior cropped segments accurately, the new logic sometimes introduces hallucinations instead of mitigating them. The proposed fix reverts to previous mel segment padding logic to restore expected outcomes, noting that different padding behavior may contribute to discrepancies. Consider refining anomaly detection thresholds to balance false positives and negatives more effectively, and ensure clarity around segment processing criteria to avoid confusion in functionality."
      }
    ],
    "token_estimation": 1345.0
  },
  {
    "index": 12,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/examples/confidence_per_token.py b/examples/confidence_per_token.py\nnew file mode 100644\nindex 000000000..0bf2a30d7\n--- /dev/null\n+++ b/examples/confidence_per_token.py\n@@ -0,0 +1,59 @@\n+# IMPORTANT: This is just for using the local whisper dir as the package directly. Delete until next comment when just installing whisper normally.\n+import sys\n+from pathlib import Path\n+sys.path.insert(0, str(Path(__file__).resolve().parents[1]))\n+# end of dev import\n+import whisper\n+\n+import colorsys\n+from typing import List\n+from whisper.tokenizer import get_tokenizer\n+from colorama import init, Style\n+\n+\n+print('Loading model')\n+model = whisper.load_model(\"large\")\n+\n+\n+print('Loading audio') # load audio and pad/trim it to fit 30 seconds\n+audio = whisper.load_audio(\"samples/your_audio.wav\")\n+audio = whisper.pad_or_trim(audio)\n+\n+\n+mel = whisper.log_mel_spectrogram(audio).to(model.device) # make log-Mel spectrogram and move to the same device as the model\n+\n+\n+detect_lang = False\n+language = \"en\"\n+if detect_lang: # detect the spoken language\n+    print('Detecting language')\n+    _, probs = model.detect_language(mel)\n+    print(f\"Detected language: {max(probs, key=probs.get)}\")\n+    language=max(probs, key=probs.get)\n+\n+\n+print('Decoding audio') # decode the audio\n+options = whisper.DecodingOptions()\n+result = whisper.decode(model, mel, options)\n+\n+\n+def get_colored_text(tokens: List[int], token_probs: List[float], tokenizer, prompt: str=\"\"):\n+    init(autoreset=False)  # Initialize colorama\n+    text_tokens = [tokenizer.decode([t]) for t in tokens]\n+\n+    output_text = \"\"\n+    for i, (token, prob) in enumerate(zip(text_tokens, token_probs)):\n+        # Interpolate between red and green in the HSV color space\n+        r, g, b = colorsys.hsv_to_rgb(prob * (1/3), 1, 1)\n+        r, g, b = int(r * 255), int(g * 255), int(b * 255)\n+        color_code = f\"\\033[38;2;{r};{g};{b}m\"\n+\n+        colored_token = f\"{color_code}{Style.BRIGHT}{token}{Style.RESET_ALL}\"\n+        output_text += colored_token\n+\n+    return output_text\n+\n+\n+tokenizer = get_tokenizer(multilingual=model.is_multilingual, language=language, task=options.task)\n+print(get_colored_text(result.tokens, result.token_probs, tokenizer))  # print text with fancy confidence colors\n+# HINT: when using a prompt, you must provide it in the get_colored_text as well\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR shows promise for enhancing output verification with Subtitle Edit, but lacks a command-line option for additional subtitles. The colorful CLI output is interesting, although it complicates the main codebase with limited utility, which @jongwook rightfully notes. Using per-token probabilities seems niche and could induce unnecessary latency. The decoding logic already incurs a significant computational cost; a more efficient approach may be to implement an additional forward pass. Some issues remain regarding accuracy when language settings are applied, which should be addressed before merging."
      }
    ],
    "token_estimation": 740.0
  },
  {
    "index": 13,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 5b819b1406a2..a20e88749f5a 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1764,6 +1776,63 @@ def _check_default_pk(cls):\n             ]\n         return []\n \n+    @classmethod\n+    def _check_composite_pk(cls):\n+        errors = []\n+        meta = cls._meta\n+        pk = meta.pk\n+\n+        if not isinstance(pk, CompositePrimaryKey):\n+            return errors\n+\n+        seen_columns = defaultdict(list)\n+\n+        for field_name in pk.field_names:\n+            hint = None\n+\n+            try:\n+                field = meta.get_field(field_name)\n+            except FieldDoesNotExist:\n+                field = None\n+\n+            if not field:\n+                hint = f\"{field_name!r} is not a valid field.\"\n+            elif not field.column:\n+                hint = f\"{field_name!r} field has no column.\"\n+            elif field.null:\n+                hint = f\"{field_name!r} field may not set 'null=True'.\"\n+            elif field.generated:\n+                hint = f\"{field_name!r} field is a generated field.\"\n+            else:\n+                seen_columns[field.column].append(field_name)\n+\n+            if hint:\n+                errors.append(\n+                    checks.Error(\n+                        f\"{field_name!r} cannot be included in the composite primary \"\n+                        \"key.\",\n+                        hint=hint,\n+                        obj=cls,\n+                        id=\"models.E042\",\n+                    )\n+                )\n+\n+        for column, field_names in seen_columns.items():\n+            if len(field_names) > 1:\n+                field_name, *rest = field_names\n+                duplicates = \", \".join(repr(field) for field in rest)\n+                errors.append(\n+                    checks.Error(\n+                        f\"{duplicates} cannot be included in the composite primary \"\n+                        \"key.\",\n+                        hint=f\"{duplicates} and {field_name!r} are the same fields.\",\n+                        obj=cls,\n+                        id=\"models.E042\",\n+                    )\n+                )\n+\n+        return errors\n+\n     @classmethod\n     def _check_db_table_comment(cls, databases):\n         if not cls._meta.db_table_comment:\ndiff --git a/django/db/models/fields/composite.py b/django/db/models/fields/composite.py\nnew file mode 100644\nindex 000000000000..550a440dcf39\n--- /dev/null\n+++ b/django/db/models/fields/composite.py\n@@ -0,0 +1,150 @@\n+from django.core import checks\n+from django.db.models import NOT_PROVIDED, Field\n+from django.db.models.expressions import ColPairs\n+from django.db.models.fields.tuple_lookups import (\n+    TupleExact,\n+    TupleGreaterThan,\n+    TupleGreaterThanOrEqual,\n+    TupleIn,\n+    TupleIsNull,\n+    TupleLessThan,\n+    TupleLessThanOrEqual,\n+)\n+from django.utils.functional import cached_property\n+\n+\n+class CompositeAttribute:\n+    def __init__(self, field):\n+        self.field = field\n+\n+    @property\n+    def attnames(self):\n+        return [field.attname for field in self.field.fields]\n+\n+    def __get__(self, instance, cls=None):\n+        return tuple(getattr(instance, attname) for attname in self.attnames)\n+\n+    def __set__(self, instance, values):\n+        attnames = self.attnames\n+        length = len(attnames)\n+\n+        if values is None:\n+            values = (None,) * length\n+\n+        if not isinstance(values, (list, tuple)):\n+            raise ValueError(f\"{self.field.name!r} must be a list or a tuple.\")\n+        if length != len(values):\n+            raise ValueError(f\"{self.field.name!r} must have {length} elements.\")\n+\n+        for attname, value in zip(attnames, values):\n+            setattr(instance, attname, value)\n+\n+\n+class CompositePrimaryKey(Field):\n+    descriptor_class = CompositeAttribute\n+\n+    def __init__(self, *args, **kwargs):\n+        if (\n+            not args\n+            or not all(isinstance(field, str) for field in args)\n+            or len(set(args)) != len(args)\n+        ):\n+            raise ValueError(\"CompositePrimaryKey args must be unique strings.\")\n+        if len(args) == 1:\n+            raise ValueError(\"CompositePrimaryKey must include at least two fields.\")\n+        if kwargs.get(\"default\", NOT_PROVIDED) is not NOT_PROVIDED:\n+            raise ValueError(\"CompositePrimaryKey cannot have a default.\")\n+        if kwargs.get(\"db_default\", NOT_PROVIDED) is not NOT_PROVIDED:\n+            raise ValueError(\"CompositePrimaryKey cannot have a database default.\")\n+        if kwargs.setdefault(\"editable\", False):\n+            raise ValueError(\"CompositePrimaryKey cannot be editable.\")\n+        if not kwargs.setdefault(\"primary_key\", True):\n+            raise ValueError(\"CompositePrimaryKey must be a primary key.\")\n+        if not kwargs.setdefault(\"blank\", True):\n+            raise ValueError(\"CompositePrimaryKey must be blank.\")\n+\n+        self.field_names = args\n+        super().__init__(**kwargs)\n+\n+    def deconstruct(self):\n+        # args is always [] so it can be ignored.\n+        name, path, _, kwargs = super().deconstruct()\n+        return name, path, self.field_names, kwargs\n+\n+    @cached_property\n+    def fields(self):\n+        meta = self.model._meta\n+        return tuple(meta.get_field(field_name) for field_name in self.field_names)\n+\n+    @cached_property\n+    def columns(self):\n+        return tuple(field.column for field in self.fields)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        super().contribute_to_class(cls, name, private_only=private_only)\n+        cls._meta.pk = self\n+        setattr(cls, self.attname, self.descriptor_class(self))\n+\n+    def get_attname_column(self):\n+        return self.get_attname(), None\n+\n+    def __iter__(self):\n+        return iter(self.fields)\n+\n+    def __len__(self):\n+        return len(self.field_names)\n+\n+    @cached_property\n+    def cached_col(self):\n+        return ColPairs(self.model._meta.db_table, self.fields, self.fields, self)\n+\n+    def get_col(self, alias, output_field=None):\n+        if alias == self.model._meta.db_table and (\n+            output_field is None or output_field == self\n+        ):\n+            return self.cached_col\n+\n+        return ColPairs(alias, self.fields, self.fields, output_field)\n+\n+    def get_pk_value_on_save(self, instance):\n+        values = []\n+\n+        for field in self.fields:\n+            value = field.value_from_object(instance)\n+            if value is None:\n+                value = field.get_pk_value_on_save(instance)\n+            values.append(value)\n+\n+        return tuple(values)\n+\n+    def _check_field_name(self):\n+        if self.name == \"pk\":\n+            return []\n+        return [\n+            checks.Error(\n+                \"'CompositePrimaryKey' must be named 'pk'.\",\n+                obj=self,\n+                id=\"fields.E013\",\n+            )\n+        ]\n+\n+\n+CompositePrimaryKey.register_lookup(TupleExact)\n+CompositePrimaryKey.register_lookup(TupleGreaterThan)\n+CompositePrimaryKey.register_lookup(TupleGreaterThanOrEqual)\n+CompositePrimaryKey.register_lookup(TupleLessThan)\n+CompositePrimaryKey.register_lookup(TupleLessThanOrEqual)\n+CompositePrimaryKey.register_lookup(TupleIn)\n+CompositePrimaryKey.register_lookup(TupleIsNull)\n+\n+\n+def unnest(fields):\n+    result = []\n+\n+    for field in fields:\n+        if isinstance(field, CompositePrimaryKey):\n+            result.extend(field.fields)\n+        else:\n+            result.append(field)\n+\n+    return result\ndiff --git a/docs/topics/composite-primary-key.txt b/docs/topics/composite-primary-key.txt\nnew file mode 100644\nindex 000000000000..9e5234ca9faa\n--- /dev/null\n+++ b/docs/topics/composite-primary-key.txt\n@@ -0,0 +1,183 @@\n+======================\n+Composite primary keys\n+======================\n+\n+.. versionadded:: 5.2\n+\n+In Django, each model has a primary key. By default, this primary key consists\n+of a single field.\n+\n+In most cases, a single primary key should suffice. In database design,\n+however, defining a primary key consisting of multiple fields is sometimes\n+necessary.\n+\n+To use a composite primary key, when creating a model set the ``pk`` field to\n+be a :class:`.CompositePrimaryKey`::\n+\n+    class Product(models.Model):\n+        name = models.CharField(max_length=100)\n+\n+\n+    class Order(models.Model):\n+        reference = models.CharField(max_length=20, primary_key=True)\n+\n+\n+    class OrderLineItem(models.Model):\n+        pk = models.CompositePrimaryKey(\"product_id\", \"order_id\")\n+        product = models.ForeignKey(Product, on_delete=models.CASCADE)\n+        order = models.ForeignKey(Order, on_delete=models.CASCADE)\n+        quantity = models.IntegerField()\n+\n+This will instruct Django to create a composite primary key\n+(``PRIMARY KEY (product_id, order_id)``) when creating the table.\n+\n+A composite primary key is represented by a ``tuple``:\n+\n+.. code-block:: pycon\n+\n+    >>> product = Product.objects.create(name=\"apple\")\n+    >>> order = Order.objects.create(reference=\"A755H\")\n+    >>> item = OrderLineItem.objects.create(product=product, order=order, quantity=1)\n+    >>> item.pk\n+    (1, \"A755H\")\n+\n+You can assign a ``tuple`` to a composite primary key. This sets the associated\n+field values.\n+\n+.. code-block:: pycon\n+\n+    >>> item = OrderLineItem(pk=(2, \"B142C\"))\n+    >>> item.pk\n+    (2, \"B142C\")\n+    >>> item.product_id\n+    2\n+    >>> item.order_id\n+    \"B142C\"\n+\n+A composite primary key can also be filtered by a ``tuple``:\n+\n+.. code-block:: pycon\n+\n+    >>> OrderLineItem.objects.filter(pk=(1, \"A755H\")).count()\n+    1\n+\n+We're still working on composite primary key support for\n+:ref:`relational fields <cpk-and-relations>`, including\n+:class:`.GenericForeignKey` fields, and the Django admin. Models with composite\n+primary keys cannot be registered in the Django admin at this time. You can\n+expect to see this in future releases.\n+\n+Migrating to a composite primary key\n+====================================\n+\n+Django doesn't support migrating to, or from, a composite primary key after the\n+table is created. It also doesn't support adding or removing fields from the\n+composite primary key.\n+\n+If you would like to migrate an existing table from a single primary key to a\n+composite primary key, follow your database backend's instructions to do so.\n+\n+Once the composite primary key is in place, add the ``CompositePrimaryKey``\n+field to your model. This allows Django to recognize and handle the composite\n+primary key appropriately.\n+\n+While migration operations (e.g. ``AddField``, ``AlterField``) on primary key\n+fields are not supported, ``makemigrations`` will still detect changes.\n+\n+In order to avoid errors, it's recommended to apply such migrations with\n+``--fake``.\n+\n+Alternatively, :class:`.SeparateDatabaseAndState` may be used to execute the\n+backend-specific migrations and Django-generated migrations in a single\n+operation.\n+\n+.. _cpk-and-relations:\n+\n+Composite primary keys and relations\n+====================================\n+\n+:ref:`Relationship fields <relationship-fields>`, including\n+:ref:`generic relations <generic-relations>` do not support composite primary\n+keys.\n+\n+For example, given the ``OrderLineItem`` model, the following is not\n+supported::\n+\n+    class Foo(models.Model):\n+        item = models.ForeignKey(OrderLineItem, on_delete=models.CASCADE)\n+\n+Because ``ForeignKey`` currently cannot reference models with composite primary\n+keys.\n+\n+To work around this limitation, ``ForeignObject`` can be used as an\n+alternative::\n+\n+    class Foo(models.Model):\n+        item_order_id = models.IntegerField()\n+        item_product_id = models.CharField(max_length=20)\n+        item = models.ForeignObject(\n+            OrderLineItem,\n+            on_delete=models.CASCADE,\n+            from_fields=(\"item_order_id\", \"item_product_id\"),\n+            to_fields=(\"order_id\", \"product_id\"),\n+        )\n+\n+``ForeignObject`` is much like ``ForeignKey``, except that it doesn't create\n+any columns (e.g. ``item_id``), foreign key constraints or indexes in the\n+database.\n+\n+.. warning::\n+\n+    ``ForeignObject`` is an internal API. This means it is not covered by our\n+    :ref:`deprecation policy <internal-release-deprecation-policy>`.\n+\n+Composite primary keys and database functions\n+=============================================\n+\n+Many database functions only accept a single expression.\n+\n+.. code-block:: sql\n+\n+    MAX(\"order_id\")  -- OK\n+    MAX(\"product_id\", \"order_id\")  -- ERROR\n+\n+As a consequence, they cannot be used with composite primary key references as\n+they are composed of multiple column expressions.\n+\n+.. code-block:: python\n+\n+    Max(\"order_id\")  # OK\n+    Max(\"pk\")  # ERROR\n+\n+Composite primary keys in forms\n+===============================\n+\n+As a composite primary key is a virtual field, a field which doesn't represent\n+a single database column, this field is excluded from ModelForms.\n+\n+For example, take the following form::\n+\n+    class OrderLineItemForm(forms.ModelForm):\n+        class Meta:\n+            model = OrderLineItem\n+            fields = \"__all__\"\n+\n+This form does not have a form field ``pk`` for the composite primary key:\n+\n+.. code-block:: pycon\n+\n+    >>> OrderLineItemForm()\n+    <OrderLineItemForm bound=False, valid=Unknown, fields=(product;order;quantity)>\n+\n+Setting the primary composite field ``pk`` as a form field raises an unknown\n+field :exc:`.FieldError`.\n+\n+.. admonition:: Primary key fields are read only\n+\n+    If you change the value of a primary key on an existing object and then\n+    save it, a new object will be created alongside the old one (see\n+    :attr:`.Field.primary_key`).\n+\n+    This is also true of composite primary keys. Hence, you may want to set\n+    :attr:`.Field.editable` to ``False`` on all primary key fields to exclude\n+    them from ModelForms.\ndiff --git a/tests/composite_pk/fixtures/tenant.json b/tests/composite_pk/fixtures/tenant.json\nnew file mode 100644\nindex 000000000000..3eeff42fefde\n--- /dev/null\n+++ b/tests/composite_pk/fixtures/tenant.json\n@@ -0,0 +1,75 @@\n+[\n+    {\n+        \"pk\": 1,\n+        \"model\": \"composite_pk.tenant\",\n+        \"fields\": {\n+            \"id\": 1,\n+            \"name\": \"Tenant 1\"\n+        }\n+    },\n+    {\n+        \"pk\": 2,\n+        \"model\": \"composite_pk.tenant\",\n+        \"fields\": {\n+            \"id\": 2,\n+            \"name\": \"Tenant 2\"\n+        }\n+    },\n+    {\n+        \"pk\": 3,\n+        \"model\": \"composite_pk.tenant\",\n+        \"fields\": {\n+            \"id\": 3,\n+            \"name\": \"Tenant 3\"\n+        }\n+    },\n+    {\n+        \"pk\": [1, 1],\n+        \"model\": \"composite_pk.user\",\n+        \"fields\": {\n+            \"tenant_id\": 1,\n+            \"id\": 1,\n+            \"email\": \"user0001@example.com\"\n+        }\n+    },\n+    {\n+        \"pk\": [1, 2],\n+        \"model\": \"composite_pk.user\",\n+        \"fields\": {\n+            \"tenant_id\": 1,\n+            \"id\": 2,\n+            \"email\": \"user0002@example.com\"\n+        }\n+    },\n+    {\n+        \"pk\": [2, 3],\n+        \"model\": \"composite_pk.user\",\n+        \"fields\": {\n+            \"email\": \"user0003@example.com\"\n+        }\n+    },\n+    {\n+        \"model\": \"composite_pk.user\",\n+        \"fields\": {\n+            \"tenant_id\": 2,\n+            \"id\": 4,\n+            \"email\": \"user0004@example.com\"\n+        }\n+    },\n+    {\n+        \"pk\": [2, \"11111111-1111-1111-1111-111111111111\"],\n+        \"model\": \"composite_pk.post\",\n+        \"fields\": {\n+            \"tenant_id\": 2,\n+            \"id\": \"11111111-1111-1111-1111-111111111111\"\n+        }\n+    },\n+    {\n+        \"pk\": [2, \"ffffffff-ffff-ffff-ffff-ffffffffffff\"],\n+        \"model\": \"composite_pk.post\",\n+        \"fields\": {\n+            \"tenant_id\": 2,\n+            \"id\": \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n+        }\n+    }\n+]\ndiff --git a/tests/composite_pk/models/tenant.py b/tests/composite_pk/models/tenant.py\nnew file mode 100644\nindex 000000000000..ac0b3d9715a1\n--- /dev/null\n+++ b/tests/composite_pk/models/tenant.py\n@@ -0,0 +1,50 @@\n+from django.db import models\n+\n+\n+class Tenant(models.Model):\n+    name = models.CharField(max_length=10, default=\"\", blank=True)\n+\n+\n+class Token(models.Model):\n+    pk = models.CompositePrimaryKey(\"tenant_id\", \"id\")\n+    tenant = models.ForeignKey(Tenant, on_delete=models.CASCADE, related_name=\"tokens\")\n+    id = models.SmallIntegerField()\n+    secret = models.CharField(max_length=10, default=\"\", blank=True)\n+\n+\n+class BaseModel(models.Model):\n+    pk = models.CompositePrimaryKey(\"tenant_id\", \"id\")\n+    tenant = models.ForeignKey(Tenant, on_delete=models.CASCADE)\n+    id = models.SmallIntegerField(unique=True)\n+\n+    class Meta:\n+        abstract = True\n+\n+\n+class User(BaseModel):\n+    email = models.EmailField(unique=True)\n+\n+\n+class Comment(models.Model):\n+    pk = models.CompositePrimaryKey(\"tenant\", \"id\")\n+    tenant = models.ForeignKey(\n+        Tenant,\n+        on_delete=models.CASCADE,\n+        related_name=\"comments\",\n+    )\n+    id = models.SmallIntegerField(unique=True, db_column=\"comment_id\")\n+    user_id = models.SmallIntegerField()\n+    user = models.ForeignObject(\n+        User,\n+        on_delete=models.CASCADE,\n+        from_fields=(\"tenant_id\", \"user_id\"),\n+        to_fields=(\"tenant_id\", \"id\"),\n+        related_name=\"comments\",\n+    )\n+    text = models.TextField(default=\"\", blank=True)\n+\n+\n+class Post(models.Model):\n+    pk = models.CompositePrimaryKey(\"tenant_id\", \"id\")\n+    tenant = models.ForeignKey(Tenant, on_delete=models.CASCADE)\n+    id = models.UUIDField()\ndiff --git a/tests/composite_pk/test_aggregate.py b/tests/composite_pk/test_aggregate.py\nnew file mode 100644\nindex 000000000000..b5474c5218bc\n--- /dev/null\n+++ b/tests/composite_pk/test_aggregate.py\n@@ -0,0 +1,139 @@\n+from django.db import NotSupportedError\n+from django.db.models import Count, Q\n+from django.test import TestCase\n+\n+from .models import Comment, Tenant, User\n+\n+\n+class CompositePKAggregateTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.tenant_1 = Tenant.objects.create()\n+        cls.tenant_2 = Tenant.objects.create()\n+        cls.user_1 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=1,\n+            email=\"user0001@example.com\",\n+        )\n+        cls.user_2 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=2,\n+            email=\"user0002@example.com\",\n+        )\n+        cls.user_3 = User.objects.create(\n+            tenant=cls.tenant_2,\n+            id=3,\n+            email=\"user0003@example.com\",\n+        )\n+        cls.comment_1 = Comment.objects.create(id=1, user=cls.user_2, text=\"foo\")\n+        cls.comment_2 = Comment.objects.create(id=2, user=cls.user_1, text=\"bar\")\n+        cls.comment_3 = Comment.objects.create(id=3, user=cls.user_1, text=\"foobar\")\n+        cls.comment_4 = Comment.objects.create(id=4, user=cls.user_3, text=\"foobarbaz\")\n+        cls.comment_5 = Comment.objects.create(id=5, user=cls.user_3, text=\"barbaz\")\n+        cls.comment_6 = Comment.objects.create(id=6, user=cls.user_3, text=\"baz\")\n+\n+    def test_users_annotated_with_comments_id_count(self):\n+        user_1, user_2, user_3 = User.objects.annotate(Count(\"comments__id\")).order_by(\n+            \"pk\"\n+        )\n+\n+        self.assertEqual(user_1, self.user_1)\n+        self.assertEqual(user_1.comments__id__count, 2)\n+        self.assertEqual(user_2, self.user_2)\n+        self.assertEqual(user_2.comments__id__count, 1)\n+        self.assertEqual(user_3, self.user_3)\n+        self.assertEqual(user_3.comments__id__count, 3)\n+\n+    def test_users_annotated_with_aliased_comments_id_count(self):\n+        user_1, user_2, user_3 = User.objects.annotate(\n+            comments_count=Count(\"comments__id\")\n+        ).order_by(\"pk\")\n+\n+        self.assertEqual(user_1, self.user_1)\n+        self.assertEqual(user_1.comments_count, 2)\n+        self.assertEqual(user_2, self.user_2)\n+        self.assertEqual(user_2.comments_count, 1)\n+        self.assertEqual(user_3, self.user_3)\n+        self.assertEqual(user_3.comments_count, 3)\n+\n+    def test_users_annotated_with_comments_count(self):\n+        user_1, user_2, user_3 = User.objects.annotate(Count(\"comments\")).order_by(\"pk\")\n+\n+        self.assertEqual(user_1, self.user_1)\n+        self.assertEqual(user_1.comments__count, 2)\n+        self.assertEqual(user_2, self.user_2)\n+        self.assertEqual(user_2.comments__count, 1)\n+        self.assertEqual(user_3, self.user_3)\n+        self.assertEqual(user_3.comments__count, 3)\n+\n+    def test_users_annotated_with_comments_count_filter(self):\n+        user_1, user_2, user_3 = User.objects.annotate(\n+            comments__count=Count(\n+                \"comments\", filter=Q(pk__in=[self.user_1.pk, self.user_2.pk])\n+            )\n+        ).order_by(\"pk\")\n+\n+        self.assertEqual(user_1, self.user_1)\n+        self.assertEqual(user_1.comments__count, 2)\n+        self.assertEqual(user_2, self.user_2)\n+        self.assertEqual(user_2.comments__count, 1)\n+        self.assertEqual(user_3, self.user_3)\n+        self.assertEqual(user_3.comments__count, 0)\n+\n+    def test_count_distinct_not_supported(self):\n+        with self.assertRaisesMessage(\n+            NotSupportedError, \"COUNT(DISTINCT) doesn't support composite primary keys\"\n+        ):\n+            self.assertIsNone(\n+                User.objects.annotate(comments__count=Count(\"comments\", distinct=True))\n+            )\n+\n+    def test_user_values_annotated_with_comments_id_count(self):\n+        self.assertSequenceEqual(\n+            User.objects.values(\"pk\").annotate(Count(\"comments__id\")).order_by(\"pk\"),\n+            (\n+                {\"pk\": self.user_1.pk, \"comments__id__count\": 2},\n+                {\"pk\": self.user_2.pk, \"comments__id__count\": 1},\n+                {\"pk\": self.user_3.pk, \"comments__id__count\": 3},\n+            ),\n+        )\n+\n+    def test_user_values_annotated_with_filtered_comments_id_count(self):\n+        self.assertSequenceEqual(\n+            User.objects.values(\"pk\")\n+            .annotate(\n+                comments_count=Count(\n+                    \"comments__id\",\n+                    filter=Q(comments__text__icontains=\"foo\"),\n+                )\n+            )\n+            .order_by(\"pk\"),\n+            (\n+                {\"pk\": self.user_1.pk, \"comments_count\": 1},\n+                {\"pk\": self.user_2.pk, \"comments_count\": 1},\n+                {\"pk\": self.user_3.pk, \"comments_count\": 1},\n+            ),\n+        )\n+\n+    def test_filter_and_count_users_by_comments_fields(self):\n+        users = User.objects.filter(comments__id__gt=2).order_by(\"pk\")\n+        self.assertEqual(users.count(), 4)\n+        self.assertSequenceEqual(\n+            users, (self.user_1, self.user_3, self.user_3, self.user_3)\n+        )\n+\n+        users = User.objects.filter(comments__text__icontains=\"foo\").order_by(\"pk\")\n+        self.assertEqual(users.count(), 3)\n+        self.assertSequenceEqual(users, (self.user_1, self.user_2, self.user_3))\n+\n+        users = User.objects.filter(comments__text__icontains=\"baz\").order_by(\"pk\")\n+        self.assertEqual(users.count(), 3)\n+        self.assertSequenceEqual(users, (self.user_3, self.user_3, self.user_3))\n+\n+    def test_order_by_comments_id_count(self):\n+        self.assertSequenceEqual(\n+            User.objects.annotate(comments_count=Count(\"comments__id\")).order_by(\n+                \"-comments_count\"\n+            ),\n+            (self.user_3, self.user_1, self.user_2),\n+        )\ndiff --git a/tests/composite_pk/test_checks.py b/tests/composite_pk/test_checks.py\nnew file mode 100644\nindex 000000000000..02a162c31df5\n--- /dev/null\n+++ b/tests/composite_pk/test_checks.py\n@@ -0,0 +1,242 @@\n+from django.core import checks\n+from django.db import connection, models\n+from django.db.models import F\n+from django.test import TestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"composite_pk\")\n+class CompositePKChecksTests(TestCase):\n+    maxDiff = None\n+\n+    def test_composite_pk_must_be_unique_strings(self):\n+        test_cases = (\n+            (),\n+            (0,),\n+            (1,),\n+            (\"id\", False),\n+            (\"id\", \"id\"),\n+            ((\"id\",),),\n+        )\n+\n+        for i, args in enumerate(test_cases):\n+            with (\n+                self.subTest(args=args),\n+                self.assertRaisesMessage(\n+                    ValueError, \"CompositePrimaryKey args must be unique strings.\"\n+                ),\n+            ):\n+                models.CompositePrimaryKey(*args)\n+\n+    def test_composite_pk_must_include_at_least_2_fields(self):\n+        expected_message = \"CompositePrimaryKey must include at least two fields.\"\n+        with self.assertRaisesMessage(ValueError, expected_message):\n+            models.CompositePrimaryKey(\"id\")\n+\n+    def test_composite_pk_cannot_have_a_default(self):\n+        expected_message = \"CompositePrimaryKey cannot have a default.\"\n+        with self.assertRaisesMessage(ValueError, expected_message):\n+            models.CompositePrimaryKey(\"tenant_id\", \"id\", default=(1, 1))\n+\n+    def test_composite_pk_cannot_have_a_database_default(self):\n+        expected_message = \"CompositePrimaryKey cannot have a database default.\"\n+        with self.assertRaisesMessage(ValueError, expected_message):\n+            models.CompositePrimaryKey(\"tenant_id\", \"id\", db_default=models.F(\"id\"))\n+\n+    def test_composite_pk_cannot_be_editable(self):\n+        expected_message = \"CompositePrimaryKey cannot be editable.\"\n+        with self.assertRaisesMessage(ValueError, expected_message):\n+            models.CompositePrimaryKey(\"tenant_id\", \"id\", editable=True)\n+\n+    def test_composite_pk_must_be_a_primary_key(self):\n+        expected_message = \"CompositePrimaryKey must be a primary key.\"\n+        with self.assertRaisesMessage(ValueError, expected_message):\n+            models.CompositePrimaryKey(\"tenant_id\", \"id\", primary_key=False)\n+\n+    def test_composite_pk_must_be_blank(self):\n+        expected_message = \"CompositePrimaryKey must be blank.\"\n+        with self.assertRaisesMessage(ValueError, expected_message):\n+            models.CompositePrimaryKey(\"tenant_id\", \"id\", blank=False)\n+\n+    def test_composite_pk_must_not_have_other_pk_field(self):\n+        class Foo(models.Model):\n+            pk = models.CompositePrimaryKey(\"foo_id\", \"id\")\n+            foo_id = models.IntegerField()\n+            id = models.IntegerField(primary_key=True)\n+\n+        self.assertEqual(\n+            Foo.check(databases=self.databases),\n+            [\n+                checks.Error(\n+                    \"The model cannot have more than one field with \"\n+                    \"'primary_key=True'.\",\n+                    obj=Foo,\n+                    id=\"models.E026\",\n+                ),\n+            ],\n+        )\n+\n+    def test_composite_pk_cannot_include_nullable_field(self):\n+        class Foo(models.Model):\n+            pk = models.CompositePrimaryKey(\"foo_id\", \"id\")\n+            foo_id = models.IntegerField()\n+            id = models.IntegerField(null=True)\n+\n+        self.assertEqual(\n+            Foo.check(databases=self.databases),\n+            [\n+                checks.Error(\n+                    \"'id' cannot be included in the composite primary key.\",\n+                    hint=\"'id' field may not set 'null=True'.\",\n+                    obj=Foo,\n+                    id=\"models.E042\",\n+                ),\n+            ],\n+        )\n+\n+    def test_composite_pk_can_include_fk_name(self):\n+        class Foo(models.Model):\n+            pass\n+\n+        class Bar(models.Model):\n+            pk = models.CompositePrimaryKey(\"foo\", \"id\")\n+            foo = models.ForeignKey(Foo, on_delete=models.CASCADE)\n+            id = models.SmallIntegerField()\n+\n+        self.assertEqual(Foo.check(databases=self.databases), [])\n+        self.assertEqual(Bar.check(databases=self.databases), [])\n+\n+    def test_composite_pk_cannot_include_same_field(self):\n+        class Foo(models.Model):\n+            pass\n+\n+        class Bar(models.Model):\n+            pk = models.CompositePrimaryKey(\"foo\", \"foo_id\")\n+            foo = models.ForeignKey(Foo, on_delete=models.CASCADE)\n+            id = models.SmallIntegerField()\n+\n+        self.assertEqual(Foo.check(databases=self.databases), [])\n+        self.assertEqual(\n+            Bar.check(databases=self.databases),\n+            [\n+                checks.Error(\n+                    \"'foo_id' cannot be included in the composite primary key.\",\n+                    hint=\"'foo_id' and 'foo' are the same fields.\",\n+                    obj=Bar,\n+                    id=\"models.E042\",\n+                ),\n+            ],\n+        )\n+\n+    def test_composite_pk_cannot_include_composite_pk_field(self):\n+        class Foo(models.Model):\n+            pk = models.CompositePrimaryKey(\"id\", \"pk\")\n+            id = models.SmallIntegerField()\n+\n+        self.assertEqual(\n+            Foo.check(databases=self.databases),\n+            [\n+                checks.Error(\n+                    \"'pk' cannot be included in the composite primary key.\",\n+                    hint=\"'pk' field has no column.\",\n+                    obj=Foo,\n+                    id=\"models.E042\",\n+                ),\n+            ],\n+        )\n+\n+    def test_composite_pk_cannot_include_db_column(self):\n+        class Foo(models.Model):\n+            pk = models.CompositePrimaryKey(\"foo\", \"bar\")\n+            foo = models.SmallIntegerField(db_column=\"foo_id\")\n+            bar = models.SmallIntegerField(db_column=\"bar_id\")\n+\n+        class Bar(models.Model):\n+            pk = models.CompositePrimaryKey(\"foo_id\", \"bar_id\")\n+            foo = models.SmallIntegerField(db_column=\"foo_id\")\n+            bar = models.SmallIntegerField(db_column=\"bar_id\")\n+\n+        self.assertEqual(Foo.check(databases=self.databases), [])\n+        self.assertEqual(\n+            Bar.check(databases=self.databases),\n+            [\n+                checks.Error(\n+                    \"'foo_id' cannot be included in the composite primary key.\",\n+                    hint=\"'foo_id' is not a valid field.\",\n+                    obj=Bar,\n+                    id=\"models.E042\",\n+                ),\n+                checks.Error(\n+                    \"'bar_id' cannot be included in the composite primary key.\",\n+                    hint=\"'bar_id' is not a valid field.\",\n+                    obj=Bar,\n+                    id=\"models.E042\",\n+                ),\n+            ],\n+        )\n+\n+    def test_foreign_object_can_refer_composite_pk(self):\n+        class Foo(models.Model):\n+            pass\n+\n+        class Bar(models.Model):\n+            pk = models.CompositePrimaryKey(\"foo_id\", \"id\")\n+            foo = models.ForeignKey(Foo, on_delete=models.CASCADE)\n+            id = models.IntegerField()\n+\n+        class Baz(models.Model):\n+            pk = models.CompositePrimaryKey(\"foo_id\", \"id\")\n+            foo = models.ForeignKey(Foo, on_delete=models.CASCADE)\n+            id = models.IntegerField()\n+            bar_id = models.IntegerField()\n+            bar = models.ForeignObject(\n+                Bar,\n+                on_delete=models.CASCADE,\n+                from_fields=(\"foo_id\", \"bar_id\"),\n+                to_fields=(\"foo_id\", \"id\"),\n+            )\n+\n+        self.assertEqual(Foo.check(databases=self.databases), [])\n+        self.assertEqual(Bar.check(databases=self.databases), [])\n+        self.assertEqual(Baz.check(databases=self.databases), [])\n+\n+    def test_composite_pk_must_be_named_pk(self):\n+        class Foo(models.Model):\n+            primary_key = models.CompositePrimaryKey(\"foo_id\", \"id\")\n+            foo_id = models.IntegerField()\n+            id = models.IntegerField()\n+\n+        self.assertEqual(\n+            Foo.check(databases=self.databases),\n+            [\n+                checks.Error(\n+                    \"'CompositePrimaryKey' must be named 'pk'.\",\n+                    obj=Foo._meta.get_field(\"primary_key\"),\n+                    id=\"fields.E013\",\n+                ),\n+            ],\n+        )\n+\n+    def test_composite_pk_cannot_include_generated_field(self):\n+        is_oracle = connection.vendor == \"oracle\"\n+\n+        class Foo(models.Model):\n+            pk = models.CompositePrimaryKey(\"id\", \"foo\")\n+            id = models.IntegerField()\n+            foo = models.GeneratedField(\n+                expression=F(\"id\"),\n+                output_field=models.IntegerField(),\n+                db_persist=not is_oracle,\n+            )\n+\n+        self.assertEqual(\n+            Foo.check(databases=self.databases),\n+            [\n+                checks.Error(\n+                    \"'foo' cannot be included in the composite primary key.\",\n+                    hint=\"'foo' field is a generated field.\",\n+                    obj=Foo,\n+                    id=\"models.E042\",\n+                ),\n+            ],\n+        )\ndiff --git a/tests/composite_pk/test_create.py b/tests/composite_pk/test_create.py\nnew file mode 100644\nindex 000000000000..7c9925b94656\n--- /dev/null\n+++ b/tests/composite_pk/test_create.py\n@@ -0,0 +1,138 @@\n+from django.test import TestCase\n+\n+from .models import Tenant, User\n+\n+\n+class CompositePKCreateTests(TestCase):\n+    maxDiff = None\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.tenant = Tenant.objects.create()\n+        cls.user = User.objects.create(\n+            tenant=cls.tenant,\n+            id=1,\n+            email=\"user0001@example.com\",\n+        )\n+\n+    def test_create_user(self):\n+        test_cases = (\n+            {\"tenant\": self.tenant, \"id\": 2412, \"email\": \"user2412@example.com\"},\n+            {\"tenant_id\": self.tenant.id, \"id\": 5316, \"email\": \"user5316@example.com\"},\n+            {\"pk\": (self.tenant.id, 7424), \"email\": \"user7424@example.com\"},\n+        )\n+\n+        for fields in test_cases:\n+            with self.subTest(fields=fields):\n+                count = User.objects.count()\n+                user = User(**fields)\n+                obj = User.objects.create(**fields)\n+                self.assertEqual(obj.tenant_id, self.tenant.id)\n+                self.assertEqual(obj.id, user.id)\n+                self.assertEqual(obj.pk, (self.tenant.id, user.id))\n+                self.assertEqual(obj.email, user.email)\n+                self.assertEqual(count + 1, User.objects.count())\n+\n+    def test_save_user(self):\n+        test_cases = (\n+            {\"tenant\": self.tenant, \"id\": 9241, \"email\": \"user9241@example.com\"},\n+            {\"tenant_id\": self.tenant.id, \"id\": 5132, \"email\": \"user5132@example.com\"},\n+            {\"pk\": (self.tenant.id, 3014), \"email\": \"user3014@example.com\"},\n+        )\n+\n+        for fields in test_cases:\n+            with self.subTest(fields=fields):\n+                count = User.objects.count()\n+                user = User(**fields)\n+                self.assertIsNotNone(user.id)\n+                self.assertIsNotNone(user.email)\n+                user.save()\n+                self.assertEqual(user.tenant_id, self.tenant.id)\n+                self.assertEqual(user.tenant, self.tenant)\n+                self.assertIsNotNone(user.id)\n+                self.assertEqual(user.pk, (self.tenant.id, user.id))\n+                self.assertEqual(user.email, fields[\"email\"])\n+                self.assertEqual(user.email, f\"user{user.id}@example.com\")\n+                self.assertEqual(count + 1, User.objects.count())\n+\n+    def test_bulk_create_users(self):\n+        objs = [\n+            User(tenant=self.tenant, id=8291, email=\"user8291@example.com\"),\n+            User(tenant_id=self.tenant.id, id=4021, email=\"user4021@example.com\"),\n+            User(pk=(self.tenant.id, 8214), email=\"user8214@example.com\"),\n+        ]\n+\n+        obj_1, obj_2, obj_3 = User.objects.bulk_create(objs)\n+\n+        self.assertEqual(obj_1.tenant_id, self.tenant.id)\n+        self.assertEqual(obj_1.id, 8291)\n+        self.assertEqual(obj_1.pk, (obj_1.tenant_id, obj_1.id))\n+        self.assertEqual(obj_1.email, \"user8291@example.com\")\n+        self.assertEqual(obj_2.tenant_id, self.tenant.id)\n+        self.assertEqual(obj_2.id, 4021)\n+        self.assertEqual(obj_2.pk, (obj_2.tenant_id, obj_2.id))\n+        self.assertEqual(obj_2.email, \"user4021@example.com\")\n+        self.assertEqual(obj_3.tenant_id, self.tenant.id)\n+        self.assertEqual(obj_3.id, 8214)\n+        self.assertEqual(obj_3.pk, (obj_3.tenant_id, obj_3.id))\n+        self.assertEqual(obj_3.email, \"user8214@example.com\")\n+\n+    def test_get_or_create_user(self):\n+        test_cases = (\n+            {\n+                \"pk\": (self.tenant.id, 8314),\n+                \"defaults\": {\"email\": \"user8314@example.com\"},\n+            },\n+            {\n+                \"tenant\": self.tenant,\n+                \"id\": 3142,\n+                \"defaults\": {\"email\": \"user3142@example.com\"},\n+            },\n+            {\n+                \"tenant_id\": self.tenant.id,\n+                \"id\": 4218,\n+                \"defaults\": {\"email\": \"user4218@example.com\"},\n+            },\n+        )\n+\n+        for fields in test_cases:\n+            with self.subTest(fields=fields):\n+                count = User.objects.count()\n+                user, created = User.objects.get_or_create(**fields)\n+                self.assertIs(created, True)\n+                self.assertIsNotNone(user.id)\n+                self.assertEqual(user.pk, (self.tenant.id, user.id))\n+                self.assertEqual(user.tenant_id, self.tenant.id)\n+                self.assertEqual(user.email, fields[\"defaults\"][\"email\"])\n+                self.assertEqual(user.email, f\"user{user.id}@example.com\")\n+                self.assertEqual(count + 1, User.objects.count())\n+\n+    def test_update_or_create_user(self):\n+        test_cases = (\n+            {\n+                \"pk\": (self.tenant.id, 2931),\n+                \"defaults\": {\"email\": \"user2931@example.com\"},\n+            },\n+            {\n+                \"tenant\": self.tenant,\n+                \"id\": 6428,\n+                \"defaults\": {\"email\": \"user6428@example.com\"},\n+            },\n+            {\n+                \"tenant_id\": self.tenant.id,\n+                \"id\": 5278,\n+                \"defaults\": {\"email\": \"user5278@example.com\"},\n+            },\n+        )\n+\n+        for fields in test_cases:\n+            with self.subTest(fields=fields):\n+                count = User.objects.count()\n+                user, created = User.objects.update_or_create(**fields)\n+                self.assertIs(created, True)\n+                self.assertIsNotNone(user.id)\n+                self.assertEqual(user.pk, (self.tenant.id, user.id))\n+                self.assertEqual(user.tenant_id, self.tenant.id)\n+                self.assertEqual(user.email, fields[\"defaults\"][\"email\"])\n+                self.assertEqual(user.email, f\"user{user.id}@example.com\")\n+                self.assertEqual(count + 1, User.objects.count())\ndiff --git a/tests/composite_pk/test_delete.py b/tests/composite_pk/test_delete.py\nnew file mode 100644\nindex 000000000000..9a14deb81334\n--- /dev/null\n+++ b/tests/composite_pk/test_delete.py\n@@ -0,0 +1,83 @@\n+from django.test import TestCase\n+\n+from .models import Comment, Tenant, User\n+\n+\n+class CompositePKDeleteTests(TestCase):\n+    maxDiff = None\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.tenant_1 = Tenant.objects.create()\n+        cls.tenant_2 = Tenant.objects.create()\n+        cls.user_1 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=1,\n+            email=\"user0001@example.com\",\n+        )\n+        cls.user_2 = User.objects.create(\n+            tenant=cls.tenant_2,\n+            id=2,\n+            email=\"user0002@example.com\",\n+        )\n+        cls.comment_1 = Comment.objects.create(id=1, user=cls.user_1)\n+        cls.comment_2 = Comment.objects.create(id=2, user=cls.user_2)\n+        cls.comment_3 = Comment.objects.create(id=3, user=cls.user_2)\n+\n+    def test_delete_tenant_by_pk(self):\n+        result = Tenant.objects.filter(pk=self.tenant_1.pk).delete()\n+\n+        self.assertEqual(\n+            result,\n+            (\n+                3,\n+                {\n+                    \"composite_pk.Comment\": 1,\n+                    \"composite_pk.User\": 1,\n+                    \"composite_pk.Tenant\": 1,\n+                },\n+            ),\n+        )\n+\n+        self.assertIs(Tenant.objects.filter(pk=self.tenant_1.pk).exists(), False)\n+        self.assertIs(Tenant.objects.filter(pk=self.tenant_2.pk).exists(), True)\n+        self.assertIs(User.objects.filter(pk=self.user_1.pk).exists(), False)\n+        self.assertIs(User.objects.filter(pk=self.user_2.pk).exists(), True)\n+        self.assertIs(Comment.objects.filter(pk=self.comment_1.pk).exists(), False)\n+        self.assertIs(Comment.objects.filter(pk=self.comment_2.pk).exists(), True)\n+        self.assertIs(Comment.objects.filter(pk=self.comment_3.pk).exists(), True)\n+\n+    def test_delete_user_by_pk(self):\n+        result = User.objects.filter(pk=self.user_1.pk).delete()\n+\n+        self.assertEqual(\n+            result, (2, {\"composite_pk.User\": 1, \"composite_pk.Comment\": 1})\n+        )\n+\n+        self.assertIs(User.objects.filter(pk=self.user_1.pk).exists(), False)\n+        self.assertIs(User.objects.filter(pk=self.user_2.pk).exists(), True)\n+        self.assertIs(Comment.objects.filter(pk=self.comment_1.pk).exists(), False)\n+        self.assertIs(Comment.objects.filter(pk=self.comment_2.pk).exists(), True)\n+        self.assertIs(Comment.objects.filter(pk=self.comment_3.pk).exists(), True)\n+\n+    def test_delete_comments_by_user(self):\n+        result = Comment.objects.filter(user=self.user_2).delete()\n+\n+        self.assertEqual(result, (2, {\"composite_pk.Comment\": 2}))\n+\n+        self.assertIs(Comment.objects.filter(pk=self.comment_1.pk).exists(), True)\n+        self.assertIs(Comment.objects.filter(pk=self.comment_2.pk).exists(), False)\n+        self.assertIs(Comment.objects.filter(pk=self.comment_3.pk).exists(), False)\n+\n+    def test_delete_without_pk(self):\n+        msg = (\n+            \"Comment object can't be deleted because its pk attribute is set \"\n+            \"to None.\"\n+        )\n+\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Comment().delete()\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Comment(tenant_id=1).delete()\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Comment(id=1).delete()\ndiff --git a/tests/composite_pk/test_filter.py b/tests/composite_pk/test_filter.py\nnew file mode 100644\nindex 000000000000..7e361c5925b2\n--- /dev/null\n+++ b/tests/composite_pk/test_filter.py\n@@ -0,0 +1,412 @@\n+from django.test import TestCase\n+\n+from .models import Comment, Tenant, User\n+\n+\n+class CompositePKFilterTests(TestCase):\n+    maxDiff = None\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.tenant_1 = Tenant.objects.create()\n+        cls.tenant_2 = Tenant.objects.create()\n+        cls.tenant_3 = Tenant.objects.create()\n+        cls.user_1 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=1,\n+            email=\"user0001@example.com\",\n+        )\n+        cls.user_2 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=2,\n+            email=\"user0002@example.com\",\n+        )\n+        cls.user_3 = User.objects.create(\n+            tenant=cls.tenant_2,\n+            id=3,\n+            email=\"user0003@example.com\",\n+        )\n+        cls.user_4 = User.objects.create(\n+            tenant=cls.tenant_3,\n+            id=4,\n+            email=\"user0004@example.com\",\n+        )\n+        cls.comment_1 = Comment.objects.create(id=1, user=cls.user_1)\n+        cls.comment_2 = Comment.objects.create(id=2, user=cls.user_1)\n+        cls.comment_3 = Comment.objects.create(id=3, user=cls.user_2)\n+        cls.comment_4 = Comment.objects.create(id=4, user=cls.user_3)\n+        cls.comment_5 = Comment.objects.create(id=5, user=cls.user_1)\n+\n+    def test_filter_and_count_user_by_pk(self):\n+        test_cases = (\n+            ({\"pk\": self.user_1.pk}, 1),\n+            ({\"pk\": self.user_2.pk}, 1),\n+            ({\"pk\": self.user_3.pk}, 1),\n+            ({\"pk\": (self.tenant_1.id, self.user_1.id)}, 1),\n+            ({\"pk\": (self.tenant_1.id, self.user_2.id)}, 1),\n+            ({\"pk\": (self.tenant_2.id, self.user_3.id)}, 1),\n+            ({\"pk\": (self.tenant_1.id, self.user_3.id)}, 0),\n+            ({\"pk\": (self.tenant_2.id, self.user_1.id)}, 0),\n+            ({\"pk\": (self.tenant_2.id, self.user_2.id)}, 0),\n+        )\n+\n+        for lookup, count in test_cases:\n+            with self.subTest(lookup=lookup, count=count):\n+                self.assertEqual(User.objects.filter(**lookup).count(), count)\n+\n+    def test_order_comments_by_pk_asc(self):\n+        self.assertSequenceEqual(\n+            Comment.objects.order_by(\"pk\"),\n+            (\n+                self.comment_1,  # (1, 1)\n+                self.comment_2,  # (1, 2)\n+                self.comment_3,  # (1, 3)\n+                self.comment_5,  # (1, 5)\n+                self.comment_4,  # (2, 4)\n+            ),\n+        )\n+\n+    def test_order_comments_by_pk_desc(self):\n+        self.assertSequenceEqual(\n+            Comment.objects.order_by(\"-pk\"),\n+            (\n+                self.comment_4,  # (2, 4)\n+                self.comment_5,  # (1, 5)\n+                self.comment_3,  # (1, 3)\n+                self.comment_2,  # (1, 2)\n+                self.comment_1,  # (1, 1)\n+            ),\n+        )\n+\n+    def test_filter_comments_by_pk_gt(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        test_cases = (\n+            (c11, (c12, c13, c15, c24)),\n+            (c12, (c13, c15, c24)),\n+            (c13, (c15, c24)),\n+            (c15, (c24,)),\n+            (c24, ()),\n+        )\n+\n+        for obj, objs in test_cases:\n+            with self.subTest(obj=obj, objs=objs):\n+                self.assertSequenceEqual(\n+                    Comment.objects.filter(pk__gt=obj.pk).order_by(\"pk\"), objs\n+                )\n+\n+    def test_filter_comments_by_pk_gte(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        test_cases = (\n+            (c11, (c11, c12, c13, c15, c24)),\n+            (c12, (c12, c13, c15, c24)),\n+            (c13, (c13, c15, c24)),\n+            (c15, (c15, c24)),\n+            (c24, (c24,)),\n+        )\n+\n+        for obj, objs in test_cases:\n+            with self.subTest(obj=obj, objs=objs):\n+                self.assertSequenceEqual(\n+                    Comment.objects.filter(pk__gte=obj.pk).order_by(\"pk\"), objs\n+                )\n+\n+    def test_filter_comments_by_pk_lt(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        test_cases = (\n+            (c24, (c11, c12, c13, c15)),\n+            (c15, (c11, c12, c13)),\n+            (c13, (c11, c12)),\n+            (c12, (c11,)),\n+            (c11, ()),\n+        )\n+\n+        for obj, objs in test_cases:\n+            with self.subTest(obj=obj, objs=objs):\n+                self.assertSequenceEqual(\n+                    Comment.objects.filter(pk__lt=obj.pk).order_by(\"pk\"), objs\n+                )\n+\n+    def test_filter_comments_by_pk_lte(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        test_cases = (\n+            (c24, (c11, c12, c13, c15, c24)),\n+            (c15, (c11, c12, c13, c15)),\n+            (c13, (c11, c12, c13)),\n+            (c12, (c11, c12)),\n+            (c11, (c11,)),\n+        )\n+\n+        for obj, objs in test_cases:\n+            with self.subTest(obj=obj, objs=objs):\n+                self.assertSequenceEqual(\n+                    Comment.objects.filter(pk__lte=obj.pk).order_by(\"pk\"), objs\n+                )\n+\n+    def test_filter_comments_by_pk_in(self):\n+        test_cases = (\n+            (),\n+            (self.comment_1,),\n+            (self.comment_1, self.comment_4),\n+        )\n+\n+        for objs in test_cases:\n+            with self.subTest(objs=objs):\n+                pks = [obj.pk for obj in objs]\n+                self.assertSequenceEqual(\n+                    Comment.objects.filter(pk__in=pks).order_by(\"pk\"), objs\n+                )\n+\n+    def test_filter_comments_by_user_and_order_by_pk_asc(self):\n+        self.assertSequenceEqual(\n+            Comment.objects.filter(user=self.user_1).order_by(\"pk\"),\n+            (self.comment_1, self.comment_2, self.comment_5),\n+        )\n+\n+    def test_filter_comments_by_user_and_order_by_pk_desc(self):\n+        self.assertSequenceEqual(\n+            Comment.objects.filter(user=self.user_1).order_by(\"-pk\"),\n+            (self.comment_5, self.comment_2, self.comment_1),\n+        )\n+\n+    def test_filter_comments_by_user_and_exclude_by_pk(self):\n+        self.assertSequenceEqual(\n+            Comment.objects.filter(user=self.user_1)\n+            .exclude(pk=self.comment_1.pk)\n+            .order_by(\"pk\"),\n+            (self.comment_2, self.comment_5),\n+        )\n+\n+    def test_filter_comments_by_user_and_contains(self):\n+        self.assertIs(\n+            Comment.objects.filter(user=self.user_1).contains(self.comment_1), True\n+        )\n+\n+    def test_filter_users_by_comments_in(self):\n+        c1, c2, c3, c4, c5 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        u1, u2, u3 = (\n+            self.user_1,\n+            self.user_2,\n+            self.user_3,\n+        )\n+        test_cases = (\n+            ((), ()),\n+            ((c1,), (u1,)),\n+            ((c1, c2), (u1, u1)),\n+            ((c1, c2, c3), (u1, u1, u2)),\n+            ((c1, c2, c3, c4), (u1, u1, u2, u3)),\n+            ((c1, c2, c3, c4, c5), (u1, u1, u1, u2, u3)),\n+        )\n+\n+        for comments, users in test_cases:\n+            with self.subTest(comments=comments, users=users):\n+                self.assertSequenceEqual(\n+                    User.objects.filter(comments__in=comments).order_by(\"pk\"), users\n+                )\n+\n+    def test_filter_users_by_comments_lt(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        u1, u2 = (\n+            self.user_1,\n+            self.user_2,\n+        )\n+        test_cases = (\n+            (c11, ()),\n+            (c12, (u1,)),\n+            (c13, (u1, u1)),\n+            (c15, (u1, u1, u2)),\n+            (c24, (u1, u1, u1, u2)),\n+        )\n+\n+        for comment, users in test_cases:\n+            with self.subTest(comment=comment, users=users):\n+                self.assertSequenceEqual(\n+                    User.objects.filter(comments__lt=comment).order_by(\"pk\"), users\n+                )\n+\n+    def test_filter_users_by_comments_lte(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        u1, u2, u3 = (\n+            self.user_1,\n+            self.user_2,\n+            self.user_3,\n+        )\n+        test_cases = (\n+            (c11, (u1,)),\n+            (c12, (u1, u1)),\n+            (c13, (u1, u1, u2)),\n+            (c15, (u1, u1, u1, u2)),\n+            (c24, (u1, u1, u1, u2, u3)),\n+        )\n+\n+        for comment, users in test_cases:\n+            with self.subTest(comment=comment, users=users):\n+                self.assertSequenceEqual(\n+                    User.objects.filter(comments__lte=comment).order_by(\"pk\"), users\n+                )\n+\n+    def test_filter_users_by_comments_gt(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        u1, u2, u3 = (\n+            self.user_1,\n+            self.user_2,\n+            self.user_3,\n+        )\n+        test_cases = (\n+            (c11, (u1, u1, u2, u3)),\n+            (c12, (u1, u2, u3)),\n+            (c13, (u1, u3)),\n+            (c15, (u3,)),\n+            (c24, ()),\n+        )\n+\n+        for comment, users in test_cases:\n+            with self.subTest(comment=comment, users=users):\n+                self.assertSequenceEqual(\n+                    User.objects.filter(comments__gt=comment).order_by(\"pk\"), users\n+                )\n+\n+    def test_filter_users_by_comments_gte(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        u1, u2, u3 = (\n+            self.user_1,\n+            self.user_2,\n+            self.user_3,\n+        )\n+        test_cases = (\n+            (c11, (u1, u1, u1, u2, u3)),\n+            (c12, (u1, u1, u2, u3)),\n+            (c13, (u1, u2, u3)),\n+            (c15, (u1, u3)),\n+            (c24, (u3,)),\n+        )\n+\n+        for comment, users in test_cases:\n+            with self.subTest(comment=comment, users=users):\n+                self.assertSequenceEqual(\n+                    User.objects.filter(comments__gte=comment).order_by(\"pk\"), users\n+                )\n+\n+    def test_filter_users_by_comments_exact(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+        u1, u2, u3 = (\n+            self.user_1,\n+            self.user_2,\n+            self.user_3,\n+        )\n+        test_cases = (\n+            (c11, (u1,)),\n+            (c12, (u1,)),\n+            (c13, (u2,)),\n+            (c15, (u1,)),\n+            (c24, (u3,)),\n+        )\n+\n+        for comment, users in test_cases:\n+            with self.subTest(comment=comment, users=users):\n+                self.assertSequenceEqual(\n+                    User.objects.filter(comments=comment).order_by(\"pk\"), users\n+                )\n+\n+    def test_filter_users_by_comments_isnull(self):\n+        u1, u2, u3, u4 = (\n+            self.user_1,\n+            self.user_2,\n+            self.user_3,\n+            self.user_4,\n+        )\n+\n+        with self.subTest(\"comments__isnull=True\"):\n+            self.assertSequenceEqual(\n+                User.objects.filter(comments__isnull=True).order_by(\"pk\"),\n+                (u4,),\n+            )\n+        with self.subTest(\"comments__isnull=False\"):\n+            self.assertSequenceEqual(\n+                User.objects.filter(comments__isnull=False).order_by(\"pk\"),\n+                (u1, u1, u1, u2, u3),\n+            )\n+\n+    def test_filter_comments_by_pk_isnull(self):\n+        c11, c12, c13, c24, c15 = (\n+            self.comment_1,\n+            self.comment_2,\n+            self.comment_3,\n+            self.comment_4,\n+            self.comment_5,\n+        )\n+\n+        with self.subTest(\"pk__isnull=True\"):\n+            self.assertSequenceEqual(\n+                Comment.objects.filter(pk__isnull=True).order_by(\"pk\"),\n+                (),\n+            )\n+        with self.subTest(\"pk__isnull=False\"):\n+            self.assertSequenceEqual(\n+                Comment.objects.filter(pk__isnull=False).order_by(\"pk\"),\n+                (c11, c12, c13, c15, c24),\n+            )\n+\n+    def test_filter_users_by_comments_subquery(self):\n+        subquery = Comment.objects.filter(id=3).only(\"pk\")\n+        queryset = User.objects.filter(comments__in=subquery)\n+        self.assertSequenceEqual(queryset, (self.user_2,))\ndiff --git a/tests/composite_pk/test_get.py b/tests/composite_pk/test_get.py\nnew file mode 100644\nindex 000000000000..c896ec26ed49\n--- /dev/null\n+++ b/tests/composite_pk/test_get.py\n@@ -0,0 +1,126 @@\n+from django.test import TestCase\n+\n+from .models import Comment, Tenant, User\n+\n+\n+class CompositePKGetTests(TestCase):\n+    maxDiff = None\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.tenant_1 = Tenant.objects.create()\n+        cls.tenant_2 = Tenant.objects.create()\n+        cls.user_1 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=1,\n+            email=\"user0001@example.com\",\n+        )\n+        cls.user_2 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=2,\n+            email=\"user0002@example.com\",\n+        )\n+        cls.user_3 = User.objects.create(\n+            tenant=cls.tenant_2,\n+            id=3,\n+            email=\"user0003@example.com\",\n+        )\n+        cls.comment_1 = Comment.objects.create(id=1, user=cls.user_1)\n+\n+    def test_get_user(self):\n+        test_cases = (\n+            {\"pk\": self.user_1.pk},\n+            {\"pk\": (self.tenant_1.id, self.user_1.id)},\n+            {\"id\": self.user_1.id},\n+        )\n+\n+        for lookup in test_cases:\n+            with self.subTest(lookup=lookup):\n+                self.assertEqual(User.objects.get(**lookup), self.user_1)\n+\n+    def test_get_comment(self):\n+        test_cases = (\n+            {\"pk\": self.comment_1.pk},\n+            {\"pk\": (self.tenant_1.id, self.comment_1.id)},\n+            {\"id\": self.comment_1.id},\n+            {\"user\": self.user_1},\n+            {\"user_id\": self.user_1.id},\n+            {\"user__id\": self.user_1.id},\n+            {\"user__pk\": self.user_1.pk},\n+            {\"tenant\": self.tenant_1},\n+            {\"tenant_id\": self.tenant_1.id},\n+            {\"tenant__id\": self.tenant_1.id},\n+            {\"tenant__pk\": self.tenant_1.pk},\n+        )\n+\n+        for lookup in test_cases:\n+            with self.subTest(lookup=lookup):\n+                self.assertEqual(Comment.objects.get(**lookup), self.comment_1)\n+\n+    def test_get_or_create_user(self):\n+        test_cases = (\n+            {\n+                \"pk\": self.user_1.pk,\n+                \"defaults\": {\"email\": \"user9201@example.com\"},\n+            },\n+            {\n+                \"pk\": (self.tenant_1.id, self.user_1.id),\n+                \"defaults\": {\"email\": \"user9201@example.com\"},\n+            },\n+            {\n+                \"tenant\": self.tenant_1,\n+                \"id\": self.user_1.id,\n+                \"defaults\": {\"email\": \"user3512@example.com\"},\n+            },\n+            {\n+                \"tenant_id\": self.tenant_1.id,\n+                \"id\": self.user_1.id,\n+                \"defaults\": {\"email\": \"user8239@example.com\"},\n+            },\n+        )\n+\n+        for fields in test_cases:\n+            with self.subTest(fields=fields):\n+                count = User.objects.count()\n+                user, created = User.objects.get_or_create(**fields)\n+                self.assertIs(created, False)\n+                self.assertEqual(user.id, self.user_1.id)\n+                self.assertEqual(user.pk, (self.tenant_1.id, self.user_1.id))\n+                self.assertEqual(user.tenant_id, self.tenant_1.id)\n+                self.assertEqual(user.email, self.user_1.email)\n+                self.assertEqual(count, User.objects.count())\n+\n+    def test_lookup_errors(self):\n+        m_tuple = \"'%s' lookup of 'pk' must be a tuple or a list\"\n+        m_2_elements = \"'%s' lookup of 'pk' must have 2 elements\"\n+        m_tuple_collection = (\n+            \"'in' lookup of 'pk' must be a collection of tuples or lists\"\n+        )\n+        m_2_elements_each = \"'in' lookup of 'pk' must have 2 elements each\"\n+        test_cases = (\n+            ({\"pk\": 1}, m_tuple % \"exact\"),\n+            ({\"pk\": (1, 2, 3)}, m_2_elements % \"exact\"),\n+            ({\"pk__exact\": 1}, m_tuple % \"exact\"),\n+            ({\"pk__exact\": (1, 2, 3)}, m_2_elements % \"exact\"),\n+            ({\"pk__in\": 1}, m_tuple % \"in\"),\n+            ({\"pk__in\": (1, 2, 3)}, m_tuple_collection),\n+            ({\"pk__in\": ((1, 2, 3),)}, m_2_elements_each),\n+            ({\"pk__gt\": 1}, m_tuple % \"gt\"),\n+            ({\"pk__gt\": (1, 2, 3)}, m_2_elements % \"gt\"),\n+            ({\"pk__gte\": 1}, m_tuple % \"gte\"),\n+            ({\"pk__gte\": (1, 2, 3)}, m_2_elements % \"gte\"),\n+            ({\"pk__lt\": 1}, m_tuple % \"lt\"),\n+            ({\"pk__lt\": (1, 2, 3)}, m_2_elements % \"lt\"),\n+            ({\"pk__lte\": 1}, m_tuple % \"lte\"),\n+            ({\"pk__lte\": (1, 2, 3)}, m_2_elements % \"lte\"),\n+        )\n+\n+        for kwargs, message in test_cases:\n+            with (\n+                self.subTest(kwargs=kwargs),\n+                self.assertRaisesMessage(ValueError, message),\n+            ):\n+                Comment.objects.get(**kwargs)\n+\n+    def test_get_user_by_comments(self):\n+        self.assertEqual(User.objects.get(comments=self.comment_1), self.user_1)\ndiff --git a/tests/composite_pk/test_models.py b/tests/composite_pk/test_models.py\nnew file mode 100644\nindex 000000000000..ca6ad8b5dc3a\n--- /dev/null\n+++ b/tests/composite_pk/test_models.py\n@@ -0,0 +1,153 @@\n+from django.contrib.contenttypes.models import ContentType\n+from django.core.exceptions import ValidationError\n+from django.test import TestCase\n+\n+from .models import Comment, Tenant, Token, User\n+\n+\n+class CompositePKModelsTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.tenant_1 = Tenant.objects.create()\n+        cls.tenant_2 = Tenant.objects.create()\n+        cls.user_1 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=1,\n+            email=\"user0001@example.com\",\n+        )\n+        cls.user_2 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=2,\n+            email=\"user0002@example.com\",\n+        )\n+        cls.user_3 = User.objects.create(\n+            tenant=cls.tenant_2,\n+            id=3,\n+            email=\"user0003@example.com\",\n+        )\n+        cls.comment_1 = Comment.objects.create(id=1, user=cls.user_1)\n+        cls.comment_2 = Comment.objects.create(id=2, user=cls.user_1)\n+        cls.comment_3 = Comment.objects.create(id=3, user=cls.user_2)\n+        cls.comment_4 = Comment.objects.create(id=4, user=cls.user_3)\n+\n+    def test_fields(self):\n+        # tenant_1\n+        self.assertSequenceEqual(\n+            self.tenant_1.user_set.order_by(\"pk\"),\n+            [self.user_1, self.user_2],\n+        )\n+        self.assertSequenceEqual(\n+            self.tenant_1.comments.order_by(\"pk\"),\n+            [self.comment_1, self.comment_2, self.comment_3],\n+        )\n+\n+        # tenant_2\n+        self.assertSequenceEqual(self.tenant_2.user_set.order_by(\"pk\"), [self.user_3])\n+        self.assertSequenceEqual(\n+            self.tenant_2.comments.order_by(\"pk\"), [self.comment_4]\n+        )\n+\n+        # user_1\n+        self.assertEqual(self.user_1.id, 1)\n+        self.assertEqual(self.user_1.tenant_id, self.tenant_1.id)\n+        self.assertEqual(self.user_1.tenant, self.tenant_1)\n+        self.assertEqual(self.user_1.pk, (self.tenant_1.id, self.user_1.id))\n+        self.assertSequenceEqual(\n+            self.user_1.comments.order_by(\"pk\"), [self.comment_1, self.comment_2]\n+        )\n+\n+        # user_2\n+        self.assertEqual(self.user_2.id, 2)\n+        self.assertEqual(self.user_2.tenant_id, self.tenant_1.id)\n+        self.assertEqual(self.user_2.tenant, self.tenant_1)\n+        self.assertEqual(self.user_2.pk, (self.tenant_1.id, self.user_2.id))\n+        self.assertSequenceEqual(self.user_2.comments.order_by(\"pk\"), [self.comment_3])\n+\n+        # comment_1\n+        self.assertEqual(self.comment_1.id, 1)\n+        self.assertEqual(self.comment_1.user_id, self.user_1.id)\n+        self.assertEqual(self.comment_1.user, self.user_1)\n+        self.assertEqual(self.comment_1.tenant_id, self.tenant_1.id)\n+        self.assertEqual(self.comment_1.tenant, self.tenant_1)\n+        self.assertEqual(self.comment_1.pk, (self.tenant_1.id, self.user_1.id))\n+\n+    def test_full_clean_success(self):\n+        test_cases = (\n+            # 1, 1234, {}\n+            ({\"tenant\": self.tenant_1, \"id\": 1234}, {}),\n+            ({\"tenant_id\": self.tenant_1.id, \"id\": 1234}, {}),\n+            ({\"pk\": (self.tenant_1.id, 1234)}, {}),\n+            # 1, 1, {\"id\"}\n+            ({\"tenant\": self.tenant_1, \"id\": 1}, {\"id\"}),\n+            ({\"tenant_id\": self.tenant_1.id, \"id\": 1}, {\"id\"}),\n+            ({\"pk\": (self.tenant_1.id, 1)}, {\"id\"}),\n+            # 1, 1, {\"tenant\", \"id\"}\n+            ({\"tenant\": self.tenant_1, \"id\": 1}, {\"tenant\", \"id\"}),\n+            ({\"tenant_id\": self.tenant_1.id, \"id\": 1}, {\"tenant\", \"id\"}),\n+            ({\"pk\": (self.tenant_1.id, 1)}, {\"tenant\", \"id\"}),\n+        )\n+\n+        for kwargs, exclude in test_cases:\n+            with self.subTest(kwargs):\n+                kwargs[\"email\"] = \"user0004@example.com\"\n+                User(**kwargs).full_clean(exclude=exclude)\n+\n+    def test_full_clean_failure(self):\n+        e_tenant_and_id = \"User with this Tenant and Id already exists.\"\n+        e_id = \"User with this Id already exists.\"\n+        test_cases = (\n+            # 1, 1, {}\n+            ({\"tenant\": self.tenant_1, \"id\": 1}, {}, (e_tenant_and_id, e_id)),\n+            ({\"tenant_id\": self.tenant_1.id, \"id\": 1}, {}, (e_tenant_and_id, e_id)),\n+            ({\"pk\": (self.tenant_1.id, 1)}, {}, (e_tenant_and_id, e_id)),\n+            # 2, 1, {}\n+            ({\"tenant\": self.tenant_2, \"id\": 1}, {}, (e_id,)),\n+            ({\"tenant_id\": self.tenant_2.id, \"id\": 1}, {}, (e_id,)),\n+            ({\"pk\": (self.tenant_2.id, 1)}, {}, (e_id,)),\n+            # 1, 1, {\"tenant\"}\n+            ({\"tenant\": self.tenant_1, \"id\": 1}, {\"tenant\"}, (e_id,)),\n+            ({\"tenant_id\": self.tenant_1.id, \"id\": 1}, {\"tenant\"}, (e_id,)),\n+            ({\"pk\": (self.tenant_1.id, 1)}, {\"tenant\"}, (e_id,)),\n+        )\n+\n+        for kwargs, exclude, messages in test_cases:\n+            with self.subTest(kwargs):\n+                with self.assertRaises(ValidationError) as ctx:\n+                    kwargs[\"email\"] = \"user0004@example.com\"\n+                    User(**kwargs).full_clean(exclude=exclude)\n+\n+                self.assertSequenceEqual(ctx.exception.messages, messages)\n+\n+    def test_field_conflicts(self):\n+        test_cases = (\n+            ({\"pk\": (1, 1), \"id\": 2}, (1, 1)),\n+            ({\"id\": 2, \"pk\": (1, 1)}, (1, 1)),\n+            ({\"pk\": (1, 1), \"tenant_id\": 2}, (1, 1)),\n+            ({\"tenant_id\": 2, \"pk\": (1, 1)}, (1, 1)),\n+            ({\"pk\": (2, 2), \"tenant_id\": 3, \"id\": 4}, (2, 2)),\n+            ({\"tenant_id\": 3, \"id\": 4, \"pk\": (2, 2)}, (2, 2)),\n+        )\n+\n+        for kwargs, pk in test_cases:\n+            with self.subTest(kwargs=kwargs):\n+                user = User(**kwargs)\n+                self.assertEqual(user.pk, pk)\n+\n+    def test_validate_unique(self):\n+        user = User.objects.get(pk=self.user_1.pk)\n+        user.id = None\n+\n+        with self.assertRaises(ValidationError) as ctx:\n+            user.validate_unique()\n+\n+        self.assertSequenceEqual(\n+            ctx.exception.messages, (\"User with this Email already exists.\",)\n+        )\n+\n+    def test_permissions(self):\n+        token = ContentType.objects.get_for_model(Token)\n+        user = ContentType.objects.get_for_model(User)\n+        comment = ContentType.objects.get_for_model(Comment)\n+        self.assertEqual(4, token.permission_set.count())\n+        self.assertEqual(4, user.permission_set.count())\n+        self.assertEqual(4, comment.permission_set.count())\ndiff --git a/tests/composite_pk/test_names_to_path.py b/tests/composite_pk/test_names_to_path.py\nnew file mode 100644\nindex 000000000000..de4a04f4cba7\n--- /dev/null\n+++ b/tests/composite_pk/test_names_to_path.py\n@@ -0,0 +1,134 @@\n+from django.db.models.query_utils import PathInfo\n+from django.db.models.sql import Query\n+from django.test import TestCase\n+\n+from .models import Comment, Tenant, User\n+\n+\n+class NamesToPathTests(TestCase):\n+    def test_id(self):\n+        query = Query(User)\n+        path, final_field, targets, rest = query.names_to_path([\"id\"], User._meta)\n+\n+        self.assertEqual(path, [])\n+        self.assertEqual(final_field, User._meta.get_field(\"id\"))\n+        self.assertEqual(targets, (User._meta.get_field(\"id\"),))\n+        self.assertEqual(rest, [])\n+\n+    def test_pk(self):\n+        query = Query(User)\n+        path, final_field, targets, rest = query.names_to_path([\"pk\"], User._meta)\n+\n+        self.assertEqual(path, [])\n+        self.assertEqual(final_field, User._meta.get_field(\"pk\"))\n+        self.assertEqual(targets, (User._meta.get_field(\"pk\"),))\n+        self.assertEqual(rest, [])\n+\n+    def test_tenant_id(self):\n+        query = Query(User)\n+        path, final_field, targets, rest = query.names_to_path(\n+            [\"tenant\", \"id\"], User._meta\n+        )\n+\n+        self.assertEqual(\n+            path,\n+            [\n+                PathInfo(\n+                    from_opts=User._meta,\n+                    to_opts=Tenant._meta,\n+                    target_fields=(Tenant._meta.get_field(\"id\"),),\n+                    join_field=User._meta.get_field(\"tenant\"),\n+                    m2m=False,\n+                    direct=True,\n+                    filtered_relation=None,\n+                ),\n+            ],\n+        )\n+        self.assertEqual(final_field, Tenant._meta.get_field(\"id\"))\n+        self.assertEqual(targets, (Tenant._meta.get_field(\"id\"),))\n+        self.assertEqual(rest, [])\n+\n+    def test_user_id(self):\n+        query = Query(Comment)\n+        path, final_field, targets, rest = query.names_to_path(\n+            [\"user\", \"id\"], Comment._meta\n+        )\n+\n+        self.assertEqual(\n+            path,\n+            [\n+                PathInfo(\n+                    from_opts=Comment._meta,\n+                    to_opts=User._meta,\n+                    target_fields=(\n+                        User._meta.get_field(\"tenant\"),\n+                        User._meta.get_field(\"id\"),\n+                    ),\n+                    join_field=Comment._meta.get_field(\"user\"),\n+                    m2m=False,\n+                    direct=True,\n+                    filtered_relation=None,\n+                ),\n+            ],\n+        )\n+        self.assertEqual(final_field, User._meta.get_field(\"id\"))\n+        self.assertEqual(targets, (User._meta.get_field(\"id\"),))\n+        self.assertEqual(rest, [])\n+\n+    def test_user_tenant_id(self):\n+        query = Query(Comment)\n+        path, final_field, targets, rest = query.names_to_path(\n+            [\"user\", \"tenant\", \"id\"], Comment._meta\n+        )\n+\n+        self.assertEqual(\n+            path,\n+            [\n+                PathInfo(\n+                    from_opts=Comment._meta,\n+                    to_opts=User._meta,\n+                    target_fields=(\n+                        User._meta.get_field(\"tenant\"),\n+                        User._meta.get_field(\"id\"),\n+                    ),\n+                    join_field=Comment._meta.get_field(\"user\"),\n+                    m2m=False,\n+                    direct=True,\n+                    filtered_relation=None,\n+                ),\n+                PathInfo(\n+                    from_opts=User._meta,\n+                    to_opts=Tenant._meta,\n+                    target_fields=(Tenant._meta.get_field(\"id\"),),\n+                    join_field=User._meta.get_field(\"tenant\"),\n+                    m2m=False,\n+                    direct=True,\n+                    filtered_relation=None,\n+                ),\n+            ],\n+        )\n+        self.assertEqual(final_field, Tenant._meta.get_field(\"id\"))\n+        self.assertEqual(targets, (Tenant._meta.get_field(\"id\"),))\n+        self.assertEqual(rest, [])\n+\n+    def test_comments(self):\n+        query = Query(User)\n+        path, final_field, targets, rest = query.names_to_path([\"comments\"], User._meta)\n+\n+        self.assertEqual(\n+            path,\n+            [\n+                PathInfo(\n+                    from_opts=User._meta,\n+                    to_opts=Comment._meta,\n+                    target_fields=(Comment._meta.get_field(\"pk\"),),\n+                    join_field=User._meta.get_field(\"comments\"),\n+                    m2m=True,\n+                    direct=False,\n+                    filtered_relation=None,\n+                ),\n+            ],\n+        )\n+        self.assertEqual(final_field, User._meta.get_field(\"comments\"))\n+        self.assertEqual(targets, (Comment._meta.get_field(\"pk\"),))\n+        self.assertEqual(rest, [])\ndiff --git a/tests/composite_pk/test_update.py b/tests/composite_pk/test_update.py\nnew file mode 100644\nindex 000000000000..e7117454477c\n--- /dev/null\n+++ b/tests/composite_pk/test_update.py\n@@ -0,0 +1,135 @@\n+from django.test import TestCase\n+\n+from .models import Comment, Tenant, Token, User\n+\n+\n+class CompositePKUpdateTests(TestCase):\n+    maxDiff = None\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.tenant_1 = Tenant.objects.create(name=\"A\")\n+        cls.tenant_2 = Tenant.objects.create(name=\"B\")\n+        cls.user_1 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=1,\n+            email=\"user0001@example.com\",\n+        )\n+        cls.user_2 = User.objects.create(\n+            tenant=cls.tenant_1,\n+            id=2,\n+            email=\"user0002@example.com\",\n+        )\n+        cls.user_3 = User.objects.create(\n+            tenant=cls.tenant_2,\n+            id=3,\n+            email=\"user0003@example.com\",\n+        )\n+        cls.comment_1 = Comment.objects.create(id=1, user=cls.user_1)\n+        cls.comment_2 = Comment.objects.create(id=2, user=cls.user_1)\n+        cls.comment_3 = Comment.objects.create(id=3, user=cls.user_2)\n+        cls.token_1 = Token.objects.create(id=1, tenant=cls.tenant_1)\n+        cls.token_2 = Token.objects.create(id=2, tenant=cls.tenant_2)\n+        cls.token_3 = Token.objects.create(id=3, tenant=cls.tenant_1)\n+        cls.token_4 = Token.objects.create(id=4, tenant=cls.tenant_2)\n+\n+    def test_update_user(self):\n+        email = \"user9315@example.com\"\n+        result = User.objects.filter(pk=self.user_1.pk).update(email=email)\n+        self.assertEqual(result, 1)\n+        user = User.objects.get(pk=self.user_1.pk)\n+        self.assertEqual(user.email, email)\n+\n+    def test_save_user(self):\n+        count = User.objects.count()\n+        email = \"user9314@example.com\"\n+        user = User.objects.get(pk=self.user_1.pk)\n+        user.email = email\n+        user.save()\n+        user.refresh_from_db()\n+        self.assertEqual(user.email, email)\n+        user = User.objects.get(pk=self.user_1.pk)\n+        self.assertEqual(user.email, email)\n+        self.assertEqual(count, User.objects.count())\n+\n+    def test_bulk_update_comments(self):\n+        comment_1 = Comment.objects.get(pk=self.comment_1.pk)\n+        comment_2 = Comment.objects.get(pk=self.comment_2.pk)\n+        comment_3 = Comment.objects.get(pk=self.comment_3.pk)\n+        comment_1.text = \"foo\"\n+        comment_2.text = \"bar\"\n+        comment_3.text = \"baz\"\n+\n+        result = Comment.objects.bulk_update(\n+            [comment_1, comment_2, comment_3], [\"text\"]\n+        )\n+\n+        self.assertEqual(result, 3)\n+        comment_1 = Comment.objects.get(pk=self.comment_1.pk)\n+        comment_2 = Comment.objects.get(pk=self.comment_2.pk)\n+        comment_3 = Comment.objects.get(pk=self.comment_3.pk)\n+        self.assertEqual(comment_1.text, \"foo\")\n+        self.assertEqual(comment_2.text, \"bar\")\n+        self.assertEqual(comment_3.text, \"baz\")\n+\n+    def test_update_or_create_user(self):\n+        test_cases = (\n+            {\n+                \"pk\": self.user_1.pk,\n+                \"defaults\": {\"email\": \"user3914@example.com\"},\n+            },\n+            {\n+                \"pk\": (self.tenant_1.id, self.user_1.id),\n+                \"defaults\": {\"email\": \"user9375@example.com\"},\n+            },\n+            {\n+                \"tenant\": self.tenant_1,\n+                \"id\": self.user_1.id,\n+                \"defaults\": {\"email\": \"user3517@example.com\"},\n+            },\n+            {\n+                \"tenant_id\": self.tenant_1.id,\n+                \"id\": self.user_1.id,\n+                \"defaults\": {\"email\": \"user8391@example.com\"},\n+            },\n+        )\n+\n+        for fields in test_cases:\n+            with self.subTest(fields=fields):\n+                count = User.objects.count()\n+                user, created = User.objects.update_or_create(**fields)\n+                self.assertIs(created, False)\n+                self.assertEqual(user.id, self.user_1.id)\n+                self.assertEqual(user.pk, (self.tenant_1.id, self.user_1.id))\n+                self.assertEqual(user.tenant_id, self.tenant_1.id)\n+                self.assertEqual(user.email, fields[\"defaults\"][\"email\"])\n+                self.assertEqual(count, User.objects.count())\n+\n+    def test_update_comment_by_user_email(self):\n+        result = Comment.objects.filter(user__email=self.user_1.email).update(\n+            text=\"foo\"\n+        )\n+\n+        self.assertEqual(result, 2)\n+        comment_1 = Comment.objects.get(pk=self.comment_1.pk)\n+        comment_2 = Comment.objects.get(pk=self.comment_2.pk)\n+        self.assertEqual(comment_1.text, \"foo\")\n+        self.assertEqual(comment_2.text, \"foo\")\n+\n+    def test_update_token_by_tenant_name(self):\n+        result = Token.objects.filter(tenant__name=\"A\").update(secret=\"bar\")\n+\n+        self.assertEqual(result, 2)\n+        token_1 = Token.objects.get(pk=self.token_1.pk)\n+        self.assertEqual(token_1.secret, \"bar\")\n+        token_3 = Token.objects.get(pk=self.token_3.pk)\n+        self.assertEqual(token_3.secret, \"bar\")\n+\n+    def test_cant_update_to_unsaved_object(self):\n+        msg = (\n+            \"Unsaved model instance <User: User object ((None, None))> cannot be used \"\n+            \"in an ORM query.\"\n+        )\n+\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Comment.objects.update(user=User())\ndiff --git a/tests/composite_pk/test_values.py b/tests/composite_pk/test_values.py\nnew file mode 100644\nindex 000000000000..a3c7a589ccbc\n--- /dev/null\n+++ b/tests/composite_pk/test_values.py\n@@ -0,0 +1,212 @@\n+from collections import namedtuple\n+from uuid import UUID\n+\n+from django.test import TestCase\n+\n+from .models import Post, Tenant, User\n+\n+\n+class CompositePKValuesTests(TestCase):\n+    USER_1_EMAIL = \"user0001@example.com\"\n+    USER_2_EMAIL = \"user0002@example.com\"\n+    USER_3_EMAIL = \"user0003@example.com\"\n+    POST_1_ID = \"77777777-7777-7777-7777-777777777777\"\n+    POST_2_ID = \"bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb\"\n+    POST_3_ID = \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\"\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        super().setUpTestData()\n+        cls.tenant_1 = Tenant.objects.create()\n+        cls.tenant_2 = Tenant.objects.create()\n+        cls.user_1 = User.objects.create(\n+            tenant=cls.tenant_1, id=1, email=cls.USER_1_EMAIL\n+        )\n+        cls.user_2 = User.objects.create(\n+            tenant=cls.tenant_1, id=2, email=cls.USER_2_EMAIL\n+        )\n+        cls.user_3 = User.objects.create(\n+            tenant=cls.tenant_2, id=3, email=cls.USER_3_EMAIL\n+        )\n+        cls.post_1 = Post.objects.create(tenant=cls.tenant_1, id=cls.POST_1_ID)\n+        cls.post_2 = Post.objects.create(tenant=cls.tenant_1, id=cls.POST_2_ID)\n+        cls.post_3 = Post.objects.create(tenant=cls.tenant_2, id=cls.POST_3_ID)\n+\n+    def test_values_list(self):\n+        with self.subTest('User.objects.values_list(\"pk\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values_list(\"pk\").order_by(\"pk\"),\n+                (\n+                    (self.user_1.pk,),\n+                    (self.user_2.pk,),\n+                    (self.user_3.pk,),\n+                ),\n+            )\n+        with self.subTest('User.objects.values_list(\"pk\", \"email\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values_list(\"pk\", \"email\").order_by(\"pk\"),\n+                (\n+                    (self.user_1.pk, self.USER_1_EMAIL),\n+                    (self.user_2.pk, self.USER_2_EMAIL),\n+                    (self.user_3.pk, self.USER_3_EMAIL),\n+                ),\n+            )\n+        with self.subTest('User.objects.values_list(\"pk\", \"id\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values_list(\"pk\", \"id\").order_by(\"pk\"),\n+                (\n+                    (self.user_1.pk, self.user_1.id),\n+                    (self.user_2.pk, self.user_2.id),\n+                    (self.user_3.pk, self.user_3.id),\n+                ),\n+            )\n+        with self.subTest('User.objects.values_list(\"pk\", \"tenant_id\", \"id\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values_list(\"pk\", \"tenant_id\", \"id\").order_by(\"pk\"),\n+                (\n+                    (self.user_1.pk, self.user_1.tenant_id, self.user_1.id),\n+                    (self.user_2.pk, self.user_2.tenant_id, self.user_2.id),\n+                    (self.user_3.pk, self.user_3.tenant_id, self.user_3.id),\n+                ),\n+            )\n+        with self.subTest('User.objects.values_list(\"pk\", flat=True)'):\n+            self.assertSequenceEqual(\n+                User.objects.values_list(\"pk\", flat=True).order_by(\"pk\"),\n+                (\n+                    self.user_1.pk,\n+                    self.user_2.pk,\n+                    self.user_3.pk,\n+                ),\n+            )\n+        with self.subTest('Post.objects.values_list(\"pk\", flat=True)'):\n+            self.assertSequenceEqual(\n+                Post.objects.values_list(\"pk\", flat=True).order_by(\"pk\"),\n+                (\n+                    (self.tenant_1.id, UUID(self.POST_1_ID)),\n+                    (self.tenant_1.id, UUID(self.POST_2_ID)),\n+                    (self.tenant_2.id, UUID(self.POST_3_ID)),\n+                ),\n+            )\n+        with self.subTest('Post.objects.values_list(\"pk\")'):\n+            self.assertSequenceEqual(\n+                Post.objects.values_list(\"pk\").order_by(\"pk\"),\n+                (\n+                    ((self.tenant_1.id, UUID(self.POST_1_ID)),),\n+                    ((self.tenant_1.id, UUID(self.POST_2_ID)),),\n+                    ((self.tenant_2.id, UUID(self.POST_3_ID)),),\n+                ),\n+            )\n+        with self.subTest('Post.objects.values_list(\"pk\", \"id\")'):\n+            self.assertSequenceEqual(\n+                Post.objects.values_list(\"pk\", \"id\").order_by(\"pk\"),\n+                (\n+                    ((self.tenant_1.id, UUID(self.POST_1_ID)), UUID(self.POST_1_ID)),\n+                    ((self.tenant_1.id, UUID(self.POST_2_ID)), UUID(self.POST_2_ID)),\n+                    ((self.tenant_2.id, UUID(self.POST_3_ID)), UUID(self.POST_3_ID)),\n+                ),\n+            )\n+        with self.subTest('Post.objects.values_list(\"id\", \"pk\")'):\n+            self.assertSequenceEqual(\n+                Post.objects.values_list(\"id\", \"pk\").order_by(\"pk\"),\n+                (\n+                    (UUID(self.POST_1_ID), (self.tenant_1.id, UUID(self.POST_1_ID))),\n+                    (UUID(self.POST_2_ID), (self.tenant_1.id, UUID(self.POST_2_ID))),\n+                    (UUID(self.POST_3_ID), (self.tenant_2.id, UUID(self.POST_3_ID))),\n+                ),\n+            )\n+        with self.subTest('User.objects.values_list(\"pk\", named=True)'):\n+            Row = namedtuple(\"Row\", [\"pk\"])\n+            self.assertSequenceEqual(\n+                User.objects.values_list(\"pk\", named=True).order_by(\"pk\"),\n+                (\n+                    Row(pk=self.user_1.pk),\n+                    Row(pk=self.user_2.pk),\n+                    Row(pk=self.user_3.pk),\n+                ),\n+            )\n+        with self.subTest('User.objects.values_list(\"pk\", \"pk\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values_list(\"pk\", \"pk\").order_by(\"pk\"),\n+                (\n+                    (self.user_1.pk,),\n+                    (self.user_2.pk,),\n+                    (self.user_3.pk,),\n+                ),\n+            )\n+        with self.subTest('User.objects.values_list(\"pk\", \"id\", \"pk\", \"id\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values_list(\"pk\", \"id\", \"pk\", \"id\").order_by(\"pk\"),\n+                (\n+                    (self.user_1.pk, self.user_1.id),\n+                    (self.user_2.pk, self.user_2.id),\n+                    (self.user_3.pk, self.user_3.id),\n+                ),\n+            )\n+\n+    def test_values(self):\n+        with self.subTest('User.objects.values(\"pk\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values(\"pk\").order_by(\"pk\"),\n+                (\n+                    {\"pk\": self.user_1.pk},\n+                    {\"pk\": self.user_2.pk},\n+                    {\"pk\": self.user_3.pk},\n+                ),\n+            )\n+        with self.subTest('User.objects.values(\"pk\", \"email\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values(\"pk\", \"email\").order_by(\"pk\"),\n+                (\n+                    {\"pk\": self.user_1.pk, \"email\": self.USER_1_EMAIL},\n+                    {\"pk\": self.user_2.pk, \"email\": self.USER_2_EMAIL},\n+                    {\"pk\": self.user_3.pk, \"email\": self.USER_3_EMAIL},\n+                ),\n+            )\n+        with self.subTest('User.objects.values(\"pk\", \"id\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values(\"pk\", \"id\").order_by(\"pk\"),\n+                (\n+                    {\"pk\": self.user_1.pk, \"id\": self.user_1.id},\n+                    {\"pk\": self.user_2.pk, \"id\": self.user_2.id},\n+                    {\"pk\": self.user_3.pk, \"id\": self.user_3.id},\n+                ),\n+            )\n+        with self.subTest('User.objects.values(\"pk\", \"tenant_id\", \"id\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values(\"pk\", \"tenant_id\", \"id\").order_by(\"pk\"),\n+                (\n+                    {\n+                        \"pk\": self.user_1.pk,\n+                        \"tenant_id\": self.user_1.tenant_id,\n+                        \"id\": self.user_1.id,\n+                    },\n+                    {\n+                        \"pk\": self.user_2.pk,\n+                        \"tenant_id\": self.user_2.tenant_id,\n+                        \"id\": self.user_2.id,\n+                    },\n+                    {\n+                        \"pk\": self.user_3.pk,\n+                        \"tenant_id\": self.user_3.tenant_id,\n+                        \"id\": self.user_3.id,\n+                    },\n+                ),\n+            )\n+        with self.subTest('User.objects.values(\"pk\", \"pk\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values(\"pk\", \"pk\").order_by(\"pk\"),\n+                (\n+                    {\"pk\": self.user_1.pk},\n+                    {\"pk\": self.user_2.pk},\n+                    {\"pk\": self.user_3.pk},\n+                ),\n+            )\n+        with self.subTest('User.objects.values(\"pk\", \"id\", \"pk\", \"id\")'):\n+            self.assertSequenceEqual(\n+                User.objects.values(\"pk\", \"id\", \"pk\", \"id\").order_by(\"pk\"),\n+                (\n+                    {\"pk\": self.user_1.pk, \"id\": self.user_1.id},\n+                    {\"pk\": self.user_2.pk, \"id\": self.user_2.id},\n+                    {\"pk\": self.user_3.pk, \"id\": self.user_3.id},\n+                ),\n+            )\ndiff --git a/tests/composite_pk/tests.py b/tests/composite_pk/tests.py\nnew file mode 100644\nindex 000000000000..71522cb836fe\n--- /dev/null\n+++ b/tests/composite_pk/tests.py\n@@ -0,0 +1,345 @@\n+import json\n+import unittest\n+from uuid import UUID\n+\n+import yaml\n+\n+from django import forms\n+from django.core import serializers\n+from django.core.exceptions import FieldError\n+from django.db import IntegrityError, connection\n+from django.db.models import CompositePrimaryKey\n+from django.forms import modelform_factory\n+from django.test import TestCase\n+\n+from .models import Comment, Post, Tenant, User\n+\n+\n+class CommentForm(forms.ModelForm):\n+    class Meta:\n+        model = Comment\n+        fields = \"__all__\"\n+\n+\n+class CompositePKTests(TestCase):\n+    maxDiff = None\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.tenant = Tenant.objects.create()\n+        cls.user = User.objects.create(\n+            tenant=cls.tenant,\n+            id=1,\n+            email=\"user0001@example.com\",\n+        )\n+        cls.comment = Comment.objects.create(tenant=cls.tenant, id=1, user=cls.user)\n+\n+    @staticmethod\n+    def get_constraints(table):\n+        with connection.cursor() as cursor:\n+            return connection.introspection.get_constraints(cursor, table)\n+\n+    def test_pk_updated_if_field_updated(self):\n+        user = User.objects.get(pk=self.user.pk)\n+        self.assertEqual(user.pk, (self.tenant.id, self.user.id))\n+        self.assertIs(user._is_pk_set(), True)\n+        user.tenant_id = 9831\n+        self.assertEqual(user.pk, (9831, self.user.id))\n+        self.assertIs(user._is_pk_set(), True)\n+        user.id = 4321\n+        self.assertEqual(user.pk, (9831, 4321))\n+        self.assertIs(user._is_pk_set(), True)\n+        user.pk = (9132, 3521)\n+        self.assertEqual(user.tenant_id, 9132)\n+        self.assertEqual(user.id, 3521)\n+        self.assertIs(user._is_pk_set(), True)\n+        user.id = None\n+        self.assertEqual(user.pk, (9132, None))\n+        self.assertEqual(user.tenant_id, 9132)\n+        self.assertIsNone(user.id)\n+        self.assertIs(user._is_pk_set(), False)\n+\n+    def test_hash(self):\n+        self.assertEqual(hash(User(pk=(1, 2))), hash((1, 2)))\n+        self.assertEqual(hash(User(tenant_id=2, id=3)), hash((2, 3)))\n+        msg = \"Model instances without primary key value are unhashable\"\n+\n+        with self.assertRaisesMessage(TypeError, msg):\n+            hash(User())\n+        with self.assertRaisesMessage(TypeError, msg):\n+            hash(User(tenant_id=1))\n+        with self.assertRaisesMessage(TypeError, msg):\n+            hash(User(id=1))\n+\n+    def test_pk_must_be_list_or_tuple(self):\n+        user = User.objects.get(pk=self.user.pk)\n+        test_cases = [\n+            \"foo\",\n+            1000,\n+            3.14,\n+            True,\n+            False,\n+        ]\n+\n+        for pk in test_cases:\n+            with self.assertRaisesMessage(\n+                ValueError, \"'pk' must be a list or a tuple.\"\n+            ):\n+                user.pk = pk\n+\n+    def test_pk_must_have_2_elements(self):\n+        user = User.objects.get(pk=self.user.pk)\n+        test_cases = [\n+            (),\n+            [],\n+            (1000,),\n+            [1000],\n+            (1, 2, 3),\n+            [1, 2, 3],\n+        ]\n+\n+        for pk in test_cases:\n+            with self.assertRaisesMessage(ValueError, \"'pk' must have 2 elements.\"):\n+                user.pk = pk\n+\n+    def test_composite_pk_in_fields(self):\n+        user_fields = {f.name for f in User._meta.get_fields()}\n+        self.assertEqual(user_fields, {\"pk\", \"tenant\", \"id\", \"email\", \"comments\"})\n+\n+        comment_fields = {f.name for f in Comment._meta.get_fields()}\n+        self.assertEqual(\n+            comment_fields,\n+            {\"pk\", \"tenant\", \"id\", \"user_id\", \"user\", \"text\"},\n+        )\n+\n+    def test_pk_field(self):\n+        pk = User._meta.get_field(\"pk\")\n+        self.assertIsInstance(pk, CompositePrimaryKey)\n+        self.assertIs(User._meta.pk, pk)\n+\n+    def test_error_on_user_pk_conflict(self):\n+        with self.assertRaises(IntegrityError):\n+            User.objects.create(tenant=self.tenant, id=self.user.id)\n+\n+    def test_error_on_comment_pk_conflict(self):\n+        with self.assertRaises(IntegrityError):\n+            Comment.objects.create(tenant=self.tenant, id=self.comment.id)\n+\n+    @unittest.skipUnless(connection.vendor == \"postgresql\", \"PostgreSQL specific test\")\n+    def test_get_constraints_postgresql(self):\n+        user_constraints = self.get_constraints(User._meta.db_table)\n+        user_pk = user_constraints[\"composite_pk_user_pkey\"]\n+        self.assertEqual(user_pk[\"columns\"], [\"tenant_id\", \"id\"])\n+        self.assertIs(user_pk[\"primary_key\"], True)\n+\n+        comment_constraints = self.get_constraints(Comment._meta.db_table)\n+        comment_pk = comment_constraints[\"composite_pk_comment_pkey\"]\n+        self.assertEqual(comment_pk[\"columns\"], [\"tenant_id\", \"comment_id\"])\n+        self.assertIs(comment_pk[\"primary_key\"], True)\n+\n+    @unittest.skipUnless(connection.vendor == \"sqlite\", \"SQLite specific test\")\n+    def test_get_constraints_sqlite(self):\n+        user_constraints = self.get_constraints(User._meta.db_table)\n+        user_pk = user_constraints[\"__primary__\"]\n+        self.assertEqual(user_pk[\"columns\"], [\"tenant_id\", \"id\"])\n+        self.assertIs(user_pk[\"primary_key\"], True)\n+\n+        comment_constraints = self.get_constraints(Comment._meta.db_table)\n+        comment_pk = comment_constraints[\"__primary__\"]\n+        self.assertEqual(comment_pk[\"columns\"], [\"tenant_id\", \"comment_id\"])\n+        self.assertIs(comment_pk[\"primary_key\"], True)\n+\n+    @unittest.skipUnless(connection.vendor == \"mysql\", \"MySQL specific test\")\n+    def test_get_constraints_mysql(self):\n+        user_constraints = self.get_constraints(User._meta.db_table)\n+        user_pk = user_constraints[\"PRIMARY\"]\n+        self.assertEqual(user_pk[\"columns\"], [\"tenant_id\", \"id\"])\n+        self.assertIs(user_pk[\"primary_key\"], True)\n+\n+        comment_constraints = self.get_constraints(Comment._meta.db_table)\n+        comment_pk = comment_constraints[\"PRIMARY\"]\n+        self.assertEqual(comment_pk[\"columns\"], [\"tenant_id\", \"comment_id\"])\n+        self.assertIs(comment_pk[\"primary_key\"], True)\n+\n+    @unittest.skipUnless(connection.vendor == \"oracle\", \"Oracle specific test\")\n+    def test_get_constraints_oracle(self):\n+        user_constraints = self.get_constraints(User._meta.db_table)\n+        user_pk = next(c for c in user_constraints.values() if c[\"primary_key\"])\n+        self.assertEqual(user_pk[\"columns\"], [\"tenant_id\", \"id\"])\n+        self.assertEqual(user_pk[\"primary_key\"], 1)\n+\n+        comment_constraints = self.get_constraints(Comment._meta.db_table)\n+        comment_pk = next(c for c in comment_constraints.values() if c[\"primary_key\"])\n+        self.assertEqual(comment_pk[\"columns\"], [\"tenant_id\", \"comment_id\"])\n+        self.assertEqual(comment_pk[\"primary_key\"], 1)\n+\n+    def test_in_bulk(self):\n+        \"\"\"\n+        Test the .in_bulk() method of composite_pk models.\n+        \"\"\"\n+        result = Comment.objects.in_bulk()\n+        self.assertEqual(result, {self.comment.pk: self.comment})\n+\n+        result = Comment.objects.in_bulk([self.comment.pk])\n+        self.assertEqual(result, {self.comment.pk: self.comment})\n+\n+    def test_iterator(self):\n+        \"\"\"\n+        Test the .iterator() method of composite_pk models.\n+        \"\"\"\n+        result = list(Comment.objects.iterator())\n+        self.assertEqual(result, [self.comment])\n+\n+    def test_query(self):\n+        users = User.objects.values_list(\"pk\").order_by(\"pk\")\n+        self.assertNotIn('AS \"pk\"', str(users.query))\n+\n+    def test_only(self):\n+        users = User.objects.only(\"pk\")\n+        self.assertSequenceEqual(users, (self.user,))\n+        user = users[0]\n+\n+        with self.assertNumQueries(0):\n+            self.assertEqual(user.pk, (self.user.tenant_id, self.user.id))\n+            self.assertEqual(user.tenant_id, self.user.tenant_id)\n+            self.assertEqual(user.id, self.user.id)\n+        with self.assertNumQueries(1):\n+            self.assertEqual(user.email, self.user.email)\n+\n+    def test_model_forms(self):\n+        fields = [\"tenant\", \"id\", \"user_id\", \"text\"]\n+        self.assertEqual(list(CommentForm.base_fields), fields)\n+\n+        form = modelform_factory(Comment, fields=\"__all__\")\n+        self.assertEqual(list(form().fields), fields)\n+\n+        with self.assertRaisesMessage(\n+            FieldError, \"Unknown field(s) (pk) specified for Comment\"\n+        ):\n+            self.assertIsNone(modelform_factory(Comment, fields=[\"pk\"]))\n+\n+\n+class CompositePKFixturesTests(TestCase):\n+    fixtures = [\"tenant\"]\n+\n+    def test_objects(self):\n+        tenant_1, tenant_2, tenant_3 = Tenant.objects.order_by(\"pk\")\n+        self.assertEqual(tenant_1.id, 1)\n+        self.assertEqual(tenant_1.name, \"Tenant 1\")\n+        self.assertEqual(tenant_2.id, 2)\n+        self.assertEqual(tenant_2.name, \"Tenant 2\")\n+        self.assertEqual(tenant_3.id, 3)\n+        self.assertEqual(tenant_3.name, \"Tenant 3\")\n+\n+        user_1, user_2, user_3, user_4 = User.objects.order_by(\"pk\")\n+        self.assertEqual(user_1.id, 1)\n+        self.assertEqual(user_1.tenant_id, 1)\n+        self.assertEqual(user_1.pk, (user_1.tenant_id, user_1.id))\n+        self.assertEqual(user_1.email, \"user0001@example.com\")\n+        self.assertEqual(user_2.id, 2)\n+        self.assertEqual(user_2.tenant_id, 1)\n+        self.assertEqual(user_2.pk, (user_2.tenant_id, user_2.id))\n+        self.assertEqual(user_2.email, \"user0002@example.com\")\n+        self.assertEqual(user_3.id, 3)\n+        self.assertEqual(user_3.tenant_id, 2)\n+        self.assertEqual(user_3.pk, (user_3.tenant_id, user_3.id))\n+        self.assertEqual(user_3.email, \"user0003@example.com\")\n+        self.assertEqual(user_4.id, 4)\n+        self.assertEqual(user_4.tenant_id, 2)\n+        self.assertEqual(user_4.pk, (user_4.tenant_id, user_4.id))\n+        self.assertEqual(user_4.email, \"user0004@example.com\")\n+\n+        post_1, post_2 = Post.objects.order_by(\"pk\")\n+        self.assertEqual(post_1.id, UUID(\"11111111-1111-1111-1111-111111111111\"))\n+        self.assertEqual(post_1.tenant_id, 2)\n+        self.assertEqual(post_1.pk, (post_1.tenant_id, post_1.id))\n+        self.assertEqual(post_2.id, UUID(\"ffffffff-ffff-ffff-ffff-ffffffffffff\"))\n+        self.assertEqual(post_2.tenant_id, 2)\n+        self.assertEqual(post_2.pk, (post_2.tenant_id, post_2.id))\n+\n+    def test_serialize_user_json(self):\n+        users = User.objects.filter(pk=(1, 1))\n+        result = serializers.serialize(\"json\", users)\n+        self.assertEqual(\n+            json.loads(result),\n+            [\n+                {\n+                    \"model\": \"composite_pk.user\",\n+                    \"pk\": [1, 1],\n+                    \"fields\": {\n+                        \"email\": \"user0001@example.com\",\n+                        \"id\": 1,\n+                        \"tenant\": 1,\n+                    },\n+                }\n+            ],\n+        )\n+\n+    def test_serialize_user_jsonl(self):\n+        users = User.objects.filter(pk=(1, 2))\n+        result = serializers.serialize(\"jsonl\", users)\n+        self.assertEqual(\n+            json.loads(result),\n+            {\n+                \"model\": \"composite_pk.user\",\n+                \"pk\": [1, 2],\n+                \"fields\": {\n+                    \"email\": \"user0002@example.com\",\n+                    \"id\": 2,\n+                    \"tenant\": 1,\n+                },\n+            },\n+        )\n+\n+    def test_serialize_user_yaml(self):\n+        users = User.objects.filter(pk=(2, 3))\n+        result = serializers.serialize(\"yaml\", users)\n+        self.assertEqual(\n+            yaml.safe_load(result),\n+            [\n+                {\n+                    \"model\": \"composite_pk.user\",\n+                    \"pk\": [2, 3],\n+                    \"fields\": {\n+                        \"email\": \"user0003@example.com\",\n+                        \"id\": 3,\n+                        \"tenant\": 2,\n+                    },\n+                },\n+            ],\n+        )\n+\n+    def test_serialize_user_python(self):\n+        users = User.objects.filter(pk=(2, 4))\n+        result = serializers.serialize(\"python\", users)\n+        self.assertEqual(\n+            result,\n+            [\n+                {\n+                    \"model\": \"composite_pk.user\",\n+                    \"pk\": [2, 4],\n+                    \"fields\": {\n+                        \"email\": \"user0004@example.com\",\n+                        \"id\": 4,\n+                        \"tenant\": 2,\n+                    },\n+                },\n+            ],\n+        )\n+\n+    def test_serialize_post_uuid(self):\n+        posts = Post.objects.filter(pk=(2, \"11111111-1111-1111-1111-111111111111\"))\n+        result = serializers.serialize(\"json\", posts)\n+        self.assertEqual(\n+            json.loads(result),\n+            [\n+                {\n+                    \"model\": \"composite_pk.post\",\n+                    \"pk\": [2, \"11111111-1111-1111-1111-111111111111\"],\n+                    \"fields\": {\n+                        \"id\": \"11111111-1111-1111-1111-111111111111\",\n+                        \"tenant\": 2,\n+                    },\n+                },\n+            ],\n+        )\ndiff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex d4345208ca43..67d258c7004b 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -4957,6 +4957,95 @@ def deconstruct(self):\n         self.assertOperationTypes(changes, \"testapp\", 0, [\"CreateModel\"])\n         self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"Book\")\n \n+    @mock.patch(\n+        \"django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition\"\n+    )\n+    def test_add_composite_pk(self, mocked_ask_method):\n+        before = [\n+            ModelState(\n+                \"app\",\n+                \"foo\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+        ]\n+        after = [\n+            ModelState(\n+                \"app\",\n+                \"foo\",\n+                [\n+                    (\"pk\", models.CompositePrimaryKey(\"foo_id\", \"bar_id\")),\n+                    (\"id\", models.IntegerField()),\n+                ],\n+            ),\n+        ]\n+\n+        changes = self.get_changes(before, after)\n+        self.assertEqual(mocked_ask_method.call_count, 0)\n+        self.assertNumberMigrations(changes, \"app\", 1)\n+        self.assertOperationTypes(changes, \"app\", 0, [\"AddField\", \"AlterField\"])\n+        self.assertOperationAttributes(\n+            changes,\n+            \"app\",\n+            0,\n+            0,\n+            name=\"pk\",\n+            model_name=\"foo\",\n+            preserve_default=True,\n+        )\n+        self.assertOperationAttributes(\n+            changes,\n+            \"app\",\n+            0,\n+            1,\n+            name=\"id\",\n+            model_name=\"foo\",\n+            preserve_default=True,\n+        )\n+\n+    def test_remove_composite_pk(self):\n+        before = [\n+            ModelState(\n+                \"app\",\n+                \"foo\",\n+                [\n+                    (\"pk\", models.CompositePrimaryKey(\"foo_id\", \"bar_id\")),\n+                    (\"id\", models.IntegerField()),\n+                ],\n+            ),\n+        ]\n+        after = [\n+            ModelState(\n+                \"app\",\n+                \"foo\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+        ]\n+\n+        changes = self.get_changes(before, after)\n+        self.assertNumberMigrations(changes, \"app\", 1)\n+        self.assertOperationTypes(changes, \"app\", 0, [\"RemoveField\", \"AlterField\"])\n+        self.assertOperationAttributes(\n+            changes,\n+            \"app\",\n+            0,\n+            0,\n+            name=\"pk\",\n+            model_name=\"foo\",\n+        )\n+        self.assertOperationAttributes(\n+            changes,\n+            \"app\",\n+            0,\n+            1,\n+            name=\"id\",\n+            model_name=\"foo\",\n+            preserve_default=True,\n+        )\n+\n \n class MigrationSuggestNameTests(SimpleTestCase):\n     def test_no_operations(self):\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 3ac813b899b7..d12533d3ac33 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -6212,6 +6212,61 @@ def test_add_field_after_generated_field(self):\n         self.assertEqual(pony_new.generated, 1)\n         self.assertEqual(pony_new.static, 2)\n \n+    def test_composite_pk_operations(self):\n+        app_label = \"test_d8d90af6\"\n+        project_state = self.set_up_test_model(app_label)\n+        operation_1 = migrations.AddField(\n+            \"Pony\", \"pk\", models.CompositePrimaryKey(\"id\", \"pink\")\n+        )\n+        operation_2 = migrations.AlterField(\"Pony\", \"id\", models.IntegerField())\n+        operation_3 = migrations.RemoveField(\"Pony\", \"pk\")\n+        table_name = f\"{app_label}_pony\"\n+\n+        # 1. Add field (pk).\n+        new_state = project_state.clone()\n+        operation_1.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation_1.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertColumnNotExists(table_name, \"pk\")\n+        Pony = new_state.apps.get_model(app_label, \"pony\")\n+        obj_1 = Pony.objects.create(weight=1)\n+        msg = (\n+            f\"obj_1={obj_1}, \"\n+            f\"obj_1.id={obj_1.id}, \"\n+            f\"obj_1.pink={obj_1.pink}, \"\n+            f\"obj_1.pk={obj_1.pk}, \"\n+            f\"Pony._meta.pk={repr(Pony._meta.pk)}, \"\n+            f\"Pony._meta.get_field('id')={repr(Pony._meta.get_field('id'))}\"\n+        )\n+        self.assertEqual(obj_1.pink, 3, msg)\n+        self.assertEqual(obj_1.pk, (obj_1.id, obj_1.pink), msg)\n+\n+        # 2. Alter field (id -> IntegerField()).\n+        project_state, new_state = new_state, new_state.clone()\n+        operation_2.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation_2.database_forwards(app_label, editor, project_state, new_state)\n+        Pony = new_state.apps.get_model(app_label, \"pony\")\n+        obj_1 = Pony.objects.get(id=obj_1.id)\n+        self.assertEqual(obj_1.pink, 3)\n+        self.assertEqual(obj_1.pk, (obj_1.id, obj_1.pink))\n+        obj_2 = Pony.objects.create(id=2, weight=2)\n+        self.assertEqual(obj_2.id, 2)\n+        self.assertEqual(obj_2.pink, 3)\n+        self.assertEqual(obj_2.pk, (obj_2.id, obj_2.pink))\n+\n+        # 3. Remove field (pk).\n+        project_state, new_state = new_state, new_state.clone()\n+        operation_3.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation_3.database_forwards(app_label, editor, project_state, new_state)\n+        Pony = new_state.apps.get_model(app_label, \"pony\")\n+        obj_1 = Pony.objects.get(id=obj_1.id)\n+        self.assertEqual(obj_1.pk, obj_1.id)\n+        obj_2 = Pony.objects.get(id=obj_2.id)\n+        self.assertEqual(obj_2.id, 2)\n+        self.assertEqual(obj_2.pk, obj_2.id)\n+\n \n class SwappableOperationTests(OperationTestBase):\n     \"\"\"\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR highlights some significant issues with the handling of composite primary keys. Firstly, an error occurs due to incorrect handling of lookups involving null values in the query syntax, particularly with the `isnull` method. Secondly, the test cases around composite keys are failing, especially with SQL query strings that are improperly constructed. Migrational issues related to composite keys need addressing. While proposed solutions are reasonable, there's a risk of added complexity. The overall progress is promising, but it requires further refinement and validation before merging."
      }
    ],
    "token_estimation": 26832.75
  },
  {
    "index": 14,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 79954a87e610..6b48d2733bee 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -605,3 +665,173 @@ def get_ancestor_link(self, ancestor):\n                 # of the chain to the ancestor is that parent\n                 # links\n                 return self.parents[parent] or parent_link\n+\n+    def _populate_directed_relation_graph(self):\n+        \"\"\"\n+        This method is used by each model to find its reverse objects. As this\n+        method is very expensive and is accessed frequently (it looks up every\n+        field in a model, in every app), it is computed on first access and then\n+        is set as a property on every model.\n+        \"\"\"\n+        related_objects_graph = defaultdict(list)\n+\n+        all_models = self.apps.get_models(include_auto_created=True)\n+        for model in all_models:\n+            fields_with_relations = (\n+                f for f in model._meta._get_fields(reverse=False)\n+                if f.is_relation and f.related_model is not None\n+            )\n+            if model._meta.auto_created:\n+                fields_with_relations = (\n+                    f for f in fields_with_relations\n+                    if not f.many_to_many\n+                )\n+\n+            for f in fields_with_relations:\n+                if not isinstance(f.rel.to, six.string_types):\n+                    # Set options_instance -> field\n+                    related_objects_graph[f.rel.to._meta].append(f)\n+\n+        for model in all_models:\n+            # Set the relation_tree using the internal __dict__. In this way\n+            # we avoid calling the cached property. In attribute lookup,\n+            # __dict__ takes precedence over a data descriptor (such as\n+            # @cached_property). This means that the _meta._relation_tree is\n+            # only called if related_objects is not in __dict__.\n+            related_objects = related_objects_graph[model._meta]\n+\n+            # If related_objects are empty, it makes sense to set\n+            # EMPTY_RELATION_TREE. This will avoid allocating multiple empty\n+            # relation trees.\n+            relation_tree = EMPTY_RELATION_TREE\n+            if related_objects:\n+                relation_tree = related_objects\n+            model._meta.__dict__['_relation_tree'] = relation_tree\n+\n+    @cached_property\n+    def _relation_tree(self):\n+        # If cache is not present, populate the cache\n+        self._populate_directed_relation_graph()\n+        # It may happen, often when the registry is not ready, that a not yet\n+        # registered model is queried. In this very rare case we simply return\n+        # an EMPTY_RELATION_TREE. When the registry will be ready, cache will\n+        # be flushed and this model will be computed properly.\n+        return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)\n+\n+    def _expire_cache(self, forward=True, reverse=True):\n+        # This method is usually called by apps.cache_clear(), when the\n+        # registry is finalized, or when a new field is added.\n+        properties_to_expire = []\n+        if forward:\n+            properties_to_expire.extend(self.FORWARD_PROPERTIES)\n+        if reverse and not self.abstract:\n+            properties_to_expire.extend(self.REVERSE_PROPERTIES)\n+\n+        for cache_key in properties_to_expire:\n+            try:\n+                delattr(self, cache_key)\n+            except AttributeError:\n+                pass\n+\n+        self._get_fields_cache = {}\n+\n+    def get_fields(self, include_parents=True, include_hidden=False):\n+        \"\"\"\n+        Returns a list of fields associated to the model. By default will only\n+        return forward fields. This can be changed by enabling or disabling\n+        field types using the parameters:\n+\n+        - include_parents: include fields derived from inheritance\n+        - include_hidden:  include fields that have a related_name that\n+                           starts with a \"+\"\n+        \"\"\"\n+        return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)\n+\n+    def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False,\n+                    export_ordered_set=False):\n+        # This helper function is used to allow recursion in ``get_fields()``\n+        # implementation and to provide a fast way for Django's internals to\n+        # access specific subsets of fields.\n+\n+        # Creates a cache key composed of all arguments\n+        cache_key = (forward, reverse, include_parents, include_hidden, export_ordered_set)\n+        try:\n+            # In order to avoid list manipulation. Always return a shallow copy\n+            # of the results.\n+            return self._get_fields_cache[cache_key]\n+        except KeyError:\n+            pass\n+\n+        # Using an OrderedDict preserves the order of insertion. This is\n+        # important when displaying a ModelForm or the contrib.admin panel\n+        # and no specific ordering is provided.\n+        fields = OrderedDict()\n+        options = {\n+            'include_parents': include_parents,\n+            'include_hidden': include_hidden,\n+            'export_ordered_set': True,\n+        }\n+\n+        # Abstract models cannot hold reverse fields.\n+        if reverse and not self.abstract:\n+            if include_parents:\n+                parent_list = self.get_parent_list()\n+                # Recursively call _get_fields() on each parent, with the same\n+                # options provided in this call.\n+                for parent in self.parents:\n+                    for obj, _ in six.iteritems(parent._meta._get_fields(forward=False, **options)):\n+                        if obj.many_to_many:\n+                            # In order for a reverse ManyToManyRel object to be\n+                            # valid, its creation counter must be > 0 and must\n+                            # be in the parent list.\n+                            if not (obj.field.creation_counter < 0 and obj.related_model not in parent_list):\n+                                fields[obj] = True\n+\n+                        elif not ((obj.field.creation_counter < 0 or obj.field.rel.parent_link)\n+                                  and obj.related_model not in parent_list):\n+                            fields[obj] = True\n+\n+            # Tree is computed once and cached until the app cache is expired.\n+            # It is composed of a list of fields pointing to the current model\n+            # from other models. If the model is a proxy model, then we also\n+            # add the concrete model.\n+            all_fields = (\n+                self._relation_tree if not self.proxy else\n+                chain(self._relation_tree, self.concrete_model._meta._relation_tree)\n+            )\n+\n+            # Pull out all related objects from forward fields\n+            for field in (f.rel for f in all_fields):\n+                # If hidden fields should be included or the relation is not\n+                # intentionally hidden, add to the fields dict.\n+                if include_hidden or not field.hidden:\n+                    fields[field] = True\n+        if forward:\n+            if include_parents:\n+                for parent in self.parents:\n+                    # Add the forward fields of each parent.\n+                    fields.update(parent._meta._get_fields(reverse=False, **options))\n+            fields.update(\n+                (field, True,)\n+                for field in chain(self.local_fields, self.local_many_to_many)\n+            )\n+\n+        if not export_ordered_set:\n+            # By default, fields contains field instances as keys and all\n+            # possible names if the field instance as values. When\n+            # _get_fields() is called, we only want to return field instances,\n+            # so we just preserve the keys.\n+            fields = list(fields.keys())\n+\n+            # Virtual fields are not inheritable, therefore they are inserted\n+            # only when the recursive _get_fields() call comes to an end.\n+            if forward:\n+                fields.extend(self.virtual_fields)\n+            fields = make_immutable_fields_list(\"get_fields()\", fields)\n+\n+        # Store result into cache for later access\n+        self._get_fields_cache[cache_key] = fields\n+\n+        # In order to avoid list manipulation. Always\n+        # return a shallow copy of the results\n+        return fields\ndiff --git a/docs/ref/models/fields.txt b/docs/ref/models/fields.txt\nindex 35997801fb08..bc214fae00c4 100644\n--- a/docs/ref/models/fields.txt\n+++ b/docs/ref/models/fields.txt\n@@ -1790,3 +1790,95 @@ Field API reference\n \n         This method must be added to fields prior to 1.7 to migrate its data\n         using :doc:`/topics/migrations`.\n+\n+.. _model-field-attributes:\n+\n+=========================\n+Field attribute reference\n+=========================\n+\n+.. versionadded:: 1.8\n+\n+Every ``Field`` instance contains several attributes that allow\n+introspecting its behavior. Use these attributes instead of ``isinstance``\n+checks when you need to write code that depends on a field's functionality.\n+These attributes can be used together with the :ref:`Model._meta API\n+<model-meta-field-api>` to narrow down a search for specific field types.\n+Custom model fields should implement these flags.\n+\n+Attributes for fields\n+=====================\n+\n+.. attribute:: Field.auto_created\n+\n+     Boolean flag that indicates if the field was automatically created, such\n+     as the ``OneToOneField`` used by model inheritance.\n+\n+.. attribute:: Field.concrete\n+\n+    Boolean flag that indicates if the field has a database column associated\n+    with it.\n+\n+.. attribute:: Field.hidden\n+\n+    Boolean flag that indicates if a field is used to back another non-hidden\n+    field's functionality (e.g. the ``content_type`` and ``object_id`` fields\n+    that make up a ``GenericForeignKey``). The ``hidden`` flag is used to\n+    distinguish what constitutes the public subset of fields on the model from\n+    all the fields on the model.\n+\n+    .. note::\n+\n+        :meth:`Options.get_fields()\n+        <django.db.models.options.Options.get_fields()>`\n+        excludes hidden fields by default. Pass in ``include_hidden=True`` to\n+        return hidden fields in the results.\n+\n+.. attribute:: Field.is_relation\n+\n+    Boolean flag that indicates if a field contains references to one or\n+    more other models for its functionality (e.g. ``ForeignKey``,\n+    ``ManyToManyField``, ``OneToOneField``, etc.).\n+\n+.. attribute:: Field.model\n+\n+    Returns the model on which the field is defined. If a field is defined on\n+    a superclass of a model, ``model`` will refer to the superclass, not the\n+    class of the instance.\n+\n+Attributes for fields with relations\n+====================================\n+\n+These attributes are used to query for the cardinality and other details of a\n+relation. These attribute are present on all fields; however, they will only\n+have meaningful values if the field is a relation type\n+(:attr:`Field.is_relation=True <Field.is_relation>`).\n+\n+.. attribute:: Field.one_to_many\n+\n+    Boolean flag that is ``True`` if the field has a one-to-many relation, such\n+    as a ``ForeignKey``; ``False`` otherwise.\n+\n+.. attribute:: Field.one_to_one\n+\n+    Boolean flag that is ``True`` if the field has a one-to-one relation, such\n+    as a ``OneToOneField``; ``False`` otherwise.\n+\n+.. attribute:: Field.many_to_many\n+\n+    Boolean flag that is ``True`` if the field has a many-to-many relation;\n+    ``False`` otherwise. The only field included with Django where this is\n+    ``True`` is ``ManyToManyField``.\n+\n+.. attribute:: Field.many_to_one\n+\n+    Boolean flag that is ``True`` if the field has a many-to-one relation, such\n+    as a ``GenericRelation`` or the reverse of a ``ForeignKey``; ``False``\n+    otherwise.\n+\n+.. attribute:: Field.related_model\n+\n+    Points to the model the field relates to. For example, ``Author`` in\n+    ``ForeignKey(Author)``. If a field has a generic relation (such as a\n+    ``GenericForeignKey`` or a ``GenericRelation``) then ``related_model``\n+    will be ``None``.\ndiff --git a/docs/ref/models/meta.txt b/docs/ref/models/meta.txt\nnew file mode 100644\nindex 000000000000..c00888c79dea\n--- /dev/null\n+++ b/docs/ref/models/meta.txt\n@@ -0,0 +1,289 @@\n+===================\n+Model ``_meta`` API\n+===================\n+\n+.. module:: django.db.models.options\n+   :synopsis: Model meta-class layer\n+\n+.. class:: Options\n+\n+The model ``_meta`` API is at the core of the Django ORM. It enables other\n+parts of the system such as lookups, queries, forms, and the admin to\n+understand the capabilities of each model. The API is accessible through\n+the ``_meta`` attribute of each model class, which is an instance of an\n+``django.db.models.options.Options`` object.\n+\n+Methods that it provides can be used to:\n+\n+* Retrieve all field instances of a model\n+* Retrieve a single field instance of a model by name\n+\n+.. versionchanged:: 1.8\n+\n+    The Model ``_meta`` API has always existed as a Django internal, but\n+    wasn't formally documented and supported. As part of the effort to\n+    make this API public, some of the already existing API entry points\n+    have changed slightly. A :ref:`migration guide <migrating-old-meta-api>`\n+    has been provided to assist in converting your code to use the new,\n+    official API.\n+\n+.. _model-meta-field-api:\n+\n+Field access API\n+================\n+\n+Retrieving a single field instance of a model by name\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+.. method:: Options.get_field(field_name)\n+\n+    Returns the field instance given a name of a field.\n+\n+    ``field_name`` can be the name of a field on the model, a field\n+    on an abstract or inherited model, or a field defined on another\n+    model that points to the model. In the latter case, the ``field_name``\n+    will be the ``related_name`` defined by the user or the name automatically\n+    generated by Django itself.\n+\n+    :attr:`Hidden fields <django.db.models.Field.hidden>` cannot be retrieved\n+    by name.\n+\n+    If a field with the given name is not found a\n+    :class:`~django.core.exceptions.FieldDoesNotExist` exception will be\n+    raised.\n+\n+    .. code-block:: python\n+\n+        >>> from django.contrib.auth.models import User\n+\n+        # A field on the model\n+        >>> User._meta.get_field('username')\n+        <django.db.models.fields.CharField: username>\n+\n+        # A field from another model that has a relation with the current model\n+        >>> User._meta.get_field('logentry')\n+        <ManyToOneRel: admin.logentry>\n+\n+        # A non existent field\n+        >>> User._meta.get_field('does_not_exist')\n+        Traceback (most recent call last):\n+            ...\n+        FieldDoesNotExist: User has no field named 'does_not_exist'\n+\n+    .. deprecated:: 1.8\n+\n+        :meth:`Options.get_field()` previously accepted a ``many_to_many``\n+        parameter which could be set to ``False`` to avoid searching\n+        ``ManyToManyField``\\s. The old behavior has been preserved for\n+        backwards compatibility; however, the parameter and this behavior\n+        has been deprecated.\n+\n+        If you wish to filter out ``ManyToManyField``\\s, you can inspect the\n+        :attr:`Field.many_to_many <django.db.models.Field.many_to_many>`\n+        attribute after calling ``get_field()``.\n+\n+Retrieving all field instances of a model\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+.. method:: Options.get_fields(include_parents=True, include_hidden=False)\n+\n+    .. versionadded:: 1.8\n+\n+    Returns a tuple of fields associated with a model. ``get_fields()`` accepts\n+    two parameters that can be used to control which fields are returned:\n+\n+    ``include_parents``\n+        ``True`` by default. Recursively includes fields defined on parent\n+        classes. If set to ``False``, ``get_fields()`` will only search for\n+        fields declared directly on the current model. Fields from models that\n+        directly inherit from abstract models or proxy classes are considered\n+        to be local, not on the parent.\n+\n+    ``include_hidden``\n+        ``False`` by default. If set to ``True``, ``get_fields()`` will include\n+        fields that are used to back other field's functionality. This will\n+        also include any fields that have a ``related_name`` (such\n+        as :class:`~django.db.models.ManyToManyField`, or\n+        :class:`~django.db.models.ForeignKey`) that start with a \"+\".\n+\n+    .. code-block:: python\n+\n+        >>> from django.contrib.auth.models import User\n+        >>> User._meta.get_fields()\n+        (<ManyToOneRel: admin.logentry>,\n+         <django.db.models.fields.AutoField: id>,\n+         <django.db.models.fields.CharField: password>,\n+         <django.db.models.fields.DateTimeField: last_login>,\n+         <django.db.models.fields.BooleanField: is_superuser>,\n+         <django.db.models.fields.CharField: username>,\n+         <django.db.models.fields.CharField: first_name>,\n+         <django.db.models.fields.CharField: last_name>,\n+         <django.db.models.fields.EmailField: email>,\n+         <django.db.models.fields.BooleanField: is_staff>,\n+         <django.db.models.fields.BooleanField: is_active>,\n+         <django.db.models.fields.DateTimeField: date_joined>,\n+         <django.db.models.fields.related.ManyToManyField: groups>,\n+         <django.db.models.fields.related.ManyToManyField: user_permissions>)\n+\n+        # Also include hidden fields.\n+        >>> User._meta.get_fields(include_hidden=True)\n+        (<ManyToOneRel: auth.user_groups>,\n+         <ManyToOneRel: auth.user_user_permissions>,\n+         <ManyToOneRel: admin.logentry>,\n+         <django.db.models.fields.AutoField: id>,\n+         <django.db.models.fields.CharField: password>,\n+         <django.db.models.fields.DateTimeField: last_login>,\n+         <django.db.models.fields.BooleanField: is_superuser>,\n+         <django.db.models.fields.CharField: username>,\n+         <django.db.models.fields.CharField: first_name>,\n+         <django.db.models.fields.CharField: last_name>,\n+         <django.db.models.fields.EmailField: email>,\n+         <django.db.models.fields.BooleanField: is_staff>,\n+         <django.db.models.fields.BooleanField: is_active>,\n+         <django.db.models.fields.DateTimeField: date_joined>,\n+         <django.db.models.fields.related.ManyToManyField: groups>,\n+         <django.db.models.fields.related.ManyToManyField: user_permissions>)\n+\n+.. _migrating-old-meta-api:\n+\n+Migrating from the old API\n+==========================\n+\n+As part of the formalization of the ``Model._meta`` API (from the\n+:class:`django.db.models.options.Options` class), a number of methods and\n+properties have been deprecated and will be removed in Django 2.0.\n+\n+These old APIs can be replicated by either:\n+\n+* invoking :meth:`Options.get_field()\n+  <django.db.models.options.Options.get_field()>`, or;\n+\n+* invoking :meth:`Options.get_fields()\n+  <django.db.models.options.Options.get_fields()>` to retrieve a list of all\n+  fields, and then filtering this list using the :ref:`field attributes\n+  <model-field-attributes>` that describe (or retrieve, in the case of\n+  ``_with_model`` variants) the properties of the desired fields.\n+\n+Although it would be possible to provide replacements for the old API, a\n+simple drop-in replacement probably won't be the best approach in practice.\n+Taking the time to refactor any field loops to make better use of the new\n+API - and possibly include fields that were previously excluded - will\n+almost certainly result in better code.\n+\n+Assuming you have a model named ``MyModel``, the following substitutions\n+can be made to convert your code to the new API:\n+\n+* ``MyModel._meta.get_field(name)``::\n+\n+      f = MyModel._meta.get_field(name)\n+\n+  then check if:\n+\n+  - ``f.auto_created == False``, because the new ``get_field()``\n+    API will find \"reverse\" relations), and:\n+\n+  - ``f.is_relation and f.related_model is None``, because the new\n+    ``get_field()`` API will find\n+    :class:`~django.contrib.contenttypes.fields.GenericForeignKey` relations;\n+\n+* ``MyModel._meta.get_field_by_name(name)``:\n+\n+  ``get_field_by_name()`` returned four values:\n+  ``(field, model, direct,  m2m)``:\n+\n+  - ``field`` can be found by ``MyModel._meta.get_field(name)``\n+\n+  - ``model`` can be found through the\n+    :attr:`~django.db.models.Field.model` attribute on the field.\n+\n+  - ``direct`` can be found by: ``not field.auto_created or field.concrete``\n+\n+    The :attr:`~django.db.models.Field.auto_created` check excludes\n+    all \"forward\" and \"reverse\" relations that are created by Django, but\n+    this also includes ``AutoField`` and ``OneToOneField`` on proxy models.\n+    We avoid filtering out these attributes using the\n+    :attr:`concrete <django.db.models.Field.concrete>` attribute.\n+\n+  - ``m2m`` can be found through the\n+    :attr:`~django.db.models.Field.many_to_many` attribute on the field.\n+\n+* ``MyModel._meta.get_fields_with_model()``::\n+\n+      [\n+          (f, f.model if f.model != MyModel else None)\n+          for f in MyModel._meta.get_fields()\n+          if not f.is_relation\n+              or f.one_to_one\n+              or (f.one_to_many and f.related_model)\n+      ]\n+\n+* ``MyModel._meta.get_concrete_fields_with_model()``::\n+\n+      [\n+          (f, f.model if f.model != MyModel else None)\n+          for f in MyModel._meta.get_fields()\n+          if f.concrete and (\n+              not f.is_relation\n+              or f.one_to_one\n+              or (f.one_to_many and f.related_model)\n+          )\n+      ]\n+\n+* ``MyModel._meta.get_m2m_with_model()``::\n+\n+      [\n+          (f, f.model if f.model != MyModel else None)\n+          for f in MyModel._meta.get_fields()\n+          if f.many_to_many and not f.auto_created\n+      ]\n+\n+* ``MyModel._meta.get_all_related_objects()``::\n+\n+      [\n+          f for f in MyModel._meta.get_fields()\n+          if f.many_to_one and f.auto_created\n+      ]\n+\n+* ``MyModel._meta.get_all_related_objects_with_model()``::\n+\n+      [\n+          (f, f.model if f.model != MyModel else None)\n+          for f in MyModel._meta.get_fields()\n+          if f.many_to_one and f.auto_created\n+      ]\n+\n+* ``MyModel._meta.get_all_related_many_to_many_objects()``::\n+\n+      [\n+          f for f in MyModel._meta.get_fields(include_hidden=True)\n+          if f.many_to_many and f.auto_created\n+      ]\n+\n+* ``MyModel._meta.get_all_related_m2m_objects_with_model()``::\n+\n+      [\n+          (f, f.model if f.model != MyModel else None)\n+          for f in MyModel._meta.get_fields(include_hidden=True)\n+          if f.many_to_many and f.auto_created\n+      ]\n+\n+* ``MyModel._meta.get_all_field_names()``::\n+\n+      from itertools import chain\n+      list(set(chain.from_iterable(\n+          (field.name, field.attname) if hasattr(field, 'attname') else (field.name,)\n+          for field in MyModel._meta.get_fields()\n+          # For complete backwards compatibility, you may want to exclude\n+          # GenericForeignKey from the results.\n+          if not (field.one_to_many and field.related_model is None)\n+      )))\n+\n+  This provides a 100% backwards compatible replacement, ensuring that both\n+  field names and attribute names ``ForeignKey``\\s are included, but fields\n+  associated with``GenericForeignKey``\\s are not. A simpler version would be::\n+\n+      [f.name for f in MyModel._meta.get_fields()]\n+\n+  While this isn't 100% backwards compatible, it may be sufficient in many\n+  situations.\n+\ndiff --git a/tests/model_fields/test_field_flags.py b/tests/model_fields/test_field_flags.py\nnew file mode 100644\nindex 000000000000..08a57db5019c\n--- /dev/null\n+++ b/tests/model_fields/test_field_flags.py\n@@ -0,0 +1,220 @@\n+from django import test\n+\n+from django.contrib.contenttypes.fields import (\n+    GenericForeignKey, GenericRelation,\n+)\n+from django.db import models\n+from django.db.models.fields.related import (\n+    ForeignObject, ForeignKey, OneToOneField, ManyToManyField,\n+    ManyToOneRel, ForeignObjectRel,\n+)\n+\n+from .models import AllFieldsModel\n+\n+\n+NON_CONCRETE_FIELDS = (\n+    ForeignObject,\n+    GenericForeignKey,\n+    GenericRelation,\n+)\n+\n+NON_EDITABLE_FIELDS = (\n+    models.BinaryField,\n+    GenericForeignKey,\n+    GenericRelation,\n+)\n+\n+RELATION_FIELDS = (\n+    ForeignKey,\n+    ForeignObject,\n+    ManyToManyField,\n+    OneToOneField,\n+    GenericForeignKey,\n+    GenericRelation,\n+)\n+\n+ONE_TO_MANY_CLASSES = {\n+    ForeignObject,\n+    ForeignKey,\n+    GenericForeignKey,\n+}\n+\n+MANY_TO_ONE_CLASSES = {\n+    ForeignObjectRel,\n+    ManyToOneRel,\n+    GenericRelation,\n+}\n+\n+MANY_TO_MANY_CLASSES = {\n+    ManyToManyField,\n+}\n+\n+ONE_TO_ONE_CLASSES = {\n+    OneToOneField,\n+}\n+\n+FLAG_PROPERTIES = (\n+    'concrete',\n+    'editable',\n+    'is_relation',\n+    'model',\n+    'hidden',\n+    'one_to_many',\n+    'many_to_one',\n+    'many_to_many',\n+    'one_to_one',\n+    'related_model',\n+)\n+\n+FLAG_PROPERTIES_FOR_RELATIONS = (\n+    'one_to_many',\n+    'many_to_one',\n+    'many_to_many',\n+    'one_to_one',\n+)\n+\n+\n+class FieldFlagsTests(test.TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        super(FieldFlagsTests, cls).setUpClass()\n+        cls.fields = (\n+            list(AllFieldsModel._meta.fields) +\n+            list(AllFieldsModel._meta.virtual_fields)\n+        )\n+\n+        cls.all_fields = (\n+            cls.fields +\n+            list(AllFieldsModel._meta.many_to_many) +\n+            list(AllFieldsModel._meta.virtual_fields)\n+        )\n+\n+        cls.fields_and_reverse_objects = (\n+            cls.all_fields +\n+            list(AllFieldsModel._meta.related_objects)\n+        )\n+\n+    def test_each_field_should_have_a_concrete_attribute(self):\n+        self.assertTrue(all(f.concrete.__class__ == bool for f in self.fields))\n+\n+    def test_each_field_should_have_an_editable_attribute(self):\n+        self.assertTrue(all(f.editable.__class__ == bool for f in self.all_fields))\n+\n+    def test_each_field_should_have_a_has_rel_attribute(self):\n+        self.assertTrue(all(f.is_relation.__class__ == bool for f in self.all_fields))\n+\n+    def test_each_object_should_have_auto_created(self):\n+        self.assertTrue(\n+            all(f.auto_created.__class__ == bool\n+            for f in self.fields_and_reverse_objects)\n+        )\n+\n+    def test_non_concrete_fields(self):\n+        for field in self.fields:\n+            if type(field) in NON_CONCRETE_FIELDS:\n+                self.assertFalse(field.concrete)\n+            else:\n+                self.assertTrue(field.concrete)\n+\n+    def test_non_editable_fields(self):\n+        for field in self.all_fields:\n+            if type(field) in NON_EDITABLE_FIELDS:\n+                self.assertFalse(field.editable)\n+            else:\n+                self.assertTrue(field.editable)\n+\n+    def test_related_fields(self):\n+        for field in self.all_fields:\n+            if type(field) in RELATION_FIELDS:\n+                self.assertTrue(field.is_relation)\n+            else:\n+                self.assertFalse(field.is_relation)\n+\n+    def test_field_names_should_always_be_available(self):\n+        for field in self.fields_and_reverse_objects:\n+            self.assertTrue(field.name)\n+\n+    def test_all_field_types_should_have_flags(self):\n+        for field in self.fields_and_reverse_objects:\n+            for flag in FLAG_PROPERTIES:\n+                self.assertTrue(hasattr(field, flag), \"Field %s does not have flag %s\" % (field, flag))\n+            if field.is_relation:\n+                true_cardinality_flags = sum(\n+                    getattr(field, flag) is True\n+                    for flag in FLAG_PROPERTIES_FOR_RELATIONS\n+                )\n+                # If the field has a relation, there should be only one of the\n+                # 4 cardinality flags available.\n+                self.assertEqual(1, true_cardinality_flags)\n+\n+    def test_cardinality_m2m(self):\n+        m2m_type_fields = (\n+            f for f in self.all_fields\n+            if f.is_relation and f.many_to_many\n+        )\n+        # Test classes are what we expect\n+        self.assertEqual(MANY_TO_MANY_CLASSES, {f.__class__ for f in m2m_type_fields})\n+\n+        # Ensure all m2m reverses are m2m\n+        for field in m2m_type_fields:\n+            reverse_field = field.rel\n+            self.assertTrue(reverse_field.is_relation)\n+            self.assertTrue(reverse_field.many_to_many)\n+            self.assertTrue(reverse_field.related_model)\n+\n+    def test_cardinality_o2m(self):\n+        o2m_type_fields = [\n+            f for f in self.fields_and_reverse_objects\n+            if f.is_relation and f.one_to_many\n+        ]\n+        # Test classes are what we expect\n+        self.assertEqual(ONE_TO_MANY_CLASSES, {f.__class__ for f in o2m_type_fields})\n+\n+        # Ensure all o2m reverses are m2o\n+        for field in o2m_type_fields:\n+            if field.concrete:\n+                reverse_field = field.rel\n+                self.assertTrue(reverse_field.is_relation and reverse_field.many_to_one)\n+\n+    def test_cardinality_m2o(self):\n+        m2o_type_fields = [\n+            f for f in self.fields_and_reverse_objects\n+            if f.is_relation and f.many_to_one\n+        ]\n+        # Test classes are what we expect\n+        self.assertEqual(MANY_TO_ONE_CLASSES, {f.__class__ for f in m2o_type_fields})\n+\n+        # Ensure all m2o reverses are o2m\n+        for obj in m2o_type_fields:\n+            if hasattr(obj, 'field'):\n+                reverse_field = obj.field\n+                self.assertTrue(reverse_field.is_relation and reverse_field.one_to_many)\n+\n+    def test_cardinality_o2o(self):\n+        o2o_type_fields = [\n+            f for f in self.all_fields\n+            if f.is_relation and f.one_to_one\n+        ]\n+        # Test classes are what we expect\n+        self.assertEqual(ONE_TO_ONE_CLASSES, {f.__class__ for f in o2o_type_fields})\n+\n+        # Ensure all o2o reverses are o2o\n+        for obj in o2o_type_fields:\n+            if hasattr(obj, 'field'):\n+                reverse_field = obj.field\n+                self.assertTrue(reverse_field.is_relation and reverse_field.one_to_one)\n+\n+    def test_hidden_flag(self):\n+        incl_hidden = set(AllFieldsModel._meta.get_fields(include_hidden=True))\n+        no_hidden = set(AllFieldsModel._meta.get_fields())\n+        fields_that_should_be_hidden = (incl_hidden - no_hidden)\n+        for f in incl_hidden:\n+            self.assertEqual(f in fields_that_should_be_hidden, f.hidden)\n+\n+    def test_model_and_reverse_model_should_equal_on_relations(self):\n+        for field in AllFieldsModel._meta.get_fields():\n+            is_concrete_forward_field = field.concrete and field.related_model\n+            if is_concrete_forward_field:\n+                reverse_field = field.rel\n+                self.assertEqual(field.model, reverse_field.related_model)\n+                self.assertEqual(field.related_model, reverse_field.model)\ndiff --git a/tests/model_meta/results.py b/tests/model_meta/results.py\nnew file mode 100644\nindex 000000000000..1efc49ed235b\n--- /dev/null\n+++ b/tests/model_meta/results.py\n@@ -0,0 +1,796 @@\n+from .models import (\n+    AbstractPerson, BasePerson, Person, Relating, Relation,\n+)\n+\n+TEST_RESULTS = {\n+    'get_all_field_names': {\n+        Person: [\n+            'baseperson_ptr',\n+            'baseperson_ptr_id',\n+            'content_type_abstract',\n+            'content_type_abstract_id',\n+            'content_type_base',\n+            'content_type_base_id',\n+            'content_type_concrete',\n+            'content_type_concrete_id',\n+            'data_abstract',\n+            'data_base',\n+            'data_inherited',\n+            'data_not_concrete_abstract',\n+            'data_not_concrete_base',\n+            'data_not_concrete_inherited',\n+            'fk_abstract',\n+            'fk_abstract_id',\n+            'fk_base',\n+            'fk_base_id',\n+            'fk_inherited',\n+            'fk_inherited_id',\n+            'followers_abstract',\n+            'followers_base',\n+            'followers_concrete',\n+            'following_abstract',\n+            'following_base',\n+            'following_inherited',\n+            'friends_abstract',\n+            'friends_base',\n+            'friends_inherited',\n+            'generic_relation_abstract',\n+            'generic_relation_base',\n+            'generic_relation_concrete',\n+            'id',\n+            'm2m_abstract',\n+            'm2m_base',\n+            'm2m_inherited',\n+            'object_id_abstract',\n+            'object_id_base',\n+            'object_id_concrete',\n+            'relating_basepeople',\n+            'relating_baseperson',\n+            'relating_people',\n+            'relating_person',\n+        ],\n+        BasePerson: [\n+            'content_type_abstract',\n+            'content_type_abstract_id',\n+            'content_type_base',\n+            'content_type_base_id',\n+            'data_abstract',\n+            'data_base',\n+            'data_not_concrete_abstract',\n+            'data_not_concrete_base',\n+            'fk_abstract',\n+            'fk_abstract_id',\n+            'fk_base',\n+            'fk_base_id',\n+            'followers_abstract',\n+            'followers_base',\n+            'following_abstract',\n+            'following_base',\n+            'friends_abstract',\n+            'friends_base',\n+            'generic_relation_abstract',\n+            'generic_relation_base',\n+            'id',\n+            'm2m_abstract',\n+            'm2m_base',\n+            'object_id_abstract',\n+            'object_id_base',\n+            'person',\n+            'relating_basepeople',\n+            'relating_baseperson'\n+        ],\n+        AbstractPerson: [\n+            'content_type_abstract',\n+            'content_type_abstract_id',\n+            'data_abstract',\n+            'data_not_concrete_abstract',\n+            'fk_abstract',\n+            'fk_abstract_id',\n+            'following_abstract',\n+            'friends_abstract',\n+            'generic_relation_abstract',\n+            'm2m_abstract',\n+            'object_id_abstract',\n+        ],\n+        Relating: [\n+            'basepeople',\n+            'basepeople_hidden',\n+            'baseperson',\n+            'baseperson_hidden',\n+            'baseperson_hidden_id',\n+            'baseperson_id',\n+            'id',\n+            'people',\n+            'people_hidden',\n+            'person',\n+            'person_hidden',\n+            'person_hidden_id',\n+            'person_id',\n+            'proxyperson',\n+            'proxyperson_hidden',\n+            'proxyperson_hidden_id',\n+            'proxyperson_id',\n+        ],\n+    },\n+    'fields': {\n+        Person: [\n+            'id',\n+            'data_abstract',\n+            'fk_abstract_id',\n+            'data_not_concrete_abstract',\n+            'content_type_abstract_id',\n+            'object_id_abstract',\n+            'data_base',\n+            'fk_base_id',\n+            'data_not_concrete_base',\n+            'content_type_base_id',\n+            'object_id_base',\n+            'baseperson_ptr_id',\n+            'data_inherited',\n+            'fk_inherited_id',\n+            'data_not_concrete_inherited',\n+            'content_type_concrete_id',\n+            'object_id_concrete',\n+        ],\n+        BasePerson: [\n+            'id',\n+            'data_abstract',\n+            'fk_abstract_id',\n+            'data_not_concrete_abstract',\n+            'content_type_abstract_id',\n+            'object_id_abstract',\n+            'data_base',\n+            'fk_base_id',\n+            'data_not_concrete_base',\n+            'content_type_base_id',\n+            'object_id_base',\n+        ],\n+        AbstractPerson: [\n+            'data_abstract',\n+            'fk_abstract_id',\n+            'data_not_concrete_abstract',\n+            'content_type_abstract_id',\n+            'object_id_abstract',\n+        ],\n+        Relating: [\n+            'id',\n+            'baseperson_id',\n+            'baseperson_hidden_id',\n+            'person_id',\n+            'person_hidden_id',\n+            'proxyperson_id',\n+            'proxyperson_hidden_id',\n+        ],\n+    },\n+    'local_fields': {\n+        Person: [\n+            'baseperson_ptr_id',\n+            'data_inherited',\n+            'fk_inherited_id',\n+            'data_not_concrete_inherited',\n+            'content_type_concrete_id',\n+            'object_id_concrete',\n+        ],\n+        BasePerson: [\n+            'id',\n+            'data_abstract',\n+            'fk_abstract_id',\n+            'data_not_concrete_abstract',\n+            'content_type_abstract_id',\n+            'object_id_abstract',\n+            'data_base',\n+            'fk_base_id',\n+            'data_not_concrete_base',\n+            'content_type_base_id',\n+            'object_id_base',\n+        ],\n+        AbstractPerson: [\n+            'data_abstract',\n+            'fk_abstract_id',\n+            'data_not_concrete_abstract',\n+            'content_type_abstract_id',\n+            'object_id_abstract',\n+        ],\n+        Relating: [\n+            'id',\n+            'baseperson_id',\n+            'baseperson_hidden_id',\n+            'person_id',\n+            'person_hidden_id',\n+            'proxyperson_id',\n+            'proxyperson_hidden_id',\n+        ],\n+    },\n+    'local_concrete_fields': {\n+        Person: [\n+            'baseperson_ptr_id',\n+            'data_inherited',\n+            'fk_inherited_id',\n+            'content_type_concrete_id',\n+            'object_id_concrete',\n+        ],\n+        BasePerson: [\n+            'id',\n+            'data_abstract',\n+            'fk_abstract_id',\n+            'content_type_abstract_id',\n+            'object_id_abstract',\n+            'data_base',\n+            'fk_base_id',\n+            'content_type_base_id',\n+            'object_id_base',\n+        ],\n+        AbstractPerson: [\n+            'data_abstract',\n+            'fk_abstract_id',\n+            'content_type_abstract_id',\n+            'object_id_abstract',\n+        ],\n+        Relating: [\n+            'id',\n+            'baseperson_id',\n+            'baseperson_hidden_id',\n+            'person_id',\n+            'person_hidden_id',\n+            'proxyperson_id',\n+            'proxyperson_hidden_id',\n+        ],\n+    },\n+    'many_to_many': {\n+        Person: [\n+            'm2m_abstract',\n+            'friends_abstract',\n+            'following_abstract',\n+            'm2m_base',\n+            'friends_base',\n+            'following_base',\n+            'm2m_inherited',\n+            'friends_inherited',\n+            'following_inherited',\n+        ],\n+        BasePerson: [\n+            'm2m_abstract',\n+            'friends_abstract',\n+            'following_abstract',\n+            'm2m_base',\n+            'friends_base',\n+            'following_base',\n+        ],\n+        AbstractPerson: [\n+            'm2m_abstract',\n+            'friends_abstract',\n+            'following_abstract',\n+        ],\n+        Relating: [\n+            'basepeople',\n+            'basepeople_hidden',\n+            'people',\n+            'people_hidden',\n+        ],\n+    },\n+    'many_to_many_with_model': {\n+        Person: [\n+            BasePerson,\n+            BasePerson,\n+            BasePerson,\n+            BasePerson,\n+            BasePerson,\n+            BasePerson,\n+            None,\n+            None,\n+            None,\n+        ],\n+        BasePerson: [\n+            None,\n+            None,\n+            None,\n+            None,\n+            None,\n+            None,\n+        ],\n+        AbstractPerson: [\n+            None,\n+            None,\n+            None,\n+        ],\n+        Relating: [\n+            None,\n+            None,\n+            None,\n+            None,\n+        ],\n+    },\n+    'get_all_related_objects_with_model_legacy': {\n+        Person: (\n+            ('relating_baseperson', BasePerson),\n+            ('relating_person', None),\n+        ),\n+        BasePerson: (\n+            ('person', None),\n+            ('relating_baseperson', None),\n+        ),\n+        Relation: (\n+            ('fk_abstract_rel', None),\n+            ('fo_abstract_rel', None),\n+            ('fk_base_rel', None),\n+            ('fo_base_rel', None),\n+            ('fk_concrete_rel', None),\n+            ('fo_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_objects_with_model_hidden_local': {\n+        Person: (\n+            ('+', None),\n+            ('+', None),\n+            ('Person_following_inherited+', None),\n+            ('Person_following_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('Relating_people+', None),\n+            ('Relating_people_hidden+', None),\n+            ('followers_concrete', None),\n+            ('friends_inherited_rel_+', None),\n+            ('relating_people', None),\n+            ('relating_person', None),\n+        ),\n+        BasePerson: (\n+            ('+', None),\n+            ('+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Relating_basepeople+', None),\n+            ('Relating_basepeople_hidden+', None),\n+            ('followers_abstract', None),\n+            ('followers_base', None),\n+            ('friends_abstract_rel_+', None),\n+            ('friends_base_rel_+', None),\n+            ('person', None),\n+            ('relating_basepeople', None),\n+            ('relating_baseperson', None),\n+        ),\n+        Relation: (\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('fk_abstract_rel', None),\n+            ('fk_base_rel', None),\n+            ('fk_concrete_rel', None),\n+            ('fo_abstract_rel', None),\n+            ('fo_base_rel', None),\n+            ('fo_concrete_rel', None),\n+            ('m2m_abstract_rel', None),\n+            ('m2m_base_rel', None),\n+            ('m2m_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_objects_with_model_hidden': {\n+        Person: (\n+            ('+', BasePerson),\n+            ('+', BasePerson),\n+            ('+', None),\n+            ('+', None),\n+            ('BasePerson_following_abstract+', BasePerson),\n+            ('BasePerson_following_abstract+', BasePerson),\n+            ('BasePerson_following_base+', BasePerson),\n+            ('BasePerson_following_base+', BasePerson),\n+            ('BasePerson_friends_abstract+', BasePerson),\n+            ('BasePerson_friends_abstract+', BasePerson),\n+            ('BasePerson_friends_base+', BasePerson),\n+            ('BasePerson_friends_base+', BasePerson),\n+            ('BasePerson_m2m_abstract+', BasePerson),\n+            ('BasePerson_m2m_base+', BasePerson),\n+            ('Person_following_inherited+', None),\n+            ('Person_following_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('Relating_basepeople+', BasePerson),\n+            ('Relating_basepeople_hidden+', BasePerson),\n+            ('Relating_people+', None),\n+            ('Relating_people_hidden+', None),\n+            ('followers_abstract', BasePerson),\n+            ('followers_base', BasePerson),\n+            ('followers_concrete', None),\n+            ('friends_abstract_rel_+', BasePerson),\n+            ('friends_base_rel_+', BasePerson),\n+            ('friends_inherited_rel_+', None),\n+            ('relating_basepeople', BasePerson),\n+            ('relating_baseperson', BasePerson),\n+            ('relating_people', None),\n+            ('relating_person', None),\n+        ),\n+        BasePerson: (\n+            ('+', None),\n+            ('+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Relating_basepeople+', None),\n+            ('Relating_basepeople_hidden+', None),\n+            ('followers_abstract', None),\n+            ('followers_base', None),\n+            ('friends_abstract_rel_+', None),\n+            ('friends_base_rel_+', None),\n+            ('person', None),\n+            ('relating_basepeople', None),\n+            ('relating_baseperson', None),\n+        ),\n+        Relation: (\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('fk_abstract_rel', None),\n+            ('fk_base_rel', None),\n+            ('fk_concrete_rel', None),\n+            ('fo_abstract_rel', None),\n+            ('fo_base_rel', None),\n+            ('fo_concrete_rel', None),\n+            ('m2m_abstract_rel', None),\n+            ('m2m_base_rel', None),\n+            ('m2m_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_objects_with_model_local': {\n+        Person: (\n+            ('followers_concrete', None),\n+            ('relating_person', None),\n+            ('relating_people', None),\n+        ),\n+        BasePerson: (\n+            ('followers_abstract', None),\n+            ('followers_base', None),\n+            ('person', None),\n+            ('relating_baseperson', None),\n+            ('relating_basepeople', None),\n+        ),\n+        Relation: (\n+            ('fk_abstract_rel', None),\n+            ('fo_abstract_rel', None),\n+            ('fk_base_rel', None),\n+            ('fo_base_rel', None),\n+            ('m2m_abstract_rel', None),\n+            ('m2m_base_rel', None),\n+            ('fk_concrete_rel', None),\n+            ('fo_concrete_rel', None),\n+            ('m2m_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_objects_with_model': {\n+        Person: (\n+            ('followers_abstract', BasePerson),\n+            ('followers_base', BasePerson),\n+            ('relating_baseperson', BasePerson),\n+            ('relating_basepeople', BasePerson),\n+            ('followers_concrete', None),\n+            ('relating_person', None),\n+            ('relating_people', None),\n+        ),\n+        BasePerson: (\n+            ('followers_abstract', None),\n+            ('followers_base', None),\n+            ('person', None),\n+            ('relating_baseperson', None),\n+            ('relating_basepeople', None),\n+        ),\n+        Relation: (\n+            ('fk_abstract_rel', None),\n+            ('fo_abstract_rel', None),\n+            ('fk_base_rel', None),\n+            ('fo_base_rel', None),\n+            ('m2m_abstract_rel', None),\n+            ('m2m_base_rel', None),\n+            ('fk_concrete_rel', None),\n+            ('fo_concrete_rel', None),\n+            ('m2m_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_objects_with_model_local_legacy': {\n+        Person: (\n+            ('relating_person', None),\n+        ),\n+        BasePerson: (\n+            ('person', None),\n+            ('relating_baseperson', None)\n+        ),\n+        Relation: (\n+            ('fk_abstract_rel', None),\n+            ('fo_abstract_rel', None),\n+            ('fk_base_rel', None),\n+            ('fo_base_rel', None),\n+            ('fk_concrete_rel', None),\n+            ('fo_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_objects_with_model_hidden_legacy': {\n+        BasePerson: (\n+            ('+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Relating_basepeople+', None),\n+            ('Relating_basepeople_hidden+', None),\n+            ('person', None),\n+            ('relating_baseperson', None),\n+        ),\n+        Person: (\n+            ('+', BasePerson),\n+            ('+', None),\n+            ('BasePerson_following_abstract+', BasePerson),\n+            ('BasePerson_following_abstract+', BasePerson),\n+            ('BasePerson_following_base+', BasePerson),\n+            ('BasePerson_following_base+', BasePerson),\n+            ('BasePerson_friends_abstract+', BasePerson),\n+            ('BasePerson_friends_abstract+', BasePerson),\n+            ('BasePerson_friends_base+', BasePerson),\n+            ('BasePerson_friends_base+', BasePerson),\n+            ('BasePerson_m2m_abstract+', BasePerson),\n+            ('BasePerson_m2m_base+', BasePerson),\n+            ('Person_following_inherited+', None),\n+            ('Person_following_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('Relating_basepeople+', BasePerson),\n+            ('Relating_basepeople_hidden+', BasePerson),\n+            ('Relating_people+', None),\n+            ('Relating_people_hidden+', None),\n+            ('relating_baseperson', BasePerson),\n+            ('relating_person', None),\n+        ),\n+        Relation: (\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('fk_abstract_rel', None),\n+            ('fk_base_rel', None),\n+            ('fk_concrete_rel', None),\n+            ('fo_abstract_rel', None),\n+            ('fo_base_rel', None),\n+            ('fo_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_objects_with_model_hidden_local_legacy': {\n+        BasePerson: (\n+            ('+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Relating_basepeople+', None),\n+            ('Relating_basepeople_hidden+', None),\n+            ('person', None),\n+            ('relating_baseperson', None),\n+        ),\n+        Person: (\n+            ('+', None),\n+            ('Person_following_inherited+', None),\n+            ('Person_following_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('Relating_people+', None),\n+            ('Relating_people_hidden+', None),\n+            ('relating_person', None),\n+        ),\n+        Relation: (\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('fk_abstract_rel', None),\n+            ('fk_base_rel', None),\n+            ('fk_concrete_rel', None),\n+            ('fo_abstract_rel', None),\n+            ('fo_base_rel', None),\n+            ('fo_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_objects_with_model_proxy_legacy': {\n+        BasePerson: (\n+            ('person', None),\n+            ('relating_baseperson', None),\n+        ),\n+        Person: (\n+            ('relating_baseperson', BasePerson),\n+            ('relating_person', None), ('relating_proxyperson', None),\n+        ),\n+        Relation: (\n+            ('fk_abstract_rel', None), ('fo_abstract_rel', None),\n+            ('fk_base_rel', None), ('fo_base_rel', None),\n+            ('fk_concrete_rel', None), ('fo_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_objects_with_model_proxy_hidden_legacy': {\n+        BasePerson: (\n+            ('+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_abstract+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_following_base+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_abstract+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_friends_base+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Relating_basepeople+', None),\n+            ('Relating_basepeople_hidden+', None),\n+            ('person', None),\n+            ('relating_baseperson', None),\n+        ),\n+        Person: (\n+            ('+', BasePerson),\n+            ('+', None),\n+            ('+', None),\n+            ('BasePerson_following_abstract+', BasePerson),\n+            ('BasePerson_following_abstract+', BasePerson),\n+            ('BasePerson_following_base+', BasePerson),\n+            ('BasePerson_following_base+', BasePerson),\n+            ('BasePerson_friends_abstract+', BasePerson),\n+            ('BasePerson_friends_abstract+', BasePerson),\n+            ('BasePerson_friends_base+', BasePerson),\n+            ('BasePerson_friends_base+', BasePerson),\n+            ('BasePerson_m2m_abstract+', BasePerson),\n+            ('BasePerson_m2m_base+', BasePerson),\n+            ('Person_following_inherited+', None),\n+            ('Person_following_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_friends_inherited+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('Relating_basepeople+', BasePerson),\n+            ('Relating_basepeople_hidden+', BasePerson),\n+            ('Relating_people+', None),\n+            ('Relating_people_hidden+', None),\n+            ('relating_baseperson', BasePerson),\n+            ('relating_person', None),\n+            ('relating_proxyperson', None),\n+        ),\n+        Relation: (\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('+', None),\n+            ('BasePerson_m2m_abstract+', None),\n+            ('BasePerson_m2m_base+', None),\n+            ('Person_m2m_inherited+', None),\n+            ('fk_abstract_rel', None),\n+            ('fk_base_rel', None),\n+            ('fk_concrete_rel', None),\n+            ('fo_abstract_rel', None),\n+            ('fo_base_rel', None),\n+            ('fo_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_many_to_many_with_model_legacy': {\n+        BasePerson: (\n+            ('friends_abstract_rel_+', None),\n+            ('followers_abstract', None),\n+            ('friends_base_rel_+', None),\n+            ('followers_base', None),\n+            ('relating_basepeople', None),\n+            ('+', None),\n+        ),\n+        Person: (\n+            ('friends_abstract_rel_+', BasePerson),\n+            ('followers_abstract', BasePerson),\n+            ('friends_base_rel_+', BasePerson),\n+            ('followers_base', BasePerson),\n+            ('relating_basepeople', BasePerson),\n+            ('+', BasePerson),\n+            ('friends_inherited_rel_+', None),\n+            ('followers_concrete', None),\n+            ('relating_people', None),\n+            ('+', None),\n+        ),\n+        Relation: (\n+            ('m2m_abstract_rel', None),\n+            ('m2m_base_rel', None),\n+            ('m2m_concrete_rel', None),\n+        ),\n+    },\n+    'get_all_related_many_to_many_local_legacy': {\n+        BasePerson: [\n+            'friends_abstract_rel_+',\n+            'followers_abstract',\n+            'friends_base_rel_+',\n+            'followers_base',\n+            'relating_basepeople',\n+            '+',\n+        ],\n+        Person: [\n+            'friends_inherited_rel_+',\n+            'followers_concrete',\n+            'relating_people',\n+            '+',\n+        ],\n+        Relation: [\n+            'm2m_abstract_rel',\n+            'm2m_base_rel',\n+            'm2m_concrete_rel',\n+        ],\n+    },\n+    'virtual_fields': {\n+        AbstractPerson: [\n+            'generic_relation_abstract',\n+            'content_object_abstract',\n+        ],\n+        BasePerson: [\n+            'generic_relation_base',\n+            'content_object_base',\n+            'generic_relation_abstract',\n+            'content_object_abstract',\n+        ],\n+        Person: [\n+            'content_object_concrete',\n+            'generic_relation_concrete',\n+            'generic_relation_base',\n+            'content_object_base',\n+            'generic_relation_abstract',\n+            'content_object_abstract',\n+        ],\n+    },\n+}\ndiff --git a/tests/model_meta/test.py b/tests/model_meta/test.py\ndeleted file mode 100644\nindex ea861d5ad5b4..000000000000\n--- a/tests/model_meta/test.py\n+++ /dev/null\n@@ -1,661 +0,0 @@\n-from django import test\n-from django.contrib.contenttypes.fields import GenericRelation\n-from django.core.exceptions import FieldDoesNotExist\n-from django.db.models.fields import related, CharField, Field\n-\n-from .models import (\n-    AbstractPerson, BasePerson, Person, Relating, Relation\n-)\n-\n-TEST_RESULTS = {\n-    'fields': {\n-        Person: [\n-            'id',\n-            'data_abstract',\n-            'fk_abstract_id',\n-            'data_not_concrete_abstract',\n-            'content_type_abstract_id',\n-            'object_id_abstract',\n-            'data_base',\n-            'fk_base_id',\n-            'data_not_concrete_base',\n-            'content_type_base_id',\n-            'object_id_base',\n-            'baseperson_ptr_id',\n-            'data_inherited',\n-            'fk_inherited_id',\n-            'data_not_concrete_inherited',\n-            'content_type_concrete_id',\n-            'object_id_concrete',\n-        ],\n-        BasePerson: [\n-            'id',\n-            'data_abstract',\n-            'fk_abstract_id',\n-            'data_not_concrete_abstract',\n-            'content_type_abstract_id',\n-            'object_id_abstract',\n-            'data_base',\n-            'fk_base_id',\n-            'data_not_concrete_base',\n-            'content_type_base_id',\n-            'object_id_base',\n-        ],\n-        AbstractPerson: [\n-            'data_abstract',\n-            'fk_abstract_id',\n-            'data_not_concrete_abstract',\n-            'content_type_abstract_id',\n-            'object_id_abstract',\n-        ],\n-        Relating: [\n-            'id',\n-            'baseperson_id',\n-            'baseperson_hidden_id',\n-            'person_id',\n-            'person_hidden_id',\n-            'proxyperson_id',\n-            'proxyperson_hidden_id',\n-        ],\n-    },\n-    'local_fields': {\n-        Person: [\n-            'baseperson_ptr_id',\n-            'data_inherited',\n-            'fk_inherited_id',\n-            'data_not_concrete_inherited',\n-            'content_type_concrete_id',\n-            'object_id_concrete',\n-        ],\n-        BasePerson: [\n-            'id',\n-            'data_abstract',\n-            'fk_abstract_id',\n-            'data_not_concrete_abstract',\n-            'content_type_abstract_id',\n-            'object_id_abstract',\n-            'data_base',\n-            'fk_base_id',\n-            'data_not_concrete_base',\n-            'content_type_base_id',\n-            'object_id_base',\n-        ],\n-        AbstractPerson: [\n-            'data_abstract',\n-            'fk_abstract_id',\n-            'data_not_concrete_abstract',\n-            'content_type_abstract_id',\n-            'object_id_abstract',\n-        ],\n-        Relating: [\n-            'id',\n-            'baseperson_id',\n-            'baseperson_hidden_id',\n-            'person_id',\n-            'person_hidden_id',\n-            'proxyperson_id',\n-            'proxyperson_hidden_id',\n-        ],\n-    },\n-    'local_concrete_fields': {\n-        Person: [\n-            'baseperson_ptr_id',\n-            'data_inherited',\n-            'fk_inherited_id',\n-            'content_type_concrete_id',\n-            'object_id_concrete',\n-        ],\n-        BasePerson: [\n-            'id',\n-            'data_abstract',\n-            'fk_abstract_id',\n-            'content_type_abstract_id',\n-            'object_id_abstract',\n-            'data_base',\n-            'fk_base_id',\n-            'content_type_base_id',\n-            'object_id_base',\n-        ],\n-        AbstractPerson: [\n-            'data_abstract',\n-            'fk_abstract_id',\n-            'content_type_abstract_id',\n-            'object_id_abstract',\n-        ],\n-        Relating: [\n-            'id',\n-            'baseperson_id',\n-            'baseperson_hidden_id',\n-            'person_id',\n-            'person_hidden_id',\n-            'proxyperson_id',\n-            'proxyperson_hidden_id',\n-        ],\n-    },\n-    'many_to_many': {\n-        Person: [\n-            'm2m_abstract',\n-            'friends_abstract',\n-            'following_abstract',\n-            'm2m_base',\n-            'friends_base',\n-            'following_base',\n-            'm2m_inherited',\n-            'friends_inherited',\n-            'following_inherited',\n-        ],\n-        BasePerson: [\n-            'm2m_abstract',\n-            'friends_abstract',\n-            'following_abstract',\n-            'm2m_base',\n-            'friends_base',\n-            'following_base',\n-        ],\n-        AbstractPerson: [\n-            'm2m_abstract',\n-            'friends_abstract',\n-            'following_abstract',\n-        ],\n-        Relating: [\n-            'basepeople',\n-            'basepeople_hidden',\n-            'people',\n-            'people_hidden',\n-        ],\n-    },\n-    'many_to_many_with_model': {\n-        Person: [\n-            BasePerson,\n-            BasePerson,\n-            BasePerson,\n-            BasePerson,\n-            BasePerson,\n-            BasePerson,\n-            None,\n-            None,\n-            None,\n-        ],\n-        BasePerson: [\n-            None,\n-            None,\n-            None,\n-            None,\n-            None,\n-            None,\n-        ],\n-        AbstractPerson: [\n-            None,\n-            None,\n-            None,\n-        ],\n-        Relating: [\n-            None,\n-            None,\n-            None,\n-            None,\n-        ],\n-    },\n-    'get_all_related_objects_with_model': {\n-        Person: (\n-            ('relating_baseperson', BasePerson),\n-            ('relating_person', None),\n-        ),\n-        BasePerson: (\n-            ('person', None),\n-            ('relating_baseperson', None),\n-        ),\n-        Relation: (\n-            ('fk_abstract_rel', None),\n-            ('fo_abstract_rel', None),\n-            ('fk_base_rel', None),\n-            ('fo_base_rel', None),\n-            ('fk_concrete_rel', None),\n-            ('fo_concrete_rel', None),\n-        ),\n-    },\n-    'get_all_related_objects_with_model_local': {\n-        Person: (\n-            ('relating_person', None),\n-        ),\n-        BasePerson: (\n-            ('person', None),\n-            ('relating_baseperson', None)\n-        ),\n-        Relation: (\n-            ('fk_abstract_rel', None),\n-            ('fo_abstract_rel', None),\n-            ('fk_base_rel', None),\n-            ('fo_base_rel', None),\n-            ('fk_concrete_rel', None),\n-            ('fo_concrete_rel', None),\n-        ),\n-    },\n-    'get_all_related_objects_with_model_hidden': {\n-        BasePerson: (\n-            ('model_meta.baseperson_friends_base', None),\n-            ('model_meta.baseperson_friends_base', None),\n-            ('model_meta.baseperson_m2m_base', None),\n-            ('model_meta.baseperson_following_base', None),\n-            ('model_meta.baseperson_following_base', None),\n-            ('model_meta.baseperson_m2m_abstract', None),\n-            ('model_meta.baseperson_friends_abstract', None),\n-            ('model_meta.baseperson_friends_abstract', None),\n-            ('model_meta.baseperson_following_abstract', None),\n-            ('model_meta.baseperson_following_abstract', None),\n-            ('model_meta.person', None),\n-            ('model_meta.relating_basepeople', None),\n-            ('model_meta.relating_basepeople_hidden', None),\n-            ('model_meta.relating', None),\n-            ('model_meta.relating', None),\n-        ),\n-        Person: (\n-            ('model_meta.baseperson_friends_base', BasePerson),\n-            ('model_meta.baseperson_friends_base', BasePerson),\n-            ('model_meta.baseperson_m2m_base', BasePerson),\n-            ('model_meta.baseperson_following_base', BasePerson),\n-            ('model_meta.baseperson_following_base', BasePerson),\n-            ('model_meta.baseperson_m2m_abstract', BasePerson),\n-            ('model_meta.baseperson_friends_abstract', BasePerson),\n-            ('model_meta.baseperson_friends_abstract', BasePerson),\n-            ('model_meta.baseperson_following_abstract', BasePerson),\n-            ('model_meta.baseperson_following_abstract', BasePerson),\n-            ('model_meta.relating_basepeople', BasePerson),\n-            ('model_meta.relating_basepeople_hidden', BasePerson),\n-            ('model_meta.relating', BasePerson),\n-            ('model_meta.relating', BasePerson),\n-            ('model_meta.person_m2m_inherited', None),\n-            ('model_meta.person_friends_inherited', None),\n-            ('model_meta.person_friends_inherited', None),\n-            ('model_meta.person_following_inherited', None),\n-            ('model_meta.person_following_inherited', None),\n-            ('model_meta.relating_people', None),\n-            ('model_meta.relating_people_hidden', None),\n-            ('model_meta.relating', None),\n-            ('model_meta.relating', None),\n-        ),\n-        Relation: (\n-            ('model_meta.baseperson_m2m_base', None),\n-            ('model_meta.baseperson_m2m_abstract', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.person_m2m_inherited', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.proxyperson', None),\n-            ('model_meta.proxyperson', None),\n-            ('model_meta.proxyperson', None),\n-        ),\n-    },\n-    'get_all_related_objects_with_model_hidden_local': {\n-        BasePerson: (\n-            ('model_meta.baseperson_friends_base', None),\n-            ('model_meta.baseperson_friends_base', None),\n-            ('model_meta.baseperson_m2m_base', None),\n-            ('model_meta.baseperson_following_base', None),\n-            ('model_meta.baseperson_following_base', None),\n-            ('model_meta.baseperson_m2m_abstract', None),\n-            ('model_meta.baseperson_friends_abstract', None),\n-            ('model_meta.baseperson_friends_abstract', None),\n-            ('model_meta.baseperson_following_abstract', None),\n-            ('model_meta.baseperson_following_abstract', None),\n-            ('model_meta.person', None),\n-            ('model_meta.relating_basepeople', None),\n-            ('model_meta.relating_basepeople_hidden', None),\n-            ('model_meta.relating', None),\n-            ('model_meta.relating', None),\n-        ),\n-        Person: (\n-            ('model_meta.person_m2m_inherited', None),\n-            ('model_meta.person_friends_inherited', None),\n-            ('model_meta.person_friends_inherited', None),\n-            ('model_meta.person_following_inherited', None),\n-            ('model_meta.person_following_inherited', None),\n-            ('model_meta.relating_people', None),\n-            ('model_meta.relating_people_hidden', None),\n-            ('model_meta.relating', None),\n-            ('model_meta.relating', None),\n-        ),\n-        Relation: (\n-            ('model_meta.baseperson_m2m_base', None),\n-            ('model_meta.baseperson_m2m_abstract', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.person_m2m_inherited', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.proxyperson', None),\n-            ('model_meta.proxyperson', None),\n-            ('model_meta.proxyperson', None),\n-        ),\n-    },\n-    'get_all_related_objects_with_model_proxy': {\n-        BasePerson: (\n-            ('person', None),\n-            ('relating_baseperson', None),\n-        ),\n-        Person: (\n-            ('relating_baseperson', BasePerson),\n-            ('relating_person', None), ('relating_proxyperson', None),\n-        ),\n-        Relation: (\n-            ('fk_abstract_rel', None), ('fo_abstract_rel', None),\n-            ('fk_base_rel', None), ('fo_base_rel', None),\n-            ('fk_concrete_rel', None), ('fo_concrete_rel', None),\n-        ),\n-    },\n-    'get_all_related_objects_with_model_proxy_hidden': {\n-        BasePerson: (\n-            ('model_meta.baseperson_friends_base', None),\n-            ('model_meta.baseperson_friends_base', None),\n-            ('model_meta.baseperson_m2m_base', None),\n-            ('model_meta.baseperson_following_base', None),\n-            ('model_meta.baseperson_following_base', None),\n-            ('model_meta.baseperson_m2m_abstract', None),\n-            ('model_meta.baseperson_friends_abstract', None),\n-            ('model_meta.baseperson_friends_abstract', None),\n-            ('model_meta.baseperson_following_abstract', None),\n-            ('model_meta.baseperson_following_abstract', None),\n-            ('model_meta.person', None),\n-            ('model_meta.relating_basepeople', None),\n-            ('model_meta.relating_basepeople_hidden', None),\n-            ('model_meta.relating', None),\n-            ('model_meta.relating', None),\n-        ),\n-        Person: (\n-            ('model_meta.baseperson_friends_base', BasePerson),\n-            ('model_meta.baseperson_friends_base', BasePerson),\n-            ('model_meta.baseperson_m2m_base', BasePerson),\n-            ('model_meta.baseperson_following_base', BasePerson),\n-            ('model_meta.baseperson_following_base', BasePerson),\n-            ('model_meta.baseperson_m2m_abstract', BasePerson),\n-            ('model_meta.baseperson_friends_abstract', BasePerson),\n-            ('model_meta.baseperson_friends_abstract', BasePerson),\n-            ('model_meta.baseperson_following_abstract', BasePerson),\n-            ('model_meta.baseperson_following_abstract', BasePerson),\n-            ('model_meta.relating_basepeople', BasePerson),\n-            ('model_meta.relating_basepeople_hidden', BasePerson),\n-            ('model_meta.relating', BasePerson),\n-            ('model_meta.relating', BasePerson),\n-            ('model_meta.person_m2m_inherited', None),\n-            ('model_meta.person_friends_inherited', None),\n-            ('model_meta.person_friends_inherited', None),\n-            ('model_meta.person_following_inherited', None),\n-            ('model_meta.person_following_inherited', None),\n-            ('model_meta.relating_people', None),\n-            ('model_meta.relating_people_hidden', None),\n-            ('model_meta.relating', None),\n-            ('model_meta.relating', None),\n-            ('model_meta.relating', None),\n-            ('model_meta.relating', None),\n-        ),\n-        Relation: (\n-            ('model_meta.baseperson_m2m_base', None),\n-            ('model_meta.baseperson_m2m_abstract', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.baseperson', None),\n-            ('model_meta.person_m2m_inherited', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.person', None),\n-            ('model_meta.proxyperson', None),\n-            ('model_meta.proxyperson', None),\n-            ('model_meta.proxyperson', None),\n-        ),\n-    },\n-    'get_all_related_many_to_many_with_model': {\n-        BasePerson: (\n-            ('friends_abstract_rel_+', None),\n-            ('followers_abstract', None),\n-            ('friends_base_rel_+', None),\n-            ('followers_base', None),\n-            ('relating_basepeople', None),\n-            ('+', None),\n-        ),\n-        Person: (\n-            ('friends_abstract_rel_+', BasePerson),\n-            ('followers_abstract', BasePerson),\n-            ('friends_base_rel_+', BasePerson),\n-            ('followers_base', BasePerson),\n-            ('relating_basepeople', BasePerson),\n-            ('+', BasePerson),\n-            ('friends_inherited_rel_+', None),\n-            ('followers_concrete', None),\n-            ('relating_people', None),\n-            ('+', None),\n-        ),\n-        Relation: (\n-            ('m2m_abstract_rel', None),\n-            ('m2m_base_rel', None),\n-            ('m2m_concrete_rel', None),\n-        ),\n-    },\n-    'get_all_related_many_to_many_local': {\n-        BasePerson: [\n-            'friends_abstract_rel_+',\n-            'followers_abstract',\n-            'friends_base_rel_+',\n-            'followers_base',\n-            'relating_basepeople',\n-            '+',\n-        ],\n-        Person: [\n-            'friends_inherited_rel_+',\n-            'followers_concrete',\n-            'relating_people',\n-            '+',\n-        ],\n-        Relation: [\n-            'm2m_abstract_rel',\n-            'm2m_base_rel',\n-            'm2m_concrete_rel',\n-        ],\n-    },\n-    'virtual_fields': {\n-        AbstractPerson: [\n-            'generic_relation_abstract',\n-            'content_object_abstract',\n-        ],\n-        BasePerson: [\n-            'generic_relation_base',\n-            'content_object_base',\n-            'generic_relation_abstract',\n-            'content_object_abstract',\n-        ],\n-        Person: [\n-            'content_object_concrete',\n-            'generic_relation_concrete',\n-            'generic_relation_base',\n-            'content_object_base',\n-            'generic_relation_abstract',\n-            'content_object_abstract',\n-        ],\n-    },\n-}\n-\n-\n-class OptionsBaseTests(test.TestCase):\n-\n-    def _map_rq_names(self, res):\n-        return tuple((o.field.related_query_name(), m) for o, m in res)\n-\n-    def _map_names(self, res):\n-        return tuple((f.name, m) for f, m in res)\n-\n-\n-class DataTests(OptionsBaseTests):\n-\n-    def test_fields(self):\n-        for model, expected_result in TEST_RESULTS['fields'].items():\n-            fields = model._meta.fields\n-            self.assertEqual([f.attname for f in fields], expected_result)\n-\n-    def test_local_fields(self):\n-        is_data_field = lambda f: isinstance(f, Field) and not isinstance(f, related.ManyToManyField)\n-\n-        for model, expected_result in TEST_RESULTS['local_fields'].items():\n-            fields = model._meta.local_fields\n-            self.assertEqual([f.attname for f in fields], expected_result)\n-            self.assertTrue(all([f.model is model for f in fields]))\n-            self.assertTrue(all([is_data_field(f) for f in fields]))\n-\n-    def test_local_concrete_fields(self):\n-        for model, expected_result in TEST_RESULTS['local_concrete_fields'].items():\n-            fields = model._meta.local_concrete_fields\n-            self.assertEqual([f.attname for f in fields], expected_result)\n-            self.assertTrue(all([f.column is not None for f in fields]))\n-\n-\n-class M2MTests(OptionsBaseTests):\n-\n-    def test_many_to_many(self):\n-        for model, expected_result in TEST_RESULTS['many_to_many'].items():\n-            fields = model._meta.many_to_many\n-            self.assertEqual([f.attname for f in fields], expected_result)\n-            self.assertTrue(all([isinstance(f.rel, related.ManyToManyRel) for f in fields]))\n-\n-    def test_many_to_many_with_model(self):\n-        for model, expected_result in TEST_RESULTS['many_to_many_with_model'].items():\n-            models = [model for field, model in model._meta.get_m2m_with_model()]\n-            self.assertEqual(models, expected_result)\n-\n-\n-class RelatedObjectsTests(OptionsBaseTests):\n-    def setUp(self):\n-        self.key_name = lambda r: r[0]\n-\n-    def test_related_objects(self):\n-        result_key = 'get_all_related_objects_with_model'\n-        for model, expected in TEST_RESULTS[result_key].items():\n-            objects = model._meta.get_all_related_objects_with_model()\n-            self.assertEqual(self._map_rq_names(objects), expected)\n-\n-    def test_related_objects_local(self):\n-        result_key = 'get_all_related_objects_with_model_local'\n-        for model, expected in TEST_RESULTS[result_key].items():\n-            objects = model._meta.get_all_related_objects_with_model(local_only=True)\n-            self.assertEqual(self._map_rq_names(objects), expected)\n-\n-    def test_related_objects_include_hidden(self):\n-        result_key = 'get_all_related_objects_with_model_hidden'\n-        for model, expected in TEST_RESULTS[result_key].items():\n-            objects = model._meta.get_all_related_objects_with_model(include_hidden=True)\n-            self.assertEqual(\n-                sorted(self._map_names(objects), key=self.key_name),\n-                sorted(expected, key=self.key_name)\n-            )\n-\n-    def test_related_objects_include_hidden_local_only(self):\n-        result_key = 'get_all_related_objects_with_model_hidden_local'\n-        for model, expected in TEST_RESULTS[result_key].items():\n-            objects = model._meta.get_all_related_objects_with_model(\n-                include_hidden=True, local_only=True)\n-            self.assertEqual(\n-                sorted(self._map_names(objects), key=self.key_name),\n-                sorted(expected, key=self.key_name)\n-            )\n-\n-    def test_related_objects_proxy(self):\n-        result_key = 'get_all_related_objects_with_model_proxy'\n-        for model, expected in TEST_RESULTS[result_key].items():\n-            objects = model._meta.get_all_related_objects_with_model(\n-                include_proxy_eq=True)\n-            self.assertEqual(self._map_rq_names(objects), expected)\n-\n-    def test_related_objects_proxy_hidden(self):\n-        result_key = 'get_all_related_objects_with_model_proxy_hidden'\n-        for model, expected in TEST_RESULTS[result_key].items():\n-            objects = model._meta.get_all_related_objects_with_model(\n-                include_proxy_eq=True, include_hidden=True)\n-            self.assertEqual(\n-                sorted(self._map_names(objects), key=self.key_name),\n-                sorted(expected, key=self.key_name)\n-            )\n-\n-\n-class RelatedM2MTests(OptionsBaseTests):\n-\n-    def test_related_m2m_with_model(self):\n-        result_key = 'get_all_related_many_to_many_with_model'\n-        for model, expected in TEST_RESULTS[result_key].items():\n-            objects = model._meta.get_all_related_m2m_objects_with_model()\n-            self.assertEqual(self._map_rq_names(objects), expected)\n-\n-    def test_related_m2m_local_only(self):\n-        result_key = 'get_all_related_many_to_many_local'\n-        for model, expected in TEST_RESULTS[result_key].items():\n-            objects = model._meta.get_all_related_many_to_many_objects(local_only=True)\n-            self.assertEqual([o.field.related_query_name() for o in objects], expected)\n-\n-    def test_related_m2m_asymmetrical(self):\n-        m2m = Person._meta.many_to_many\n-        self.assertIn('following_base', [f.attname for f in m2m])\n-        related_m2m = Person._meta.get_all_related_many_to_many_objects()\n-        self.assertIn('followers_base', [o.field.related_query_name() for o in related_m2m])\n-\n-    def test_related_m2m_symmetrical(self):\n-        m2m = Person._meta.many_to_many\n-        self.assertIn('friends_base', [f.attname for f in m2m])\n-        related_m2m = Person._meta.get_all_related_many_to_many_objects()\n-        self.assertIn('friends_inherited_rel_+', [o.field.related_query_name() for o in related_m2m])\n-\n-\n-class VirtualFieldsTests(OptionsBaseTests):\n-\n-    def test_virtual_fields(self):\n-        for model, expected_names in TEST_RESULTS['virtual_fields'].items():\n-            objects = model._meta.virtual_fields\n-            self.assertEqual(sorted([f.name for f in objects]), sorted(expected_names))\n-\n-\n-class GetFieldByNameTests(OptionsBaseTests):\n-\n-    def test_get_data_field(self):\n-        field_info = Person._meta.get_field_by_name('data_abstract')\n-        self.assertEqual(field_info[1:], (BasePerson, True, False))\n-        self.assertIsInstance(field_info[0], CharField)\n-\n-    def test_get_m2m_field(self):\n-        field_info = Person._meta.get_field_by_name('m2m_base')\n-        self.assertEqual(field_info[1:], (BasePerson, True, True))\n-        self.assertIsInstance(field_info[0], related.ManyToManyField)\n-\n-    def test_get_related_object(self):\n-        field_info = Person._meta.get_field_by_name('relating_baseperson')\n-        self.assertEqual(field_info[1:], (BasePerson, False, False))\n-        self.assertIsInstance(field_info[0], related.ForeignObjectRel)\n-\n-    def test_get_related_m2m(self):\n-        field_info = Person._meta.get_field_by_name('relating_people')\n-        self.assertEqual(field_info[1:], (None, False, True))\n-        self.assertIsInstance(field_info[0], related.ForeignObjectRel)\n-\n-    def test_get_generic_foreign_key(self):\n-        # For historic reasons generic foreign keys aren't available.\n-        with self.assertRaises(FieldDoesNotExist):\n-            Person._meta.get_field_by_name('content_object_base')\n-\n-    def test_get_generic_relation(self):\n-        field_info = Person._meta.get_field_by_name('generic_relation_base')\n-        self.assertEqual(field_info[1:], (None, True, False))\n-        self.assertIsInstance(field_info[0], GenericRelation)\ndiff --git a/tests/model_meta/test_legacy.py b/tests/model_meta/test_legacy.py\nnew file mode 100644\nindex 000000000000..60bfb1641ff4\n--- /dev/null\n+++ b/tests/model_meta/test_legacy.py\n@@ -0,0 +1,166 @@\n+import warnings\n+\n+from django import test\n+from django.contrib.contenttypes.fields import GenericRelation\n+from django.core.exceptions import FieldDoesNotExist\n+from django.db.models.fields import related, CharField\n+from django.utils.deprecation import RemovedInDjango20Warning\n+\n+from .models import BasePerson, Person\n+from .results import TEST_RESULTS\n+\n+\n+class OptionsBaseTests(test.TestCase):\n+\n+    def _map_related_query_names(self, res):\n+        return tuple((o.field.related_query_name(), m) for o, m in res)\n+\n+    def _map_names(self, res):\n+        return tuple((f.name, m) for f, m in res)\n+\n+\n+class M2MTests(OptionsBaseTests):\n+\n+    def test_many_to_many_with_model(self):\n+        for model, expected_result in TEST_RESULTS['many_to_many_with_model'].items():\n+            with warnings.catch_warnings(record=True) as warning:\n+                warnings.simplefilter(\"always\")\n+                models = [model for field, model in model._meta.get_m2m_with_model()]\n+                self.assertEqual([RemovedInDjango20Warning], [w.message.__class__ for w in warning])\n+            self.assertEqual(models, expected_result)\n+\n+\n+@test.ignore_warnings(category=RemovedInDjango20Warning)\n+class RelatedObjectsTests(OptionsBaseTests):\n+    key_name = lambda self, r: r[0]\n+\n+    def test_related_objects(self):\n+        result_key = 'get_all_related_objects_with_model_legacy'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = model._meta.get_all_related_objects_with_model()\n+            self.assertEqual(self._map_related_query_names(objects), expected)\n+\n+    def test_related_objects_local(self):\n+        result_key = 'get_all_related_objects_with_model_local_legacy'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = model._meta.get_all_related_objects_with_model(local_only=True)\n+            self.assertEqual(self._map_related_query_names(objects), expected)\n+\n+    def test_related_objects_include_hidden(self):\n+        result_key = 'get_all_related_objects_with_model_hidden_legacy'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = model._meta.get_all_related_objects_with_model(include_hidden=True)\n+            self.assertEqual(\n+                sorted(self._map_names(objects), key=self.key_name),\n+                sorted(expected, key=self.key_name)\n+            )\n+\n+    def test_related_objects_include_hidden_local_only(self):\n+        result_key = 'get_all_related_objects_with_model_hidden_local_legacy'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = model._meta.get_all_related_objects_with_model(\n+                include_hidden=True, local_only=True)\n+            self.assertEqual(\n+                sorted(self._map_names(objects), key=self.key_name),\n+                sorted(expected, key=self.key_name)\n+            )\n+\n+    def test_related_objects_proxy(self):\n+        result_key = 'get_all_related_objects_with_model_proxy_legacy'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = model._meta.get_all_related_objects_with_model(\n+                include_proxy_eq=True)\n+            self.assertEqual(self._map_related_query_names(objects), expected)\n+\n+    def test_related_objects_proxy_hidden(self):\n+        result_key = 'get_all_related_objects_with_model_proxy_hidden_legacy'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = model._meta.get_all_related_objects_with_model(\n+                include_proxy_eq=True, include_hidden=True)\n+            self.assertEqual(\n+                sorted(self._map_names(objects), key=self.key_name),\n+                sorted(expected, key=self.key_name)\n+            )\n+\n+\n+@test.ignore_warnings(category=RemovedInDjango20Warning)\n+class RelatedM2MTests(OptionsBaseTests):\n+\n+    def test_related_m2m_with_model(self):\n+        result_key = 'get_all_related_many_to_many_with_model_legacy'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = model._meta.get_all_related_m2m_objects_with_model()\n+            self.assertEqual(self._map_related_query_names(objects), expected)\n+\n+    def test_related_m2m_local_only(self):\n+        result_key = 'get_all_related_many_to_many_local_legacy'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = model._meta.get_all_related_many_to_many_objects(local_only=True)\n+            self.assertEqual([o.field.related_query_name() for o in objects], expected)\n+\n+    def test_related_m2m_asymmetrical(self):\n+        m2m = Person._meta.many_to_many\n+        self.assertTrue('following_base' in [f.attname for f in m2m])\n+        related_m2m = Person._meta.get_all_related_many_to_many_objects()\n+        self.assertTrue('followers_base' in [o.field.related_query_name() for o in related_m2m])\n+\n+    def test_related_m2m_symmetrical(self):\n+        m2m = Person._meta.many_to_many\n+        self.assertTrue('friends_base' in [f.attname for f in m2m])\n+        related_m2m = Person._meta.get_all_related_many_to_many_objects()\n+        self.assertIn('friends_inherited_rel_+', [o.field.related_query_name() for o in related_m2m])\n+\n+\n+@test.ignore_warnings(category=RemovedInDjango20Warning)\n+class GetFieldByNameTests(OptionsBaseTests):\n+\n+    def test_get_data_field(self):\n+        field_info = Person._meta.get_field_by_name('data_abstract')\n+        self.assertEqual(field_info[1:], (BasePerson, True, False))\n+        self.assertIsInstance(field_info[0], CharField)\n+\n+    def test_get_m2m_field(self):\n+        field_info = Person._meta.get_field_by_name('m2m_base')\n+        self.assertEqual(field_info[1:], (BasePerson, True, True))\n+        self.assertIsInstance(field_info[0], related.ManyToManyField)\n+\n+    def test_get_related_object(self):\n+        field_info = Person._meta.get_field_by_name('relating_baseperson')\n+        self.assertEqual(field_info[1:], (BasePerson, False, False))\n+        self.assertTrue(field_info[0].auto_created)\n+\n+    def test_get_related_m2m(self):\n+        field_info = Person._meta.get_field_by_name('relating_people')\n+        self.assertEqual(field_info[1:], (None, False, True))\n+        self.assertTrue(field_info[0].auto_created)\n+\n+    def test_get_generic_relation(self):\n+        field_info = Person._meta.get_field_by_name('generic_relation_base')\n+        self.assertEqual(field_info[1:], (None, True, False))\n+        self.assertIsInstance(field_info[0], GenericRelation)\n+\n+    def test_get_m2m_field_invalid(self):\n+        with warnings.catch_warnings(record=True) as warning:\n+            warnings.simplefilter(\"always\")\n+            self.assertRaises(\n+                FieldDoesNotExist,\n+                Person._meta.get_field,\n+                **{'field_name': 'm2m_base', 'many_to_many': False}\n+            )\n+            self.assertEqual(Person._meta.get_field('m2m_base', many_to_many=True).name, 'm2m_base')\n+\n+            # 2 RemovedInDjango20Warning messages should be raised, one for each call of get_field()\n+            # with the 'many_to_many' argument.\n+            self.assertEqual(\n+                [RemovedInDjango20Warning, RemovedInDjango20Warning],\n+                [w.message.__class__ for w in warning]\n+            )\n+\n+\n+@test.ignore_warnings(category=RemovedInDjango20Warning)\n+class GetAllFieldNamesTestCase(OptionsBaseTests):\n+\n+    def test_get_all_field_names(self):\n+        for model, expected_names in TEST_RESULTS['get_all_field_names'].items():\n+            objects = model._meta.get_all_field_names()\n+            self.assertEqual(sorted(map(str, objects)), sorted(expected_names))\ndiff --git a/tests/model_meta/tests.py b/tests/model_meta/tests.py\nnew file mode 100644\nindex 000000000000..31ffa4ac9383\n--- /dev/null\n+++ b/tests/model_meta/tests.py\n@@ -0,0 +1,247 @@\n+from django.apps import apps\n+from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation\n+from django.core.exceptions import FieldDoesNotExist\n+from django.db.models.fields import related, CharField, Field\n+from django.db.models.options import IMMUTABLE_WARNING, EMPTY_RELATION_TREE\n+from django.test import TestCase\n+\n+from .models import Relation, AbstractPerson, BasePerson, Person, ProxyPerson, Relating\n+from .results import TEST_RESULTS\n+\n+\n+class OptionsBaseTests(TestCase):\n+\n+    def _map_related_query_names(self, res):\n+        return tuple((o.name, m) for o, m in res)\n+\n+    def _map_names(self, res):\n+        return tuple((f.name, m) for f, m in res)\n+\n+    def _model(self, current_model, field):\n+        model = field.model._meta.concrete_model\n+        return None if model == current_model else model\n+\n+    def _details(self, current_model, relation):\n+        direct = isinstance(relation, Field) or isinstance(relation, GenericForeignKey)\n+        model = relation.model._meta.concrete_model\n+        if model == current_model:\n+            model = None\n+\n+        field = relation if direct else relation.field\n+        m2m = isinstance(field, related.ManyToManyField)\n+        return relation, model, direct, m2m\n+\n+\n+class GetFieldsTests(OptionsBaseTests):\n+\n+    def test_get_fields_is_immutable(self):\n+        msg = IMMUTABLE_WARNING % \"get_fields()\"\n+        for _ in range(2):\n+            # Running unit test twice to ensure both non-cached and cached result\n+            # are immutable.\n+            fields = Person._meta.get_fields()\n+            with self.assertRaisesMessage(AttributeError, msg):\n+                fields += [\"errors\"]\n+\n+\n+class DataTests(OptionsBaseTests):\n+\n+    def test_fields(self):\n+        for model, expected_result in TEST_RESULTS['fields'].items():\n+            fields = model._meta.fields\n+            self.assertEqual([f.attname for f in fields], expected_result)\n+\n+    def test_local_fields(self):\n+        is_data_field = lambda f: isinstance(f, Field) and not isinstance(f, related.ManyToManyField)\n+\n+        for model, expected_result in TEST_RESULTS['local_fields'].items():\n+            fields = model._meta.local_fields\n+            self.assertEqual([f.attname for f in fields], expected_result)\n+            for f in fields:\n+                self.assertEqual(f.model, model)\n+                self.assertTrue(is_data_field(f))\n+\n+    def test_local_concrete_fields(self):\n+        for model, expected_result in TEST_RESULTS['local_concrete_fields'].items():\n+            fields = model._meta.local_concrete_fields\n+            self.assertEqual([f.attname for f in fields], expected_result)\n+            for f in fields:\n+                self.assertIsNotNone(f.column)\n+\n+\n+class M2MTests(OptionsBaseTests):\n+\n+    def test_many_to_many(self):\n+        for model, expected_result in TEST_RESULTS['many_to_many'].items():\n+            fields = model._meta.many_to_many\n+            self.assertEqual([f.attname for f in fields], expected_result)\n+            for f in fields:\n+                self.assertTrue(f.many_to_many and f.is_relation)\n+\n+    def test_many_to_many_with_model(self):\n+        for model, expected_result in TEST_RESULTS['many_to_many_with_model'].items():\n+            models = [self._model(model, field) for field in model._meta.many_to_many]\n+            self.assertEqual(models, expected_result)\n+\n+\n+class RelatedObjectsTests(OptionsBaseTests):\n+    key_name = lambda self, r: r[0]\n+\n+    def test_related_objects(self):\n+        result_key = 'get_all_related_objects_with_model'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = [\n+                (field, self._model(model, field))\n+                for field in model._meta.get_fields()\n+                if field.auto_created and not field.concrete\n+            ]\n+            self.assertEqual(self._map_related_query_names(objects), expected)\n+\n+    def test_related_objects_local(self):\n+        result_key = 'get_all_related_objects_with_model_local'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = [\n+                (field, self._model(model, field))\n+                for field in model._meta.get_fields(include_parents=False)\n+                if field.auto_created and not field.concrete\n+            ]\n+            self.assertEqual(self._map_related_query_names(objects), expected)\n+\n+    def test_related_objects_include_hidden(self):\n+        result_key = 'get_all_related_objects_with_model_hidden'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = [\n+                (field, self._model(model, field))\n+                for field in model._meta.get_fields(include_hidden=True)\n+                if field.auto_created and not field.concrete\n+            ]\n+            self.assertEqual(\n+                sorted(self._map_names(objects), key=self.key_name),\n+                sorted(expected, key=self.key_name)\n+            )\n+\n+    def test_related_objects_include_hidden_local_only(self):\n+        result_key = 'get_all_related_objects_with_model_hidden_local'\n+        for model, expected in TEST_RESULTS[result_key].items():\n+            objects = [\n+                (field, self._model(model, field))\n+                for field in model._meta.get_fields(include_hidden=True, include_parents=False)\n+                if field.auto_created and not field.concrete\n+            ]\n+            self.assertEqual(\n+                sorted(self._map_names(objects), key=self.key_name),\n+                sorted(expected, key=self.key_name)\n+            )\n+\n+\n+class VirtualFieldsTests(OptionsBaseTests):\n+\n+    def test_virtual_fields(self):\n+        for model, expected_names in TEST_RESULTS['virtual_fields'].items():\n+            objects = model._meta.virtual_fields\n+            self.assertEqual(sorted([f.name for f in objects]), sorted(expected_names))\n+\n+\n+class GetFieldByNameTests(OptionsBaseTests):\n+\n+    def test_get_data_field(self):\n+        field_info = self._details(Person, Person._meta.get_field('data_abstract'))\n+        self.assertEqual(field_info[1:], (BasePerson, True, False))\n+        self.assertIsInstance(field_info[0], CharField)\n+\n+    def test_get_m2m_field(self):\n+        field_info = self._details(Person, Person._meta.get_field('m2m_base'))\n+        self.assertEqual(field_info[1:], (BasePerson, True, True))\n+        self.assertIsInstance(field_info[0], related.ManyToManyField)\n+\n+    def test_get_related_object(self):\n+        field_info = self._details(Person, Person._meta.get_field('relating_baseperson'))\n+        self.assertEqual(field_info[1:], (BasePerson, False, False))\n+        self.assertIsInstance(field_info[0], related.ForeignObjectRel)\n+\n+    def test_get_related_m2m(self):\n+        field_info = self._details(Person, Person._meta.get_field('relating_people'))\n+        self.assertEqual(field_info[1:], (None, False, True))\n+        self.assertIsInstance(field_info[0], related.ForeignObjectRel)\n+\n+    def test_get_generic_relation(self):\n+        field_info = self._details(Person, Person._meta.get_field('generic_relation_base'))\n+        self.assertEqual(field_info[1:], (None, True, False))\n+        self.assertIsInstance(field_info[0], GenericRelation)\n+\n+    def test_get_fields_only_searaches_forward_on_apps_not_ready(self):\n+        opts = Person._meta\n+        # If apps registry is not ready, get_field() searches over only\n+        # forward fields.\n+        opts.apps.ready = False\n+        try:\n+            # 'data_abstract' is a forward field, and therefore will be found\n+            self.assertTrue(opts.get_field('data_abstract'))\n+            msg = (\n+                \"Person has no field named 'relating_baseperson'. The app \"\n+                \"cache isn't ready yet, so if this is a forward field, it \"\n+                \"won't be available yet.\"\n+            )\n+            # 'data_abstract' is a reverse field, and will raise an exception\n+            with self.assertRaisesMessage(FieldDoesNotExist, msg):\n+                opts.get_field('relating_baseperson')\n+        finally:\n+            opts.apps.ready = True\n+\n+\n+class RelationTreeTests(TestCase):\n+    all_models = (Relation, AbstractPerson, BasePerson, Person, ProxyPerson, Relating)\n+\n+    def setUp(self):\n+        apps.clear_cache()\n+\n+    def test_clear_cache_clears_relation_tree(self):\n+        # The apps.clear_cache is setUp() should have deleted all trees.\n+        # Exclude abstract models that are not included in the Apps registry\n+        # and have no cache.\n+        all_models_with_cache = (m for m in self.all_models if not m._meta.abstract)\n+        for m in all_models_with_cache:\n+            self.assertNotIn('_relation_tree', m._meta.__dict__)\n+\n+    def test_first_relation_tree_access_populates_all(self):\n+        # On first access, relation tree should have populated cache.\n+        self.assertTrue(self.all_models[0]._meta._relation_tree)\n+\n+        # AbstractPerson does not have any relations, so relation_tree\n+        # should just return an EMPTY_RELATION_TREE.\n+        self.assertEqual(AbstractPerson._meta._relation_tree, EMPTY_RELATION_TREE)\n+\n+        # All the other models should already have their relation tree\n+        # in the internal __dict__ .\n+        all_models_but_abstractperson = (m for m in self.all_models if m is not AbstractPerson)\n+        for m in all_models_but_abstractperson:\n+            self.assertIn('_relation_tree', m._meta.__dict__)\n+\n+    def test_relations_related_objects(self):\n+        # Testing non hidden related objects\n+        self.assertEqual(\n+            sorted([field.related_query_name() for field in Relation._meta._relation_tree\n+                   if not field.rel.field.rel.is_hidden()]),\n+            sorted([\n+                'fk_abstract_rel', 'fk_abstract_rel', 'fk_abstract_rel', 'fk_base_rel', 'fk_base_rel',\n+                'fk_base_rel', 'fk_concrete_rel', 'fk_concrete_rel', 'fo_abstract_rel', 'fo_abstract_rel',\n+                'fo_abstract_rel', 'fo_base_rel', 'fo_base_rel', 'fo_base_rel', 'fo_concrete_rel',\n+                'fo_concrete_rel', 'm2m_abstract_rel', 'm2m_abstract_rel', 'm2m_abstract_rel',\n+                'm2m_base_rel', 'm2m_base_rel', 'm2m_base_rel', 'm2m_concrete_rel', 'm2m_concrete_rel',\n+            ])\n+        )\n+        # Testing hidden related objects\n+        self.assertEqual(\n+            sorted([field.related_query_name() for field in BasePerson._meta._relation_tree]),\n+            sorted([\n+                '+', '+', 'BasePerson_following_abstract+', 'BasePerson_following_abstract+',\n+                'BasePerson_following_base+', 'BasePerson_following_base+', 'BasePerson_friends_abstract+',\n+                'BasePerson_friends_abstract+', 'BasePerson_friends_base+', 'BasePerson_friends_base+',\n+                'BasePerson_m2m_abstract+', 'BasePerson_m2m_base+', 'Relating_basepeople+',\n+                'Relating_basepeople_hidden+', 'followers_abstract', 'followers_abstract', 'followers_abstract',\n+                'followers_base', 'followers_base', 'followers_base', 'friends_abstract_rel_+', 'friends_abstract_rel_+',\n+                'friends_abstract_rel_+', 'friends_base_rel_+', 'friends_base_rel_+', 'friends_base_rel_+', 'person',\n+                'person', 'relating_basepeople', 'relating_baseperson',\n+            ])\n+        )\n+        self.assertEqual([field.related_query_name() for field in AbstractPerson._meta._relation_tree], [])\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "You're encountering a Django registry issue due to admin checks firing too early. I've added a fix and will run tests with `-Wall` shortly. However, your branch has numerous flake8 errors, likely due to unmerged master changes. Please rebase and squash your commits. Also, while refining the internal API, consider maintaining consistency in naming and usage; for example, ensure `field_names` returns unique canonical names without duplicates. Let's strive for cleaner code and adherence to modern conventions moving forward."
      }
    ],
    "token_estimation": 26112.75
  },
  {
    "index": 15,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/contrib/postgres/fields/jsonb.py b/django/contrib/postgres/fields/jsonb.py\nindex c402dd19d8e4..15d4daf466f0 100644\n--- a/django/contrib/postgres/fields/jsonb.py\n+++ b/django/contrib/postgres/fields/jsonb.py\n@@ -1,185 +1,41 @@\n-import json\n+import warnings\n \n-from psycopg2.extras import Json\n-\n-from django.contrib.postgres import forms, lookups\n-from django.core import exceptions\n-from django.db.models import (\n-    Field, TextField, Transform, lookups as builtin_lookups,\n+from django.db.models import JSONField as BuiltinJSONField\n+from django.db.models.fields.json import (\n+    KeyTextTransform as BuiltinKeyTextTransform,\n+    KeyTransform as BuiltinKeyTransform,\n )\n-from django.db.models.fields.mixins import CheckFieldDefaultMixin\n-from django.utils.translation import gettext_lazy as _\n+from django.utils.deprecation import RemovedInDjango40Warning\n \n __all__ = ['JSONField']\n \n \n-class JsonAdapter(Json):\n-    \"\"\"\n-    Customized psycopg2.extras.Json to allow for a custom encoder.\n-    \"\"\"\n-    def __init__(self, adapted, dumps=None, encoder=None):\n-        self.encoder = encoder\n-        super().__init__(adapted, dumps=dumps)\n-\n-    def dumps(self, obj):\n-        options = {'cls': self.encoder} if self.encoder else {}\n-        return json.dumps(obj, **options)\n-\n-\n-class JSONField(CheckFieldDefaultMixin, Field):\n-    empty_strings_allowed = False\n-    description = _('A JSON object')\n-    default_error_messages = {\n-        'invalid': _(\"Value must be valid JSON.\"),\n+class JSONField(BuiltinJSONField):\n+    system_check_deprecated_details = {\n+        'msg': (\n+            'django.contrib.postgres.fields.JSONField is deprecated '\n+            'and will be removed in Django 4.0.'\n+        ),\n+        'hint': 'Use django.db.models.JSONField instead.',\n+        'id': 'fields.W903'\n     }\n-    _default_hint = ('dict', '{}')\n-\n-    def __init__(self, verbose_name=None, name=None, encoder=None, **kwargs):\n-        if encoder and not callable(encoder):\n-            raise ValueError(\"The encoder parameter must be a callable object.\")\n-        self.encoder = encoder\n-        super().__init__(verbose_name, name, **kwargs)\n-\n-    def db_type(self, connection):\n-        return 'jsonb'\n-\n-    def deconstruct(self):\n-        name, path, args, kwargs = super().deconstruct()\n-        if self.encoder is not None:\n-            kwargs['encoder'] = self.encoder\n-        return name, path, args, kwargs\n-\n-    def get_transform(self, name):\n-        transform = super().get_transform(name)\n-        if transform:\n-            return transform\n-        return KeyTransformFactory(name)\n-\n-    def get_prep_value(self, value):\n-        if value is not None:\n-            return JsonAdapter(value, encoder=self.encoder)\n-        return value\n-\n-    def validate(self, value, model_instance):\n-        super().validate(value, model_instance)\n-        options = {'cls': self.encoder} if self.encoder else {}\n-        try:\n-            json.dumps(value, **options)\n-        except TypeError:\n-            raise exceptions.ValidationError(\n-                self.error_messages['invalid'],\n-                code='invalid',\n-                params={'value': value},\n-            )\n-\n-    def value_to_string(self, obj):\n-        return self.value_from_object(obj)\n \n-    def formfield(self, **kwargs):\n-        return super().formfield(**{\n-            'form_class': forms.JSONField,\n-            **kwargs,\n-        })\n \n-\n-JSONField.register_lookup(lookups.DataContains)\n-JSONField.register_lookup(lookups.ContainedBy)\n-JSONField.register_lookup(lookups.HasKey)\n-JSONField.register_lookup(lookups.HasKeys)\n-JSONField.register_lookup(lookups.HasAnyKeys)\n-JSONField.register_lookup(lookups.JSONExact)\n-\n-\n-class KeyTransform(Transform):\n-    operator = '->'\n-    nested_operator = '#>'\n-\n-    def __init__(self, key_name, *args, **kwargs):\n+class KeyTransform(BuiltinKeyTransform):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            'django.contrib.postgres.fields.jsonb.KeyTransform is deprecated in favor of '\n+            'django.db.models.fields.json.KeyTransform',\n+            RemovedInDjango40Warning, stacklevel=2\n+        )\n         super().__init__(*args, **kwargs)\n-        self.key_name = key_name\n \n-    def as_sql(self, compiler, connection):\n-        key_transforms = [self.key_name]\n-        previous = self.lhs\n-        while isinstance(previous, KeyTransform):\n-            key_transforms.insert(0, previous.key_name)\n-            previous = previous.lhs\n-        lhs, params = compiler.compile(previous)\n-        if len(key_transforms) > 1:\n-            return '(%s %s %%s)' % (lhs, self.nested_operator), params + [key_transforms]\n-        try:\n-            lookup = int(self.key_name)\n-        except ValueError:\n-            lookup = self.key_name\n-        return '(%s %s %%s)' % (lhs, self.operator), tuple(params) + (lookup,)\n \n-\n-class KeyTextTransform(KeyTransform):\n-    operator = '->>'\n-    nested_operator = '#>>'\n-    output_field = TextField()\n-\n-\n-class KeyTransformTextLookupMixin:\n-    \"\"\"\n-    Mixin for combining with a lookup expecting a text lhs from a JSONField\n-    key lookup. Make use of the ->> operator instead of casting key values to\n-    text and performing the lookup on the resulting representation.\n-    \"\"\"\n-    def __init__(self, key_transform, *args, **kwargs):\n-        assert isinstance(key_transform, KeyTransform)\n-        key_text_transform = KeyTextTransform(\n-            key_transform.key_name, *key_transform.source_expressions, **key_transform.extra\n+class KeyTextTransform(BuiltinKeyTextTransform):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            'django.contrib.postgres.fields.jsonb.KeyTextTransform is deprecated in favor of '\n+            'django.db.models.fields.json.KeyTextTransform',\n+            RemovedInDjango40Warning, stacklevel=2\n         )\n-        super().__init__(key_text_transform, *args, **kwargs)\n-\n-\n-class KeyTransformIExact(KeyTransformTextLookupMixin, builtin_lookups.IExact):\n-    pass\n-\n-\n-class KeyTransformIContains(KeyTransformTextLookupMixin, builtin_lookups.IContains):\n-    pass\n-\n-\n-class KeyTransformStartsWith(KeyTransformTextLookupMixin, builtin_lookups.StartsWith):\n-    pass\n-\n-\n-class KeyTransformIStartsWith(KeyTransformTextLookupMixin, builtin_lookups.IStartsWith):\n-    pass\n-\n-\n-class KeyTransformEndsWith(KeyTransformTextLookupMixin, builtin_lookups.EndsWith):\n-    pass\n-\n-\n-class KeyTransformIEndsWith(KeyTransformTextLookupMixin, builtin_lookups.IEndsWith):\n-    pass\n-\n-\n-class KeyTransformRegex(KeyTransformTextLookupMixin, builtin_lookups.Regex):\n-    pass\n-\n-\n-class KeyTransformIRegex(KeyTransformTextLookupMixin, builtin_lookups.IRegex):\n-    pass\n-\n-\n-KeyTransform.register_lookup(KeyTransformIExact)\n-KeyTransform.register_lookup(KeyTransformIContains)\n-KeyTransform.register_lookup(KeyTransformStartsWith)\n-KeyTransform.register_lookup(KeyTransformIStartsWith)\n-KeyTransform.register_lookup(KeyTransformEndsWith)\n-KeyTransform.register_lookup(KeyTransformIEndsWith)\n-KeyTransform.register_lookup(KeyTransformRegex)\n-KeyTransform.register_lookup(KeyTransformIRegex)\n-\n-\n-class KeyTransformFactory:\n-\n-    def __init__(self, key_name):\n-        self.key_name = key_name\n-\n-    def __call__(self, *args, **kwargs):\n-        return KeyTransform(self.key_name, *args, **kwargs)\n+        super().__init__(*args, **kwargs)\ndiff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nnew file mode 100644\nindex 000000000000..a4d3d22f833e\n--- /dev/null\n+++ b/django/db/models/fields/json.py\n@@ -0,0 +1,527 @@\n+import json\n+\n+from django import forms\n+from django.core import exceptions\n+from django.db.models import lookups\n+from django.db.models.lookups import (\n+    FieldGetDbPrepValueMixin, Lookup, Transform,\n+)\n+from django.db.utils import NotSupportedError\n+from django.utils.translation import gettext_lazy as _\n+\n+from . import Field\n+from .mixins import CheckFieldDefaultMixin\n+\n+\n+class JSONField(CheckFieldDefaultMixin, Field):\n+    description = _('A JSON object')\n+    default_error_messages = {\n+        'invalid': _('Value must be valid JSON.'),\n+    }\n+    _default_hint = ('dict', '{}')\n+\n+    def __init__(\n+        self, verbose_name=None, name=None, encoder=None,\n+        decoder=None, *args, **kwargs\n+    ):\n+        self.encoder, self.decoder = encoder, decoder\n+        super().__init__(verbose_name, name, *args, **kwargs)\n+\n+    def deconstruct(self):\n+        name, path, args, kwargs = super().deconstruct()\n+        path = 'django.db.models.JSONField'\n+        if self.encoder is not None:\n+            kwargs['encoder'] = self.encoder\n+        if self.decoder is not None:\n+            kwargs['decoder'] = self.decoder\n+        return name, path, args, kwargs\n+\n+    def from_db_value(self, value, expression, connection):\n+        if value is None:\n+            return value\n+        elif connection.vendor == 'postgresql' and self.decoder is None:\n+            return value\n+        else:\n+            try:\n+                return json.loads(value, cls=self.decoder)\n+            except json.JSONDecodeError:\n+                return value\n+\n+    def get_internal_type(self):\n+        return 'JSONField'\n+\n+    def get_prep_value(self, value):\n+        if value is None:\n+            return value\n+        return json.dumps(value, cls=self.encoder)\n+\n+    def get_transform(self, name):\n+        transform = super().get_transform(name)\n+        if transform:\n+            return transform\n+        return KeyTransformFactory(name)\n+\n+    def select_format(self, compiler, sql, params):\n+        if compiler.connection.vendor == 'postgresql' and self.decoder is not None:\n+            # Avoid psycopg2's automatic decoding to allow custom decoder\n+            return '%s::text' % sql, params\n+        return super().select_format(compiler, sql, params)\n+\n+    def validate(self, value, model_instance):\n+        super().validate(value, model_instance)\n+        try:\n+            json.dumps(value, cls=self.encoder)\n+        except TypeError:\n+            raise exceptions.ValidationError(\n+                self.error_messages['invalid'],\n+                code='invalid',\n+                params={'value': value},\n+            )\n+\n+    def value_to_string(self, obj):\n+        return self.value_from_object(obj)\n+\n+    def formfield(self, **kwargs):\n+        return super().formfield(**{\n+            'form_class': forms.JSONField,\n+            'encoder': self.encoder,\n+            'decoder': self.decoder,\n+            **kwargs,\n+        })\n+\n+\n+def compile_json_path(key_transforms):\n+    path = ['$']\n+    for key_transform in key_transforms:\n+        try:\n+            num = int(key_transform)\n+        except ValueError:  # non-integer\n+            path.append('.')\n+            path.append(json.dumps(key_transform))\n+        else:\n+            path.append('[%s]' % num)\n+    return ''.join(path)\n+\n+\n+class SimpleFunctionOperatorMixin(FieldGetDbPrepValueMixin):\n+    def as_sql_function(self, compiler, connection, template, flipped=False):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        if flipped:\n+            return template % (rhs, lhs), tuple(rhs_params) + tuple(lhs_params)\n+        else:\n+            return template % (lhs, rhs), tuple(lhs_params) + tuple(rhs_params)\n+\n+    def as_sql_operator(self, compiler, connection, operator):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        params = tuple(lhs_params) + tuple(rhs_params)\n+        return '%s %s %s' % (lhs, operator, rhs), params\n+\n+    def as_postgresql(self, compiler, connection):\n+        return self.as_sql_operator(compiler, connection, self.postgres_operator)\n+\n+    def as_sql(self, compiler, connection):\n+        raise NotSupportedError(\n+            '%s lookup is not supported by this database backend.' % self.lookup_name\n+        )\n+\n+\n+class HasKeyLookup(SimpleFunctionOperatorMixin, Lookup):\n+    logical_operator = None\n+\n+    def as_sql(self, compiler, connection, template=None):\n+        if isinstance(self.lhs, KeyTransform):\n+            lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n+        else:\n+            lhs, lhs_params, lhs_key_transforms = *compiler.compile(self.lhs), []\n+        rhs = [self.rhs] if not isinstance(self.rhs, (list, tuple)) else list(self.rhs)\n+        rhs_params = []\n+        for key in rhs:\n+            if isinstance(key, str):\n+                rhs_params.insert(0, compile_json_path(lhs_key_transforms + [key]))\n+            else:\n+                if isinstance(key, KeyTransform):\n+                    _, _, key_transforms = key.preprocess_lhs(compiler, connection)\n+                else:\n+                    key_transforms = []\n+                rhs_params.insert(0, compile_json_path(lhs_key_transforms + key_transforms))\n+        sql = template % lhs\n+        if self.logical_operator:\n+            # Add condition for each key.\n+            sql = '(%s)' % self.logical_operator.join([sql] * len(rhs_params))\n+        return sql, tuple(lhs_params) + tuple(rhs_params)\n+\n+    def as_mysql(self, compiler, connection):\n+        return self.as_sql(compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\")\n+\n+    def as_oracle(self, compiler, connection):\n+        sql, params = self.as_sql(compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\")\n+        # Add paths directly into SQL because path expressions cannot be passed\n+        # as bind variables on Oracle.\n+        return sql % tuple(params), []\n+\n+    def as_sqlite(self, compiler, connection):\n+        return self.as_sql(compiler, connection, template='JSON_TYPE(%s, %%s) IS NOT NULL')\n+\n+\n+@JSONField.register_lookup\n+class HasKey(HasKeyLookup):\n+    lookup_name = 'has_key'\n+    postgres_operator = '?'\n+    prepare_rhs = False\n+\n+\n+@JSONField.register_lookup\n+class HasAnyKeys(HasKeyLookup):\n+    lookup_name = 'has_any_keys'\n+    postgres_operator = '?|'\n+    logical_operator = ' OR '\n+\n+    def get_prep_lookup(self):\n+        return [\n+            str(item) if not isinstance(item, KeyTransform) else item\n+            for item in self.rhs\n+        ]\n+\n+\n+@JSONField.register_lookup\n+class HasKeys(HasAnyKeys):\n+    lookup_name = 'has_keys'\n+    postgres_operator = '?&'\n+    logical_operator = ' AND '\n+\n+\n+@JSONField.register_lookup\n+class DataContains(SimpleFunctionOperatorMixin, Lookup):\n+    lookup_name = 'contains'\n+    postgres_operator = '@>'\n+\n+    def as_mysql(self, compiler, connection, flipped=False):\n+        return super().as_sql_function(\n+            compiler, connection, template=\"JSON_CONTAINS(%s, %s, '$')\", flipped=flipped\n+        )\n+\n+    def as_oracle(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        if isinstance(self.rhs, KeyTransform):\n+            _, _, key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n+            return \"JSON_EXISTS(%s, '%s')\" % (lhs, compile_json_path(key_transforms)), []\n+        else:\n+            rhs = json.loads(self.rhs)\n+        if isinstance(rhs, dict):\n+            if not rhs:\n+                return \"DBMS_LOB.SUBSTR(%s) LIKE '{%%%%}'\" % lhs, []\n+            conditions = []\n+            for key, value in rhs.items():\n+                k = json.dumps(key)\n+                if value is None:\n+                    conditions.append(\n+                        \"(JSON_EXISTS(%s, '$.%s') AND\"\n+                        \" COALESCE(JSON_QUERY(%s, '$.%s'), JSON_VALUE(%s, '$.%s')) IS NULL)\" % ((lhs, k) * 3)\n+                    )\n+                elif isinstance(value, (list, dict)):\n+                    conditions.append(\n+                        \"JSON_QUERY(%s, '$.%s') = JSON_QUERY('{\\\"val\\\": %s}', '$.val')\" % (lhs, k, json.dumps(value))\n+                    )\n+                else:\n+                    conditions.append(\n+                        \"JSON_VALUE(%s, '$.%s') = JSON_VALUE('{\\\"val\\\": %s}', '$.val')\" % (lhs, k, json.dumps(value))\n+                    )\n+            return ' AND '.join(conditions), []\n+        else:\n+            return 'DBMS_LOB.SUBSTR(%s) = %%s' % lhs, [self.rhs]\n+\n+    def as_sqlite(self, compiler, connection, flipped=False):\n+        return super().as_sql_function(\n+            compiler, connection, template='django_json_contains(%s, %s)', flipped=flipped\n+        )\n+\n+\n+@JSONField.register_lookup\n+class ContainedBy(DataContains):\n+    lookup_name = 'contained_by'\n+    postgres_operator = '<@'\n+\n+    def as_mysql(self, compiler, connection):\n+        return super().as_mysql(compiler, connection, flipped=True)\n+\n+    def as_oracle(self, compiler, connection):\n+        return super().as_sql(compiler, connection)\n+\n+    def as_sqlite(self, compiler, connection):\n+        return super().as_sqlite(compiler, connection, flipped=True)\n+\n+\n+@JSONField.register_lookup\n+class JSONExact(lookups.Exact):\n+    can_use_none_as_rhs = True\n+\n+    def process_lhs(self, compiler, connection):\n+        lhs, lhs_params = super().process_lhs(compiler, connection)\n+        if connection.vendor == 'sqlite':\n+            rhs, rhs_params = super().process_rhs(compiler, connection)\n+            if rhs == '%s' and rhs_params == [None]:\n+                # Need to use JSON_TYPE instead of JSON_EXTRACT\n+                # to determine JSON null values.\n+                lhs = \"JSON_TYPE(%s, '$')\" % lhs\n+        return lhs, lhs_params\n+\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        # Treat None lookup values as null.\n+        if rhs == '%s' and rhs_params == [None]:\n+            rhs, rhs_params = ('%s', ['null'])\n+        if connection.vendor == 'mysql':\n+            func = [\"JSON_EXTRACT(%s, '$')\" for value in rhs_params]\n+            rhs = rhs % tuple(func)\n+        return rhs, rhs_params\n+\n+\n+class KeyTransform(Transform):\n+    postgres_operator = '->'\n+    postgres_nested_operator = '#>'\n+\n+    def __init__(self, key_name, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.key_name = key_name\n+\n+    def preprocess_lhs(self, compiler, connection, lhs_only=False):\n+        if not lhs_only:\n+            key_transforms = [self.key_name]\n+        previous = self.lhs\n+        while isinstance(previous, KeyTransform):\n+            if not lhs_only:\n+                key_transforms.insert(0, previous.key_name)\n+            previous = previous.lhs\n+        lhs, params = compiler.compile(previous)\n+        return (lhs, params, key_transforms) if not lhs_only else (lhs, params)\n+\n+    def as_mysql(self, compiler, connection):\n+        lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path(key_transforms)\n+        return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n+\n+    def as_oracle(self, compiler, connection):\n+        lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path(key_transforms)\n+        return \"COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))\" % ((lhs, json_path) * 2), tuple(params)\n+\n+    def as_postgresql(self, compiler, connection):\n+        lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n+        if len(key_transforms) > 1:\n+            return '(%s %s %%s)' % (lhs, self.postgres_nested_operator), params + [key_transforms]\n+        try:\n+            lookup = int(self.key_name)\n+        except ValueError:\n+            lookup = self.key_name\n+        return '(%s %s %%s)' % (lhs, self.postgres_operator), tuple(params) + (lookup,)\n+\n+    def as_sqlite(self, compiler, connection):\n+        lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n+        json_path = compile_json_path(key_transforms)\n+        return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n+\n+\n+class KeyTextTransform(KeyTransform):\n+    postgres_operator = '->>'\n+    postgres_nested_operator = '#>>'\n+\n+\n+class KeyTransformTextLookupMixin:\n+    \"\"\"\n+    Mixin for combining with a lookup expecting a text lhs from a JSONField\n+    key lookup. On PostgreSQL, make use of the ->> operator instead of casting\n+    key values to text and performing the lookup on the resulting representation.\n+    On MySQL, JSON_UNQUOTE is applied to the lhs.\n+    \"\"\"\n+    def __init__(self, key_transform, *args, **kwargs):\n+        if not isinstance(key_transform, KeyTransform):\n+            raise TypeError(\n+                'Transform should be an instance of KeyTransform in order to use this lookup.'\n+            )\n+        key_text_transform = KeyTextTransform(\n+            key_transform.key_name, *key_transform.source_expressions, **key_transform.extra\n+        )\n+        super().__init__(key_text_transform, *args, **kwargs)\n+\n+\n+class KeyTransformNumericLookupMixin:\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        if connection.vendor != 'postgresql':\n+            rhs_params = [json.loads(value) for value in rhs_params]\n+        return rhs, rhs_params\n+\n+\n+class CaseInsensitiveMixin:\n+    \"\"\"\n+    Mixin to allow case-insensitive comparison of JSON values on MySQL.\n+    MySQL handles strings used in JSON context using the utf8mb4_bin collation.\n+    Because utf8mb4_bin is a binary collation, comparison of JSON values is case-sensitive.\n+    \"\"\"\n+    def process_lhs(self, compiler, connection):\n+        lhs, lhs_params = super().process_lhs(compiler, connection)\n+        if connection.vendor == 'mysql':\n+            return 'LOWER(%s)' % lhs, lhs_params\n+        return lhs, lhs_params\n+\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        if connection.vendor == 'mysql':\n+            return 'LOWER(%s)' % rhs, rhs_params\n+        return rhs, rhs_params\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformIsNull(lookups.IsNull):\n+    def as_oracle(self, compiler, connection):\n+        if isinstance(self.lhs, KeyTransform):\n+            prev_lhs, prev_params, key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n+        else:\n+            prev_lhs, prev_params, key_transforms = *compiler.compile(self.lhs), []\n+        json_path = compile_json_path(key_transforms)\n+        if self.rhs:\n+            return (\n+                \"(NOT JSON_EXISTS(%s, '%s') OR JSON_QUERY(%s, '$') IS NULL)\" % (prev_lhs, json_path, prev_lhs),\n+                prev_params\n+            )\n+        else:\n+            return \"JSON_EXISTS(%s, '%s')\" % (prev_lhs, json_path), prev_params\n+\n+    def as_sqlite(self, compiler, connection):\n+        lhs, lhs_params = super().process_lhs(compiler, connection)\n+        if isinstance(self.lhs, KeyTransform):\n+            prev_lhs, prev_params = self.lhs.preprocess_lhs(compiler, connection, lhs_only=True)\n+        else:\n+            prev_lhs, prev_params = compiler.compile(self.lhs)\n+        if self.rhs:\n+            return 'JSON_TYPE(%s, %%s) IS NULL' % prev_lhs, lhs_params\n+        else:\n+            return 'JSON_TYPE(%s, %%s) IS NOT NULL' % prev_lhs, lhs_params\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformExact(JSONExact):\n+    def process_lhs(self, compiler, connection):\n+        lhs, lhs_params = super().process_lhs(compiler, connection)\n+        if connection.vendor == 'sqlite':\n+            rhs, rhs_params = super().process_rhs(compiler, connection)\n+            if rhs == '%s' and rhs_params == ['null']:\n+                if isinstance(self.lhs, KeyTransform):\n+                    lhs, params = self.lhs.preprocess_lhs(compiler, connection, lhs_only=True)\n+                else:\n+                    lhs, params = compiler.compile(self.lhs)\n+                lhs = 'JSON_TYPE(%s, %%s)' % lhs\n+        return lhs, lhs_params\n+\n+    def process_rhs(self, compiler, connection):\n+        if isinstance(self.rhs, KeyTransform):\n+            rhs, rhs_params = super(lookups.Exact, self).process_rhs(compiler, connection)\n+            if connection.vendor == 'oracle':\n+                rhs_params *= 2\n+            return rhs, rhs_params\n+        else:\n+            rhs, rhs_params = super().process_rhs(compiler, connection)\n+        if connection.vendor == 'oracle':\n+            func = []\n+            for value in rhs_params:\n+                val = json.loads(value)\n+                if isinstance(val, (list, dict)):\n+                    func.append(\"JSON_QUERY('{\\\"val\\\": %s}', '$.val')\" % value)\n+                else:\n+                    func.append(\"JSON_VALUE('{\\\"val\\\": %s}', '$.val')\" % value)\n+            rhs = rhs % tuple(func)\n+            rhs_params = []\n+        elif connection.vendor == 'sqlite':\n+            func = [\"JSON_EXTRACT(%s, '$')\" if value != 'null' else '%s' for value in rhs_params]\n+            rhs = rhs % tuple(func)\n+        return rhs, rhs_params\n+\n+    def as_oracle(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        if rhs_params == ['null']:\n+            lhs, lhs_params = self.process_lhs(compiler, connection)\n+            if isinstance(self.lhs, KeyTransform):\n+                prev_lhs, _, key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n+            else:\n+                prev_lhs, _, key_transforms = *compiler.compile(self.lhs), []\n+            json_path = compile_json_path(key_transforms)\n+            sql = \"(JSON_EXISTS(%s, '%s') AND %s IS NULL)\" % (prev_lhs, json_path, lhs)\n+            return sql, []\n+        else:\n+            return super().as_sql(compiler, connection)\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformContains(KeyTransformTextLookupMixin, lookups.Contains):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformLte(KeyTransformNumericLookupMixin, lookups.LessThanOrEqual):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformLt(KeyTransformNumericLookupMixin, lookups.LessThan):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):\n+    pass\n+\n+\n+@KeyTransform.register_lookup\n+class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):\n+    pass\n+\n+\n+class KeyTransformFactory:\n+\n+    def __init__(self, key_name):\n+        self.key_name = key_name\n+\n+    def __call__(self, *args, **kwargs):\n+        return KeyTransform(self.key_name, *args, **kwargs)\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex c5374c7e9dba..f26ca1fbe15f 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1211,3 +1212,65 @@ def to_python(self, value):\n             except ValueError:\n                 raise ValidationError(self.error_messages['invalid'], code='invalid')\n         return value\n+\n+\n+class InvalidJSONInput(str):\n+    pass\n+\n+\n+class JSONString(str):\n+    pass\n+\n+\n+class JSONField(CharField):\n+    default_error_messages = {\n+        'invalid': _('Enter a valid JSON value.'),\n+    }\n+    widget = Textarea\n+\n+    def __init__(self, encoder=None, decoder=None, **kwargs):\n+        self.encoder, self.decoder = encoder, decoder\n+        super().__init__(**kwargs)\n+\n+    def to_python(self, value):\n+        if self.disabled:\n+            return value\n+        if value in self.empty_values:\n+            return None\n+        elif isinstance(value, (list, dict, int, float, JSONString)):\n+            return value\n+        try:\n+            converted = json.loads(value, cls=self.decoder)\n+        except json.JSONDecodeError:\n+            raise ValidationError(\n+                self.error_messages['invalid'],\n+                code='invalid',\n+                params={'value': value},\n+            )\n+        if isinstance(converted, str):\n+            return JSONString(converted)\n+        else:\n+            return converted\n+\n+    def bound_data(self, data, initial):\n+        if self.disabled:\n+            return initial\n+        try:\n+            return json.loads(data, cls=self.decoder)\n+        except json.JSONDecodeError:\n+            return InvalidJSONInput(data)\n+\n+    def prepare_value(self, value):\n+        if isinstance(value, InvalidJSONInput):\n+            return value\n+        return json.dumps(value, cls=self.encoder)\n+\n+    def has_changed(self, initial, data):\n+        if super().has_changed(initial, data):\n+            return True\n+        # For purposes of seeing whether something has changed, True isn't the\n+        # same as 1 and the order of keys doesn't matter.\n+        return (\n+            json.dumps(initial, sort_keys=True, cls=self.encoder) !=\n+            json.dumps(self.to_python(data), sort_keys=True, cls=self.encoder)\n+        )\ndiff --git a/docs/ref/databases.txt b/docs/ref/databases.txt\nindex b4c190bafddd..5610fdb7d707 100644\n--- a/docs/ref/databases.txt\n+++ b/docs/ref/databases.txt\n@@ -778,6 +778,95 @@ iterator. Your code must handle this.\n \n .. _`Isolation in SQLite`: https://sqlite.org/isolation.html\n \n+.. _sqlite-json1:\n+\n+Enabling JSON1 extension on SQLite\n+----------------------------------\n+\n+This document describes how to enable JSON1 extension on Python's\n+:py:mod:`sqlite3` library so that :class:`~django.db.models.JSONField` can be\n+used. If the extension is not enabled on your installation and there is no\n+other database connection that supports ``JSONField``, a system error will be\n+raised (\"``No database connection that supports JSONField is found.``\"). To\n+check if the extension is enabled on your installation, you can do a query with\n+one of the functions included in the extension, e.g. ``JSON()``. For example::\n+\n+    >>> import sqlite3\n+    >>> conn = sqlite3.connect(':memory:')\n+    >>> c = conn.cursor()\n+    >>> c.execute(\"SELECT JSON('123');\")\n+\n+If the query doesn't throw any errors, then the JSON1 extension should already\n+be enabled. Otherwise, follow the instructions below according to your\n+operating system to set it up correctly.\n+\n+Linux\n+~~~~~\n+\n+On most major Linux distributions, the JSON1 extension is included in their\n+SQLite and/or Python packages and enabled by default. If that's not the case on\n+your installation, then do the following:\n+\n+- Download the `SQLite amalgamation`_,\n+  with or without the configuration script.\n+- Extract the source code archive and enter the directory of the result.\n+- Compile the source code using the ``-DSQLITE_ENABLE_JSON1`` flag to enable\n+  the JSON1 extension. For example:\n+\n+  .. code-block:: console\n+\n+      gcc -DSQLITE_ENABLE_JSON1 -c -fPIC sqlite3.c\n+\n+  To enable other extensions, see the `compilation instructions`_.\n+- Create a shared library. For example:\n+\n+  .. code-block:: console\n+\n+      gcc -shared -o libsqlite3.so -fPIC sqlite3.o -ldl -lpthread\n+\n+- Place the resulting file (``libsqlite3.so``) in a desired directory, e.g.\n+  ``/usr/lib/sqlite3/``.\n+- Set the ``LD_PRELOAD`` environment variable to use your compiled SQLite every\n+  time you run Django. For example:\n+\n+  .. code-block:: console\n+\n+      export LD_PRELOAD=/usr/lib/sqlite3/libsqlite3.so\n+\n+- Now, the JSON1 extension should be ready to be used in Python and Django.\n+\n+.. _`SQLite amalgamation`: https://www.sqlite.org/download.html\n+.. _`compilation instructions`: https://www.sqlite.org/howtocompile.html\n+\n+Mac\n+~~~\n+\n+On Mac, follow the instructions for Linux above, but instead of setting the\n+``LD_PRELOAD`` environment variable, use ``DYLD_LIBRARY_PATH``. For example:\n+\n+  .. code-block:: console\n+\n+      export DYLD_LIBRARY_PATH=/usr/lib/sqlite3\n+\n+Windows\n+~~~~~~~\n+\n+- Download the `precompiled DLL`_ that matches your Python installation (32-bit\n+  or 64-bit).\n+- Locate your Python installation. By default, it should be in\n+  ``%localappdata%\\Programs\\Python\\PythonXX``, where ``XX`` is the Python\n+  version. For example, it's located in\n+  ``C:\\Users\\<username>\\AppData\\Local\\Programs\\Python\\Python37``. If you added\n+  Python installation directory to your ``PATH`` environment variable, you can\n+  run the command ``where python`` on a command prompt to locate it.\n+- Enter the ``DLLs`` directory in your Python installation.\n+- Rename (or delete) ``sqlite3.dll`` inside the ``DLLs`` directory.\n+- Extract ``sqlite3.dll`` from the downloaded DLL archive and put it in the\n+  ``DLLs`` directory.\n+- Now, the JSON1 extension should be ready to be used in Python and Django.\n+\n+.. _`precompiled DLL`: https://www.sqlite.org/download.html\n+\n .. _oracle-notes:\n \n Oracle notes\ndiff --git a/docs/ref/forms/fields.txt b/docs/ref/forms/fields.txt\nindex d2a0550a47e2..da05905af497 100644\n--- a/docs/ref/forms/fields.txt\n+++ b/docs/ref/forms/fields.txt\n@@ -809,6 +809,64 @@ For each field, we describe the default widget used if you don't specify\n         ``192.0.2.1``. Default is disabled. Can only be used\n         when ``protocol`` is set to ``'both'``.\n \n+``JSONField``\n+-------------\n+\n+.. class:: JSONField(encoder=None, decoder=None, **kwargs)\n+\n+    A field which accepts JSON encoded data for a\n+    :class:`~django.db.models.JSONField`.\n+\n+    * Default widget: :class:`Textarea`\n+    * Empty value: ``''`` (an empty string)\n+    * Normalizes to: Python representation of the JSON value (usually as a\n+      dictionary, list, string, number, boolean or ``None``), depending on\n+      ``decoder``.\n+    * Validates that the given value is a valid JSON value.\n+    * Error message keys: ``required``, ``invalid``\n+\n+    Takes two optional arguments:\n+\n+    .. attribute:: encoder\n+\n+        A :py:class:`json.JSONEncoder` subclass to serialize data types\n+        not supported by the standard JSON serializer (``datetime``, ``uuid``,\n+        etc.). For example, you can use the\n+        :class:`~django.core.serializers.json.DjangoJSONEncoder` class.\n+\n+        The ``encoder`` is used to serialize the data before it's rendered by the\n+        widget. It is also used in :meth:`Field.has_changed()`.\n+\n+        If ``None`` is specified, it defaults to ``json.JSONEncoder``.\n+\n+    .. attribute:: decoder\n+\n+        A :py:class:`json.JSONDecoder` subclass to deserialize the input.\n+        Your deserialization may need to account for the fact that you can't be\n+        certain of the input type. For example, you run the risk of returning a\n+        ``datetime`` that was actually a string that just happened to be in the\n+        same format chosen for ``datetime``\\s.\n+\n+        The ``decoder`` can be used to validate the input. If\n+        :py:class:`json.JSONDecodeError` is raised during the deserialization, a\n+        ``ValidationError`` will be raised.\n+\n+        If ``None`` is specified, it defaults to ``json.JSONDecoder``.\n+\n+    Specification for ``JSONEncoder`` and ``JSONDecoder`` subclasses can be found\n+    in the Python documentation.\n+\n+    .. note::\n+\n+        If you use a :class:`ModelForm <django.forms.ModelForm>`, the ``encoder`` and\n+        ``decoder`` from its :class:`~django.db.models.JSONField` will be used.\n+\n+    .. admonition:: User friendly forms\n+\n+        ``JSONField`` is not particularly user friendly in most cases. However,\n+        it is a useful way to format data from a client-side widget for\n+        submission to the server.\n+\n ``MultipleChoiceField``\n -----------------------\n \ndiff --git a/docs/ref/models/fields.txt b/docs/ref/models/fields.txt\nindex d321506d996a..3b4f88367fd8 100644\n--- a/docs/ref/models/fields.txt\n+++ b/docs/ref/models/fields.txt\n@@ -1169,6 +1169,84 @@ are converted to lowercase.\n If you allow for blank values, you have to allow for null values since blank\n values are stored as null.\n \n+``JSONField``\n+-------------\n+\n+.. class:: JSONField(encoder=None, decoder=None, **options)\n+\n+A field for storing JSON encoded data. In Python the data is represented in\n+its Python native format: dictionaries, lists, strings, numbers, booleans\n+and ``None``.\n+\n+.. attribute:: JSONField.encoder\n+\n+    An optional :py:class:`json.JSONEncoder` subclass to serialize data types\n+    not supported by the standard JSON serializer (``datetime``, ``uuid``,\n+    etc.). For example, you can use the\n+    :class:`~django.core.serializers.json.DjangoJSONEncoder` class.\n+\n+    If ``None`` is specified, it defaults to ``json.JSONEncoder``.\n+\n+.. attribute:: JSONField.decoder\n+\n+    An optional :py:class:`json.JSONDecoder` subclass to deserialize the value\n+    retrieved from the database. The value will be in the format chosen by the\n+    custom encoder (most often a string). Your deserialization may need to\n+    account for the fact that you can't be certain of the input type. For\n+    example, you run the risk of returning a ``datetime`` that was actually a\n+    string that just happened to be in the same format chosen for\n+    ``datetime``\\s.\n+\n+    If ``None`` is specified, it defaults to ``json.JSONDecoder``.\n+\n+Specification for ``JSONEncoder`` and ``JSONDecoder`` subclasses can be found\n+in the Python documentation.\n+\n+If you give the field a :attr:`~django.db.models.Field.default`, ensure\n+it's an immutable object, such as a ``str``, or a callable object that returns\n+a fresh mutable object each time, such as ``dict`` or a function. Providing a\n+mutable default object like ``default={}`` or ``default=[]`` shares the one\n+object between all model instances. There is a system check for this.\n+\n+To query ``JSONField`` in the database, see\n+:ref:`Querying JSONField <querying-jsonfield>`.\n+\n+.. note::\n+\n+    Oracle Database supports storing JSON data using SQL data types\n+    ``VARCHAR2``, ``CLOB``, and ``BLOB``. ``JSONField`` uses ``CLOB``.\n+\n+.. note::\n+\n+    PostgreSQL has two native JSON based data types: ``json`` and ``jsonb``.\n+    The main difference between them is how they are stored and how they can be\n+    queried. PostgreSQL's ``json`` field is stored as the original string\n+    representation of the JSON and must be decoded on the fly when queried\n+    based on keys. The ``jsonb`` field is stored based on the actual structure\n+    of the JSON which allows indexing. The trade-off is a small additional cost\n+    on writing to the ``jsonb`` field. ``JSONField`` uses ``jsonb``.\n+\n+.. admonition:: MariaDB users\n+\n+    Requires MariaDB 10.2.7 or later.\n+\n+.. admonition:: MySQL users\n+\n+    Requires MySQL 5.7.8 or later.\n+\n+.. admonition:: Oracle users\n+\n+    Oracle Database does not support storing JSON scalar values. Only JSON\n+    objects and arrays (represented in Python using :py:class:`dict` and\n+    :py:class:`list`) are supported.\n+\n+.. admonition:: SQLite users\n+\n+    Requires SQLite 3.9.0 or later with the JSON1_ extension enabled. See\n+    :ref:`sqlite-json1` for more details.\n+\n+.. _JSON1: https://www.sqlite.org/json1.html\n+\n ``NullBooleanField``\n --------------------\n \ndiff --git a/docs/topics/db/queries.txt b/docs/topics/db/queries.txt\nindex 79f38084fa55..fba275616178 100644\n--- a/docs/topics/db/queries.txt\n+++ b/docs/topics/db/queries.txt\n@@ -790,6 +790,286 @@ being evaluated and therefore populate the cache::\n     Simply printing the queryset will not populate the cache. This is because\n     the call to ``__repr__()`` only returns a slice of the entire queryset.\n \n+.. _querying-jsonfield:\n+\n+Querying ``JSONField``\n+======================\n+\n+Lookups implementation is different in :class:`~django.db.models.JSONField`,\n+mainly due to the existence of key transformations. To demonstrate, we will\n+use the following example model::\n+\n+    from django.db import models\n+\n+    class Dog(models.Model):\n+        name = models.CharField(max_length=200)\n+        data = models.JSONField()\n+\n+        def __str__(self):\n+            return self.name\n+\n+As with other fields, storing ``None`` as the field's value will store it as\n+SQL ``NULL``. While not recommended, it is possible to store JSON scalar\n+``null`` instead of SQL ``NULL`` by using\n+:meth:`Value('null') <django.db.models.Value>`. However, after retrieved from\n+the database, the Python representation of the data is the same as SQL\n+``NULL``, i.e. ``None``. Therefore, it can be hard to distinguish between the\n+two.\n+\n+Note that this only applies to ``None`` as the top-level value of the field.\n+If ``None`` is inside a :py:class:`list` or :py:class:`dict`, it will always\n+be interpreted as JSON ``null``.\n+\n+When querying, ``None`` value will always be interpreted as JSON ``null``.\n+To query for SQL ``NULL``, use :lookup:`isnull`.\n+\n+To illustrate::\n+\n+    >>> Dog.objects.create(name='Max', data=None)  # Stored as SQL NULL\n+    >>> Dog.objects.create(name='Archie', data=Value('null'))  # Stored as JSON null\n+\n+    >>> Dog.objects.filter(data=None)\n+    <QuerySet [<Dog: Archie>]>\n+    >>> Dog.objects.filter(data=Value('null'))\n+    <QuerySet [<Dog: Archie>]>\n+    >>> Dog.objects.filter(data__isnull=True)\n+    <QuerySet [<Dog: Max>]>\n+\n+.. note::\n+\n+    Storing JSON scalar ``null`` does not violate\n+    :attr:`null=False <django.db.models.Field.null>`.\n+\n+.. fieldlookup:: jsonfield.key\n+\n+Key, index, and path transforms\n+-------------------------------\n+\n+To query based on a given dictionary key, simply use that key as the lookup\n+name::\n+\n+    >>> Dog.objects.create(name='Rufus', data={\n+    ...     'breed': 'labrador',\n+    ...     'owner': {\n+    ...         'name': 'Bob',\n+    ...         'other_pets': [{\n+    ...             'name': 'Fishy',\n+    ...         }],\n+    ...     },\n+    ... })\n+    >>> Dog.objects.create(name='Meg', data={'breed': 'collie', 'owner': None})\n+\n+    >>> Dog.objects.filter(data__breed='collie')\n+    <QuerySet [<Dog: Meg>]>\n+\n+Multiple keys can be chained together to form a path transform::\n+\n+    >>> Dog.objects.filter(data__owner__name='Bob')\n+    <QuerySet [<Dog: Rufus>]>\n+\n+If the key is an integer, it will be interpreted as an index transform in an\n+array::\n+\n+    >>> Dog.objects.filter(data__owner__other_pets__0__name='Fishy')\n+    <QuerySet [<Dog: Rufus>]>\n+\n+If the key you wish to query by clashes with the name of another lookup, use\n+the :lookup:`contains <jsonfield.contains>` lookup instead.\n+\n+.. note::\n+\n+    The transform examples given above implicitly use the :lookup:`exact`\n+    lookup. Key, index, and path transforms can also be chained with\n+    :lookup:`iexact`, :lookup:`contains`, :lookup:`icontains`,\n+    :lookup:`startswith`, :lookup:`istartswith`, :lookup:`endswith`,\n+    :lookup:`iendswith`, :lookup:`regex`, :lookup:`iregex`, :lookup:`lt`,\n+    :lookup:`lte`, :lookup:`gt`, and :lookup:`gte` lookups.\n+\n+To query for ``null`` in JSON data, use ``None`` as a value::\n+\n+    >>> Dog.objects.filter(data__owner=None)\n+    <QuerySet [<Dog: Meg>]>\n+\n+To query for missing keys, use the ``isnull`` lookup::\n+\n+    >>> Dog.objects.create(name='Shep', data={'breed': 'collie'})\n+    >>> Dog.objects.filter(data__owner__isnull=True)\n+    <QuerySet [<Dog: Shep>]>\n+\n+.. warning::\n+\n+    Since any string could be a key in a JSON object, any lookup other than\n+    those listed below will be interpreted as a key lookup. No errors are\n+    raised. Be extra careful for typing mistakes, and always check your queries\n+    work as you intend.\n+\n+.. admonition:: MariaDB and Oracle users\n+\n+    Using :meth:`~django.db.models.query.QuerySet.order_by` on key, index,\n+    or path transforms will sort the objects using the string representation\n+    of the values. This is because MariaDB and Oracle Database do not provide\n+    a function that converts JSON values into their equivalent SQL values.\n+    Therefore, ordering by numerical JSON values does not work as expected.\n+\n+.. admonition:: Oracle users\n+\n+    On Oracle Database, using ``None`` as the lookup value in an\n+    :meth:`~django.db.models.query.QuerySet.exclude` query will return objects\n+    that do not have ``null`` as the value at the given path, including objects\n+    that do not have the path. On other database backends, the query will\n+    return objects that have the path and the value is not ``null``.\n+\n+.. note::\n+\n+    On PostgreSQL, if only one key or index is used, the SQL operator ``->`` is\n+    used. If multiple operators are used then the ``#>`` operator is used.\n+    On MySQL, MariaDB, and SQLite, the ``JSON_EXTRACT`` function is used.\n+    On Oracle Database, a combination of ``JSON_QUERY`` and ``JSON_VALUE``\n+    using ``COALESCE`` is used.\n+\n+Containment and key operations\n+------------------------------\n+\n+.. fieldlookup:: jsonfield.contains\n+\n+``contains``\n+~~~~~~~~~~~~\n+\n+The :lookup:`contains` lookup is overridden on ``JSONField``. The returned\n+objects are those where the given ``dict`` of key-value pairs are all\n+contained in the top-level of the field. For example::\n+\n+    >>> Dog.objects.create(name='Rufus', data={'breed': 'labrador', 'owner': 'Bob'})\n+    >>> Dog.objects.create(name='Meg', data={'breed': 'collie', 'owner': 'Bob'})\n+    >>> Dog.objects.create(name='Fred', data={})\n+\n+    >>> Dog.objects.filter(data__contains={'owner': 'Bob'})\n+    <QuerySet [<Dog: Rufus>, <Dog: Meg>]>\n+\n+    >>> Dog.objects.filter(data__contains={'breed': 'collie'})\n+    <QuerySet [<Dog: Meg>]>\n+\n+.. note::\n+\n+    This lookup is only overridden on ``JSONField``. It is not overridden on\n+    key, index, and path transforms.\n+\n+.. note::\n+\n+    On PostgreSQL, the implementation uses the SQL operator ``@>``. On MySQL\n+    and MariaDB, it uses the SQL function ``JSON_CONTAINS``. On Oracle\n+    Database, it uses the SQL function ``JSON_QUERY`` and ``JSON_VALUE``.\n+    On SQLite, it uses the SQL function ``JSON_EXTRACT`` and ``JSON_TYPE``.\n+\n+.. admonition:: Oracle and SQLite users\n+\n+    Since Oracle Database and SQLite don't provide a built-in function to\n+    support this lookup, the implementation is actually similar to key\n+    lookups chained together with the SQL operator ``AND``.\n+\n+.. fieldlookup:: jsonfield.contained_by\n+\n+``contained_by``\n+~~~~~~~~~~~~~~~~\n+\n+This is the inverse of the :lookup:`contains <jsonfield.contains>` lookup -\n+the objects returned will be those where the key-value pairs on the object are\n+a subset of those in the value passed. For\n+example::\n+\n+    >>> Dog.objects.create(name='Rufus', data={'breed': 'labrador', 'owner': 'Bob'})\n+    >>> Dog.objects.create(name='Meg', data={'breed': 'collie', 'owner': 'Bob'})\n+    >>> Dog.objects.create(name='Fred', data={})\n+\n+    >>> Dog.objects.filter(data__contained_by={'breed': 'collie', 'owner': 'Bob'})\n+    <QuerySet [<Dog: Meg>, <Dog: Fred>]>\n+\n+    >>> Dog.objects.filter(data__contained_by={'breed': 'collie'})\n+    <QuerySet [<Dog: Fred>]>\n+\n+.. note::\n+\n+    On PostgreSQL, the implementation uses the SQL operator ``<@``. On MySQL\n+    and MariaDB, it uses the SQL function ``JSON_CONTAINS`` like ``contains``\n+    lookup but with the arguments switched.\n+\n+.. admonition:: Oracle and SQLite users\n+\n+    Due to the limitation on Oracle and SQLite database backends, this lookup\n+    is not supported.\n+\n+.. fieldlookup:: jsonfield.has_key\n+\n+``has_key``\n+~~~~~~~~~~~\n+\n+Returns objects where the given key is in the top-level of the data. For\n+example::\n+\n+    >>> Dog.objects.create(name='Rufus', data={'breed': 'labrador'})\n+    >>> Dog.objects.create(name='Meg', data={'breed': 'collie', 'owner': 'Bob'})\n+\n+    >>> Dog.objects.filter(data__has_key='owner')\n+    <QuerySet [<Dog: Meg>]>\n+\n+.. note::\n+\n+    On PostgreSQL, the implementation uses the SQL operator ``?``. On MySQL\n+    and MariaDB, it uses the SQL function ``JSON_CONTAINS_PATH``. On Oracle\n+    Database, it uses the SQL function ``JSON_EXISTS``. On SQLite, it uses\n+    the SQL function ``JSON_TYPE``.\n+\n+.. admonition:: SQLite users\n+\n+    The implementation uses ``JSON_TYPE`` along with ``IS NOT NULL`` clause.\n+    The function ``JSON_EXTRACT`` is not used because it also returns SQL\n+    ``NULL`` for JSON value ``null``, which makes it impossible to\n+    differentiate between a missing key and an existing key with a ``null``\n+    value.\n+\n+.. fieldlookup:: jsonfield.has_any_keys\n+\n+``has_any_keys``\n+~~~~~~~~~~~~~~~~\n+\n+Returns objects where any of the given keys are in the top-level of the data.\n+For example::\n+\n+    >>> Dog.objects.create(name='Rufus', data={'breed': 'labrador'})\n+    >>> Dog.objects.create(name='Meg', data={'owner': 'Bob'})\n+    >>> Dog.objects.create(name='Fred', data={})\n+\n+    >>> Dog.objects.filter(data__has_any_keys=['owner', 'breed'])\n+    <QuerySet [<Dog: Rufus>, <Dog: Meg>]>\n+\n+.. note::\n+\n+    On PostgreSQL, the implementation uses the SQL operator ``?|``. On all\n+    other database backends, the implementation is similar to\n+    :lookup:`contains <jsonfield.contains>` lookup and each key is joined\n+    using the SQL ``OR`` operator.\n+\n+.. fieldlookup:: jsonfield.has_keys\n+\n+``has_keys``\n+~~~~~~~~~~~~\n+\n+Returns objects where all of the given keys are in the top-level of the data.\n+For example::\n+\n+    >>> Dog.objects.create(name='Rufus', data={})\n+    >>> Dog.objects.create(name='Meg', data={'breed': 'collie', 'owner': 'Bob'})\n+\n+    >>> Dog.objects.filter(data__has_keys=['breed', 'owner'])\n+    <QuerySet [<Dog: Meg>]>\n+\n+.. note::\n+\n+    On PostgreSQL, the implementation uses the SQL operator ``?&``. On all\n+    other database backends, the implementation is similar to\n+    :lookup:`contains <jsonfield.contains>` lookup and each key is joined\n+    using the SQL ``AND`` operator.\n+\n .. _complex-lookups-with-q:\n \n Complex lookups with ``Q`` objects\ndiff --git a/tests/forms_tests/field_tests/test_jsonfield.py b/tests/forms_tests/field_tests/test_jsonfield.py\nnew file mode 100644\nindex 000000000000..521b74e98c98\n--- /dev/null\n+++ b/tests/forms_tests/field_tests/test_jsonfield.py\n@@ -0,0 +1,110 @@\n+import json\n+import uuid\n+\n+from django import forms\n+from django.core import exceptions\n+from django.core.serializers.json import DjangoJSONEncoder\n+from django.test import SimpleTestCase\n+\n+\n+class CustomDecoder(json.JSONDecoder):\n+    def __init__(self, object_hook=None, *args, **kwargs):\n+        return super().__init__(object_hook=self.object_hook, *args, **kwargs)\n+\n+    def object_hook(self, dct):\n+        try:\n+            dct['uuid'] = uuid.UUID(dct['uuid'])\n+        except KeyError:\n+            pass\n+        return dct\n+\n+\n+class TestFormField(SimpleTestCase):\n+\n+    def test_valid(self):\n+        field = forms.JSONField()\n+        value = field.clean('{\"a\": \"b\"}')\n+        self.assertEqual(value, {'a': 'b'})\n+\n+    def test_valid_empty(self):\n+        field = forms.JSONField(required=False)\n+        value = field.clean('')\n+        self.assertIsNone(value)\n+\n+    def test_invalid(self):\n+        field = forms.JSONField()\n+        with self.assertRaisesMessage(exceptions.ValidationError, 'Enter a valid JSON value.'):\n+            field.clean('{some badly formed: json}')\n+\n+    def test_formfield_disabled(self):\n+        class JsonForm(forms.Form):\n+            name = forms.CharField()\n+            jfield = forms.JSONField(disabled=True)\n+\n+        form = JsonForm({'name': 'xyz', 'jfield': '[\"bar\"]'}, initial={'jfield': ['foo']})\n+        self.assertIn('[&quot;foo&quot;]</textarea>', form.as_p())\n+\n+    def test_prepare_value(self):\n+        field = forms.JSONField()\n+        self.assertEqual(field.prepare_value({'a': 'b'}), '{\"a\": \"b\"}')\n+        self.assertEqual(field.prepare_value(None), 'null')\n+        self.assertEqual(field.prepare_value('foo'), '\"foo\"')\n+\n+    def test_redisplay_wrong_input(self):\n+        \"\"\"\n+        When displaying a bound form (typically due to invalid input), the form\n+        should not overquote JSONField inputs.\n+        \"\"\"\n+        class JsonForm(forms.Form):\n+            name = forms.CharField(max_length=2)\n+            jfield = forms.JSONField()\n+\n+        # JSONField input is fine, name is too long\n+        form = JsonForm({'name': 'xyz', 'jfield': '[\"foo\"]'})\n+        self.assertNotIn('jfield', form.errors)\n+        self.assertIn('[&quot;foo&quot;]</textarea>', form.as_p())\n+\n+        # This time, the JSONField input is wrong\n+        form = JsonForm({'name': 'xy', 'jfield': '{\"foo\"}'})\n+        self.assertIn('jfield', form.errors)\n+        self.assertIn('{&quot;foo&quot;}</textarea>', form.as_p())\n+\n+    def test_widget(self):\n+        \"\"\"The default widget of a JSONField is a Textarea.\"\"\"\n+        field = forms.JSONField()\n+        self.assertIsInstance(field.widget, forms.widgets.Textarea)\n+\n+    def test_custom_widget_kwarg(self):\n+        \"\"\"The widget can be overridden with a kwarg.\"\"\"\n+        field = forms.JSONField(widget=forms.widgets.Input)\n+        self.assertIsInstance(field.widget, forms.widgets.Input)\n+\n+    def test_custom_widget_attribute(self):\n+        \"\"\"The widget can be overridden with an attribute.\"\"\"\n+        class CustomJSONField(forms.JSONField):\n+            widget = forms.widgets.Input\n+\n+        field = CustomJSONField()\n+        self.assertIsInstance(field.widget, forms.widgets.Input)\n+\n+    def test_already_converted_value(self):\n+        field = forms.JSONField(required=False)\n+        tests = [\n+            '[\"a\", \"b\", \"c\"]', '{\"a\": 1, \"b\": 2}', '1', '1.5', '\"foo\"',\n+            'true', 'false', 'null',\n+        ]\n+        for json_string in tests:\n+            with self.subTest(json_string=json_string):\n+                val = field.clean(json_string)\n+                self.assertEqual(field.clean(val), val)\n+\n+    def test_has_changed(self):\n+        field = forms.JSONField()\n+        self.assertIs(field.has_changed({'a': True}, '{\"a\": 1}'), True)\n+        self.assertIs(field.has_changed({'a': 1, 'b': 2}, '{\"b\": 2, \"a\": 1}'), False)\n+\n+    def test_custom_encoder_decoder(self):\n+        value = {'uuid': uuid.UUID('{12345678-1234-5678-1234-567812345678}')}\n+        field = forms.JSONField(encoder=DjangoJSONEncoder, decoder=CustomDecoder)\n+        self.assertEqual(field.prepare_value(value), '{\"uuid\": \"12345678-1234-5678-1234-567812345678\"}')\n+        self.assertEqual(field.clean('{\"uuid\": \"12345678-1234-5678-1234-567812345678\"}'), value)\ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nnew file mode 100644\nindex 000000000000..12bb95899ec9\n--- /dev/null\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -0,0 +1,691 @@\n+import json\n+import operator\n+import uuid\n+from unittest import skipIf\n+\n+from tests.forms_tests.field_tests.test_jsonfield import CustomDecoder\n+\n+from django import forms\n+from django.core import checks, serializers\n+from django.core.exceptions import ValidationError\n+from django.core.serializers.json import DjangoJSONEncoder\n+from django.db import (\n+    DataError, IntegrityError, OperationalError, connection, models,\n+)\n+from django.db.models import Count, F, OuterRef, Q, Subquery, Transform, Value\n+from django.db.models.expressions import RawSQL\n+from django.db.models.fields.json import (\n+    KeyTextTransform, KeyTransform, KeyTransformFactory,\n+    KeyTransformTextLookupMixin,\n+)\n+from django.db.models.functions import Cast\n+from django.db.utils import DatabaseError\n+from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n+from django.test.utils import CaptureQueriesContext, isolate_apps\n+from django.utils.version import PY37\n+\n+from .models import JSONModel, NullableJSONModel\n+\n+\n+class StrEncoder(json.JSONEncoder):\n+    def encode(self, obj):\n+        return str(obj)\n+\n+\n+class SetEncoderDecoderMixin:\n+    def _set_encoder_decoder(self, encoder, decoder):\n+        field = JSONModel._meta.get_field('value')\n+        field.encoder, field.decoder = encoder, decoder\n+        return field.check()\n+\n+    def tearDown(self):\n+        self._set_encoder_decoder(None, None)\n+        return super().tearDown()\n+\n+\n+class TestFieldMeta(SetEncoderDecoderMixin, TestCase):\n+    def test_deconstruction(self):\n+        field = models.JSONField(\n+            'JSON data', 'data', default=list, encoder=DjangoJSONEncoder, decoder=CustomDecoder\n+        )\n+        name, path, args, kwargs = field.deconstruct()\n+        self.assertEqual(name, 'data')\n+        self.assertEqual(path, 'django.db.models.JSONField')\n+        self.assertEqual(args, [])\n+        self.assertEqual(kwargs, {\n+            'verbose_name': 'JSON data', 'default': list,\n+            'encoder': DjangoJSONEncoder, 'decoder': CustomDecoder\n+        })\n+\n+    def test_get_transforms(self):\n+        @models.JSONField.register_lookup\n+        class MyTransform(Transform):\n+            lookup_name = 'my_transform'\n+        field = models.JSONField()\n+        transform = field.get_transform('my_transform')\n+        self.assertIs(transform, MyTransform)\n+        models.JSONField._unregister_lookup(MyTransform)\n+        models.JSONField._clear_cached_lookups()\n+        transform = field.get_transform('my_transform')\n+        self.assertIsInstance(transform, KeyTransformFactory)\n+\n+    def test_key_transform_text_lookup_mixin_non_key_transform(self):\n+        transform = Transform('test')\n+        with self.assertRaisesMessage(\n+            TypeError,\n+            'Transform should be an instance of KeyTransform in order to use this lookup.'\n+        ):\n+            KeyTransformTextLookupMixin(transform)\n+\n+\n+class TestValidation(SetEncoderDecoderMixin, TestCase):\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.uuid_value = {'uuid': uuid.UUID('{12345678-1234-5678-1234-567812345678}')}\n+\n+    def test_validation_error(self):\n+        field = models.JSONField()\n+        with self.assertRaises(ValidationError) as err:\n+            field.clean(self.uuid_value, None)\n+        self.assertEqual(err.exception.code, 'invalid')\n+        self.assertEqual(err.exception.message % err.exception.params, 'Value must be valid JSON.')\n+\n+    def test_not_serializable(self):\n+        obj = JSONModel(value=self.uuid_value)\n+        if PY37:\n+            msg = 'Object of type UUID is not JSON serializable'\n+        else:\n+            msg = \"Object of type 'UUID' is not JSON serializable\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            obj.save()\n+\n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_custom_encoder_decoder(self):\n+        self._set_encoder_decoder(DjangoJSONEncoder, CustomDecoder)\n+        obj = JSONModel(value=self.uuid_value)\n+        obj.clean_fields()\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.value, self.uuid_value)\n+\n+    @skipUnlessDBFeature('supports_json_field')\n+    def test_db_check_constraints(self):\n+        value = '{@!invalid json value 123 $!@#'\n+        self._set_encoder_decoder(StrEncoder, None)\n+        obj = JSONModel(value=value)\n+        with self.assertRaises((IntegrityError, DataError, OperationalError)):\n+            obj.save()\n+\n+\n+class TestModelFormField(SimpleTestCase):\n+    def test_formfield(self):\n+        model_field = models.JSONField()\n+        form_field = model_field.formfield()\n+        self.assertIsInstance(form_field, forms.JSONField)\n+\n+    def test_formfield_custom_encoder_decoder(self):\n+        model_field = models.JSONField(encoder=DjangoJSONEncoder, decoder=CustomDecoder)\n+        form_field = model_field.formfield()\n+        self.assertIs(form_field.encoder, DjangoJSONEncoder)\n+        self.assertIs(form_field.decoder, CustomDecoder)\n+\n+\n+@isolate_apps('model_fields.test_jsonfield')\n+@skipUnlessDBFeature('supports_json_field')\n+class TestChecks(TestCase):\n+    def test_invalid_default(self):\n+        class MyModel(models.Model):\n+            field = models.JSONField(default={})\n+\n+        model = MyModel()\n+        self.assertEqual(model.check(), [\n+            checks.Warning(\n+                msg=(\n+                    \"JSONField default should be a callable instead of an \"\n+                    \"instance so that it's not shared between all field \"\n+                    \"instances.\"\n+                ),\n+                hint='Use a callable instead, e.g., use `dict` instead of `{}`.',\n+                obj=MyModel._meta.get_field('field'),\n+                id='fields.E010',\n+            )\n+        ])\n+\n+    def test_valid_default(self):\n+        class MyModel(models.Model):\n+            field = models.JSONField(default=dict)\n+\n+        model = MyModel()\n+        self.assertEqual(model.check(), [])\n+\n+    def test_valid_default_none(self):\n+        class MyModel(models.Model):\n+            field = models.JSONField(default=None)\n+\n+        model = MyModel()\n+        self.assertEqual(model.check(), [])\n+\n+    def test_valid_callable_default(self):\n+        def callable_default():\n+            return {'it': 'works'}\n+\n+        class MyModel(models.Model):\n+            field = models.JSONField(default=callable_default)\n+\n+        model = MyModel()\n+        self.assertEqual(model.check(), [])\n+\n+\n+class TestSerialization(SimpleTestCase):\n+    test_data = (\n+        '[{\"fields\": {\"value\": %s}, '\n+        '\"model\": \"model_fields.jsonmodel\", \"pk\": null}]'\n+    )\n+    test_values = (\n+        # (Python value, serialized value),\n+        ({'a': 'b', 'c': None}, '{\"a\": \"b\", \"c\": null}'),\n+        ('abc', '\"abc\"'),\n+        ('{\"a\": \"a\"}', '\"{\\\\\"a\\\\\": \\\\\"a\\\\\"}\"'),\n+    )\n+\n+    def test_dumping(self):\n+        for value, serialized in self.test_values:\n+            with self.subTest(value=value):\n+                instance = JSONModel(value=value)\n+                data = serializers.serialize('json', [instance])\n+                self.assertJSONEqual(data, self.test_data % serialized)\n+\n+    def test_loading(self):\n+        for value, serialized in self.test_values:\n+            with self.subTest(value=value):\n+                instance = list(\n+                    serializers.deserialize('json', self.test_data % serialized)\n+                )[0].object\n+                self.assertEqual(instance.value, value)\n+\n+\n+@skipUnlessDBFeature('supports_json_field')\n+class TestSaveLoad(TestCase):\n+    def test_null(self):\n+        obj = NullableJSONModel(value=None)\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertEqual(\n+            obj.value,\n+            '' if connection.features.interprets_empty_strings_as_nulls else None,\n+        )\n+\n+    @skipUnlessDBFeature('supports_primitives_in_json_field')\n+    def test_json_null_different_from_sql_null(self):\n+        json_null = NullableJSONModel.objects.create(value=Value('null'))\n+        json_null.refresh_from_db()\n+        sql_null = NullableJSONModel.objects.create(value=None)\n+        sql_null.refresh_from_db()\n+\n+        # They are different in the database ('null' vs NULL).\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value=Value('null')),\n+            [json_null]\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value=None),\n+            [json_null]\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True),\n+            [sql_null]\n+        )\n+        # They are equal in Python (None).\n+        self.assertEqual(json_null.value, sql_null.value)\n+\n+    @skipUnlessDBFeature('supports_primitives_in_json_field')\n+    def test_primitives(self):\n+        values = [\n+            True,\n+            1,\n+            1.45,\n+            'String',\n+            '',\n+        ]\n+        for value in values:\n+            with self.subTest(value=value):\n+                obj = JSONModel(value=value)\n+                obj.save()\n+                obj.refresh_from_db()\n+                if value == Value('null'):\n+                    value = None\n+                self.assertEqual(obj.value, value)\n+\n+    def test_dict(self):\n+        values = [\n+            {},\n+            {'name': 'John', 'age': 20, 'height': 180.3},\n+            {'a': True, 'b': {'b1': False, 'b2': None}},\n+        ]\n+        for value in values:\n+            with self.subTest(value=value):\n+                obj = JSONModel.objects.create(value=value)\n+                obj.refresh_from_db()\n+                self.assertEqual(obj.value, value)\n+\n+    def test_list(self):\n+        values = [\n+            [],\n+            ['John', 20, 180.3],\n+            [True, [False, None]],\n+        ]\n+        for value in values:\n+            with self.subTest(value=value):\n+                obj = JSONModel.objects.create(value=value)\n+                obj.refresh_from_db()\n+                self.assertEqual(obj.value, value)\n+\n+    def test_realistic_object(self):\n+        value = {\n+            'name': 'John',\n+            'age': 20,\n+            'pets': [\n+                {'name': 'Kit', 'type': 'cat', 'age': 2},\n+                {'name': 'Max', 'type': 'dog', 'age': 1},\n+            ],\n+            'courses': [\n+                ['A1', 'A2', 'A3'],\n+                ['B1', 'B2'],\n+                ['C1'],\n+            ],\n+        }\n+        obj = JSONModel.objects.create(value=value)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.value, value)\n+\n+\n+@skipUnlessDBFeature('supports_json_field')\n+class TestQuerying(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.primitives = [True, False, 'yes', 7, 9.6]\n+        values = [\n+            None,\n+            [],\n+            {},\n+            {'a': 'b', 'c': 14},\n+            {\n+                'a': 'b',\n+                'c': 14,\n+                'd': ['e', {'f': 'g'}],\n+                'h': True,\n+                'i': False,\n+                'j': None,\n+                'k': {'l': 'm'},\n+            },\n+            [1, [2]],\n+            {'k': True, 'l': False},\n+            {\n+                'foo': 'bar',\n+                'baz': {'a': 'b', 'c': 'd'},\n+                'bar': ['foo', 'bar'],\n+                'bax': {'foo': 'bar'},\n+            },\n+        ]\n+        cls.objs = [\n+            NullableJSONModel.objects.create(value=value)\n+            for value in values\n+        ]\n+        if connection.features.supports_primitives_in_json_field:\n+            cls.objs.extend([\n+                NullableJSONModel.objects.create(value=value)\n+                for value in cls.primitives\n+            ])\n+\n+    def test_has_key_with_null_value(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_key='j'),\n+            [self.objs[4]]\n+        )\n+\n+    def test_has_key(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_key='a'),\n+            [self.objs[3], self.objs[4]]\n+        )\n+\n+    def test_has_keys(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_keys=['a', 'c', 'h']),\n+            [self.objs[4]]\n+        )\n+\n+    def test_has_any_keys(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__has_any_keys=['c', 'l']),\n+            [self.objs[3], self.objs[4], self.objs[6]],\n+        )\n+\n+    @skipUnlessDBFeature('supports_primitives_in_json_field')\n+    def test_contains_primitives(self):\n+        for value in self.primitives:\n+            with self.subTest(value=value):\n+                self.assertTrue(\n+                    NullableJSONModel.objects.filter(value__contains=value).exists()\n+                )\n+\n+    def test_contains_empty_dict(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__contains={}),\n+            self.objs[2:5] + self.objs[6:8],\n+        )\n+\n+    def test_contains_multiple(self):\n+        query = NullableJSONModel.objects.filter(value__contains={'k': True, 'l': False})\n+        self.assertSequenceEqual(\n+            query,\n+            [self.objs[6]]\n+        )\n+\n+    def test_contains_complex(self):\n+        query = NullableJSONModel.objects.filter(value__contains={'d': ['e', {'f': 'g'}]})\n+        self.assertSequenceEqual(\n+            query,\n+            [self.objs[4]]\n+        )\n+\n+    def test_contains_array(self):\n+        query = NullableJSONModel.objects.filter(value__contains=[1, [2]])\n+        self.assertSequenceEqual(\n+            query,\n+            [self.objs[5]]\n+        )\n+\n+    def test_contains_null(self):\n+        query = NullableJSONModel.objects.filter(value__contains={'i': False, 'j': None})\n+        self.assertSequenceEqual(\n+            query,\n+            [self.objs[4]]\n+        )\n+\n+    @skipIf(connection.vendor == 'oracle', \"Oracle does not support 'contained_by' lookup.\")\n+    def test_contained_by(self):\n+        query = NullableJSONModel.objects.filter(value__contained_by={'a': 'b', 'c': 14, 'h': True})\n+        self.assertSequenceEqual(\n+            query,\n+            [self.objs[2], self.objs[3]]\n+        )\n+\n+    def test_exact(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__exact={}),\n+            [self.objs[2]]\n+        )\n+\n+    def test_exact_complex(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__exact={'a': 'b', 'c': 14}),\n+            [self.objs[3]]\n+        )\n+\n+    def test_isnull(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True),\n+            [self.objs[0]]\n+        )\n+\n+    def test_ordering_by_transform(self):\n+        objs = [\n+            NullableJSONModel.objects.create(value={'ord': 93, 'name': 'bar'}),\n+            NullableJSONModel.objects.create(value={'ord': 22.1, 'name': 'foo'}),\n+            NullableJSONModel.objects.create(value={'ord': -1, 'name': 'baz'}),\n+            NullableJSONModel.objects.create(value={'ord': 21.931902, 'name': 'spam'}),\n+            NullableJSONModel.objects.create(value={'ord': -100291029, 'name': 'eggs'}),\n+        ]\n+        query = NullableJSONModel.objects.filter(value__name__isnull=False).order_by('value__ord')\n+        if connection.vendor == 'mysql' and connection.mysql_is_mariadb or connection.vendor == 'oracle':\n+            # MariaDB and Oracle use string representation of the JSON values to sort the objects.\n+            self.assertSequenceEqual(query, [objs[2], objs[4], objs[3], objs[1], objs[0]])\n+        else:\n+            self.assertSequenceEqual(query, [objs[4], objs[2], objs[3], objs[1], objs[0]])\n+\n+    def test_ordering_grouping_by_key_transform(self):\n+        base_qs = NullableJSONModel.objects.filter(value__d__0__isnull=False)\n+        for qs in (\n+            base_qs.order_by('value__d__0'),\n+            base_qs.annotate(key=KeyTransform('0', KeyTransform('d', 'value'))).order_by('key'),\n+        ):\n+            self.assertSequenceEqual(qs, [self.objs[4]])\n+        qs = NullableJSONModel.objects.filter(value__isnull=False)\n+        if connection.vendor != 'oracle':\n+            # Oracle doesn't support direct COUNT on LOB fields.\n+            self.assertQuerysetEqual(\n+                qs.values('value__d__0').annotate(count=Count('value__d__0')).order_by('count'),\n+                [1, 11],\n+                operator.itemgetter('count'),\n+            )\n+        expected = [(None, 0), ('g', 1)] if connection.vendor != 'oracle' else [('', 0), ('g', 1)]\n+        self.assertQuerysetEqual(\n+            qs.filter(value__isnull=False).annotate(\n+                key=KeyTextTransform('f', KeyTransform('1', KeyTransform('d', 'value'))),\n+            ).values('key').annotate(count=Count('key')).order_by('count'),\n+            expected,\n+            operator.itemgetter('key', 'count'),\n+        )\n+\n+    def test_key_transform_raw_expression(self):\n+        if connection.vendor == 'postgresql':\n+            expr = RawSQL('%s::jsonb', ['{\"x\": \"bar\"}'])\n+        else:\n+            expr = RawSQL('%s', ['{\"x\": \"bar\"}'])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__foo=KeyTransform('x', expr)),\n+            [self.objs[7]],\n+        )\n+\n+    def test_key_transform_expression(self):\n+        if connection.vendor == 'oracle' or connection.vendor == 'mysql' and connection.mysql_is_mariadb:\n+            expr = 'key'\n+        else:\n+            expr = Cast('key', models.JSONField())\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__0__isnull=False).annotate(\n+                key=KeyTransform('d', 'value'),\n+                chain=KeyTransform('0', 'key'),\n+                expr=KeyTransform('0', expr),\n+            ).filter(chain=F('expr')),\n+            [self.objs[4]],\n+        )\n+\n+    def test_nested_key_transform_raw_expression(self):\n+        if connection.vendor == 'postgresql':\n+            expr = RawSQL('%s::jsonb', ['{\"x\": {\"y\": \"bar\"}}'])\n+        else:\n+            expr = RawSQL('%s', ['{\"x\": {\"y\": \"bar\"}}'])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__foo=KeyTransform('y', KeyTransform('x', expr))),\n+            [self.objs[7]],\n+        )\n+\n+    def test_nested_key_transform_expression(self):\n+        if connection.vendor == 'oracle' or connection.vendor == 'mysql' and connection.mysql_is_mariadb:\n+            expr = 'key'\n+        else:\n+            expr = Cast('key', models.JSONField())\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__0__isnull=False).annotate(\n+                key=KeyTransform('d', 'value'),\n+                chain=KeyTransform('f', KeyTransform('1', 'key')),\n+                expr=KeyTransform('f', KeyTransform('1', expr)),\n+            ).filter(chain=F('expr')),\n+            [self.objs[4]],\n+        )\n+\n+    def test_deep_values(self):\n+        query = NullableJSONModel.objects.values_list('value__k__l')\n+        empty = ('',) if connection.features.interprets_empty_strings_as_nulls else (None,)\n+        expected_objs = [empty] * len(self.objs)\n+        expected_objs[4] = ('m',)\n+        self.assertSequenceEqual(query, expected_objs)\n+\n+    @skipUnlessDBFeature('can_distinct_on_fields')\n+    def test_deep_distinct(self):\n+        query = NullableJSONModel.objects.distinct('value__k__l').values_list('value__k__l')\n+        self.assertSequenceEqual(query, [('m',), (None,)])\n+\n+    def test_isnull_key(self):\n+        # key__isnull=False works the same as has_key='key'.\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__a__isnull=True),\n+            self.objs[:3] + self.objs[5:]\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__a__isnull=False),\n+            [self.objs[3], self.objs[4]]\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=False),\n+            [self.objs[4]]\n+        )\n+\n+    def test_none_key(self):\n+        self.assertSequenceEqual(NullableJSONModel.objects.filter(value__j=None), [self.objs[4]])\n+\n+    def test_none_key_exclude(self):\n+        obj = NullableJSONModel.objects.create(value={'j': 1})\n+        if connection.vendor == 'oracle':\n+            # On Oracle, the query returns JSON objects and arrays that do not have a 'null' value\n+            # at the specified path, including those that do not have the key.\n+            self.assertSequenceEqual(\n+                NullableJSONModel.objects.exclude(value__j=None),\n+                self.objs[1:4] + self.objs[5:] + [obj]\n+            )\n+        else:\n+            self.assertSequenceEqual(NullableJSONModel.objects.exclude(value__j=None), [obj])\n+\n+    def test_isnull_key_or_none(self):\n+        obj = NullableJSONModel.objects.create(value={'a': None})\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(Q(value__a__isnull=True) | Q(value__a=None)),\n+            self.objs[:3] + self.objs[5:] + [obj]\n+        )\n+\n+    def test_shallow_list_lookup(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__0=1),\n+            [self.objs[5]]\n+        )\n+\n+    def test_shallow_obj_lookup(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__a='b'),\n+            [self.objs[3], self.objs[4]]\n+        )\n+\n+    def test_obj_subquery_lookup(self):\n+        qs = NullableJSONModel.objects.annotate(\n+            field=Subquery(NullableJSONModel.objects.filter(pk=OuterRef('pk')).values('value')),\n+        ).filter(field__a='b')\n+        self.assertSequenceEqual(qs, [self.objs[3], self.objs[4]])\n+\n+    def test_deep_lookup_objs(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__k__l='m'),\n+            [self.objs[4]]\n+        )\n+\n+    def test_shallow_lookup_obj_target(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__k={'l': 'm'}),\n+            [self.objs[4]]\n+        )\n+\n+    def test_deep_lookup_array(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__1__0=2),\n+            [self.objs[5]]\n+        )\n+\n+    def test_deep_lookup_mixed(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__d__1__f='g'),\n+            [self.objs[4]]\n+        )\n+\n+    def test_deep_lookup_transform(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__c__gt=2),\n+            [self.objs[3], self.objs[4]]\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__c__lt=5),\n+            []\n+        )\n+\n+    def test_usage_in_subquery(self):\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(id__in=NullableJSONModel.objects.filter(value__c=14)),\n+            self.objs[3:5]\n+        )\n+\n+    def test_iexact(self):\n+        self.assertTrue(NullableJSONModel.objects.filter(value__foo__iexact='BaR').exists())\n+        self.assertFalse(NullableJSONModel.objects.filter(value__foo__iexact='\"BaR\"').exists())\n+\n+    def test_contains(self):\n+        self.assertTrue(NullableJSONModel.objects.filter(value__foo__contains='ar').exists())\n+\n+    def test_icontains(self):\n+        self.assertTrue(NullableJSONModel.objects.filter(value__foo__icontains='A').exists())\n+\n+    def test_startswith(self):\n+        self.assertTrue(NullableJSONModel.objects.filter(value__foo__startswith='b').exists())\n+\n+    def test_istartswith(self):\n+        self.assertTrue(NullableJSONModel.objects.filter(value__foo__istartswith='B').exists())\n+\n+    def test_endswith(self):\n+        self.assertTrue(NullableJSONModel.objects.filter(value__foo__endswith='r').exists())\n+\n+    def test_iendswith(self):\n+        self.assertTrue(NullableJSONModel.objects.filter(value__foo__iendswith='R').exists())\n+\n+    def test_regex(self):\n+        self.assertTrue(NullableJSONModel.objects.filter(value__foo__regex=r'^bar$').exists())\n+\n+    def test_iregex(self):\n+        self.assertTrue(NullableJSONModel.objects.filter(value__foo__iregex=r'^bAr$').exists())\n+\n+    def test_key_sql_injection(self):\n+        with CaptureQueriesContext(connection) as queries:\n+            query = NullableJSONModel.objects.filter(**{\"\"\"value__test' = '\"a\"') OR 1 = 1 OR ('d\"\"\": 'x', })\n+            if connection.vendor == 'oracle':\n+                with self.assertRaises(DatabaseError):\n+                    query.exists()\n+            else:\n+                self.assertFalse(query.exists())\n+        if connection.vendor == 'postgresql':\n+            self.assertIn(\n+                \"\"\".\"value\" -> 'test'' = ''\"a\"'') OR 1 = 1 OR (''d') = '\"x\"' \"\"\",\n+                queries[0]['sql'],\n+            )\n+\n+    def test_lookups_with_key_transform(self):\n+        sql = '%s::jsonb' if connection.vendor == 'postgresql' else '%s'\n+        tests = (\n+            ('value__d__contains', 'e'),\n+            ('value__baz__contained_by', {'a': 'b', 'c': 'd', 'e': 'f'}),\n+            ('value__baz__has_key', 'c'),\n+            ('value__baz__has_keys', ['a', 'c']),\n+            ('value__baz__has_any_keys', ['a', 'x']),\n+            ('value__contains', KeyTransform('bax', 'value')),\n+            (\n+                'value__contained_by',\n+                KeyTransform('x', RawSQL(sql, ['{\"x\": {\"a\": \"b\", \"c\": 1, \"d\": \"e\"}}'])),\n+            ),\n+            ('value__has_key', KeyTextTransform('foo', 'value')),\n+        )\n+        if connection.vendor == 'oracle':\n+            # contained_by is not supported in Oracle.\n+            tests = tests[0:1] + tests[2:6] + tests[7:]\n+        for lookup, value in tests:\n+            with self.subTest(lookup=lookup):\n+                self.assertTrue(NullableJSONModel.objects.filter(\n+                    **{lookup: value},\n+                ).exists())\ndiff --git a/tests/postgres_tests/test_json.py b/tests/postgres_tests/test_json.py\ndeleted file mode 100644\nindex 0ffa05f98144..000000000000\n--- a/tests/postgres_tests/test_json.py\n+++ /dev/null\n@@ -1,579 +0,0 @@\n-import datetime\n-import operator\n-import uuid\n-from decimal import Decimal\n-\n-from django.core import checks, exceptions, serializers\n-from django.core.serializers.json import DjangoJSONEncoder\n-from django.db import connection\n-from django.db.models import Count, F, OuterRef, Q, Subquery\n-from django.db.models.expressions import RawSQL\n-from django.db.models.functions import Cast\n-from django.forms import CharField, Form, widgets\n-from django.test.utils import CaptureQueriesContext, isolate_apps\n-from django.utils.html import escape\n-\n-from . import PostgreSQLSimpleTestCase, PostgreSQLTestCase\n-from .models import JSONModel, PostgreSQLModel\n-\n-try:\n-    from django.contrib.postgres import forms\n-    from django.contrib.postgres.fields import JSONField\n-    from django.contrib.postgres.fields.jsonb import KeyTextTransform, KeyTransform\n-except ImportError:\n-    pass\n-\n-\n-class TestModelMetaOrdering(PostgreSQLSimpleTestCase):\n-    def test_ordering_by_json_field_value(self):\n-        class TestJSONModel(JSONModel):\n-            class Meta:\n-                ordering = ['field__value']\n-\n-        self.assertEqual(TestJSONModel.check(), [])\n-\n-\n-class TestSaveLoad(PostgreSQLTestCase):\n-    def test_null(self):\n-        instance = JSONModel()\n-        instance.save()\n-        loaded = JSONModel.objects.get()\n-        self.assertIsNone(loaded.field)\n-\n-    def test_empty_object(self):\n-        instance = JSONModel(field={})\n-        instance.save()\n-        loaded = JSONModel.objects.get()\n-        self.assertEqual(loaded.field, {})\n-\n-    def test_empty_list(self):\n-        instance = JSONModel(field=[])\n-        instance.save()\n-        loaded = JSONModel.objects.get()\n-        self.assertEqual(loaded.field, [])\n-\n-    def test_boolean(self):\n-        instance = JSONModel(field=True)\n-        instance.save()\n-        loaded = JSONModel.objects.get()\n-        self.assertIs(loaded.field, True)\n-\n-    def test_string(self):\n-        instance = JSONModel(field='why?')\n-        instance.save()\n-        loaded = JSONModel.objects.get()\n-        self.assertEqual(loaded.field, 'why?')\n-\n-    def test_number(self):\n-        instance = JSONModel(field=1)\n-        instance.save()\n-        loaded = JSONModel.objects.get()\n-        self.assertEqual(loaded.field, 1)\n-\n-    def test_realistic_object(self):\n-        obj = {\n-            'a': 'b',\n-            'c': 1,\n-            'd': ['e', {'f': 'g'}],\n-            'h': True,\n-            'i': False,\n-            'j': None,\n-        }\n-        instance = JSONModel(field=obj)\n-        instance.save()\n-        loaded = JSONModel.objects.get()\n-        self.assertEqual(loaded.field, obj)\n-\n-    def test_custom_encoding(self):\n-        \"\"\"\n-        JSONModel.field_custom has a custom DjangoJSONEncoder.\n-        \"\"\"\n-        some_uuid = uuid.uuid4()\n-        obj_before = {\n-            'date': datetime.date(2016, 8, 12),\n-            'datetime': datetime.datetime(2016, 8, 12, 13, 44, 47, 575981),\n-            'decimal': Decimal('10.54'),\n-            'uuid': some_uuid,\n-        }\n-        obj_after = {\n-            'date': '2016-08-12',\n-            'datetime': '2016-08-12T13:44:47.575',\n-            'decimal': '10.54',\n-            'uuid': str(some_uuid),\n-        }\n-        JSONModel.objects.create(field_custom=obj_before)\n-        loaded = JSONModel.objects.get()\n-        self.assertEqual(loaded.field_custom, obj_after)\n-\n-\n-class TestQuerying(PostgreSQLTestCase):\n-    @classmethod\n-    def setUpTestData(cls):\n-        cls.objs = JSONModel.objects.bulk_create([\n-            JSONModel(field=None),\n-            JSONModel(field=True),\n-            JSONModel(field=False),\n-            JSONModel(field='yes'),\n-            JSONModel(field=7),\n-            JSONModel(field=[]),\n-            JSONModel(field={}),\n-            JSONModel(field={\n-                'a': 'b',\n-                'c': 1,\n-            }),\n-            JSONModel(field={\n-                'a': 'b',\n-                'c': 1,\n-                'd': ['e', {'f': 'g'}],\n-                'h': True,\n-                'i': False,\n-                'j': None,\n-                'k': {'l': 'm'},\n-            }),\n-            JSONModel(field=[1, [2]]),\n-            JSONModel(field={\n-                'k': True,\n-                'l': False,\n-            }),\n-            JSONModel(field={\n-                'foo': 'bar',\n-                'baz': {'a': 'b', 'c': 'd'},\n-                'bar': ['foo', 'bar'],\n-                'bax': {'foo': 'bar'},\n-            }),\n-        ])\n-\n-    def test_exact(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__exact={}),\n-            [self.objs[6]]\n-        )\n-\n-    def test_exact_complex(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__exact={'a': 'b', 'c': 1}),\n-            [self.objs[7]]\n-        )\n-\n-    def test_isnull(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__isnull=True),\n-            [self.objs[0]]\n-        )\n-\n-    def test_ordering_by_transform(self):\n-        objs = [\n-            JSONModel.objects.create(field={'ord': 93, 'name': 'bar'}),\n-            JSONModel.objects.create(field={'ord': 22.1, 'name': 'foo'}),\n-            JSONModel.objects.create(field={'ord': -1, 'name': 'baz'}),\n-            JSONModel.objects.create(field={'ord': 21.931902, 'name': 'spam'}),\n-            JSONModel.objects.create(field={'ord': -100291029, 'name': 'eggs'}),\n-        ]\n-        query = JSONModel.objects.filter(field__name__isnull=False).order_by('field__ord')\n-        self.assertSequenceEqual(query, [objs[4], objs[2], objs[3], objs[1], objs[0]])\n-\n-    def test_ordering_grouping_by_key_transform(self):\n-        base_qs = JSONModel.objects.filter(field__d__0__isnull=False)\n-        for qs in (\n-            base_qs.order_by('field__d__0'),\n-            base_qs.annotate(key=KeyTransform('0', KeyTransform('d', 'field'))).order_by('key'),\n-        ):\n-            self.assertSequenceEqual(qs, [self.objs[8]])\n-        qs = JSONModel.objects.filter(field__isnull=False)\n-        self.assertQuerysetEqual(\n-            qs.values('field__d__0').annotate(count=Count('field__d__0')).order_by('count'),\n-            [1, 10],\n-            operator.itemgetter('count'),\n-        )\n-        self.assertQuerysetEqual(\n-            qs.filter(field__isnull=False).annotate(\n-                key=KeyTextTransform('f', KeyTransform('1', KeyTransform('d', 'field'))),\n-            ).values('key').annotate(count=Count('key')).order_by('count'),\n-            [(None, 0), ('g', 1)],\n-            operator.itemgetter('key', 'count'),\n-        )\n-\n-    def test_key_transform_raw_expression(self):\n-        expr = RawSQL('%s::jsonb', ['{\"x\": \"bar\"}'])\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__foo=KeyTransform('x', expr)),\n-            [self.objs[-1]],\n-        )\n-\n-    def test_key_transform_expression(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__d__0__isnull=False).annotate(\n-                key=KeyTransform('d', 'field'),\n-                chain=KeyTransform('0', 'key'),\n-                expr=KeyTransform('0', Cast('key', JSONField())),\n-            ).filter(chain=F('expr')),\n-            [self.objs[8]],\n-        )\n-\n-    def test_nested_key_transform_raw_expression(self):\n-        expr = RawSQL('%s::jsonb', ['{\"x\": {\"y\": \"bar\"}}'])\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__foo=KeyTransform('y', KeyTransform('x', expr))),\n-            [self.objs[-1]],\n-        )\n-\n-    def test_nested_key_transform_expression(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__d__0__isnull=False).annotate(\n-                key=KeyTransform('d', 'field'),\n-                chain=KeyTransform('f', KeyTransform('1', 'key')),\n-                expr=KeyTransform('f', KeyTransform('1', Cast('key', JSONField()))),\n-            ).filter(chain=F('expr')),\n-            [self.objs[8]],\n-        )\n-\n-    def test_deep_values(self):\n-        query = JSONModel.objects.values_list('field__k__l')\n-        self.assertSequenceEqual(\n-            query,\n-            [\n-                (None,), (None,), (None,), (None,), (None,), (None,),\n-                (None,), (None,), ('m',), (None,), (None,), (None,),\n-            ]\n-        )\n-\n-    def test_deep_distinct(self):\n-        query = JSONModel.objects.distinct('field__k__l').values_list('field__k__l')\n-        self.assertSequenceEqual(query, [('m',), (None,)])\n-\n-    def test_isnull_key(self):\n-        # key__isnull works the same as has_key='key'.\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__a__isnull=True),\n-            self.objs[:7] + self.objs[9:]\n-        )\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__a__isnull=False),\n-            [self.objs[7], self.objs[8]]\n-        )\n-\n-    def test_none_key(self):\n-        self.assertSequenceEqual(JSONModel.objects.filter(field__j=None), [self.objs[8]])\n-\n-    def test_none_key_exclude(self):\n-        obj = JSONModel.objects.create(field={'j': 1})\n-        self.assertSequenceEqual(JSONModel.objects.exclude(field__j=None), [obj])\n-\n-    def test_isnull_key_or_none(self):\n-        obj = JSONModel.objects.create(field={'a': None})\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(Q(field__a__isnull=True) | Q(field__a=None)),\n-            self.objs[:7] + self.objs[9:] + [obj]\n-        )\n-\n-    def test_contains(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__contains={'a': 'b'}),\n-            [self.objs[7], self.objs[8]]\n-        )\n-\n-    def test_contained_by(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__contained_by={'a': 'b', 'c': 1, 'h': True}),\n-            [self.objs[6], self.objs[7]]\n-        )\n-\n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__has_key='a'),\n-            [self.objs[7], self.objs[8]]\n-        )\n-\n-    def test_has_keys(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__has_keys=['a', 'c', 'h']),\n-            [self.objs[8]]\n-        )\n-\n-    def test_has_any_keys(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__has_any_keys=['c', 'l']),\n-            [self.objs[7], self.objs[8], self.objs[10]]\n-        )\n-\n-    def test_shallow_list_lookup(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__0=1),\n-            [self.objs[9]]\n-        )\n-\n-    def test_shallow_obj_lookup(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__a='b'),\n-            [self.objs[7], self.objs[8]]\n-        )\n-\n-    def test_obj_subquery_lookup(self):\n-        qs = JSONModel.objects.annotate(\n-            value=Subquery(JSONModel.objects.filter(pk=OuterRef('pk')).values('field')),\n-        ).filter(value__a='b')\n-        self.assertSequenceEqual(qs, [self.objs[7], self.objs[8]])\n-\n-    def test_deep_lookup_objs(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__k__l='m'),\n-            [self.objs[8]]\n-        )\n-\n-    def test_shallow_lookup_obj_target(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__k={'l': 'm'}),\n-            [self.objs[8]]\n-        )\n-\n-    def test_deep_lookup_array(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__1__0=2),\n-            [self.objs[9]]\n-        )\n-\n-    def test_deep_lookup_mixed(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__d__1__f='g'),\n-            [self.objs[8]]\n-        )\n-\n-    def test_deep_lookup_transform(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__c__gt=1),\n-            []\n-        )\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(field__c__lt=5),\n-            [self.objs[7], self.objs[8]]\n-        )\n-\n-    def test_usage_in_subquery(self):\n-        self.assertSequenceEqual(\n-            JSONModel.objects.filter(id__in=JSONModel.objects.filter(field__c=1)),\n-            self.objs[7:9]\n-        )\n-\n-    def test_iexact(self):\n-        self.assertTrue(JSONModel.objects.filter(field__foo__iexact='BaR').exists())\n-        self.assertFalse(JSONModel.objects.filter(field__foo__iexact='\"BaR\"').exists())\n-\n-    def test_icontains(self):\n-        self.assertFalse(JSONModel.objects.filter(field__foo__icontains='\"bar\"').exists())\n-\n-    def test_startswith(self):\n-        self.assertTrue(JSONModel.objects.filter(field__foo__startswith='b').exists())\n-\n-    def test_istartswith(self):\n-        self.assertTrue(JSONModel.objects.filter(field__foo__istartswith='B').exists())\n-\n-    def test_endswith(self):\n-        self.assertTrue(JSONModel.objects.filter(field__foo__endswith='r').exists())\n-\n-    def test_iendswith(self):\n-        self.assertTrue(JSONModel.objects.filter(field__foo__iendswith='R').exists())\n-\n-    def test_regex(self):\n-        self.assertTrue(JSONModel.objects.filter(field__foo__regex=r'^bar$').exists())\n-\n-    def test_iregex(self):\n-        self.assertTrue(JSONModel.objects.filter(field__foo__iregex=r'^bAr$').exists())\n-\n-    def test_key_sql_injection(self):\n-        with CaptureQueriesContext(connection) as queries:\n-            self.assertFalse(\n-                JSONModel.objects.filter(**{\n-                    \"\"\"field__test' = '\"a\"') OR 1 = 1 OR ('d\"\"\": 'x',\n-                }).exists()\n-            )\n-        self.assertIn(\n-            \"\"\".\"field\" -> 'test'' = ''\"a\"'') OR 1 = 1 OR (''d') = '\"x\"' \"\"\",\n-            queries[0]['sql'],\n-        )\n-\n-    def test_lookups_with_key_transform(self):\n-        tests = (\n-            ('field__d__contains', 'e'),\n-            ('field__baz__contained_by', {'a': 'b', 'c': 'd', 'e': 'f'}),\n-            ('field__baz__has_key', 'c'),\n-            ('field__baz__has_keys', ['a', 'c']),\n-            ('field__baz__has_any_keys', ['a', 'x']),\n-            ('field__contains', KeyTransform('bax', 'field')),\n-            (\n-                'field__contained_by',\n-                KeyTransform('x', RawSQL('%s::jsonb', ['{\"x\": {\"a\": \"b\", \"c\": 1, \"d\": \"e\"}}'])),\n-            ),\n-            ('field__has_key', KeyTextTransform('foo', 'field')),\n-        )\n-        for lookup, value in tests:\n-            with self.subTest(lookup=lookup):\n-                self.assertTrue(JSONModel.objects.filter(\n-                    **{lookup: value},\n-                ).exists())\n-\n-\n-@isolate_apps('postgres_tests')\n-class TestChecks(PostgreSQLSimpleTestCase):\n-\n-    def test_invalid_default(self):\n-        class MyModel(PostgreSQLModel):\n-            field = JSONField(default={})\n-\n-        model = MyModel()\n-        self.assertEqual(model.check(), [\n-            checks.Warning(\n-                msg=(\n-                    \"JSONField default should be a callable instead of an \"\n-                    \"instance so that it's not shared between all field \"\n-                    \"instances.\"\n-                ),\n-                hint='Use a callable instead, e.g., use `dict` instead of `{}`.',\n-                obj=MyModel._meta.get_field('field'),\n-                id='fields.E010',\n-            )\n-        ])\n-\n-    def test_valid_default(self):\n-        class MyModel(PostgreSQLModel):\n-            field = JSONField(default=dict)\n-\n-        model = MyModel()\n-        self.assertEqual(model.check(), [])\n-\n-    def test_valid_default_none(self):\n-        class MyModel(PostgreSQLModel):\n-            field = JSONField(default=None)\n-\n-        model = MyModel()\n-        self.assertEqual(model.check(), [])\n-\n-\n-class TestSerialization(PostgreSQLSimpleTestCase):\n-    test_data = (\n-        '[{\"fields\": {\"field\": %s, \"field_custom\": null}, '\n-        '\"model\": \"postgres_tests.jsonmodel\", \"pk\": null}]'\n-    )\n-    test_values = (\n-        # (Python value, serialized value),\n-        ({'a': 'b', 'c': None}, '{\"a\": \"b\", \"c\": null}'),\n-        ('abc', '\"abc\"'),\n-        ('{\"a\": \"a\"}', '\"{\\\\\"a\\\\\": \\\\\"a\\\\\"}\"'),\n-    )\n-\n-    def test_dumping(self):\n-        for value, serialized in self.test_values:\n-            with self.subTest(value=value):\n-                instance = JSONModel(field=value)\n-                data = serializers.serialize('json', [instance])\n-                self.assertJSONEqual(data, self.test_data % serialized)\n-\n-    def test_loading(self):\n-        for value, serialized in self.test_values:\n-            with self.subTest(value=value):\n-                instance = list(serializers.deserialize('json', self.test_data % serialized))[0].object\n-                self.assertEqual(instance.field, value)\n-\n-\n-class TestValidation(PostgreSQLSimpleTestCase):\n-\n-    def test_not_serializable(self):\n-        field = JSONField()\n-        with self.assertRaises(exceptions.ValidationError) as cm:\n-            field.clean(datetime.timedelta(days=1), None)\n-        self.assertEqual(cm.exception.code, 'invalid')\n-        self.assertEqual(cm.exception.message % cm.exception.params, \"Value must be valid JSON.\")\n-\n-    def test_custom_encoder(self):\n-        with self.assertRaisesMessage(ValueError, \"The encoder parameter must be a callable object.\"):\n-            field = JSONField(encoder=DjangoJSONEncoder())\n-        field = JSONField(encoder=DjangoJSONEncoder)\n-        self.assertEqual(field.clean(datetime.timedelta(days=1), None), datetime.timedelta(days=1))\n-\n-\n-class TestFormField(PostgreSQLSimpleTestCase):\n-\n-    def test_valid(self):\n-        field = forms.JSONField()\n-        value = field.clean('{\"a\": \"b\"}')\n-        self.assertEqual(value, {'a': 'b'})\n-\n-    def test_valid_empty(self):\n-        field = forms.JSONField(required=False)\n-        value = field.clean('')\n-        self.assertIsNone(value)\n-\n-    def test_invalid(self):\n-        field = forms.JSONField()\n-        with self.assertRaises(exceptions.ValidationError) as cm:\n-            field.clean('{some badly formed: json}')\n-        self.assertEqual(cm.exception.messages[0], '“{some badly formed: json}” value must be valid JSON.')\n-\n-    def test_formfield(self):\n-        model_field = JSONField()\n-        form_field = model_field.formfield()\n-        self.assertIsInstance(form_field, forms.JSONField)\n-\n-    def test_formfield_disabled(self):\n-        class JsonForm(Form):\n-            name = CharField()\n-            jfield = forms.JSONField(disabled=True)\n-\n-        form = JsonForm({'name': 'xyz', 'jfield': '[\"bar\"]'}, initial={'jfield': ['foo']})\n-        self.assertIn('[&quot;foo&quot;]</textarea>', form.as_p())\n-\n-    def test_prepare_value(self):\n-        field = forms.JSONField()\n-        self.assertEqual(field.prepare_value({'a': 'b'}), '{\"a\": \"b\"}')\n-        self.assertEqual(field.prepare_value(None), 'null')\n-        self.assertEqual(field.prepare_value('foo'), '\"foo\"')\n-\n-    def test_redisplay_wrong_input(self):\n-        \"\"\"\n-        When displaying a bound form (typically due to invalid input), the form\n-        should not overquote JSONField inputs.\n-        \"\"\"\n-        class JsonForm(Form):\n-            name = CharField(max_length=2)\n-            jfield = forms.JSONField()\n-\n-        # JSONField input is fine, name is too long\n-        form = JsonForm({'name': 'xyz', 'jfield': '[\"foo\"]'})\n-        self.assertIn('[&quot;foo&quot;]</textarea>', form.as_p())\n-\n-        # This time, the JSONField input is wrong\n-        form = JsonForm({'name': 'xy', 'jfield': '{\"foo\"}'})\n-        # Appears once in the textarea and once in the error message\n-        self.assertEqual(form.as_p().count(escape('{\"foo\"}')), 2)\n-\n-    def test_widget(self):\n-        \"\"\"The default widget of a JSONField is a Textarea.\"\"\"\n-        field = forms.JSONField()\n-        self.assertIsInstance(field.widget, widgets.Textarea)\n-\n-    def test_custom_widget_kwarg(self):\n-        \"\"\"The widget can be overridden with a kwarg.\"\"\"\n-        field = forms.JSONField(widget=widgets.Input)\n-        self.assertIsInstance(field.widget, widgets.Input)\n-\n-    def test_custom_widget_attribute(self):\n-        \"\"\"The widget can be overridden with an attribute.\"\"\"\n-        class CustomJSONField(forms.JSONField):\n-            widget = widgets.Input\n-\n-        field = CustomJSONField()\n-        self.assertIsInstance(field.widget, widgets.Input)\n-\n-    def test_already_converted_value(self):\n-        field = forms.JSONField(required=False)\n-        tests = [\n-            '[\"a\", \"b\", \"c\"]', '{\"a\": 1, \"b\": 2}', '1', '1.5', '\"foo\"',\n-            'true', 'false', 'null',\n-        ]\n-        for json_string in tests:\n-            val = field.clean(json_string)\n-            self.assertEqual(field.clean(val), val)\n-\n-    def test_has_changed(self):\n-        field = forms.JSONField()\n-        self.assertIs(field.has_changed({'a': True}, '{\"a\": 1}'), True)\n-        self.assertIs(field.has_changed({'a': 1, 'b': 2}, '{\"b\": 2, \"a\": 1}'), False)\ndiff --git a/tests/postgres_tests/test_json_deprecation.py b/tests/postgres_tests/test_json_deprecation.py\nnew file mode 100644\nindex 000000000000..aba1828c66eb\n--- /dev/null\n+++ b/tests/postgres_tests/test_json_deprecation.py\n@@ -0,0 +1,54 @@\n+try:\n+    from django.contrib.postgres.fields import JSONField as ModelJSONField\n+    from django.contrib.postgres.fields.jsonb import KeyTransform, KeyTextTransform\n+    from django.contrib.postgres.forms import JSONField as FormJSONField\n+except ImportError:\n+    pass\n+\n+from django.utils.deprecation import RemovedInDjango40Warning\n+\n+from . import PostgreSQLSimpleTestCase\n+from .models import PostgreSQLModel\n+\n+\n+class DeprecationTests(PostgreSQLSimpleTestCase):\n+    def test_model_field_deprecation_message(self):\n+        warning = {\n+            'msg': (\n+                'django.contrib.postgres.fields.JSONField is deprecated '\n+                'and will be removed in Django 4.0.'\n+            ),\n+            'hint': 'Use django.db.models.JSONField instead.',\n+            'id': 'fields.W903',\n+        }\n+\n+        class PostgreSQLJSONModel(PostgreSQLModel):\n+            field = ModelJSONField()\n+        warnings = PostgreSQLJSONModel().check()\n+        self.assertEqual(warnings[0].msg, warning['msg'])\n+        self.assertEqual(warnings[0].hint, warning['hint'])\n+        self.assertEqual(warnings[0].id, warning['id'])\n+\n+    def test_form_field_deprecation_message(self):\n+        msg = (\n+            'django.contrib.postgres.forms.JSONField is deprecated in favor of '\n+            'django.forms.JSONField'\n+        )\n+        with self.assertWarnsMessage(RemovedInDjango40Warning, msg):\n+            FormJSONField()\n+\n+    def test_key_transform_deprecation_message(self):\n+        msg = (\n+            'django.contrib.postgres.fields.jsonb.KeyTransform is deprecated in favor of '\n+            'django.db.models.fields.json.KeyTransform'\n+        )\n+        with self.assertWarnsMessage(RemovedInDjango40Warning, msg):\n+            KeyTransform('foo', 'bar')\n+\n+    def test_key_text_transform_deprecation_message(self):\n+        msg = (\n+            'django.contrib.postgres.fields.jsonb.KeyTextTransform is deprecated in favor of '\n+            'django.db.models.fields.json.KeyTextTransform'\n+        )\n+        with self.assertWarnsMessage(RemovedInDjango40Warning, msg):\n+            KeyTextTransform('foo', 'bar')\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR showcases significant progress on integrating JSON support across databases. The decision to update MariaDB is solid, ensuring compatibility with Django 3.0. However, the implementation of `supports_json` and querying JSON features needs refinement, particularly for SQLite compatibility checks. Catching errors to identify JSON support seems reasonable, but ensure it won't disrupt transactions. For Oracle, direct string formatting may expose SQL injection risks; proceed cautiously. Overall, the push towards unifying JSON functionalities across backends is commendable, but additional testing is essential to guarantee consistent behavior."
      }
    ],
    "token_estimation": 26435.0
  },
  {
    "index": 17,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/core/cache/backends/redis.py b/django/core/cache/backends/redis.py\nnew file mode 100644\nindex 000000000000..16556b1ded5c\n--- /dev/null\n+++ b/django/core/cache/backends/redis.py\n@@ -0,0 +1,224 @@\n+\"\"\"Redis cache backend.\"\"\"\n+\n+import random\n+import re\n+\n+from django.core.cache.backends.base import DEFAULT_TIMEOUT, BaseCache\n+from django.core.serializers.base import PickleSerializer\n+from django.utils.functional import cached_property\n+from django.utils.module_loading import import_string\n+\n+\n+class RedisSerializer(PickleSerializer):\n+    def dumps(self, obj):\n+        if isinstance(obj, int):\n+            return obj\n+        return super().dumps(obj)\n+\n+    def loads(self, data):\n+        try:\n+            return int(data)\n+        except ValueError:\n+            return super().loads(data)\n+\n+\n+class RedisCacheClient:\n+    def __init__(\n+        self,\n+        servers,\n+        serializer=None,\n+        db=None,\n+        pool_class=None,\n+        parser_class=None,\n+    ):\n+        import redis\n+\n+        self._lib = redis\n+        self._servers = servers\n+        self._pools = {}\n+\n+        self._client = self._lib.Redis\n+\n+        if isinstance(pool_class, str):\n+            pool_class = import_string(pool_class)\n+        self._pool_class = pool_class or self._lib.ConnectionPool\n+\n+        if isinstance(serializer, str):\n+            serializer = import_string(serializer)\n+        if callable(serializer):\n+            serializer = serializer()\n+        self._serializer = serializer or RedisSerializer()\n+\n+        if isinstance(parser_class, str):\n+            parser_class = import_string(parser_class)\n+        parser_class = parser_class or self._lib.connection.DefaultParser\n+\n+        self._pool_options = {'parser_class': parser_class, 'db': db}\n+\n+    def _get_connection_pool_index(self, write):\n+        # Write to the first server. Read from other servers if there are more,\n+        # otherwise read from the first server.\n+        if write or len(self._servers) == 1:\n+            return 0\n+        return random.randint(1, len(self._servers) - 1)\n+\n+    def _get_connection_pool(self, write):\n+        index = self._get_connection_pool_index(write)\n+        if index not in self._pools:\n+            self._pools[index] = self._pool_class.from_url(\n+                self._servers[index], **self._pool_options,\n+            )\n+        return self._pools[index]\n+\n+    def get_client(self, key=None, *, write=False):\n+        # key is used so that the method signature remains the same and custom\n+        # cache client can be implemented which might require the key to select\n+        # the server, e.g. sharding.\n+        pool = self._get_connection_pool(write)\n+        return self._client(connection_pool=pool)\n+\n+    def add(self, key, value, timeout):\n+        client = self.get_client(key, write=True)\n+        value = self._serializer.dumps(value)\n+\n+        if timeout == 0:\n+            if ret := bool(client.set(key, value, nx=True)):\n+                client.delete(key)\n+            return ret\n+        else:\n+            return bool(client.set(key, value, ex=timeout, nx=True))\n+\n+    def get(self, key, default):\n+        client = self.get_client(key)\n+        value = client.get(key)\n+        return default if value is None else self._serializer.loads(value)\n+\n+    def set(self, key, value, timeout):\n+        client = self.get_client(key, write=True)\n+        value = self._serializer.dumps(value)\n+        if timeout == 0:\n+            client.delete(key)\n+        else:\n+            client.set(key, value, ex=timeout)\n+\n+    def touch(self, key, timeout):\n+        client = self.get_client(key, write=True)\n+        if timeout is None:\n+            return bool(client.persist(key))\n+        else:\n+            return bool(client.expire(key, timeout))\n+\n+    def delete(self, key):\n+        client = self.get_client(key, write=True)\n+        return bool(client.delete(key))\n+\n+    def get_many(self, keys):\n+        client = self.get_client(None)\n+        ret = client.mget(keys)\n+        return {\n+            k: self._serializer.loads(v) for k, v in zip(keys, ret) if v is not None\n+        }\n+\n+    def has_key(self, key):\n+        client = self.get_client(key)\n+        return bool(client.exists(key))\n+\n+    def incr(self, key, delta):\n+        client = self.get_client(key)\n+        if not client.exists(key):\n+            raise ValueError(\"Key '%s' not found.\" % key)\n+        return client.incr(key, delta)\n+\n+    def set_many(self, data, timeout):\n+        client = self.get_client(None, write=True)\n+        pipeline = client.pipeline()\n+        pipeline.mset({k: self._serializer.dumps(v) for k, v in data.items()})\n+\n+        if timeout is not None:\n+            # Setting timeout for each key as redis does not support timeout\n+            # with mset().\n+            for key in data:\n+                pipeline.expire(key, timeout)\n+        pipeline.execute()\n+\n+    def delete_many(self, keys):\n+        client = self.get_client(None, write=True)\n+        client.delete(*keys)\n+\n+    def clear(self):\n+        client = self.get_client(None, write=True)\n+        return bool(client.flushdb())\n+\n+\n+class RedisCache(BaseCache):\n+    def __init__(self, server, params):\n+        super().__init__(params)\n+        if isinstance(server, str):\n+            self._servers = re.split('[;,]', server)\n+        else:\n+            self._servers = server\n+\n+        self._class = RedisCacheClient\n+        self._options = params.get('OPTIONS', {})\n+\n+    @cached_property\n+    def _cache(self):\n+        return self._class(self._servers, **self._options)\n+\n+    def get_backend_timeout(self, timeout=DEFAULT_TIMEOUT):\n+        if timeout == DEFAULT_TIMEOUT:\n+            timeout = self.default_timeout\n+        # The key will be made persistent if None used as a timeout.\n+        # Non-positive values will cause the key to be deleted.\n+        return None if timeout is None else max(0, int(timeout))\n+\n+    def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n+        key = self.make_and_validate_key(key, version=version)\n+        return self._cache.add(key, value, self.get_backend_timeout(timeout))\n+\n+    def get(self, key, default=None, version=None):\n+        key = self.make_and_validate_key(key, version=version)\n+        return self._cache.get(key, default)\n+\n+    def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n+        key = self.make_and_validate_key(key, version=version)\n+        self._cache.set(key, value, self.get_backend_timeout(timeout))\n+\n+    def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n+        key = self.make_and_validate_key(key, version=version)\n+        return self._cache.touch(key, self.get_backend_timeout(timeout))\n+\n+    def delete(self, key, version=None):\n+        key = self.make_and_validate_key(key, version=version)\n+        return self._cache.delete(key)\n+\n+    def get_many(self, keys, version=None):\n+        key_map = {self.make_and_validate_key(key, version=version): key for key in keys}\n+        ret = self._cache.get_many(key_map.keys())\n+        return {key_map[k]: v for k, v in ret.items()}\n+\n+    def has_key(self, key, version=None):\n+        key = self.make_and_validate_key(key, version=version)\n+        return self._cache.has_key(key)\n+\n+    def incr(self, key, delta=1, version=None):\n+        key = self.make_and_validate_key(key, version=version)\n+        return self._cache.incr(key, delta)\n+\n+    def set_many(self, data, timeout=DEFAULT_TIMEOUT, version=None):\n+        safe_data = {}\n+        for key, value in data.items():\n+            key = self.make_and_validate_key(key, version=version)\n+            safe_data[key] = value\n+        self._cache.set_many(safe_data, self.get_backend_timeout(timeout))\n+        return []\n+\n+    def delete_many(self, keys, version=None):\n+        safe_keys = []\n+        for key in keys:\n+            key = self.make_and_validate_key(key, version=version)\n+            safe_keys.append(key)\n+        self._cache.delete_many(safe_keys)\n+\n+    def clear(self):\n+        return self._cache.clear()\ndiff --git a/docs/topics/cache.txt b/docs/topics/cache.txt\nindex 0f25260672ce..3bc35fd51d06 100644\n--- a/docs/topics/cache.txt\n+++ b/docs/topics/cache.txt\n@@ -169,6 +168,71 @@ particularly temporary.\n     some problems and seems to be unmaintained. Use ``PyMemcacheCache`` or\n     ``PyLibMCCache`` instead.\n \n+.. _redis:\n+\n+Redis\n+-----\n+\n+.. versionadded:: 4.0\n+\n+Redis__ is an in-memory database that can be used for caching. To begin you'll\n+need a Redis server running either locally or on a remote machine.\n+\n+__ https://redis.io/\n+\n+After setting up the Redis server, you'll need to install Python bindings for\n+Redis. `redis-py`_ is the binding supported natively by Django. Installing the\n+additional `hiredis-py`_ package is also recommended.\n+\n+.. _`redis-py`: https://pypi.org/project/redis/\n+.. _`hiredis-py`: https://pypi.org/project/hiredis/\n+\n+To use Redis as your cache backend with Django:\n+\n+* Set :setting:`BACKEND <CACHES-BACKEND>` to\n+  ``django.core.cache.backends.redis.RedisCache``.\n+\n+* Set :setting:`LOCATION <CACHES-LOCATION>` to the URL pointing to your Redis\n+  instance, using the appropriate scheme. See the ``redis-py`` docs for\n+  `details on the available schemes\n+  <https://redis-py.readthedocs.io/en/stable/#redis.ConnectionPool.from_url>`_.\n+\n+For example, if Redis is running on localhost (127.0.0.1) port 6379::\n+\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.redis.RedisCache',\n+            'LOCATION': 'redis://127.0.0.1:6379',\n+        }\n+    }\n+\n+Often Redis servers are protected with authentication. In order to supply a\n+username and password, add them in the ``LOCATION`` along with the URL::\n+\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.redis.RedisCache',\n+            'LOCATION': 'redis://username:password@127.0.0.1:6379',\n+        }\n+    }\n+\n+If you have multiple Redis servers set up in the replication mode, you can\n+specify the servers either as a semicolon or comma delimited string, or as a\n+list. While using multiple servers, write operations are performed on the first\n+server (leader). Read operations are performed on the other servers (replicas)\n+chosen at random::\n+\n+    CACHES = {\n+        'default': {\n+            'BACKEND': 'django.core.cache.backends.redis.RedisCache',\n+            'LOCATION': [\n+                'redis://127.0.0.1:6379', # leader\n+                'redis://127.0.0.1:6378', # read-replica 1\n+                'redis://127.0.0.1:6377', # read-replica 2\n+            ],\n+        }\n+    }\n+\n .. _database-caching:\n \n Database caching\n\ndiff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 0e2f5f7d1f04..b88066285801 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1727,6 +1732,60 @@ def test_empty_cache_file_considered_expired(self):\n             self.assertIs(cache._is_expired(fh), True)\n \n \n+@unittest.skipUnless(RedisCache_params, \"Redis backend not configured\")\n+@override_settings(CACHES=caches_setting_for_tests(\n+    base=RedisCache_params,\n+    exclude=redis_excluded_caches,\n+))\n+class RedisCacheTests(BaseCacheTests, TestCase):\n+\n+    def setUp(self):\n+        import redis\n+        super().setUp()\n+        self.lib = redis\n+\n+    @property\n+    def incr_decr_type_error(self):\n+        return self.lib.ResponseError\n+\n+    def test_cache_client_class(self):\n+        self.assertIs(cache._class, RedisCacheClient)\n+        self.assertIsInstance(cache._cache, RedisCacheClient)\n+\n+    def test_get_backend_timeout_method(self):\n+        positive_timeout = 10\n+        positive_backend_timeout = cache.get_backend_timeout(positive_timeout)\n+        self.assertEqual(positive_backend_timeout, positive_timeout)\n+\n+        negative_timeout = -5\n+        negative_backend_timeout = cache.get_backend_timeout(negative_timeout)\n+        self.assertEqual(negative_backend_timeout, 0)\n+\n+        none_timeout = None\n+        none_backend_timeout = cache.get_backend_timeout(none_timeout)\n+        self.assertIsNone(none_backend_timeout)\n+\n+    def test_get_connection_pool_index(self):\n+        pool_index = cache._cache._get_connection_pool_index(write=True)\n+        self.assertEqual(pool_index, 0)\n+        pool_index = cache._cache._get_connection_pool_index(write=False)\n+        if len(cache._cache._servers) == 1:\n+            self.assertEqual(pool_index, 0)\n+        else:\n+            self.assertGreater(pool_index, 0)\n+            self.assertLess(pool_index, len(cache._cache._servers))\n+\n+    def test_get_connection_pool(self):\n+        pool = cache._cache._get_connection_pool(write=True)\n+        self.assertIsInstance(pool, self.lib.ConnectionPool)\n+\n+        pool = cache._cache._get_connection_pool(write=False)\n+        self.assertIsInstance(pool, self.lib.ConnectionPool)\n+\n+    def test_get_client(self):\n+        self.assertIsInstance(cache._cache.get_client(), self.lib.Redis)\n+\n+\n class FileBasedCachePathLibTests(FileBasedCacheTests):\n     def mkdtemp(self):\n         tmp_dir = super().mkdtemp()\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The failing test `test_createcachetable_observes_database_router` indicates a mismatch in expected vs. actual database queries during the cache table creation. This issue could stem from naming conflicts with `my_cache_table`, which aligns with existing test tables. Consider renaming to avoid conflicts, as you noted that changing the name resolved the issue. Regarding zero timeout handling for Redis, ensure proper checks in `get_backend_timeout`, as Redis-py doesn't support it. Refactoring the import of `redis` into the `__init__` method is also a solid approach to prevent import errors when the library isn't available."
      }
    ],
    "token_estimation": 3444.0
  },
  {
    "index": 18,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 1937ca16c7ce..49ca80192438 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1118,3 +1151,168 @@ def asc(self):\n \n     def desc(self):\n         self.descending = True\n+\n+\n+class Window(Expression):\n+    template = '%(expression)s OVER (%(window)s)'\n+    # Although the main expression may either be an aggregate or an\n+    # expression with an aggregate function, the GROUP BY that will\n+    # be introduced in the query as a result is not desired.\n+    contains_aggregate = False\n+    contains_over_clause = True\n+    filterable = False\n+\n+    def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):\n+        self.partition_by = partition_by\n+        self.order_by = order_by\n+        self.frame = frame\n+\n+        if not getattr(expression, 'window_compatible', False):\n+            raise ValueError(\n+                \"Expression '%s' isn't compatible with OVER clauses.\" %\n+                expression.__class__.__name__\n+            )\n+\n+        if self.partition_by is not None:\n+            if not isinstance(self.partition_by, (tuple, list)):\n+                self.partition_by = (self.partition_by,)\n+            self.partition_by = ExpressionList(*self.partition_by)\n+\n+        if self.order_by is not None:\n+            if isinstance(self.order_by, (list, tuple)):\n+                self.order_by = ExpressionList(*self.order_by)\n+            elif not isinstance(self.order_by, BaseExpression):\n+                raise ValueError(\n+                    'order_by must be either an Expression or a sequence of '\n+                    'expressions.'\n+                )\n+        super().__init__(output_field=output_field)\n+        self.source_expression = self._parse_expressions(expression)[0]\n+\n+    def _resolve_output_field(self):\n+        return self.source_expression.output_field\n+\n+    def get_source_expressions(self):\n+        return [self.source_expression, self.partition_by, self.order_by, self.frame]\n+\n+    def set_source_expressions(self, exprs):\n+        self.source_expression, self.partition_by, self.order_by, self.frame = exprs\n+\n+    def as_sql(self, compiler, connection, function=None, template=None):\n+        connection.ops.check_expression_support(self)\n+        expr_sql, params = compiler.compile(self.source_expression)\n+        window_sql, window_params = [], []\n+\n+        if self.partition_by is not None:\n+            sql_expr, sql_params = self.partition_by.as_sql(\n+                compiler=compiler, connection=connection,\n+                template='PARTITION BY %(expressions)s',\n+            )\n+            window_sql.extend(sql_expr)\n+            window_params.extend(sql_params)\n+\n+        if self.order_by is not None:\n+            window_sql.append(' ORDER BY ')\n+            order_sql, order_params = compiler.compile(self.order_by)\n+            window_sql.extend(''.join(order_sql))\n+            window_params.extend(order_params)\n+\n+        if self.frame:\n+            frame_sql, frame_params = compiler.compile(self.frame)\n+            window_sql.extend(' ' + frame_sql)\n+            window_params.extend(frame_params)\n+\n+        params.extend(window_params)\n+        template = template or self.template\n+\n+        return template % {\n+            'expression': expr_sql,\n+            'window': ''.join(window_sql).strip()\n+        }, params\n+\n+    def __str__(self):\n+        return '{} OVER ({}{}{})'.format(\n+            str(self.source_expression),\n+            'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',\n+            'ORDER BY ' + str(self.order_by) if self.order_by else '',\n+            str(self.frame or ''),\n+        )\n+\n+    def __repr__(self):\n+        return '<%s: %s>' % (self.__class__.__name__, self)\n+\n+    def get_group_by_cols(self):\n+        return []\n+\n+\n+class WindowFrame(Expression):\n+    \"\"\"\n+    Model the frame clause in window expressions. There are two types of frame\n+    clauses which are subclasses, however, all processing and validation (by no\n+    means intended to be complete) is done here. Thus, providing an end for a\n+    frame is optional (the default is UNBOUNDED FOLLOWING, which is the last\n+    row in the frame).\n+    \"\"\"\n+    template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'\n+\n+    def __init__(self, start=None, end=None):\n+        self.start = start\n+        self.end = end\n+\n+    def set_source_expressions(self, exprs):\n+        self.start, self.end = exprs\n+\n+    def get_source_expressions(self):\n+        return [Value(self.start), Value(self.end)]\n+\n+    def as_sql(self, compiler, connection):\n+        connection.ops.check_expression_support(self)\n+        start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)\n+        return self.template % {\n+            'frame_type': self.frame_type,\n+            'start': start,\n+            'end': end,\n+        }, []\n+\n+    def __repr__(self):\n+        return '<%s: %s>' % (self.__class__.__name__, self)\n+\n+    def get_group_by_cols(self):\n+        return []\n+\n+    def __str__(self):\n+        if self.start is not None and self.start < 0:\n+            start = '%d %s' % (abs(self.start), connection.ops.PRECEDING)\n+        elif self.start is not None and self.start == 0:\n+            start = connection.ops.CURRENT_ROW\n+        else:\n+            start = connection.ops.UNBOUNDED_PRECEDING\n+\n+        if self.end is not None and self.end > 0:\n+            end = '%d %s' % (self.end, connection.ops.FOLLOWING)\n+        elif self.end is not None and self.end == 0:\n+            end = connection.ops.CURRENT_ROW\n+        else:\n+            end = connection.ops.UNBOUNDED_FOLLOWING\n+        return self.template % {\n+            'frame_type': self.frame_type,\n+            'start': start,\n+            'end': end,\n+        }\n+\n+    def window_frame_start_end(self, connection, start, end):\n+        raise NotImplementedError('Subclasses must implement window_frame_start_end().')\n+\n+\n+class RowRange(WindowFrame):\n+    frame_type = 'ROWS'\n+\n+    def window_frame_start_end(self, connection, start, end):\n+        return connection.ops.window_frame_rows_start_end(start, end)\n+\n+\n+class ValueRange(WindowFrame):\n+    frame_type = 'RANGE'\n+\n+    def window_frame_start_end(self, connection, start, end):\n+        return connection.ops.window_frame_range_start_end(start, end)\ndiff --git a/django/db/models/functions/window.py b/django/db/models/functions/window.py\nnew file mode 100644\nindex 000000000000..3719dfca8863\n--- /dev/null\n+++ b/django/db/models/functions/window.py\n@@ -0,0 +1,118 @@\n+from django.db.models import FloatField, Func, IntegerField\n+\n+__all__ = [\n+    'CumeDist', 'DenseRank', 'FirstValue', 'Lag', 'LastValue', 'Lead',\n+    'NthValue', 'Ntile', 'PercentRank', 'Rank', 'RowNumber',\n+]\n+\n+\n+class CumeDist(Func):\n+    function = 'CUME_DIST'\n+    name = 'CumeDist'\n+    output_field = FloatField()\n+    window_compatible = True\n+\n+\n+class DenseRank(Func):\n+    function = 'DENSE_RANK'\n+    name = 'DenseRank'\n+    output_field = IntegerField()\n+    window_compatible = True\n+\n+\n+class FirstValue(Func):\n+    arity = 1\n+    function = 'FIRST_VALUE'\n+    name = 'FirstValue'\n+    window_compatible = True\n+\n+\n+class LagLeadFunction(Func):\n+    window_compatible = True\n+\n+    def __init__(self, expression, offset=1, default=None, **extra):\n+        if expression is None:\n+            raise ValueError(\n+                '%s requires a non-null source expression.' %\n+                self.__class__.__name__\n+            )\n+        if offset is None or offset <= 0:\n+            raise ValueError(\n+                '%s requires a positive integer for the offset.' %\n+                self.__class__.__name__\n+            )\n+        args = (expression, offset)\n+        if default is not None:\n+            args += (default,)\n+        super().__init__(*args, **extra)\n+\n+    def _resolve_output_field(self):\n+        sources = self.get_source_expressions()\n+        return sources[0].output_field\n+\n+\n+class Lag(LagLeadFunction):\n+    function = 'LAG'\n+    name = 'Lag'\n+\n+\n+class LastValue(Func):\n+    arity = 1\n+    function = 'LAST_VALUE'\n+    name = 'LastValue'\n+    window_compatible = True\n+\n+\n+class Lead(LagLeadFunction):\n+    function = 'LEAD'\n+    name = 'Lead'\n+\n+\n+class NthValue(Func):\n+    function = 'NTH_VALUE'\n+    name = 'NthValue'\n+    window_compatible = True\n+\n+    def __init__(self, expression, nth=1, **extra):\n+        if expression is None:\n+            raise ValueError('%s requires a non-null source expression.' % self.__class__.__name__)\n+        if nth is None or nth <= 0:\n+            raise ValueError('%s requires a positive integer as for nth.' % self.__class__.__name__)\n+        super().__init__(expression, nth, **extra)\n+\n+    def _resolve_output_field(self):\n+        sources = self.get_source_expressions()\n+        return sources[0].output_field\n+\n+\n+class Ntile(Func):\n+    function = 'NTILE'\n+    name = 'Ntile'\n+    output_field = IntegerField()\n+    window_compatible = True\n+\n+    def __init__(self, num_buckets=1, **extra):\n+        if num_buckets <= 0:\n+            raise ValueError('num_buckets must be greater than 0.')\n+        super().__init__(num_buckets, **extra)\n+\n+\n+class PercentRank(Func):\n+    function = 'PERCENT_RANK'\n+    name = 'PercentRank'\n+    output_field = FloatField()\n+    window_compatible = True\n+\n+\n+class Rank(Func):\n+    function = 'RANK'\n+    name = 'Rank'\n+    output_field = IntegerField()\n+    window_compatible = True\n+\n+\n+class RowNumber(Func):\n+    function = 'ROW_NUMBER'\n+    name = 'RowNumber'\n+    output_field = IntegerField()\n+    window_compatible = True\ndiff --git a/docs/ref/models/database-functions.txt b/docs/ref/models/database-functions.txt\nindex 875786c6402a..f5a9af3a059d 100644\n--- a/docs/ref/models/database-functions.txt\n+++ b/docs/ref/models/database-functions.txt\n@@ -819,3 +819,132 @@ Usage example::\n      'minute': 'minute': datetime.datetime(2014, 6, 15, 14, 30, tzinfo=<UTC>),\n      'second': datetime.datetime(2014, 6, 15, 14, 30, 50, tzinfo=<UTC>)\n     }\n+\n+.. _window-functions:\n+\n+Window functions\n+================\n+\n+.. versionadded:: 2.0\n+\n+There are a number of functions to use in a\n+:class:`~django.db.models.expressions.Window` expression for computing the rank\n+of elements or the :class:`Ntile` of some rows.\n+\n+``CumeDist``\n+------------\n+\n+.. class:: CumeDist(*expressions, **extra)\n+\n+Calculates the cumulative distribution of a value within a window or partition.\n+The cumulative distribution is defined as the number of rows preceding or\n+peered with the current row divided by the total number of rows in the frame.\n+\n+``DenseRank``\n+-------------\n+\n+.. class:: DenseRank(*expressions, **extra)\n+\n+Equivalent to :class:`Rank` but does not have gaps.\n+\n+``FirstValue``\n+--------------\n+\n+.. class:: FirstValue(expression, **extra)\n+\n+Returns the value evaluated at the row that's the first row of the window\n+frame, or ``None`` if no such value exists.\n+\n+``Lag``\n+-------\n+\n+.. class:: Lag(expression, offset=1, default=None, **extra)\n+\n+Calculates the value offset by ``offset``, and if no row exists there, returns\n+``default``.\n+\n+``default`` must have the same type as the ``expression``, however, this is\n+only validated by the database and not in Python.\n+\n+``LastValue``\n+-------------\n+\n+.. class:: LastValue(expression, **extra)\n+\n+Comparable to :class:`FirstValue`, it calculates the last value in a given\n+frame clause.\n+\n+``Lead``\n+--------\n+\n+.. class:: Lead(expression, offset=1, default=None, **extra)\n+\n+Calculates the leading value in a given :ref:`frame <window-frames>`. Both\n+``offset`` and ``default`` are evaluated with respect to the current row.\n+\n+``default`` must have the same type as the ``expression``, however, this is\n+only validated by the database and not in Python.\n+\n+``NthValue``\n+------------\n+\n+.. class:: NthValue(expression, nth=1, **extra)\n+\n+Computes the row relative to the offset ``nth`` (must be a positive value)\n+within the window. Returns ``None`` if no row exists.\n+\n+Some databases may handle a nonexistent nth-value differently. For example,\n+Oracle returns an empty string rather than ``None`` for character-based\n+expressions. Django doesn't do any conversions in these cases.\n+\n+``Ntile``\n+---------\n+\n+.. class:: Ntile(num_buckets=1, **extra)\n+\n+Calculates a partition for each of the rows in the frame clause, distributing\n+numbers as evenly as possible between 1 and ``num_buckets``. If the rows don't\n+divide evenly into a number of buckets, one or more buckets will be represented\n+more frequently.\n+\n+``PercentRank``\n+---------------\n+\n+.. class:: PercentRank(*expressions, **extra)\n+\n+Computes the percentile rank of the rows in the frame clause. This\n+computation is equivalent to evaluating::\n+\n+    (rank - 1) / (total rows - 1)\n+\n+The following table explains the calculation for the percentile rank of a row:\n+\n+===== ===== ==== ============ ============\n+Row # Value Rank Calculation  Percent Rank\n+===== ===== ==== ============ ============\n+1     15    1    (1-1)/(7-1)  0.0000\n+2     20    2    (2-1)/(7-1)  0.1666\n+3     20    2    (2-1)/(7-1)  0.1666\n+4     20    2    (2-1)/(7-1)  0.1666\n+5     30    5    (5-1)/(7-1)  0.6666\n+6     30    5    (5-1)/(7-1)  0.6666\n+7     40    7    (7-1)/(7-1)  1.0000\n+===== ===== ==== ============ ============\n+\n+``Rank``\n+--------\n+\n+.. class:: Rank(*expressions, **extra)\n+\n+Comparable to ``RowNumber``, this function ranks rows in the window. The\n+computed rank contains gaps. Use :class:`DenseRank` to compute rank without\n+gaps.\n+\n+``RowNumber``\n+-------------\n+\n+.. class:: RowNumber(*expressions, **extra)\n+\n+Computes the row number according to the ordering of either the frame clause\n+or the ordering of the whole query if there is no partitioning of the\n+:ref:`window frame <window-frames>`.\ndiff --git a/docs/ref/models/expressions.txt b/docs/ref/models/expressions.txt\nindex 0974a9dd5101..6ef1001a9ffb 100644\n--- a/docs/ref/models/expressions.txt\n+++ b/docs/ref/models/expressions.txt\n@@ -649,6 +656,184 @@ should avoid them if possible.\n     force you to acknowledge that you're not interpolating your SQL with user\n     provided data.\n \n+Window functions\n+----------------\n+\n+.. versionadded:: 2.0\n+\n+Window functions provide a way to apply functions on partitions. Unlike a\n+normal aggregation function which computes a final result for each set defined\n+by the group by, window functions operate on :ref:`frames <window-frames>` and\n+partitions, and compute the result for each row.\n+\n+You can specify multiple windows in the same query which in Django ORM would be\n+equivalent to including multiple expressions in a :doc:`QuerySet.annotate()\n+</topics/db/aggregation>` call. The ORM doesn't make use of named windows,\n+instead they are part of the selected columns.\n+\n+.. class:: Window(expression, partition_by=None, order_by=None, frame=None, output_field=None)\n+\n+    .. attribute:: filterable\n+\n+        Defaults to ``False``. The SQL standard disallows referencing window\n+        functions in the ``WHERE`` clause and Django raises an exception when\n+        constructing a ``QuerySet`` that would do that.\n+\n+    .. attribute:: template\n+\n+        Defaults to ``%(expression)s OVER (%(window)s)'``. If only the\n+        ``expression`` argument is provided, the window clause will be blank.\n+\n+The ``Window`` class is the main expression for an ``OVER`` clause.\n+\n+The ``expression`` argument is either a :ref:`window function\n+<window-functions>`, an :ref:`aggregate function <aggregation-functions>`, or\n+an expression that's compatible in a window clause.\n+\n+The ``partition_by`` argument is a list of expressions (column names should be\n+wrapped in an ``F``-object) that control the partitioning of the rows.\n+Partitioning narrows which rows are used to compute the result set.\n+\n+The ``output_field`` is specified either as an argument or by the expression.\n+\n+The ``order_by`` argument accepts a sequence of expressions on which you can\n+call :meth:`~django.db.models.Expression.asc` and\n+:meth:`~django.db.models.Expression.desc`. The ordering controls the order in\n+which the expression is applied. For example, if you sum over the rows in a\n+partition, the first result is just the value of the first row, the second is\n+the sum of first and second row.\n+\n+The ``frame`` parameter specifies which other rows that should be used in the\n+computation. See :ref:`window-frames` for details.\n+\n+For example, to annotate each movie with the average rating for the movies by\n+the same studio in the same genre and release year::\n+\n+    >>> from django.db.models import Avg, ExtractYear, F, Window\n+    >>> Movie.objects.annotate(\n+    >>>     avg_rating=Window(\n+    >>>         expression=Avg('rating'),\n+    >>>         partition_by=[F('studio'), F('genre')],\n+    >>>         order_by=ExtractYear('released').asc(),\n+    >>>     ),\n+    >>> )\n+\n+This makes it easy to check if a movie is rated better or worse than its peers.\n+\n+You may want to apply multiple expressions over the same window, i.e., the\n+same partition and frame. For example, you could modify the previous example\n+to also include the best and worst rating in each movie's group (same studio,\n+genre, and release year) by using three window functions in the same query. The\n+partition and ordering from the previous example is extracted into a dictionary\n+to reduce repetition::\n+\n+    >>> from django.db.models import Avg, ExtractYear, F, Max, Min, Window\n+    >>> window = {\n+    >>>    'partition': [F('studio'), F('genre')],\n+    >>>    'order_by': ExtractYear('released').asc(),\n+    >>> }\n+    >>> Movie.objects.annotate(\n+    >>>     avg_rating=Window(\n+    >>>         expression=Avg('rating'), **window,\n+    >>>     ),\n+    >>>     best=Window(\n+    >>>         expression=Max('rating'), **window,\n+    >>>     ),\n+    >>>     worst=Window(\n+    >>>         expression=Min('rating'), **window,\n+    >>>     ),\n+    >>> )\n+\n+Among Django's built-in database backends, MySQL 8.0.2+, PostgreSQL, and Oracle\n+support window expressions. Support for different window expression features\n+varies among the different databases. For example, the options in\n+:meth:`~django.db.models.Expression.asc` and\n+:meth:`~django.db.models.Expression.desc` may not be supported. Consult the\n+documentation for your database as needed.\n+\n+.. _window-frames:\n+\n+Frames\n+~~~~~~\n+\n+For a window frame, you can choose either a range-based sequence of rows or an\n+ordinary sequence of rows.\n+\n+.. class:: ValueRange(start=None, end=None)\n+\n+    .. attribute:: frame_type\n+\n+        This attribute is set to ``'RANGE'``.\n+\n+    PostgreSQL has limited support for ``ValueRange`` and only supports use of\n+    the standard start and end points, such as ``CURRENT ROW`` and ``UNBOUNDED\n+    FOLLOWING``.\n+\n+.. class:: RowRange(start=None, end=None)\n+\n+    .. attribute:: frame_type\n+\n+        This attribute is set to ``'ROWS'``.\n+\n+Both classes return SQL with the template::\n+\n+    %(frame_type)s BETWEEN %(start)s AND %(end)s\n+\n+Frames narrow the rows that are used for computing the result. They shift from\n+some start point to some specified end point. Frames can be used with and\n+without partitions, but it's often a good idea to specify an ordering of the\n+window to ensure a deterministic result. In a frame, a peer in a frame is a row\n+with an equivalent value, or all rows if an ordering clause isn't present.\n+\n+The default starting point for a frame is ``UNBOUNDED PRECEDING`` which is the\n+first row of the partition. The end point is always explicitly included in the\n+SQL generated by the ORM and is by default ``UNBOUNDED FOLLOWING``. The default\n+frame includes all rows from the partition to the last row in the set.\n+\n+The accepted values for the ``start`` and ``end`` arguments are ``None``, an\n+integer, or zero. A negative integer for ``start`` results in ``N preceding``,\n+while ``None`` yields ``UNBOUNDED PRECEDING``. For both ``start`` and ``end``,\n+zero will return ``CURRENT ROW``. Positive integers are accepted for ``end``.\n+\n+There's a difference in what ``CURRENT ROW`` includes. When specified in\n+``ROWS`` mode, the frame starts or ends with the current row. When specified in\n+``RANGE`` mode, the frame starts or ends at the first or last peer according to\n+the ordering clause. Thus, ``RANGE CURRENT ROW`` evaluates the expression for\n+rows which have the same value specified by the ordering. Because the template\n+includes both the ``start`` and ``end`` points, this may be expressed with::\n+\n+    ValueRange(start=0, end=0)\n+\n+If a movie's \"peers\" are described as movies released by the same studio in the\n+same genre in the same year, this ``RowRange`` example annotates each movie\n+with the average rating of a movie's two prior and two following peers::\n+\n+    >>> from django.db.models import Avg, ExtractYear, F, RowRange, Window\n+    >>> Movie.objects.annotate(\n+    >>>     avg_rating=Window(\n+    >>>         expression=Avg('rating'),\n+    >>>         partition_by=[F('studio'), F('genre')],\n+    >>>         order_by=ExtractYear('released').asc(),\n+    >>>         frame=RowRange(start=-2, end=2),\n+    >>>     ),\n+    >>> )\n+\n+If the database supports it, you can specify the start and end points based on\n+values of an expression in the partition. If the ``released`` field of the\n+``Movie`` model stores the release month of each movies, this ``ValueRange``\n+example annotates each movie with the average rating of a movie's peers\n+released between twelve months before and twelve months after the each movie.\n+\n+    >>> from django.db.models import Avg, ExpressionList, F, ValueRange, Window\n+    >>> Movie.objects.annotate(\n+    >>>     avg_rating=Window(\n+    >>>         expression=Avg('rating'),\n+    >>>         partition_by=[F('studio'), F('genre')],\n+    >>>         order_by=F('released').asc(),\n+    >>>         frame=ValueRange(start=-12, end=12),\n+    >>>     ),\n+    >>> )\n+\n .. currentmodule:: django.db.models\n \n Technical Information\n\ndiff --git a/tests/expressions_window/tests.py b/tests/expressions_window/tests.py\nnew file mode 100644\nindex 000000000000..e61516b4b647\n--- /dev/null\n+++ b/tests/expressions_window/tests.py\n@@ -0,0 +1,783 @@\n+import datetime\n+from unittest import skipIf, skipUnless\n+\n+from django.core.exceptions import FieldError\n+from django.db import NotSupportedError, connection\n+from django.db.models import (\n+    F, RowRange, Value, ValueRange, Window, WindowFrame,\n+)\n+from django.db.models.aggregates import Avg, Max, Min, Sum\n+from django.db.models.functions import (\n+    CumeDist, DenseRank, ExtractYear, FirstValue, Lag, LastValue, Lead,\n+    NthValue, Ntile, PercentRank, Rank, RowNumber, Upper,\n+)\n+from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n+\n+from .models import Employee\n+\n+\n+@skipUnlessDBFeature('supports_over_clause')\n+class WindowFunctionTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        Employee.objects.bulk_create([\n+            Employee(name=e[0], salary=e[1], department=e[2], hire_date=e[3])\n+            for e in [\n+                ('Jones', 45000, 'Accounting', datetime.datetime(2005, 11, 1)),\n+                ('Williams', 37000, 'Accounting', datetime.datetime(2009, 6, 1)),\n+                ('Jenson', 45000, 'Accounting', datetime.datetime(2008, 4, 1)),\n+                ('Adams', 50000, 'Accounting', datetime.datetime(2013, 7, 1)),\n+                ('Smith', 55000, 'Sales', datetime.datetime(2007, 6, 1)),\n+                ('Brown', 53000, 'Sales', datetime.datetime(2009, 9, 1)),\n+                ('Johnson', 40000, 'Marketing', datetime.datetime(2012, 3, 1)),\n+                ('Smith', 38000, 'Marketing', datetime.datetime(2009, 10, 1)),\n+                ('Wilkinson', 60000, 'IT', datetime.datetime(2011, 3, 1)),\n+                ('Moore', 34000, 'IT', datetime.datetime(2013, 8, 1)),\n+                ('Miller', 100000, 'Management', datetime.datetime(2005, 6, 1)),\n+                ('Johnson', 80000, 'Management', datetime.datetime(2005, 7, 1)),\n+            ]\n+        ])\n+\n+    def test_dense_rank(self):\n+        qs = Employee.objects.annotate(rank=Window(\n+            expression=DenseRank(),\n+            order_by=ExtractYear(F('hire_date')).asc(),\n+        ))\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 1),\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 1),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 1),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 2),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 3),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 4),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 4),\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 4),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 5),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 6),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 7),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 7),\n+        ], lambda entry: (entry.name, entry.salary, entry.department, entry.hire_date, entry.rank), ordered=False)\n+\n+    def test_department_salary(self):\n+        qs = Employee.objects.annotate(department_sum=Window(\n+            expression=Sum('salary'),\n+            partition_by=F('department'),\n+            order_by=[F('hire_date').asc()],\n+        )).order_by('department', 'department_sum')\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 'Accounting', 45000, 45000),\n+            ('Jenson', 'Accounting', 45000, 90000),\n+            ('Williams', 'Accounting', 37000, 127000),\n+            ('Adams', 'Accounting', 50000, 177000),\n+            ('Wilkinson', 'IT', 60000, 60000),\n+            ('Moore', 'IT', 34000, 94000),\n+            ('Miller', 'Management', 100000, 100000),\n+            ('Johnson', 'Management', 80000, 180000),\n+            ('Smith', 'Marketing', 38000, 38000),\n+            ('Johnson', 'Marketing', 40000, 78000),\n+            ('Smith', 'Sales', 55000, 55000),\n+            ('Brown', 'Sales', 53000, 108000),\n+        ], lambda entry: (entry.name, entry.department, entry.salary, entry.department_sum))\n+\n+    def test_rank(self):\n+        \"\"\"\n+        Rank the employees based on the year they're were hired. Since there\n+        are multiple employees hired in different years, this will contain\n+        gaps.\n+        \"\"\"\n+        qs = Employee.objects.annotate(rank=Window(\n+            expression=Rank(),\n+            order_by=ExtractYear(F('hire_date')).asc(),\n+        ))\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 1),\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 1),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 1),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 4),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 5),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 6),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 6),\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 6),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 9),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 10),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 11),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 11),\n+        ], lambda entry: (entry.name, entry.salary, entry.department, entry.hire_date, entry.rank), ordered=False)\n+\n+    def test_row_number(self):\n+        \"\"\"\n+        The row number window function computes the number based on the order\n+        in which the tuples were inserted. Depending on the backend,\n+\n+        Oracle requires an ordering-clause in the Window expression.\n+        \"\"\"\n+        qs = Employee.objects.annotate(row_number=Window(\n+            expression=RowNumber(),\n+            order_by=F('pk').asc(),\n+        )).order_by('pk')\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 'Accounting', 1),\n+            ('Williams', 'Accounting', 2),\n+            ('Jenson', 'Accounting', 3),\n+            ('Adams', 'Accounting', 4),\n+            ('Smith', 'Sales', 5),\n+            ('Brown', 'Sales', 6),\n+            ('Johnson', 'Marketing', 7),\n+            ('Smith', 'Marketing', 8),\n+            ('Wilkinson', 'IT', 9),\n+            ('Moore', 'IT', 10),\n+            ('Miller', 'Management', 11),\n+            ('Johnson', 'Management', 12),\n+        ], lambda entry: (entry.name, entry.department, entry.row_number))\n+\n+    @skipIf(connection.vendor == 'oracle', \"Oracle requires ORDER BY in row_number, ANSI:SQL doesn't\")\n+    def test_row_number_no_ordering(self):\n+        \"\"\"\n+        The row number window function computes the number based on the order\n+        in which the tuples were inserted.\n+        \"\"\"\n+        # Add a default ordering for consistent results across databases.\n+        qs = Employee.objects.annotate(row_number=Window(\n+            expression=RowNumber(),\n+        )).order_by('pk')\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 'Accounting', 1),\n+            ('Williams', 'Accounting', 2),\n+            ('Jenson', 'Accounting', 3),\n+            ('Adams', 'Accounting', 4),\n+            ('Smith', 'Sales', 5),\n+            ('Brown', 'Sales', 6),\n+            ('Johnson', 'Marketing', 7),\n+            ('Smith', 'Marketing', 8),\n+            ('Wilkinson', 'IT', 9),\n+            ('Moore', 'IT', 10),\n+            ('Miller', 'Management', 11),\n+            ('Johnson', 'Management', 12),\n+        ], lambda entry: (entry.name, entry.department, entry.row_number))\n+\n+    def test_avg_salary_department(self):\n+        qs = Employee.objects.annotate(avg_salary=Window(\n+            expression=Avg('salary'),\n+            order_by=F('department').asc(),\n+            partition_by='department',\n+        )).order_by('department', '-salary', 'name')\n+        self.assertQuerysetEqual(qs, [\n+            ('Adams', 50000, 'Accounting', 44250.00),\n+            ('Jenson', 45000, 'Accounting', 44250.00),\n+            ('Jones', 45000, 'Accounting', 44250.00),\n+            ('Williams', 37000, 'Accounting', 44250.00),\n+            ('Wilkinson', 60000, 'IT', 47000.00),\n+            ('Moore', 34000, 'IT', 47000.00),\n+            ('Miller', 100000, 'Management', 90000.00),\n+            ('Johnson', 80000, 'Management', 90000.00),\n+            ('Johnson', 40000, 'Marketing', 39000.00),\n+            ('Smith', 38000, 'Marketing', 39000.00),\n+            ('Smith', 55000, 'Sales', 54000.00),\n+            ('Brown', 53000, 'Sales', 54000.00),\n+        ], transform=lambda row: (row.name, row.salary, row.department, row.avg_salary))\n+\n+    def test_lag(self):\n+        \"\"\"\n+        Compute the difference between an employee's salary and the next\n+        highest salary in the employee's department. Return None if the\n+        employee has the lowest salary.\n+        \"\"\"\n+        qs = Employee.objects.annotate(lag=Window(\n+            expression=Lag(expression='salary', offset=1),\n+            partition_by=F('department'),\n+            order_by=[F('salary').asc(), F('name').asc()],\n+        )).order_by('department')\n+        self.assertQuerysetEqual(qs, [\n+            ('Williams', 37000, 'Accounting', None),\n+            ('Jenson', 45000, 'Accounting', 37000),\n+            ('Jones', 45000, 'Accounting', 45000),\n+            ('Adams', 50000, 'Accounting', 45000),\n+            ('Moore', 34000, 'IT', None),\n+            ('Wilkinson', 60000, 'IT', 34000),\n+            ('Johnson', 80000, 'Management', None),\n+            ('Miller', 100000, 'Management', 80000),\n+            ('Smith', 38000, 'Marketing', None),\n+            ('Johnson', 40000, 'Marketing', 38000),\n+            ('Brown', 53000, 'Sales', None),\n+            ('Smith', 55000, 'Sales', 53000),\n+        ], transform=lambda row: (row.name, row.salary, row.department, row.lag))\n+\n+    def test_first_value(self):\n+        qs = Employee.objects.annotate(first_value=Window(\n+            expression=FirstValue('salary'),\n+            partition_by=F('department'),\n+            order_by=F('hire_date').asc(),\n+        )).order_by('department', 'hire_date')\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 45000),\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 45000),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 45000),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 60000),\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 100000),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 38000),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 55000),\n+        ], lambda row: (row.name, row.salary, row.department, row.hire_date, row.first_value))\n+\n+    def test_last_value(self):\n+        qs = Employee.objects.annotate(last_value=Window(\n+            expression=LastValue('hire_date'),\n+            partition_by=F('department'),\n+            order_by=F('hire_date').asc(),\n+        ))\n+        self.assertQuerysetEqual(qs, [\n+            ('Adams', 'Accounting', datetime.date(2013, 7, 1), 50000, datetime.date(2013, 7, 1)),\n+            ('Jenson', 'Accounting', datetime.date(2008, 4, 1), 45000, datetime.date(2008, 4, 1)),\n+            ('Jones', 'Accounting', datetime.date(2005, 11, 1), 45000, datetime.date(2005, 11, 1)),\n+            ('Williams', 'Accounting', datetime.date(2009, 6, 1), 37000, datetime.date(2009, 6, 1)),\n+            ('Moore', 'IT', datetime.date(2013, 8, 1), 34000, datetime.date(2013, 8, 1)),\n+            ('Wilkinson', 'IT', datetime.date(2011, 3, 1), 60000, datetime.date(2011, 3, 1)),\n+            ('Miller', 'Management', datetime.date(2005, 6, 1), 100000, datetime.date(2005, 6, 1)),\n+            ('Johnson', 'Management', datetime.date(2005, 7, 1), 80000, datetime.date(2005, 7, 1)),\n+            ('Johnson', 'Marketing', datetime.date(2012, 3, 1), 40000, datetime.date(2012, 3, 1)),\n+            ('Smith', 'Marketing', datetime.date(2009, 10, 1), 38000, datetime.date(2009, 10, 1)),\n+            ('Brown', 'Sales', datetime.date(2009, 9, 1), 53000, datetime.date(2009, 9, 1)),\n+            ('Smith', 'Sales', datetime.date(2007, 6, 1), 55000, datetime.date(2007, 6, 1)),\n+        ], transform=lambda row: (row.name, row.department, row.hire_date, row.salary, row.last_value), ordered=False)\n+\n+    def test_function_list_of_values(self):\n+        qs = Employee.objects.annotate(lead=Window(\n+            expression=Lead(expression='salary'),\n+            order_by=[F('hire_date').asc(), F('name').desc()],\n+            partition_by='department',\n+        )).values_list('name', 'salary', 'department', 'hire_date', 'lead')\n+        self.assertNotIn('GROUP BY', str(qs.query))\n+        self.assertSequenceEqual(qs, [\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 37000),\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 50000),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 34000),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 80000),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 40000),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 53000),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),\n+        ])\n+\n+    def test_min_department(self):\n+        \"\"\"An alternative way to specify a query for FirstValue.\"\"\"\n+        qs = Employee.objects.annotate(min_salary=Window(\n+            expression=Min('salary'),\n+            partition_by=F('department'),\n+            order_by=[F('salary').asc(), F('name').asc()]\n+        )).order_by('department', 'salary', 'name')\n+        self.assertQuerysetEqual(qs, [\n+            ('Williams', 'Accounting', 37000, 37000),\n+            ('Jenson', 'Accounting', 45000, 37000),\n+            ('Jones', 'Accounting', 45000, 37000),\n+            ('Adams', 'Accounting', 50000, 37000),\n+            ('Moore', 'IT', 34000, 34000),\n+            ('Wilkinson', 'IT', 60000, 34000),\n+            ('Johnson', 'Management', 80000, 80000),\n+            ('Miller', 'Management', 100000, 80000),\n+            ('Smith', 'Marketing', 38000, 38000),\n+            ('Johnson', 'Marketing', 40000, 38000),\n+            ('Brown', 'Sales', 53000, 53000),\n+            ('Smith', 'Sales', 55000, 53000),\n+        ], lambda row: (row.name, row.department, row.salary, row.min_salary))\n+\n+    def test_max_per_year(self):\n+        \"\"\"\n+        Find the maximum salary awarded in the same year as the\n+        employee was hired, regardless of the department.\n+        \"\"\"\n+        qs = Employee.objects.annotate(max_salary_year=Window(\n+            expression=Max('salary'),\n+            order_by=ExtractYear('hire_date').asc(),\n+            partition_by=ExtractYear('hire_date')\n+        )).order_by(ExtractYear('hire_date'), 'salary')\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 'Accounting', 45000, 2005, 100000),\n+            ('Johnson', 'Management', 80000, 2005, 100000),\n+            ('Miller', 'Management', 100000, 2005, 100000),\n+            ('Smith', 'Sales', 55000, 2007, 55000),\n+            ('Jenson', 'Accounting', 45000, 2008, 45000),\n+            ('Williams', 'Accounting', 37000, 2009, 53000),\n+            ('Smith', 'Marketing', 38000, 2009, 53000),\n+            ('Brown', 'Sales', 53000, 2009, 53000),\n+            ('Wilkinson', 'IT', 60000, 2011, 60000),\n+            ('Johnson', 'Marketing', 40000, 2012, 40000),\n+            ('Moore', 'IT', 34000, 2013, 50000),\n+            ('Adams', 'Accounting', 50000, 2013, 50000),\n+        ], lambda row: (row.name, row.department, row.salary, row.hire_date.year, row.max_salary_year))\n+\n+    def test_cume_dist(self):\n+        \"\"\"\n+        Compute the cumulative distribution for the employees based on the\n+        salary in increasing order. Equal to rank/total number of rows (12).\n+        \"\"\"\n+        qs = Employee.objects.annotate(cume_dist=Window(\n+            expression=CumeDist(),\n+            order_by=F('salary').asc(),\n+        )).order_by('salary', 'name')\n+        # Round result of cume_dist because Oracle uses greater precision.\n+        self.assertQuerysetEqual(qs, [\n+            ('Moore', 'IT', 34000, 0.0833333333),\n+            ('Williams', 'Accounting', 37000, 0.1666666667),\n+            ('Smith', 'Marketing', 38000, 0.25),\n+            ('Johnson', 'Marketing', 40000, 0.3333333333),\n+            ('Jenson', 'Accounting', 45000, 0.5),\n+            ('Jones', 'Accounting', 45000, 0.5),\n+            ('Adams', 'Accounting', 50000, 0.5833333333),\n+            ('Brown', 'Sales', 53000, 0.6666666667),\n+            ('Smith', 'Sales', 55000, 0.75),\n+            ('Wilkinson', 'IT', 60000, 0.8333333333),\n+            ('Johnson', 'Management', 80000, 0.9166666667),\n+            ('Miller', 'Management', 100000, 1),\n+        ], lambda row: (row.name, row.department, row.salary, round(row.cume_dist, 10)))\n+\n+    def test_nthvalue(self):\n+        qs = Employee.objects.annotate(\n+            nth_value=Window(expression=NthValue(\n+                expression='salary', nth=2),\n+                order_by=[F('hire_date').asc(), F('name').desc()],\n+                partition_by=F('department'),\n+            )\n+        ).order_by('department', 'hire_date', 'name')\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 'Accounting', datetime.date(2005, 11, 1), 45000, None),\n+            ('Jenson', 'Accounting', datetime.date(2008, 4, 1), 45000, 45000),\n+            ('Williams', 'Accounting', datetime.date(2009, 6, 1), 37000, 45000),\n+            ('Adams', 'Accounting', datetime.date(2013, 7, 1), 50000, 45000),\n+            ('Wilkinson', 'IT', datetime.date(2011, 3, 1), 60000, None),\n+            ('Moore', 'IT', datetime.date(2013, 8, 1), 34000, 34000),\n+            ('Miller', 'Management', datetime.date(2005, 6, 1), 100000, None),\n+            ('Johnson', 'Management', datetime.date(2005, 7, 1), 80000, 80000),\n+            ('Smith', 'Marketing', datetime.date(2009, 10, 1), 38000, None),\n+            ('Johnson', 'Marketing', datetime.date(2012, 3, 1), 40000, 40000),\n+            ('Smith', 'Sales', datetime.date(2007, 6, 1), 55000, None),\n+            ('Brown', 'Sales', datetime.date(2009, 9, 1), 53000, 53000),\n+        ], lambda row: (row.name, row.department, row.hire_date, row.salary, row.nth_value))\n+\n+    def test_lead(self):\n+        \"\"\"\n+        Determine what the next person hired in the same department makes.\n+        Because the dataset is ambiguous, the name is also part of the\n+        ordering clause. No default is provided, so None/NULL should be\n+        returned.\n+        \"\"\"\n+        qs = Employee.objects.annotate(lead=Window(\n+            expression=Lead(expression='salary'),\n+            order_by=[F('hire_date').asc(), F('name').desc()],\n+            partition_by='department',\n+        )).order_by('department')\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 37000),\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 50000),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 34000),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 80000),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 40000),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 53000),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),\n+        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.lead))\n+\n+    def test_lead_offset(self):\n+        \"\"\"\n+        Determine what the person hired after someone makes. Due to\n+        ambiguity, the name is also included in the ordering.\n+        \"\"\"\n+        qs = Employee.objects.annotate(lead=Window(\n+            expression=Lead('salary', offset=2),\n+            partition_by='department',\n+            order_by=F('hire_date').asc(),\n+        ))\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 37000),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 50000),\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), None),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), None),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), None),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), None),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), None),\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), None),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), None),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), None),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), None),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), None),\n+        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.lead),\n+            ordered=False\n+        )\n+\n+    def test_lead_default(self):\n+        qs = Employee.objects.annotate(lead_default=Window(\n+            expression=Lead(expression='salary', offset=5, default=60000),\n+            partition_by=F('department'),\n+            order_by=F('department').asc(),\n+        ))\n+        self.assertEqual(list(qs.values_list('lead_default', flat=True).distinct()), [60000])\n+\n+    def test_ntile(self):\n+        \"\"\"\n+        Compute the group for each of the employees across the entire company,\n+        based on how high the salary is for them. There are twelve employees\n+        so it divides evenly into four groups.\n+        \"\"\"\n+        qs = Employee.objects.annotate(ntile=Window(\n+            expression=Ntile(num_buckets=4),\n+            order_by=F('salary').desc(),\n+        )).order_by('ntile', '-salary', 'name')\n+        self.assertQuerysetEqual(qs, [\n+            ('Miller', 'Management', 100000, 1),\n+            ('Johnson', 'Management', 80000, 1),\n+            ('Wilkinson', 'IT', 60000, 1),\n+            ('Smith', 'Sales', 55000, 2),\n+            ('Brown', 'Sales', 53000, 2),\n+            ('Adams', 'Accounting', 50000, 2),\n+            ('Jenson', 'Accounting', 45000, 3),\n+            ('Jones', 'Accounting', 45000, 3),\n+            ('Johnson', 'Marketing', 40000, 3),\n+            ('Smith', 'Marketing', 38000, 4),\n+            ('Williams', 'Accounting', 37000, 4),\n+            ('Moore', 'IT', 34000, 4),\n+        ], lambda x: (x.name, x.department, x.salary, x.ntile))\n+\n+    def test_percent_rank(self):\n+        \"\"\"\n+        Calculate the percentage rank of the employees across the entire\n+        company based on salary and name (in case of ambiguity).\n+        \"\"\"\n+        qs = Employee.objects.annotate(percent_rank=Window(\n+            expression=PercentRank(),\n+            order_by=[F('salary').asc(), F('name').asc()],\n+        )).order_by('percent_rank')\n+        # Round to account for precision differences among databases.\n+        self.assertQuerysetEqual(qs, [\n+            ('Moore', 'IT', 34000, 0.0),\n+            ('Williams', 'Accounting', 37000, 0.0909090909),\n+            ('Smith', 'Marketing', 38000, 0.1818181818),\n+            ('Johnson', 'Marketing', 40000, 0.2727272727),\n+            ('Jenson', 'Accounting', 45000, 0.3636363636),\n+            ('Jones', 'Accounting', 45000, 0.4545454545),\n+            ('Adams', 'Accounting', 50000, 0.5454545455),\n+            ('Brown', 'Sales', 53000, 0.6363636364),\n+            ('Smith', 'Sales', 55000, 0.7272727273),\n+            ('Wilkinson', 'IT', 60000, 0.8181818182),\n+            ('Johnson', 'Management', 80000, 0.9090909091),\n+            ('Miller', 'Management', 100000, 1.0),\n+        ], transform=lambda row: (row.name, row.department, row.salary, round(row.percent_rank, 10)))\n+\n+    def test_nth_returns_null(self):\n+        \"\"\"\n+        Find the nth row of the data set. None is returned since there are\n+        fewer than 20 rows in the test data.\n+        \"\"\"\n+        qs = Employee.objects.annotate(nth_value=Window(\n+            expression=NthValue('salary', nth=20),\n+            order_by=F('salary').asc()\n+        ))\n+        self.assertEqual(list(qs.values_list('nth_value', flat=True).distinct()), [None])\n+\n+    def test_multiple_partitioning(self):\n+        \"\"\"\n+        Find the maximum salary for each department for people hired in the\n+        same year.\n+        \"\"\"\n+        qs = Employee.objects.annotate(max=Window(\n+            expression=Max('salary'),\n+            partition_by=[F('department'), ExtractYear(F('hire_date'))],\n+        )).order_by('department', 'hire_date', 'name')\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 45000),\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 37000),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 50000),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 34000),\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 100000),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 40000),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 53000),\n+        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.max))\n+\n+    def test_multiple_ordering(self):\n+        \"\"\"\n+        Accumulate the salaries over the departments based on hire_date.\n+        If two people were hired on the same date in the same department, the\n+        ordering clause will render a different result for those people.\n+        \"\"\"\n+        qs = Employee.objects.annotate(sum=Window(\n+            expression=Sum('salary'),\n+            partition_by='department',\n+            order_by=[F('hire_date').asc(), F('name').asc()],\n+        )).order_by('department', 'sum')\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 45000),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 90000),\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 127000),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 177000),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 94000),\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 180000),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 78000),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 108000),\n+        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.sum))\n+\n+    @skipIf(connection.vendor == 'postgresql', 'n following/preceding not supported by PostgreSQL')\n+    def test_range_n_preceding_and_following(self):\n+        qs = Employee.objects.annotate(sum=Window(\n+            expression=Sum('salary'),\n+            order_by=F('salary').asc(),\n+            partition_by='department',\n+            frame=ValueRange(start=-2, end=2),\n+        ))\n+        self.assertIn('RANGE BETWEEN 2 PRECEDING AND 2 FOLLOWING', str(qs.query))\n+        self.assertQuerysetEqual(qs, [\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 37000),\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 90000),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 90000),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 50000),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 53000),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 55000),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 40000),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 38000),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 60000),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 34000),\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 100000),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 80000),\n+        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.sum), ordered=False)\n+\n+    def test_range_unbound(self):\n+        \"\"\"A query with RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING.\"\"\"\n+        qs = Employee.objects.annotate(sum=Window(\n+            expression=Sum('salary'),\n+            partition_by='department',\n+            order_by=[F('hire_date').asc(), F('name').asc()],\n+            frame=ValueRange(start=None, end=None),\n+        )).order_by('department', 'hire_date', 'name')\n+        self.assertIn('RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING', str(qs.query))\n+        self.assertQuerysetEqual(qs, [\n+            ('Jones', 'Accounting', 45000, datetime.date(2005, 11, 1), 177000),\n+            ('Jenson', 'Accounting', 45000, datetime.date(2008, 4, 1), 177000),\n+            ('Williams', 'Accounting', 37000, datetime.date(2009, 6, 1), 177000),\n+            ('Adams', 'Accounting', 50000, datetime.date(2013, 7, 1), 177000),\n+            ('Wilkinson', 'IT', 60000, datetime.date(2011, 3, 1), 94000),\n+            ('Moore', 'IT', 34000, datetime.date(2013, 8, 1), 94000),\n+            ('Miller', 'Management', 100000, datetime.date(2005, 6, 1), 180000),\n+            ('Johnson', 'Management', 80000, datetime.date(2005, 7, 1), 180000),\n+            ('Smith', 'Marketing', 38000, datetime.date(2009, 10, 1), 78000),\n+            ('Johnson', 'Marketing', 40000, datetime.date(2012, 3, 1), 78000),\n+            ('Smith', 'Sales', 55000, datetime.date(2007, 6, 1), 108000),\n+            ('Brown', 'Sales', 53000, datetime.date(2009, 9, 1), 108000),\n+        ], transform=lambda row: (row.name, row.department, row.salary, row.hire_date, row.sum))\n+\n+    def test_row_range_rank(self):\n+        \"\"\"\n+        A query with ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING.\n+        The resulting sum is the sum of the three next (if they exist) and all\n+        previous rows according to the ordering clause.\n+        \"\"\"\n+        qs = Employee.objects.annotate(sum=Window(\n+            expression=Sum('salary'),\n+            order_by=[F('hire_date').asc(), F('name').desc()],\n+            frame=RowRange(start=None, end=3),\n+        )).order_by('sum', 'hire_date')\n+        self.assertIn('ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING', str(qs.query))\n+        self.assertQuerysetEqual(qs, [\n+            ('Miller', 100000, 'Management', datetime.date(2005, 6, 1), 280000),\n+            ('Johnson', 80000, 'Management', datetime.date(2005, 7, 1), 325000),\n+            ('Jones', 45000, 'Accounting', datetime.date(2005, 11, 1), 362000),\n+            ('Smith', 55000, 'Sales', datetime.date(2007, 6, 1), 415000),\n+            ('Jenson', 45000, 'Accounting', datetime.date(2008, 4, 1), 453000),\n+            ('Williams', 37000, 'Accounting', datetime.date(2009, 6, 1), 513000),\n+            ('Brown', 53000, 'Sales', datetime.date(2009, 9, 1), 553000),\n+            ('Smith', 38000, 'Marketing', datetime.date(2009, 10, 1), 603000),\n+            ('Wilkinson', 60000, 'IT', datetime.date(2011, 3, 1), 637000),\n+            ('Johnson', 40000, 'Marketing', datetime.date(2012, 3, 1), 637000),\n+            ('Adams', 50000, 'Accounting', datetime.date(2013, 7, 1), 637000),\n+            ('Moore', 34000, 'IT', datetime.date(2013, 8, 1), 637000),\n+        ], transform=lambda row: (row.name, row.salary, row.department, row.hire_date, row.sum))\n+\n+    @skipUnlessDBFeature('can_distinct_on_fields')\n+    def test_distinct_window_function(self):\n+        \"\"\"\n+        Window functions are not aggregates, and hence a query to filter out\n+        duplicates may be useful.\n+        \"\"\"\n+        qs = Employee.objects.annotate(\n+            sum=Window(\n+                expression=Sum('salary'),\n+                partition_by=ExtractYear('hire_date'),\n+                order_by=ExtractYear('hire_date')\n+            ),\n+            year=ExtractYear('hire_date'),\n+        ).values('year', 'sum').distinct('year').order_by('year')\n+        results = [\n+            {'year': 2005, 'sum': 225000}, {'year': 2007, 'sum': 55000},\n+            {'year': 2008, 'sum': 45000}, {'year': 2009, 'sum': 128000},\n+            {'year': 2011, 'sum': 60000}, {'year': 2012, 'sum': 40000},\n+            {'year': 2013, 'sum': 84000},\n+        ]\n+        for idx, val in zip(range(len(results)), results):\n+            with self.subTest(result=val):\n+                self.assertEqual(qs[idx], val)\n+\n+    def test_fail_update(self):\n+        \"\"\"Window expressions can't be used in an UPDATE statement.\"\"\"\n+        msg = 'Window expressions are not allowed in this query'\n+        with self.assertRaisesMessage(FieldError, msg):\n+            Employee.objects.filter(department='Management').update(\n+                salary=Window(expression=Max('salary'), partition_by='department'),\n+            )\n+\n+    def test_fail_insert(self):\n+        \"\"\"Window expressions can't be used in an INSERT statement.\"\"\"\n+        msg = 'Window expressions are not allowed in this query'\n+        with self.assertRaisesMessage(FieldError, msg):\n+            Employee.objects.create(\n+                name='Jameson', department='Management', hire_date=datetime.date(2007, 7, 1),\n+                salary=Window(expression=Sum(Value(10000), order_by=F('pk').asc())),\n+            )\n+\n+    def test_invalid_start_value_range(self):\n+        msg = \"start argument must be a negative integer, zero, or None, but got '3'.\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(Employee.objects.annotate(test=Window(\n+                expression=Sum('salary'),\n+                order_by=F('hire_date').asc(),\n+                frame=ValueRange(start=3),\n+            )))\n+\n+    def test_invalid_end_value_range(self):\n+        msg = \"end argument must be a positive integer, zero, or None, but got '-3'.\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(Employee.objects.annotate(test=Window(\n+                expression=Sum('salary'),\n+                order_by=F('hire_date').asc(),\n+                frame=ValueRange(end=-3),\n+            )))\n+\n+    def test_invalid_type_end_value_range(self):\n+        msg = \"end argument must be a positive integer, zero, or None, but got 'a'.\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(Employee.objects.annotate(test=Window(\n+                expression=Sum('salary'),\n+                order_by=F('hire_date').asc(),\n+                frame=ValueRange(end='a'),\n+            )))\n+\n+    def test_invalid_type_start_value_range(self):\n+        msg = \"start argument must be a negative integer, zero, or None, but got 'a'.\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(Employee.objects.annotate(test=Window(\n+                expression=Sum('salary'),\n+                frame=ValueRange(start='a'),\n+            )))\n+\n+    def test_invalid_type_end_row_range(self):\n+        msg = \"end argument must be a positive integer, zero, or None, but got 'a'.\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(Employee.objects.annotate(test=Window(\n+                expression=Sum('salary'),\n+                frame=RowRange(end='a'),\n+            )))\n+\n+    @skipUnless(connection.vendor == 'postgresql', 'Frame construction not allowed on PostgreSQL')\n+    def test_postgresql_illegal_range_frame_start(self):\n+        msg = 'PostgreSQL only supports UNBOUNDED together with PRECEDING and FOLLOWING.'\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            list(Employee.objects.annotate(test=Window(\n+                expression=Sum('salary'),\n+                order_by=F('hire_date').asc(),\n+                frame=ValueRange(start=-1),\n+            )))\n+\n+    @skipUnless(connection.vendor == 'postgresql', 'Frame construction not allowed on PostgreSQL')\n+    def test_postgresql_illegal_range_frame_end(self):\n+        msg = 'PostgreSQL only supports UNBOUNDED together with PRECEDING and FOLLOWING.'\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            list(Employee.objects.annotate(test=Window(\n+                expression=Sum('salary'),\n+                order_by=F('hire_date').asc(),\n+                frame=ValueRange(end=1),\n+            )))\n+\n+    def test_invalid_type_start_row_range(self):\n+        msg = \"start argument must be a negative integer, zero, or None, but got 'a'.\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(Employee.objects.annotate(test=Window(\n+                expression=Sum('salary'),\n+                order_by=F('hire_date').asc(),\n+                frame=RowRange(start='a'),\n+            )))\n+\n+\n+class NonQueryWindowTests(SimpleTestCase):\n+    def test_window_repr(self):\n+        self.assertEqual(\n+            repr(Window(expression=Sum('salary'), partition_by='department')),\n+            '<Window: Sum(F(salary)) OVER (PARTITION BY F(department))>'\n+        )\n+        self.assertEqual(\n+            repr(Window(expression=Avg('salary'), order_by=F('department').asc())),\n+            '<Window: Avg(F(salary)) OVER (ORDER BY OrderBy(F(department), descending=False))>'\n+        )\n+\n+    def test_window_frame_repr(self):\n+        self.assertEqual(\n+            repr(RowRange(start=-1)),\n+            '<RowRange: ROWS BETWEEN 1 PRECEDING AND UNBOUNDED FOLLOWING>'\n+        )\n+        self.assertEqual(\n+            repr(ValueRange(start=None, end=1)),\n+            '<ValueRange: RANGE BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING>'\n+        )\n+        self.assertEqual(\n+            repr(ValueRange(start=0, end=0)),\n+            '<ValueRange: RANGE BETWEEN CURRENT ROW AND CURRENT ROW>'\n+        )\n+        self.assertEqual(\n+            repr(RowRange(start=0, end=0)),\n+            '<RowRange: ROWS BETWEEN CURRENT ROW AND CURRENT ROW>'\n+        )\n+\n+    def test_empty_group_by_cols(self):\n+        window = Window(expression=Sum('pk'))\n+        self.assertEqual(window.get_group_by_cols(), [])\n+        self.assertFalse(window.contains_aggregate)\n+\n+    def test_frame_empty_group_by_cols(self):\n+        frame = WindowFrame()\n+        self.assertEqual(frame.get_group_by_cols(), [])\n+\n+    def test_frame_window_frame_notimplemented(self):\n+        frame = WindowFrame()\n+        msg = 'Subclasses must implement window_frame_start_end().'\n+        with self.assertRaisesMessage(NotImplementedError, msg):\n+            frame.window_frame_start_end(None, None, None)\n+\n+    def test_invalid_filter(self):\n+        msg = 'Window is disallowed in the filter clause'\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Employee.objects.annotate(dense_rank=Window(expression=DenseRank())).filter(dense_rank__gte=1)\n+\n+    def test_invalid_order_by(self):\n+        msg = 'order_by must be either an Expression or a sequence of expressions'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Window(expression=Sum('power'), order_by='-horse')\n+\n+    def test_invalid_source_expression(self):\n+        msg = \"Expression 'Upper' isn't compatible with OVER clauses.\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Window(expression=Upper('name'))\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Great work on this PR! However, consider disallowing filtering by annotated window expressions to prevent exceptions. Additionally, the `GROUP BY` issue needs addressing to prevent unintended additions to the query. Aggregates shouldn't inherit from `WindowFunc`; instead, integrate the `window_compatible` property into the base aggregate type. Minimal changes to documentation around this are essential. Lastly, it’d be beneficial to enhance test coverage with diverse sample data to fully illustrate concepts, while ensuring redundancy in tests is minimized."
      }
    ],
    "token_estimation": 16049.5
  },
  {
    "index": 19,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex d2f9be75f7d9..82ddb1754323 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2349,6 +2357,58 @@ def test_alter_db_table_with_model_change(self):\n             changes, \"testapp\", 0, 1, name=\"newauthor\", table=\"author_three\"\n         )\n \n+    def test_alter_db_table_comment_add(self):\n+        changes = self.get_changes(\n+            [self.author_empty], [self.author_with_db_table_comment]\n+        )\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelTableComment\"])\n+        self.assertOperationAttributes(\n+            changes, \"testapp\", 0, 0, name=\"author\", table_comment=\"Table comment\"\n+        )\n+\n+    def test_alter_db_table_comment_change(self):\n+        author_with_new_db_table_comment = ModelState(\n+            \"testapp\",\n+            \"Author\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+            ],\n+            {\"db_table_comment\": \"New table comment\"},\n+        )\n+        changes = self.get_changes(\n+            [self.author_with_db_table_comment],\n+            [author_with_new_db_table_comment],\n+        )\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelTableComment\"])\n+        self.assertOperationAttributes(\n+            changes,\n+            \"testapp\",\n+            0,\n+            0,\n+            name=\"author\",\n+            table_comment=\"New table comment\",\n+        )\n+\n+    def test_alter_db_table_comment_remove(self):\n+        changes = self.get_changes(\n+            [self.author_with_db_table_comment],\n+            [self.author_empty],\n+        )\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelTableComment\"])\n+        self.assertOperationAttributes(\n+            changes, \"testapp\", 0, 0, name=\"author\", db_table_comment=None\n+        )\n+\n+    def test_alter_db_table_comment_no_changes(self):\n+        changes = self.get_changes(\n+            [self.author_with_db_table_comment],\n+            [self.author_with_db_table_comment],\n+        )\n+        self.assertNumberMigrations(changes, \"testapp\", 0)\n+\n     def test_identical_regex_doesnt_alter(self):\n         from_state = ModelState(\n             \"testapp\",\ndiff --git a/tests/schema/tests.py b/tests/schema/tests.py\nindex 9b2b512c1b1f..e325fa0c8846 100644\n--- a/tests/schema/tests.py\n+++ b/tests/schema/tests.py\n@@ -4390,6 +4411,186 @@ def test_add_unique_charfield(self):\n             ],\n         )\n \n+    @skipUnlessDBFeature(\"supports_comments\")\n+    def test_add_db_comment_charfield(self):\n+        comment = \"Custom comment\"\n+        field = CharField(max_length=255, db_comment=comment)\n+        field.set_attributes_from_name(\"name_with_comment\")\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            editor.add_field(Author, field)\n+        self.assertEqual(\n+            self.get_column_comment(Author._meta.db_table, \"name_with_comment\"),\n+            comment,\n+        )\n+\n+    @skipUnlessDBFeature(\"supports_comments\")\n+    def test_add_db_comment_and_default_charfield(self):\n+        comment = \"Custom comment with default\"\n+        field = CharField(max_length=255, default=\"Joe Doe\", db_comment=comment)\n+        field.set_attributes_from_name(\"name_with_comment_default\")\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            Author.objects.create(name=\"Before adding a new field\")\n+            editor.add_field(Author, field)\n+\n+        self.assertEqual(\n+            self.get_column_comment(Author._meta.db_table, \"name_with_comment_default\"),\n+            comment,\n+        )\n+        with connection.cursor() as cursor:\n+            cursor.execute(\n+                f\"SELECT name_with_comment_default FROM {Author._meta.db_table};\"\n+            )\n+            for row in cursor.fetchall():\n+                self.assertEqual(row[0], \"Joe Doe\")\n+\n+    @skipUnlessDBFeature(\"supports_comments\")\n+    def test_alter_db_comment(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        # Add comment.\n+        old_field = Author._meta.get_field(\"name\")\n+        new_field = CharField(max_length=255, db_comment=\"Custom comment\")\n+        new_field.set_attributes_from_name(\"name\")\n+        with connection.schema_editor() as editor:\n+            editor.alter_field(Author, old_field, new_field, strict=True)\n+        self.assertEqual(\n+            self.get_column_comment(Author._meta.db_table, \"name\"),\n+            \"Custom comment\",\n+        )\n+        # Alter comment.\n+        old_field = new_field\n+        new_field = CharField(max_length=255, db_comment=\"New custom comment\")\n+        new_field.set_attributes_from_name(\"name\")\n+        with connection.schema_editor() as editor:\n+            editor.alter_field(Author, old_field, new_field, strict=True)\n+        self.assertEqual(\n+            self.get_column_comment(Author._meta.db_table, \"name\"),\n+            \"New custom comment\",\n+        )\n+        # Remove comment.\n+        old_field = new_field\n+        new_field = CharField(max_length=255)\n+        new_field.set_attributes_from_name(\"name\")\n+        with connection.schema_editor() as editor:\n+            editor.alter_field(Author, old_field, new_field, strict=True)\n+        self.assertIn(\n+            self.get_column_comment(Author._meta.db_table, \"name\"),\n+            [None, \"\"],\n+        )\n+\n+    @skipUnlessDBFeature(\"supports_comments\", \"supports_foreign_keys\")\n+    def test_alter_db_comment_foreign_key(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            editor.create_model(Book)\n+\n+        comment = \"FK custom comment\"\n+        old_field = Book._meta.get_field(\"author\")\n+        new_field = ForeignKey(Author, CASCADE, db_comment=comment)\n+        new_field.set_attributes_from_name(\"author\")\n+        with connection.schema_editor() as editor:\n+            editor.alter_field(Book, old_field, new_field, strict=True)\n+        self.assertEqual(\n+            self.get_column_comment(Book._meta.db_table, \"author_id\"),\n+            comment,\n+        )\n+\n+    @skipUnlessDBFeature(\"supports_comments\")\n+    def test_alter_field_type_preserve_comment(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+\n+        comment = \"This is the name.\"\n+        old_field = Author._meta.get_field(\"name\")\n+        new_field = CharField(max_length=255, db_comment=comment)\n+        new_field.set_attributes_from_name(\"name\")\n+        new_field.model = Author\n+        with connection.schema_editor() as editor:\n+            editor.alter_field(Author, old_field, new_field, strict=True)\n+        self.assertEqual(\n+            self.get_column_comment(Author._meta.db_table, \"name\"),\n+            comment,\n+        )\n+        # Changing a field type should preserve the comment.\n+        old_field = new_field\n+        new_field = CharField(max_length=511, db_comment=comment)\n+        new_field.set_attributes_from_name(\"name\")\n+        new_field.model = Author\n+        with connection.schema_editor() as editor:\n+            editor.alter_field(Author, new_field, old_field, strict=True)\n+        # Comment is preserved.\n+        self.assertEqual(\n+            self.get_column_comment(Author._meta.db_table, \"name\"),\n+            comment,\n+        )\n+\n+    @isolate_apps(\"schema\")\n+    @skipUnlessDBFeature(\"supports_comments\")\n+    def test_db_comment_table(self):\n+        class ModelWithDbTableComment(Model):\n+            class Meta:\n+                app_label = \"schema\"\n+                db_table_comment = \"Custom table comment\"\n+\n+        with connection.schema_editor() as editor:\n+            editor.create_model(ModelWithDbTableComment)\n+        self.isolated_local_models = [ModelWithDbTableComment]\n+        self.assertEqual(\n+            self.get_table_comment(ModelWithDbTableComment._meta.db_table),\n+            \"Custom table comment\",\n+        )\n+        # Alter table comment.\n+        old_db_table_comment = ModelWithDbTableComment._meta.db_table_comment\n+        with connection.schema_editor() as editor:\n+            editor.alter_db_table_comment(\n+                ModelWithDbTableComment, old_db_table_comment, \"New table comment\"\n+            )\n+        self.assertEqual(\n+            self.get_table_comment(ModelWithDbTableComment._meta.db_table),\n+            \"New table comment\",\n+        )\n+        # Remove table comment.\n+        old_db_table_comment = ModelWithDbTableComment._meta.db_table_comment\n+        with connection.schema_editor() as editor:\n+            editor.alter_db_table_comment(\n+                ModelWithDbTableComment, old_db_table_comment, None\n+            )\n+        self.assertIn(\n+            self.get_table_comment(ModelWithDbTableComment._meta.db_table),\n+            [None, \"\"],\n+        )\n+\n+    @isolate_apps(\"schema\")\n+    @skipUnlessDBFeature(\"supports_comments\", \"supports_foreign_keys\")\n+    def test_db_comments_from_abstract_model(self):\n+        class AbstractModelWithDbComments(Model):\n+            name = CharField(\n+                max_length=255, db_comment=\"Custom comment\", null=True, blank=True\n+            )\n+\n+            class Meta:\n+                app_label = \"schema\"\n+                abstract = True\n+                db_table_comment = \"Custom table comment\"\n+\n+        class ModelWithDbComments(AbstractModelWithDbComments):\n+            pass\n+\n+        with connection.schema_editor() as editor:\n+            editor.create_model(ModelWithDbComments)\n+        self.isolated_local_models = [ModelWithDbComments]\n+\n+        self.assertEqual(\n+            self.get_column_comment(ModelWithDbComments._meta.db_table, \"name\"),\n+            \"Custom comment\",\n+        )\n+        self.assertEqual(\n+            self.get_table_comment(ModelWithDbComments._meta.db_table),\n+            \"Custom table comment\",\n+        )\n+\n     @unittest.skipUnless(connection.vendor == \"postgresql\", \"PostgreSQL specific\")\n     def test_alter_field_add_index_to_charfield(self):\n         # Create the table and verify no initial indexes.\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR discusses the addition of `db_comment` support in Django, highlighting the limitations of existing test utilities like `assertTableExists()`. It suggests adding a new assertion method for better coverage and proposes modifying `get_table_description()` to include `db_comment`, although this raises concerns about targeting test-specific changes. Several test cases were added, particularly for ManyToManyFields and proxy models, emphasizing the need for careful handling of db comments in those scenarios. The collaborative approach to feedback is commendable, and the author is proactive in considering edge cases and documentation needs."
      }
    ],
    "token_estimation": 2766.75
  },
  {
    "index": 20,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/core/management/commands/shell.py b/django/core/management/commands/shell.py\nindex f55b346406aa..1619561fea2e 100644\n--- a/django/core/management/commands/shell.py\n+++ b/django/core/management/commands/shell.py\n@@ -111,10 +127,68 @@ def python(self, options):\n         # Start the interactive interpreter.\n         code.interact(local=imported_objects)\n \n+    def get_and_report_namespace(self, verbosity, no_imports=False):\n+        if no_imports:\n+            return {}\n+\n+        namespace = self.get_namespace()\n+\n+        if verbosity < 1:\n+            return namespace\n+\n+        amount = len(namespace)\n+        msg = f\"{amount} objects imported automatically\"\n+\n+        if verbosity < 2:\n+            self.stdout.write(f\"{msg} (use -v 2 for details).\", self.style.SUCCESS)\n+            return namespace\n+\n+        imports_by_module = defaultdict(list)\n+        for obj_name, obj in namespace.items():\n+            if hasattr(obj, \"__module__\") and (\n+                (hasattr(obj, \"__qualname__\") and obj.__qualname__.find(\".\") == -1)\n+                or not hasattr(obj, \"__qualname__\")\n+            ):\n+                imports_by_module[obj.__module__].append(obj_name)\n+            if not hasattr(obj, \"__module__\") and hasattr(obj, \"__name__\"):\n+                tokens = obj.__name__.split(\".\")\n+                if obj_name in tokens:\n+                    module = \".\".join(t for t in tokens if t != obj_name)\n+                    imports_by_module[module].append(obj_name)\n+\n+        import_string = \"\\n\".join(\n+            [\n+                f\"  from {module} import {objects}\"\n+                for module, imported_objects in imports_by_module.items()\n+                if (objects := \", \".join(imported_objects))\n+            ]\n+        )\n+\n+        try:\n+            import isort\n+        except ImportError:\n+            pass\n+        else:\n+            import_string = isort.code(import_string)\n+\n+        self.stdout.write(\n+            f\"{msg}, including:\\n\\n{import_string}\", self.style.SUCCESS, ending=\"\\n\\n\"\n+        )\n+\n+        return namespace\n+\n+    def get_namespace(self):\n+        apps_models = apps.get_models()\n+        namespace = {}\n+        for model in reversed(apps_models):\n+            if model.__module__:\n+                namespace[model.__name__] = model\n+        return namespace\n+\n     def handle(self, **options):\n         # Execute the command and exit.\n         if options[\"command\"]:\n-            exec(options[\"command\"], globals())\n+            exec(options[\"command\"], {**globals(), **self.get_namespace()})\n             return\n \n         # Execute stdin if it has anything to read and exit.\n\ndiff --git a/docs/howto/custom-shell.txt b/docs/howto/custom-shell.txt\nnew file mode 100644\nindex 000000000000..07034dd197d4\n--- /dev/null\n+++ b/docs/howto/custom-shell.txt\n@@ -0,0 +1,57 @@\n+======================================\n+How to customize the ``shell`` command\n+======================================\n+\n+The Django :djadmin:`shell` is an interactive Python environment that provides\n+access to models and settings, making it useful for testing code, experimenting\n+with queries, and interacting with application data.\n+\n+Customizing the :djadmin:`shell` command allows adding extra functionality or\n+pre-loading specific modules. To do this, create a new management command that subclasses\n+``django.core.management.commands.shell.Command`` and overrides the existing\n+``shell`` management command. For more details, refer to the guide on\n+:ref:`overriding commands <overriding-commands>`.\n+\n+.. _customizing-shell-auto-imports:\n+\n+Customize automatic imports\n+===========================\n+\n+.. versionadded:: 5.2\n+\n+To customize the automatic import behavior of the :djadmin:`shell` management\n+command, override the ``get_namespace()`` method. For example:\n+\n+.. code-block:: python\n+    :caption: ``polls/management/commands/shell.py``\n+\n+    from django.core.management.commands import shell\n+\n+\n+    class Command(shell.Command):\n+        def get_namespace(self):\n+            from django.urls.base import resolve, reverse\n+\n+            return {\n+                **super().get_namespace(),\n+                \"resolve\": resolve,\n+                \"reverse\": reverse,\n+            }\n+\n+The above customization adds :func:`~django.urls.resolve` and\n+:func:`~django.urls.reverse` to the default namespace, which includes all\n+models from all apps. These two functions will then be available when the\n+shell opens, without a manual import statement.\n+\n+If you prefer to not have models automatically imported, create a custom\n+``get_namespace()`` that excludes the ``super().get_namespace()`` call:\n+\n+.. code-block:: python\n+    :caption: ``polls/management/commands/shell.py``\n+\n+    from django.core.management.commands import shell\n+\n+\n+    class Command(shell.Command):\n+        def get_namespace(self):\n+            return {}\ndiff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex ca823f6290a6..49528cca8e6d 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -122,3 +141,166 @@ def test_python(self):\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() toward the\n     # end of shell's handle() method.\n+\n+\n+class ShellCommandAutoImportsTestCase(SimpleTestCase):\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\"shell\", \"django.contrib.auth\", \"django.contrib.contenttypes\"]\n+    )\n+    def test_get_namespace(self):\n+        namespace = shell.Command().get_namespace()\n+\n+        self.assertEqual(\n+            namespace,\n+            {\n+                \"Marker\": Marker,\n+                \"Phone\": Phone,\n+                \"ContentType\": ContentType,\n+                \"Group\": Group,\n+                \"Permission\": Permission,\n+                \"User\": User,\n+            },\n+        )\n+\n+    @override_settings(INSTALLED_APPS=[\"basic\", \"shell\"])\n+    @isolate_apps(\"basic\", \"shell\", kwarg_name=\"apps\")\n+    def test_get_namespace_precedence(self, apps):\n+        class Article(models.Model):\n+            class Meta:\n+                app_label = \"basic\"\n+\n+        winner_article = Article\n+\n+        class Article(models.Model):\n+            class Meta:\n+                app_label = \"shell\"\n+\n+        with mock.patch(\"django.apps.apps.get_models\", return_value=apps.get_models()):\n+            namespace = shell.Command().get_namespace()\n+            self.assertEqual(namespace, {\"Article\": winner_article})\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\"shell\", \"django.contrib.auth\", \"django.contrib.contenttypes\"]\n+    )\n+    def test_get_namespace_overridden(self):\n+        class TestCommand(shell.Command):\n+            def get_namespace(self):\n+                from django.urls.base import resolve, reverse\n+\n+                return {\n+                    **super().get_namespace(),\n+                    \"resolve\": resolve,\n+                    \"reverse\": reverse,\n+                }\n+\n+        namespace = TestCommand().get_namespace()\n+\n+        self.assertEqual(\n+            namespace,\n+            {\n+                \"resolve\": resolve,\n+                \"reverse\": reverse,\n+                \"Marker\": Marker,\n+                \"Phone\": Phone,\n+                \"ContentType\": ContentType,\n+                \"Group\": Group,\n+                \"Permission\": Permission,\n+                \"User\": User,\n+            },\n+        )\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\"shell\", \"django.contrib.auth\", \"django.contrib.contenttypes\"]\n+    )\n+    def test_no_imports_flag(self):\n+        for verbosity in (0, 1, 2, 3):\n+            with self.subTest(verbosity=verbosity), captured_stdout() as stdout:\n+                namespace = shell.Command().get_and_report_namespace(\n+                    verbosity=verbosity, no_imports=True\n+                )\n+            self.assertEqual(namespace, {})\n+            self.assertEqual(stdout.getvalue().strip(), \"\")\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\"shell\", \"django.contrib.auth\", \"django.contrib.contenttypes\"]\n+    )\n+    def test_verbosity_zero(self):\n+        with captured_stdout() as stdout:\n+            cmd = shell.Command()\n+            namespace = cmd.get_and_report_namespace(verbosity=0)\n+        self.assertEqual(namespace, cmd.get_namespace())\n+        self.assertEqual(stdout.getvalue().strip(), \"\")\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\"shell\", \"django.contrib.auth\", \"django.contrib.contenttypes\"]\n+    )\n+    def test_verbosity_one(self):\n+        with captured_stdout() as stdout:\n+            cmd = shell.Command()\n+            namespace = cmd.get_and_report_namespace(verbosity=1)\n+        self.assertEqual(namespace, cmd.get_namespace())\n+        self.assertEqual(\n+            stdout.getvalue().strip(),\n+            \"6 objects imported automatically (use -v 2 for details).\",\n+        )\n+\n+    @override_settings(INSTALLED_APPS=[\"shell\", \"django.contrib.contenttypes\"])\n+    @mock.patch.dict(sys.modules, {\"isort\": None})\n+    def test_message_with_stdout_listing_objects_with_isort_not_installed(self):\n+        class TestCommand(shell.Command):\n+            def get_namespace(self):\n+                class MyClass:\n+                    pass\n+\n+                constant = \"constant\"\n+\n+                return {\n+                    **super().get_namespace(),\n+                    \"MyClass\": MyClass,\n+                    \"constant\": constant,\n+                }\n+\n+        with captured_stdout() as stdout:\n+            TestCommand().get_and_report_namespace(verbosity=2)\n+\n+        self.assertEqual(\n+            stdout.getvalue().strip(),\n+            \"5 objects imported automatically, including:\\n\\n\"\n+            \"  from django.contrib.contenttypes.models import ContentType\\n\"\n+            \"  from shell.models import Phone, Marker\",\n+        )\n+\n+    @override_settings(INSTALLED_APPS=[\"shell\", \"django.contrib.contenttypes\"])\n+    def test_message_with_stdout_listing_objects_with_isort(self):\n+        sorted_imports = (\n+            \"  from shell.models import Marker, Phone\\n\\n\"\n+            \"  from django.contrib.contenttypes.models import ContentType\"\n+        )\n+        mock_isort_code = mock.Mock(code=mock.MagicMock(return_value=sorted_imports))\n+\n+        class TestCommand(shell.Command):\n+            def get_namespace(self):\n+                class MyClass:\n+                    pass\n+\n+                constant = \"constant\"\n+\n+                return {\n+                    **super().get_namespace(),\n+                    \"MyClass\": MyClass,\n+                    \"constant\": constant,\n+                }\n+\n+        with (\n+            mock.patch.dict(sys.modules, {\"isort\": mock_isort_code}),\n+            captured_stdout() as stdout,\n+        ):\n+            TestCommand().get_and_report_namespace(verbosity=2)\n+\n+        self.assertEqual(\n+            stdout.getvalue().strip(),\n+            \"5 objects imported automatically, including:\\n\\n\"\n+            \"  from shell.models import Marker, Phone\\n\\n\"\n+            \"  from django.contrib.contenttypes.models import ContentType\",\n+        )\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The tests need to be added within `ShellCommandTestCase`. Unit-test `get_namespace()` directly and complement it with integration tests similar to current ones. Existing tests lack coverage for different shell launches; adding tests for the default `python` shell would be beneficial, though be cautious about interaction with startup files. It's worth addressing the `--no-startup` flag's behavior regarding auto-imports, and filtering out None values from `locals()` aligns with clean coding practices. Lastly, sorting imports using isort is recommended to maintain consistency."
      }
    ],
    "token_estimation": 2927.25
  },
  {
    "index": 21,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/models/indexes.py b/django/db/models/indexes.py\nindex fddde3b16f34..5530d0b66128 100644\n--- a/django/db/models/indexes.py\n+++ b/django/db/models/indexes.py\n@@ -137,3 +184,84 @@ def __eq__(self, other):\n         if self.__class__ == other.__class__:\n             return self.deconstruct() == other.deconstruct()\n         return NotImplemented\n+\n+\n+class IndexExpression(Func):\n+    \"\"\"Order and wrap expressions for CREATE INDEX statements.\"\"\"\n+    template = '%(expressions)s'\n+    wrapper_classes = (OrderBy, Collate)\n+\n+    def set_wrapper_classes(self, connection=None):\n+        # Some databases (e.g. MySQL) treats COLLATE as an indexed expression.\n+        if connection and connection.features.collate_as_index_expression:\n+            self.wrapper_classes = tuple([\n+                wrapper_cls\n+                for wrapper_cls in self.wrapper_classes\n+                if wrapper_cls is not Collate\n+            ])\n+\n+    @classmethod\n+    def register_wrappers(cls, *wrapper_classes):\n+        cls.wrapper_classes = wrapper_classes\n+\n+    def resolve_expression(\n+        self,\n+        query=None,\n+        allow_joins=True,\n+        reuse=None,\n+        summarize=False,\n+        for_save=False,\n+    ):\n+        expressions = list(self.flatten())\n+        # Split expressions and wrappers.\n+        index_expressions, wrappers = partition(\n+            lambda e: isinstance(e, self.wrapper_classes),\n+            expressions,\n+        )\n+        wrapper_types = [type(wrapper) for wrapper in wrappers]\n+        if len(wrapper_types) != len(set(wrapper_types)):\n+            raise ValueError(\n+                \"Multiple references to %s can't be used in an indexed \"\n+                \"expression.\" % ', '.join([\n+                    wrapper_cls.__qualname__ for wrapper_cls in self.wrapper_classes\n+                ])\n+            )\n+        if expressions[1:len(wrappers) + 1] != wrappers:\n+            raise ValueError(\n+                '%s must be topmost expressions in an indexed expression.'\n+                % ', '.join([\n+                    wrapper_cls.__qualname__ for wrapper_cls in self.wrapper_classes\n+                ])\n+            )\n+        # Wrap expressions in parentheses if they are not column references.\n+        root_expression = index_expressions[1]\n+        resolve_root_expression = root_expression.resolve_expression(\n+            query,\n+            allow_joins,\n+            reuse,\n+            summarize,\n+            for_save,\n+        )\n+        if not isinstance(resolve_root_expression, Col):\n+            root_expression = Func(root_expression, template='(%(expressions)s)')\n+\n+        if wrappers:\n+            # Order wrappers and set their expressions.\n+            wrappers = sorted(\n+                wrappers,\n+                key=lambda w: self.wrapper_classes.index(type(w)),\n+            )\n+            wrappers = [wrapper.copy() for wrapper in wrappers]\n+            for i, wrapper in enumerate(wrappers[:-1]):\n+                wrapper.set_source_expressions([wrappers[i + 1]])\n+            # Set the root expression on the deepest wrapper.\n+            wrappers[-1].set_source_expressions([root_expression])\n+            self.set_source_expressions([wrappers[0]])\n+        else:\n+            # Use the root expression, if there are no wrappers.\n+            self.set_source_expressions([root_expression])\n+        return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+\n+    def as_sqlite(self, compiler, connection, **extra_context):\n+        # Casting to numeric is unnecessary.\n+        return self.as_sql(compiler, connection, **extra_context)\ndiff --git a/tests/backends/test_ddl_references.py b/tests/backends/test_ddl_references.py\nindex d96ebcb57f08..bd4036ee3358 100644\n--- a/tests/backends/test_ddl_references.py\n+++ b/tests/backends/test_ddl_references.py\n@@ -181,3 +187,66 @@ def test_str(self):\n         reference = MockReference('reference', {}, {})\n         statement = Statement(\"%(reference)s - %(non_reference)s\", reference=reference, non_reference='non_reference')\n         self.assertEqual(str(statement), 'reference - non_reference')\n+\n+\n+class ExpressionsTests(TransactionTestCase):\n+    available_apps = []\n+\n+    def setUp(self):\n+        compiler = Person.objects.all().query.get_compiler(connection.alias)\n+        self.editor = connection.schema_editor()\n+        self.expressions = Expressions(\n+            table=Person._meta.db_table,\n+            expressions=ExpressionList(\n+                IndexExpression(F('first_name')),\n+                IndexExpression(F('last_name').desc()),\n+                IndexExpression(Upper('last_name')),\n+            ).resolve_expression(compiler.query),\n+            compiler=compiler,\n+            quote_value=self.editor.quote_value,\n+        )\n+\n+    def test_references_table(self):\n+        self.assertIs(self.expressions.references_table(Person._meta.db_table), True)\n+        self.assertIs(self.expressions.references_table('other'), False)\n+\n+    def test_references_column(self):\n+        table = Person._meta.db_table\n+        self.assertIs(self.expressions.references_column(table, 'first_name'), True)\n+        self.assertIs(self.expressions.references_column(table, 'last_name'), True)\n+        self.assertIs(self.expressions.references_column(table, 'other'), False)\n+\n+    def test_rename_table_references(self):\n+        table = Person._meta.db_table\n+        self.expressions.rename_table_references(table, 'other')\n+        self.assertIs(self.expressions.references_table(table), False)\n+        self.assertIs(self.expressions.references_table('other'), True)\n+        self.assertIn(\n+            '%s.%s' % (\n+                self.editor.quote_name('other'),\n+                self.editor.quote_name('first_name'),\n+            ),\n+            str(self.expressions),\n+        )\n+\n+    def test_rename_column_references(self):\n+        table = Person._meta.db_table\n+        self.expressions.rename_column_references(table, 'first_name', 'other')\n+        self.assertIs(self.expressions.references_column(table, 'other'), True)\n+        self.assertIs(self.expressions.references_column(table, 'first_name'), False)\n+        self.assertIn(\n+            '%s.%s' % (self.editor.quote_name(table), self.editor.quote_name('other')),\n+            str(self.expressions),\n+        )\n+\n+    def test_str(self):\n+        table_name = self.editor.quote_name(Person._meta.db_table)\n+        expected_str = '%s.%s, %s.%s DESC, (UPPER(%s.%s))' % (\n+            table_name,\n+            self.editor.quote_name('first_name'),\n+            table_name,\n+            self.editor.quote_name('last_name'),\n+            table_name,\n+            self.editor.quote_name('last_name'),\n+        )\n+        self.assertEqual(str(self.expressions), expected_str)\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 38ad6a2d1818..897808f75bbc 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1939,6 +1940,76 @@ def test_remove_index_state_forwards(self):\n         new_model = new_state.apps.get_model('test_rminsf', 'Pony')\n         self.assertIsNot(old_model, new_model)\n \n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_add_func_index(self):\n+        app_label = 'test_addfuncin'\n+        index_name = f'{app_label}_pony_abs_idx'\n+        table_name = f'{app_label}_pony'\n+        project_state = self.set_up_test_model(app_label)\n+        index = models.Index(Abs('weight'), name=index_name)\n+        operation = migrations.AddIndex('Pony', index)\n+        self.assertEqual(\n+            operation.describe(),\n+            'Create index test_addfuncin_pony_abs_idx on Abs(F(weight)) on model Pony',\n+        )\n+        self.assertEqual(\n+            operation.migration_name_fragment,\n+            'pony_test_addfuncin_pony_abs_idx',\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+        self.assertEqual(len(new_state.models[app_label, 'pony'].options['indexes']), 1)\n+        self.assertIndexNameNotExists(table_name, index_name)\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNameExists(table_name, index_name)\n+        # Reversal.\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+        self.assertIndexNameNotExists(table_name, index_name)\n+        # Deconstruction.\n+        definition = operation.deconstruct()\n+        self.assertEqual(definition[0], 'AddIndex')\n+        self.assertEqual(definition[1], [])\n+        self.assertEqual(definition[2], {'model_name': 'Pony', 'index': index})\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_remove_func_index(self):\n+        app_label = 'test_rmfuncin'\n+        index_name = f'{app_label}_pony_abs_idx'\n+        table_name = f'{app_label}_pony'\n+        project_state = self.set_up_test_model(app_label, indexes=[\n+            models.Index(Abs('weight'), name=index_name),\n+        ])\n+        self.assertTableExists(table_name)\n+        self.assertIndexNameExists(table_name, index_name)\n+        operation = migrations.RemoveIndex('Pony', index_name)\n+        self.assertEqual(\n+            operation.describe(),\n+            'Remove index test_rmfuncin_pony_abs_idx from Pony',\n+        )\n+        self.assertEqual(\n+            operation.migration_name_fragment,\n+            'remove_pony_test_rmfuncin_pony_abs_idx',\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+        self.assertEqual(len(new_state.models[app_label, 'pony'].options['indexes']), 0)\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNameNotExists(table_name, index_name)\n+        # Reversal.\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+        self.assertIndexNameExists(table_name, index_name)\n+        # Deconstruction.\n+        definition = operation.deconstruct()\n+        self.assertEqual(definition[0], 'RemoveIndex')\n+        self.assertEqual(definition[1], [])\n+        self.assertEqual(definition[2], {'model_name': 'Pony', 'name': index_name})\n+\n     def test_alter_field_with_index(self):\n         \"\"\"\n         Test AlterField operation with an index to ensure indexes created via\ndiff --git a/tests/postgres_tests/test_indexes.py b/tests/postgres_tests/test_indexes.py\nindex b9888f48431a..49646feb97c8 100644\n--- a/tests/postgres_tests/test_indexes.py\n+++ b/tests/postgres_tests/test_indexes.py\n@@ -455,3 +527,83 @@ def test_spgist_parameters(self):\n         with connection.schema_editor() as editor:\n             editor.remove_index(CharFieldModel, index)\n         self.assertNotIn(index_name, self.get_constraints(CharFieldModel._meta.db_table))\n+\n+    def test_op_class(self):\n+        index_name = 'test_op_class'\n+        index = Index(\n+            OpClass(Lower('field'), name='text_pattern_ops'),\n+            name=index_name,\n+        )\n+        with connection.schema_editor() as editor:\n+            editor.add_index(TextFieldModel, index)\n+        with editor.connection.cursor() as cursor:\n+            cursor.execute(self.get_opclass_query, [index_name])\n+            self.assertCountEqual(cursor.fetchall(), [('text_pattern_ops', index_name)])\n+\n+    def test_op_class_descending_collation(self):\n+        collation = connection.features.test_collations.get('non_default')\n+        if not collation:\n+            self.skipTest(\n+                'This backend does not support case-insensitive collations.'\n+            )\n+        index_name = 'test_op_class_descending_collation'\n+        index = Index(\n+            Collate(\n+                OpClass(Lower('field'), name='text_pattern_ops').desc(nulls_last=True),\n+                collation=collation,\n+            ),\n+            name=index_name,\n+        )\n+        with connection.schema_editor() as editor:\n+            editor.add_index(TextFieldModel, index)\n+            self.assertIn(\n+                'COLLATE %s' % editor.quote_name(collation),\n+                str(index.create_sql(TextFieldModel, editor)),\n+            )\n+        with editor.connection.cursor() as cursor:\n+            cursor.execute(self.get_opclass_query, [index_name])\n+            self.assertCountEqual(cursor.fetchall(), [('text_pattern_ops', index_name)])\n+        table = TextFieldModel._meta.db_table\n+        constraints = self.get_constraints(table)\n+        self.assertIn(index_name, constraints)\n+        self.assertEqual(constraints[index_name]['orders'], ['DESC'])\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(TextFieldModel, index)\n+        self.assertNotIn(index_name, self.get_constraints(table))\n+\n+    def test_op_class_descending_partial(self):\n+        index_name = 'test_op_class_descending_partial'\n+        index = Index(\n+            OpClass(Lower('field'), name='text_pattern_ops').desc(),\n+            name=index_name,\n+            condition=Q(field__contains='China'),\n+        )\n+        with connection.schema_editor() as editor:\n+            editor.add_index(TextFieldModel, index)\n+        with editor.connection.cursor() as cursor:\n+            cursor.execute(self.get_opclass_query, [index_name])\n+            self.assertCountEqual(cursor.fetchall(), [('text_pattern_ops', index_name)])\n+        constraints = self.get_constraints(TextFieldModel._meta.db_table)\n+        self.assertIn(index_name, constraints)\n+        self.assertEqual(constraints[index_name]['orders'], ['DESC'])\n+\n+    def test_op_class_descending_partial_tablespace(self):\n+        index_name = 'test_op_class_descending_partial_tablespace'\n+        index = Index(\n+            OpClass(Lower('field').desc(), name='text_pattern_ops'),\n+            name=index_name,\n+            condition=Q(field__contains='China'),\n+            db_tablespace='pg_default',\n+        )\n+        with connection.schema_editor() as editor:\n+            editor.add_index(TextFieldModel, index)\n+            self.assertIn(\n+                'TABLESPACE \"pg_default\" ',\n+                str(index.create_sql(TextFieldModel, editor))\n+            )\n+        with editor.connection.cursor() as cursor:\n+            cursor.execute(self.get_opclass_query, [index_name])\n+            self.assertCountEqual(cursor.fetchall(), [('text_pattern_ops', index_name)])\n+        constraints = self.get_constraints(TextFieldModel._meta.db_table)\n+        self.assertIn(index_name, constraints)\n+        self.assertEqual(constraints[index_name]['orders'], ['DESC'])\ndiff --git a/tests/schema/tests.py b/tests/schema/tests.py\nindex 7740065d311e..b994c252d969 100644\n--- a/tests/schema/tests.py\n+++ b/tests/schema/tests.py\n@@ -2481,6 +2488,366 @@ def test_text_field_with_db_index(self):\n         assertion = self.assertIn if connection.features.supports_index_on_text_field else self.assertNotIn\n         assertion('text_field', self.get_indexes(AuthorTextFieldWithIndex._meta.db_table))\n \n+    def _index_expressions_wrappers(self):\n+        index_expression = IndexExpression()\n+        index_expression.set_wrapper_classes(connection)\n+        return ', '.join([\n+            wrapper_cls.__qualname__ for wrapper_cls in index_expression.wrapper_classes\n+        ])\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index_multiple_wrapper_references(self):\n+        index = Index(OrderBy(F('name').desc(), descending=True), name='name')\n+        msg = (\n+            \"Multiple references to %s can't be used in an indexed expression.\"\n+            % self._index_expressions_wrappers()\n+        )\n+        with connection.schema_editor() as editor:\n+            with self.assertRaisesMessage(ValueError, msg):\n+                editor.add_index(Author, index)\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index_invalid_topmost_expressions(self):\n+        index = Index(Upper(F('name').desc()), name='name')\n+        msg = (\n+            '%s must be topmost expressions in an indexed expression.'\n+            % self._index_expressions_wrappers()\n+        )\n+        with connection.schema_editor() as editor:\n+            with self.assertRaisesMessage(ValueError, msg):\n+                editor.add_index(Author, index)\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        index = Index(Lower('name').desc(), name='func_lower_idx')\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            editor.add_index(Author, index)\n+            sql = index.create_sql(Author, editor)\n+        table = Author._meta.db_table\n+        if connection.features.supports_index_column_ordering:\n+            self.assertIndexOrder(table, index.name, ['DESC'])\n+        # SQL contains a database function.\n+        self.assertIs(sql.references_column(table, 'name'), True)\n+        self.assertIn('LOWER(%s)' % editor.quote_name('name'), str(sql))\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Author, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index_f(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Tag)\n+        index = Index('slug', F('title').desc(), name='func_f_idx')\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            editor.add_index(Tag, index)\n+            sql = index.create_sql(Tag, editor)\n+        table = Tag._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        if connection.features.supports_index_column_ordering:\n+            self.assertIndexOrder(Tag._meta.db_table, index.name, ['ASC', 'DESC'])\n+        # SQL contains columns.\n+        self.assertIs(sql.references_column(table, 'slug'), True)\n+        self.assertIs(sql.references_column(table, 'title'), True)\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Tag, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index_lookups(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        with register_lookup(CharField, Lower), register_lookup(IntegerField, Abs):\n+            index = Index(\n+                F('name__lower'),\n+                F('weight__abs'),\n+                name='func_lower_abs_lookup_idx',\n+            )\n+            # Add index.\n+            with connection.schema_editor() as editor:\n+                editor.add_index(Author, index)\n+                sql = index.create_sql(Author, editor)\n+        table = Author._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        # SQL contains columns.\n+        self.assertIs(sql.references_column(table, 'name'), True)\n+        self.assertIs(sql.references_column(table, 'weight'), True)\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Author, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_composite_func_index(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        index = Index(Lower('name'), Upper('name'), name='func_lower_upper_idx')\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            editor.add_index(Author, index)\n+            sql = index.create_sql(Author, editor)\n+        table = Author._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        # SQL contains database functions.\n+        self.assertIs(sql.references_column(table, 'name'), True)\n+        sql = str(sql)\n+        self.assertIn('LOWER(%s)' % editor.quote_name('name'), sql)\n+        self.assertIn('UPPER(%s)' % editor.quote_name('name'), sql)\n+        self.assertLess(sql.index('LOWER'), sql.index('UPPER'))\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Author, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_composite_func_index_field_and_expression(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            editor.create_model(Book)\n+        index = Index(\n+            F('author').desc(),\n+            Lower('title').asc(),\n+            'pub_date',\n+            name='func_f_lower_field_idx',\n+        )\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            editor.add_index(Book, index)\n+            sql = index.create_sql(Book, editor)\n+        table = Book._meta.db_table\n+        constraints = self.get_constraints(table)\n+        if connection.features.supports_index_column_ordering:\n+            self.assertIndexOrder(table, index.name, ['DESC', 'ASC', 'ASC'])\n+        self.assertEqual(len(constraints[index.name]['columns']), 3)\n+        self.assertEqual(constraints[index.name]['columns'][2], 'pub_date')\n+        # SQL contains database functions and columns.\n+        self.assertIs(sql.references_column(table, 'author_id'), True)\n+        self.assertIs(sql.references_column(table, 'title'), True)\n+        self.assertIs(sql.references_column(table, 'pub_date'), True)\n+        self.assertIn('LOWER(%s)' % editor.quote_name('title'), str(sql))\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Book, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    @isolate_apps('schema')\n+    def test_func_index_f_decimalfield(self):\n+        class Node(Model):\n+            value = DecimalField(max_digits=5, decimal_places=2)\n+\n+            class Meta:\n+                app_label = 'schema'\n+\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Node)\n+        index = Index(F('value'), name='func_f_decimalfield_idx')\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            editor.add_index(Node, index)\n+            sql = index.create_sql(Node, editor)\n+        table = Node._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        self.assertIs(sql.references_column(table, 'value'), True)\n+        # SQL doesn't contain casting.\n+        self.assertNotIn('CAST', str(sql))\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Node, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index_cast(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        index = Index(Cast('weight', FloatField()), name='func_cast_idx')\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            editor.add_index(Author, index)\n+            sql = index.create_sql(Author, editor)\n+        table = Author._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        self.assertIs(sql.references_column(table, 'weight'), True)\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Author, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index_collate(self):\n+        collation = connection.features.test_collations.get('non_default')\n+        if not collation:\n+            self.skipTest(\n+                'This backend does not support case-insensitive collations.'\n+            )\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            editor.create_model(BookWithSlug)\n+        index = Index(\n+            Collate(F('title'), collation=collation).desc(),\n+            Collate('slug', collation=collation),\n+            name='func_collate_idx',\n+        )\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            editor.add_index(BookWithSlug, index)\n+            sql = index.create_sql(BookWithSlug, editor)\n+        table = Book._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        if connection.features.supports_index_column_ordering:\n+            self.assertIndexOrder(table, index.name, ['DESC', 'ASC'])\n+        # SQL contains columns and a collation.\n+        self.assertIs(sql.references_column(table, 'title'), True)\n+        self.assertIs(sql.references_column(table, 'slug'), True)\n+        self.assertIn('COLLATE %s' % editor.quote_name(collation), str(sql))\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Book, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    @skipIfDBFeature('collate_as_index_expression')\n+    def test_func_index_collate_f_ordered(self):\n+        collation = connection.features.test_collations.get('non_default')\n+        if not collation:\n+            self.skipTest(\n+                'This backend does not support case-insensitive collations.'\n+            )\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        index = Index(\n+            Collate(F('name').desc(), collation=collation),\n+            name='func_collate_f_desc_idx',\n+        )\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            editor.add_index(Author, index)\n+            sql = index.create_sql(Author, editor)\n+        table = Author._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        if connection.features.supports_index_column_ordering:\n+            self.assertIndexOrder(table, index.name, ['DESC'])\n+        # SQL contains columns and a collation.\n+        self.assertIs(sql.references_column(table, 'name'), True)\n+        self.assertIn('COLLATE %s' % editor.quote_name(collation), str(sql))\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Author, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index_calc(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        index = Index(F('height') / (F('weight') + Value(5)), name='func_calc_idx')\n+        # Add index.\n+        with connection.schema_editor() as editor:\n+            editor.add_index(Author, index)\n+            sql = index.create_sql(Author, editor)\n+        table = Author._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        # SQL contains columns and expressions.\n+        self.assertIs(sql.references_column(table, 'height'), True)\n+        self.assertIs(sql.references_column(table, 'weight'), True)\n+        sql = str(sql)\n+        self.assertIs(\n+            sql.index(editor.quote_name('height')) <\n+            sql.index('/') <\n+            sql.index(editor.quote_name('weight')) <\n+            sql.index('+') <\n+            sql.index('5'),\n+            True,\n+        )\n+        # Remove index.\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(Author, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes', 'supports_json_field')\n+    @isolate_apps('schema')\n+    def test_func_index_json_key_transform(self):\n+        class JSONModel(Model):\n+            field = JSONField()\n+\n+            class Meta:\n+                app_label = 'schema'\n+\n+        with connection.schema_editor() as editor:\n+            editor.create_model(JSONModel)\n+        self.isolated_local_models = [JSONModel]\n+        index = Index('field__some_key', name='func_json_key_idx')\n+        with connection.schema_editor() as editor:\n+            editor.add_index(JSONModel, index)\n+            sql = index.create_sql(JSONModel, editor)\n+        table = JSONModel._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        self.assertIs(sql.references_column(table, 'field'), True)\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(JSONModel, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes', 'supports_json_field')\n+    @isolate_apps('schema')\n+    def test_func_index_json_key_transform_cast(self):\n+        class JSONModel(Model):\n+            field = JSONField()\n+\n+            class Meta:\n+                app_label = 'schema'\n+\n+        with connection.schema_editor() as editor:\n+            editor.create_model(JSONModel)\n+        self.isolated_local_models = [JSONModel]\n+        index = Index(\n+            Cast(KeyTextTransform('some_key', 'field'), IntegerField()),\n+            name='func_json_key_cast_idx',\n+        )\n+        with connection.schema_editor() as editor:\n+            editor.add_index(JSONModel, index)\n+            sql = index.create_sql(JSONModel, editor)\n+        table = JSONModel._meta.db_table\n+        self.assertIn(index.name, self.get_constraints(table))\n+        self.assertIs(sql.references_column(table, 'field'), True)\n+        with connection.schema_editor() as editor:\n+            editor.remove_index(JSONModel, index)\n+        self.assertNotIn(index.name, self.get_constraints(table))\n+\n+    @skipIfDBFeature('supports_expression_indexes')\n+    def test_func_index_unsupported(self):\n+        # Index is ignored on databases that don't support indexes on\n+        # expressions.\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        index = Index(F('name'), name='random_idx')\n+        with connection.schema_editor() as editor, self.assertNumQueries(0):\n+            self.assertIsNone(editor.add_index(Author, index))\n+            self.assertIsNone(editor.remove_index(Author, index))\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index_nonexistent_field(self):\n+        index = Index(Lower('nonexistent'), name='func_nonexistent_idx')\n+        msg = (\n+            \"Cannot resolve keyword 'nonexistent' into field. Choices are: \"\n+            \"height, id, name, uuid, weight\"\n+        )\n+        with self.assertRaisesMessage(FieldError, msg):\n+            with connection.schema_editor() as editor:\n+                editor.add_index(Author, index)\n+\n+    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_func_index_nondeterministic(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        index = Index(Random(), name='func_random_idx')\n+        with connection.schema_editor() as editor:\n+            with self.assertRaises(DatabaseError):\n+                editor.add_index(Author, index)\n+\n     def test_primary_key(self):\n         \"\"\"\n         Tests altering of the primary key\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Good job on revising this PR! A couple of critical points to address: \n\nFirst, ensure the API for partial functional indexes is clear and supports the `Q` conditions properly. The inclusion of covering indexes could enhance functionality but remember that it's specific to Postgres 11. Also, consider implementing an option for automatic conversion of string fields to `F()` in the `__init__` method to improve usability.\n\nLastly, the `Index` ordering needs refactoring to prevent confusion with composite indexes. Let's keep pushing for clarity and compatibility across databases."
      }
    ],
    "token_estimation": 8138.25
  },
  {
    "index": 22,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex 7b86a2def54d..56e749f05def 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -840,3 +840,172 @@ def test_update_conflicts_unique_fields_update_fields_db_column(self):\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n         )\n+\n+    @skipUnlessDBFeature(\"supports_update_conflicts_with_condition\")\n+    def test_bulk_create_with_q_expression(self):\n+        initial_items = [\n+            UpsertConflict(number=1, rank=1, name=\"John\"),\n+            UpsertConflict(number=2, rank=3, name=\"Mary\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(initial_items)\n+        updated_items = [\n+            UpsertConflict(number=1, rank=3, name=\"Steve\"),\n+            UpsertConflict(number=2, rank=2, name=\"Olivia\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(\n+            updated_items,\n+            update_conflicts=True,\n+            update_fields=[\"name\", \"rank\"],\n+            unique_fields=[\"number\"],\n+            condition=Q(rank__lt=3),\n+        )\n+        self.assertEqual(UpsertConflict.objects.get(number=1).name, \"Steve\")\n+        self.assertEqual(UpsertConflict.objects.get(number=2).name, \"Mary\")\n+\n+    @skipUnlessDBFeature(\"supports_update_conflicts_with_condition\")\n+    def test_bulk_create_with_f_expression(self):\n+        initial_items = [\n+            UpsertConflict(number=1, rank=1, name=\"John\"),\n+            UpsertConflict(number=2, rank=4, name=\"Mary\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(initial_items)\n+        updated_items = [\n+            UpsertConflict(number=1, rank=3, name=\"Steve\"),\n+            UpsertConflict(number=2, rank=4, name=\"Olivia\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(\n+            updated_items,\n+            update_conflicts=True,\n+            update_fields=[\"name\", \"rank\"],\n+            unique_fields=[\"number\"],\n+            condition=Q(rank__lt=F(\"number\") + 1),\n+        )\n+        self.assertEqual(UpsertConflict.objects.get(number=1).name, \"Steve\")\n+        self.assertEqual(UpsertConflict.objects.get(number=2).name, \"Mary\")\n+\n+    @skipUnlessDBFeature(\"supports_update_conflicts_with_condition\")\n+    def test_bulk_create_with_complex_condition(self):\n+        initial_items = [\n+            UpsertConflict(number=1, rank=3, name=\"John\"),\n+            UpsertConflict(number=2, rank=2, name=\"Mary\"),\n+            UpsertConflict(number=3, rank=6, name=\"Alice\"),\n+            UpsertConflict(number=4, rank=7, name=\"Bob\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(initial_items)\n+        updated_items = [\n+            UpsertConflict(number=1, rank=1, name=\"Steve\"),\n+            UpsertConflict(number=2, rank=2, name=\"Olivia\"),\n+            UpsertConflict(number=3, rank=3, name=\"Emma\"),\n+            UpsertConflict(number=4, rank=4, name=\"Lucas\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(\n+            updated_items,\n+            update_conflicts=True,\n+            update_fields=[\"name\", \"rank\"],\n+            unique_fields=[\"number\"],\n+            condition=Q(rank__gt=F(\"number\") + 1) & ~Q(name__startswith=\"A\")\n+            | Q(number__gt=3),\n+        )\n+        self.assertEqual(UpsertConflict.objects.get(number=1).name, \"Steve\")\n+        self.assertEqual(UpsertConflict.objects.get(number=2).name, \"Mary\")\n+        self.assertEqual(UpsertConflict.objects.get(number=3).name, \"Alice\")\n+        self.assertEqual(UpsertConflict.objects.get(number=4).name, \"Lucas\")\n+\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts_with_condition\",\n+        \"supports_excluded_expression\",\n+    )\n+    def test_bulk_create_with_excluded_expression(self):\n+        initial_items = [\n+            UpsertConflict(number=1, rank=3, name=\"John\"),\n+            UpsertConflict(number=2, rank=2, name=\"Mary\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(initial_items)\n+        updated_items = [\n+            UpsertConflict(number=1, rank=4, name=\"Steve\"),\n+            UpsertConflict(number=2, rank=1, name=\"Olivia\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(\n+            updated_items,\n+            update_conflicts=True,\n+            update_fields=[\"name\", \"rank\"],\n+            unique_fields=[\"number\"],\n+            condition=Q(rank__lt=Excluded(\"rank\")),\n+        )\n+        self.assertEqual(UpsertConflict.objects.get(number=1).name, \"Steve\")\n+        self.assertEqual(UpsertConflict.objects.get(number=2).name, \"Mary\")\n+\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts_with_condition\",\n+        \"supports_excluded_expression\",\n+    )\n+    def test_bulk_create_with_complex_excluded_expression(self):\n+        initial_items = [\n+            UpsertConflict(number=1, rank=3, name=\"John\"),\n+            UpsertConflict(number=2, rank=5, name=\"Mary\"),\n+            UpsertConflict(number=3, rank=4, name=\"EmmaAlice\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(initial_items)\n+        updated_items = [\n+            UpsertConflict(number=1, rank=5, name=\"Steve\"),\n+            UpsertConflict(number=2, rank=4, name=\"Olivia\"),\n+            UpsertConflict(number=3, rank=6, name=\"Emma\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(\n+            updated_items,\n+            update_conflicts=True,\n+            update_fields=[\"name\", \"rank\"],\n+            unique_fields=[\"number\"],\n+            condition=(\n+                Q(rank__gt=F(\"number\") + 1) & Q(rank__lt=Excluded(\"rank\"))\n+                | Q(name__startswith=Excluded(\"name\"))\n+            ),\n+        )\n+        self.assertEqual(UpsertConflict.objects.get(number=1).name, \"Steve\")\n+        self.assertEqual(UpsertConflict.objects.get(number=2).name, \"Mary\")\n+        self.assertEqual(UpsertConflict.objects.get(number=3).name, \"Emma\")\n+\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts_with_condition\",\n+        \"supports_excluded_expression\",\n+    )\n+    def test_bulk_create_with_arithmetic_excluded_expression(self):\n+        initial_items = [\n+            UpsertConflict(number=1, rank=5, name=\"John\"),\n+            UpsertConflict(number=2, rank=2, name=\"Mary\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(initial_items)\n+        updated_items = [\n+            UpsertConflict(number=1, rank=3, name=\"Steve\"),\n+            UpsertConflict(number=2, rank=4, name=\"Olivia\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(\n+            updated_items,\n+            update_conflicts=True,\n+            update_fields=[\"name\", \"rank\"],\n+            unique_fields=[\"number\"],\n+            condition=Q(rank__gt=Excluded(\"rank\") + 1),\n+        )\n+        self.assertEqual(UpsertConflict.objects.get(number=1).name, \"Steve\")\n+        self.assertEqual(UpsertConflict.objects.get(number=2).name, \"Mary\")\n+\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"supports_update_conflicts_with_condition\"\n+    )\n+    @skipIfDBFeature(\"supports_excluded_expression\")\n+    def test_excluded_not_supported(self):\n+        bulk_create_kwargs = {\n+            \"update_conflicts\": True,\n+            \"update_fields\": [\"name\", \"rank\"],\n+            \"condition\": Q(rank__lt=Excluded(\"rank\")),\n+        }\n+        if connection.features.supports_update_conflicts_with_target:\n+            bulk_create_kwargs[\"unique_fields\"] = [\"number\"]\n+        msg = (\n+            f\"{connection.vendor} doesn't support partial updating rows on \"\n+            \"conflicts during INSERT\"\n+        )\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            UpsertConflict.objects.bulk_create(\n+                [UpsertConflict(number=1, rank=1, name=\"Steve\")], **bulk_create_kwargs\n+            )\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Thanks for the work on this feature; it’s valuable. However, the current approach still relies too heavily on backend-specific SQL, which raises security risks, particularly around SQL injection. The primary focus should be enhancing the `where_clause` support for passing expressions rather than hardcoding for `F` and `Q`. Addressing PostgreSQL’s `EXCLUDED` is also key—consider subclassing `F` to manage this better. Lastly, ensure all comments in the previous reviews are addressed before moving forward."
      }
    ],
    "token_estimation": 2050.5
  },
  {
    "index": 23,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/docs/ref/models/querysets.txt b/docs/ref/models/querysets.txt\nindex c7ab413f5337..e46e57c6643c 100644\n--- a/docs/ref/models/querysets.txt\n+++ b/docs/ref/models/querysets.txt\n@@ -264,6 +264,78 @@ control the name of the annotation::\n For an in-depth discussion of aggregation, see :doc:`the topic guide on\n Aggregation </topics/db/aggregation>`.\n \n+\n+.. currentmodule:: django.db.models.query\n+\n+.. class:: FilteredRelation(relation_name, condition=Q())\n+\n+    .. versionadded:: 2.0\n+    .. attribute:: FilteredRelation.relation_name\n+\n+        The name of the field on which you'd like to filter the relation.\n+    .. attribute:: FilteredRelation.condition\n+\n+        A :class:`~django.db.models.Q` object to control the filtering.\n+\n+Annotate supports also a new kind of argument that is an instance of\n+:class:`.FilteredRelation`.\n+\n+This kind of parameter allows to pass filtering options inside the the ``ON``\n+clause when a ``JOIN`` is performed.\n+It does not act on the default relationship but on the given ``alias`` given\n+as name of the parameter (``pizzas_vegetarian`` in example below).\n+\n+Example::\n+\n+    >>> from django.db.models import FilteredRelation\n+    >>> Restaurant.objects.annotate(\n+    ...    pizzas_vegetarian=FilteredRelation(\n+    ...        'pizzas', condition=Q(pizzas__vegetarian=True),\n+    ...    )).filter(pizzas_vegetarian__name__icontains='Mozzarella')\n+\n+This query will join the model Restaurant only to Pizzas that have vegetarian\n+flag to True. This results into a performance improvement, noticeable if the\n+join is performed through a large number of rows. Because the filtering from\n+the ``WHERE`` clause will only operate on a subset of Pizzas (the vegetarian\n+ones).\n+\n+.. admonition:: You need to be aware of some limitations\n+\n+    The :class:`.FilteredRelation` can not contain\n+    conditions that span over deep relations.\n+    The condition can only apply on fields that satisfy the constraint\n+    ``Field.is_relation is False``.\n+\n+    Example::\n+\n+        >>> Restaurant.objects.annotate(\n+        ...    pizzas_with_toppings_startswith_n=FilteredRelation(\n+        ...        'pizzas__toppings',\n+        ...        condition=Q(pizzas__toppings__name__startswith='n'),\n+        ...     )).filter(pizzas_with_toppings_startswith_n__isnull=False)\n+\n+    Will raise ``ValueError`` \"Filtered relation\n+    'pizzas_with_toppings_startswith_n' cannot operate on foreign key\n+    'pizzas__toppings'\".\n+\n+.. admonition:: :meth:`~.QuerySet.prefetch_related()` is not supported\n+\n+    If you try to use :meth:`~.QuerySet.prefetch_related()` with a\n+    FilteredRelation alias, ``ValueError`` will be raised, with the following\n+    message::\n+\n+        \"prefetch_related() is not supported with filtered relation 'alias'\"\n+\n+\n+.. admonition:: :meth:`~.QuerySet.only()` is not supported\n+\n+    If you try to use :meth:`~.QuerySet.only()` with a FilteredRelation alias,\n+    ``ValueError`` will be raised, with the following message::\n+\n+        \"only() is not supported with filtered relation 'alias'\"\n+\n+.. currentmodule:: django.db.models.query.QuerySet\n+\n ``order_by()``\n ~~~~~~~~~~~~~~\n \ndiff --git a/tests/filtered_relation/models.py b/tests/filtered_relation/models.py\nnew file mode 100644\nindex 000000000000..c4233a69f8a3\n--- /dev/null\n+++ b/tests/filtered_relation/models.py\n@@ -0,0 +1,100 @@\n+from django.db import models\n+\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=50, unique=True)\n+    favourite_books = models.ManyToManyField(\n+        'Book',\n+        related_name='preferred_by_authors',\n+        related_query_name='preferred_by_authors',\n+    )\n+\n+    def __str__(self):\n+        return self.name\n+\n+\n+class Editor(models.Model):\n+    name = models.CharField(max_length=255)\n+\n+    def __str__(self):\n+        return self.name\n+\n+\n+class Book(models.Model):\n+    AVAILABLE = 'available'\n+    RESERVED = 'reserved'\n+    RENTED = 'rented'\n+    STATES = (\n+        (AVAILABLE, 'Available'),\n+        (RESERVED, 'reserved'),\n+        (RENTED, 'Rented'),\n+    )\n+    title = models.CharField(max_length=255)\n+    author = models.ForeignKey(\n+        Author,\n+        models.CASCADE,\n+        related_name='books',\n+        related_query_name='book',\n+    )\n+    editor = models.ForeignKey(Editor, models.CASCADE)\n+    state = models.CharField(max_length=9, choices=STATES, default=AVAILABLE)\n+\n+    def __str__(self):\n+        return self.title\n+\n+\n+class Borrower(models.Model):\n+    name = models.CharField(max_length=50, unique=True)\n+\n+    def __str__(self):\n+        return self.name\n+\n+\n+class Reservation(models.Model):\n+    NEW = 'new'\n+    STOPPED = 'stopped'\n+    STATES = (\n+        (NEW, 'New'),\n+        (STOPPED, 'Stopped'),\n+    )\n+    borrower = models.ForeignKey(\n+        Borrower,\n+        models.CASCADE,\n+        related_name='reservations',\n+        related_query_name='reservation',\n+    )\n+    book = models.ForeignKey(\n+        Book,\n+        models.CASCADE,\n+        related_name='reservations',\n+        related_query_name='reservation',\n+    )\n+    state = models.CharField(max_length=7, choices=STATES, default=NEW)\n+\n+    def __str__(self):\n+        return '-'.join((self.book.name, self.borrower.name, self.state))\n+\n+\n+class RentalSession(models.Model):\n+    NEW = 'new'\n+    STOPPED = 'stopped'\n+    STATES = (\n+        (NEW, 'New'),\n+        (STOPPED, 'Stopped'),\n+    )\n+    borrower = models.ForeignKey(\n+        Borrower,\n+        models.CASCADE,\n+        related_name='rental_sessions',\n+        related_query_name='rental_session',\n+    )\n+    book = models.ForeignKey(\n+        Book,\n+        models.CASCADE,\n+        related_name='rental_sessions',\n+        related_query_name='rental_session',\n+    )\n+    state = models.CharField(max_length=7, choices=STATES, default=NEW)\n+\n+    def __str__(self):\n+        return '-'.join((self.book.name, self.borrower.name, self.state))\ndiff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py\nnew file mode 100644\nindex 000000000000..9a11ceeab086\n--- /dev/null\n+++ b/tests/filtered_relation/tests.py\n@@ -0,0 +1,367 @@\n+from django.db import connection\n+from django.db.models import Case, Count, F, FilteredRelation, Q, When\n+from django.test import TestCase\n+from django.test.testcases import skipUnlessDBFeature\n+\n+from .models import Author, Book, Borrower, Editor, RentalSession, Reservation\n+\n+\n+class FilteredRelationTests(TestCase):\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.author1 = Author.objects.create(name='Alice')\n+        cls.author2 = Author.objects.create(name='Jane')\n+\n+        cls.editor_a = Editor.objects.create(name='a')\n+        cls.editor_b = Editor.objects.create(name='b')\n+\n+        cls.book1 = Book.objects.create(\n+            title='Poem by Alice',\n+            editor=cls.editor_a,\n+            author=cls.author1,\n+        )\n+\n+        cls.book2 = Book.objects.create(\n+            title='The book by Jane A',\n+            editor=cls.editor_b,\n+            author=cls.author2,\n+        )\n+\n+        cls.book3 = Book.objects.create(\n+            title='The book by Jane B',\n+            editor=cls.editor_b,\n+            author=cls.author2,\n+        )\n+\n+        cls.book4 = Book.objects.create(\n+            title='The book by Alice',\n+            editor=cls.editor_a,\n+            author=cls.author1,\n+        )\n+        cls.author1.favourite_books.add(cls.book2)\n+        cls.author1.favourite_books.add(cls.book3)\n+\n+    def test_filtered_relation_select_related(self):\n+        qs = Author.objects.annotate(\n+            book_join=FilteredRelation('book', condition=Q())\n+        ).select_related('book_join__editor').order_by('pk', 'book_join__pk')\n+        with self.assertNumQueries(1):\n+            expected = [\n+                (self.author1, self.book1, self.editor_a, self.author1),\n+                (self.author1, self.book4, self.editor_a, self.author1),\n+                (self.author2, self.book2, self.editor_b, self.author2),\n+                (self.author2, self.book3, self.editor_b, self.author2),\n+            ]\n+            self.assertQuerysetEqual(\n+                qs, expected, lambda x: (x, x.book_join, x.book_join.editor, x.book_join.author)\n+            )\n+\n+    def test_filtered_relation_select_related_foreign_key(self):\n+        # this doesn't make much sense, but let's have it anyways...\n+        qs = Book.objects.annotate(\n+            author_join=FilteredRelation('author', condition=Q())\n+        ).select_related('author_join').order_by('pk')\n+        with self.assertNumQueries(1):\n+            expected = [\n+                (self.book1, self.author1),\n+                (self.book2, self.author2),\n+                (self.book3, self.author2),\n+                (self.book4, self.author1),\n+            ]\n+            self.assertQuerysetEqual(\n+                qs, expected, lambda x: (x, x.author_join)\n+            )\n+\n+    def test_filtered_relation_wo_join(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation(\n+                    'book', condition=Q(book__title__iexact='poem by alice'),\n+                )), [self.author1, self.author2])\n+\n+    def test_filered_relation_with_join(self):\n+        self.assertQuerysetEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation(\n+                    'book', condition=Q(book__title__iexact='poem by alice'),\n+                )).filter(book_alice__isnull=False), [\"<Author: Alice>\"])\n+\n+    def test_filtered_relation_alias_mapping_other(self):\n+        queryset = Author.objects.annotate(\n+            book_alice=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='poem by alice'),\n+            )).filter(book_alice__isnull=False)\n+        self.assertIn(\n+            'INNER JOIN {} book_alice ON'.format(\n+                connection.ops.quote_name('filtered_relation_book'),\n+            ),\n+            str(queryset.query))\n+\n+    def test_filtered_relation_with_multiple_filter(self):\n+        self.assertQuerysetEqual(\n+            Author.objects.annotate(\n+                book_editor_a=FilteredRelation(\n+                    'book', condition=Q(book__title__icontains='book',\n+                                        book__editor_id=self.editor_a.pk),\n+                )).filter(book_editor_a__isnull=False), [\"<Author: Alice>\"])\n+\n+    def test_filtered_relation_multiple_times(self):\n+        self.assertQuerysetEqual(\n+            Author.objects.annotate(\n+                book_title_alice=FilteredRelation(\n+                    'book', condition=Q(book__title__icontains='alice'),\n+                )).filter(book_title_alice__isnull=False).filter(book_title_alice__isnull=False).distinct(),\n+            [\"<Author: Alice>\"])\n+\n+    def test_exclude_relation_with_join(self):\n+        self.assertQuerysetEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation(\n+                    'book', condition=~Q(book__title__icontains='alice'),\n+                )).filter(book_alice__isnull=False).distinct(),\n+            [\"<Author: Jane>\"])\n+\n+    def test_filtered_relation_with_m2m(self):\n+        qs = Author.objects.annotate(\n+            favourite_books_written_by_jane=FilteredRelation(\n+                'favourite_books', condition=Q(favourite_books__in=[self.book2]),\n+            )).filter(favourite_books_written_by_jane__isnull=False)\n+        self.assertQuerysetEqual(qs, [\"<Author: Alice>\"])\n+\n+    def test_filtered_relation_with_m2m_deep(self):\n+        qs = Author.objects.annotate(\n+            favourite_books_written_by_jane=FilteredRelation(\n+                'favourite_books', condition=Q(favourite_books__author=self.author2),\n+            )).filter(favourite_books_written_by_jane__title='The book by Jane B')\n+        self.assertQuerysetEqual(qs, [\"<Author: Alice>\"])\n+\n+    def test_filtered_relation_with_m2m_multijoin(self):\n+        qs = Author.objects.annotate(\n+            favourite_books_written_by_jane=FilteredRelation(\n+                'favourite_books', condition=Q(favourite_books__author=self.author2),\n+            )).filter(favourite_books_written_by_jane__editor__name='b').distinct()\n+        self.assertQuerysetEqual(qs, [\"<Author: Alice>\"])\n+\n+    def test_filtered_relation_values_list(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation(\n+                    'book', condition=Q(book__title__iexact='poem by alice'),\n+                )).filter(book_alice__isnull=False).values_list(\n+                    'book_alice__title', flat=True),\n+            [\"Poem by Alice\"])\n+\n+    def test_filtered_relation_values(self):\n+        self.assertSequenceEqual(Author.objects.annotate(\n+            book_alice=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='poem by alice'),\n+            )).filter(book_alice__isnull=False).values(),\n+            [{'id': 1, 'name': 'Alice'}])\n+\n+    def test_filtered_relation_extra(self):\n+        self.assertSequenceEqual(Author.objects.annotate(\n+            book_alice=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='poem by alice'),\n+            )).filter(book_alice__isnull=False).extra(\n+                where=[\"1 = 1\"]),\n+            [self.author1])\n+\n+    @skipUnlessDBFeature('supports_select_union')\n+    def test_filtered_relation_union(self):\n+        qs1 = Author.objects.annotate(\n+            book_alice=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='poem by alice'),\n+            )).filter(book_alice__isnull=False)\n+        qs2 = Author.objects.annotate(\n+            book_jane=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='the book by jane a'),\n+            )).filter(book_jane__isnull=False)\n+        self.assertSequenceEqual(qs1.union(qs2), [self.author1, self.author2])\n+\n+    @skipUnlessDBFeature('supports_select_intersection')\n+    def test_filtered_relation_intersection(self):\n+        qs1 = Author.objects.annotate(\n+            book_alice=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='poem by alice'),\n+            )).filter(book_alice__isnull=False)\n+        qs2 = Author.objects.annotate(\n+            book_jane=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='the book by jane a'),\n+            )).filter(book_jane__isnull=False)\n+        self.assertQuerysetEqual(qs1.intersection(qs2), [])\n+\n+    @skipUnlessDBFeature('supports_select_difference')\n+    def test_filtered_relation_difference(self):\n+        qs1 = Author.objects.annotate(\n+            book_alice=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='poem by alice'),\n+            )).filter(book_alice__isnull=False)\n+        qs2 = Author.objects.annotate(\n+            book_jane=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='the book by jane a'),\n+            )).filter(book_jane__isnull=False)\n+        self.assertSequenceEqual(qs1.difference(qs2), [self.author1])\n+\n+    def test_filtered_relation_select_for_update(self):\n+        self.assertQuerysetEqual(Author.objects.annotate(\n+            book_jane=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='the book by jane a'),\n+            )).filter(book_jane__isnull=False).select_for_update(),\n+            ['<Author: Jane>'])\n+\n+    def test_filtered_relation_defer(self):\n+        # One query for the list, and one query to fetch the\n+        # deferred title.\n+        with self.assertNumQueries(2):\n+            self.assertQuerysetEqual(Author.objects.annotate(\n+                book_alice=FilteredRelation(\n+                    'book', condition=Q(book__title__iexact='poem by alice'),\n+                )).filter(book_alice__isnull=False).select_related(\n+                    'book_alice').defer('book_alice__title'),\n+                [\"Poem by Alice\"], lambda author: author.book_alice.title)\n+\n+    def test_filtered_relation_only_not_supported(self):\n+        msg = \"only() is not supported with filtered relation 'book_alice'\"\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation(\n+                    'book', condition=Q(book__title__iexact='poem by alice'),\n+                )).filter(book_alice__isnull=False).select_related('book_alice').only(\n+                    'book_alice__state')\n+\n+    def test_filtered_relation_as_subquery(self):\n+        inner_qs = Author.objects.annotate(\n+            book_alice=FilteredRelation(\n+                'book', condition=Q(book__title__iexact='poem by alice'),\n+            )).filter(book_alice__isnull=False)\n+        qs = Author.objects.filter(id__in=inner_qs)\n+        self.assertQuerysetEqual(qs, [\"<Author: Alice>\"])\n+\n+    def test_filtered_relation_with_foreign_key_error(self):\n+        msg = (\"Filtered relation 'alice_favourite_books' cannot operate on foreign key\"\n+               \" 'author__favourite_books__author'.\")\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(\n+                Book.objects.annotate(\n+                    alice_favourite_books=FilteredRelation(\n+                        'author__favourite_books',\n+                        condition=Q(author__favourite_books__author=self.author1),\n+                    )).filter(alice_favourite_books__title__icontains='poem')\n+            )\n+\n+    def test_filtered_relation_with_foreign_key_on_condition_error(self):\n+        msg = (\"Filtered relation 'book_edited_by_b' cannot operate on foreign key\"\n+               \" 'book__editor__name__icontains'.\")\n+        with self.assertRaisesMessage(ValueError, msg):\n+            list(\n+                Author.objects.annotate(\n+                    book_edited_by_b=FilteredRelation(\n+                        'book', condition=Q(book__editor__name__icontains='b'),\n+                    )).filter(book_edited_by_b__isnull=False)\n+            )\n+\n+    def test_filtered_relation_with_empty_relation_name_error(self):\n+        with self.assertRaisesMessage(ValueError, 'relation_name cannot be empty'):\n+            FilteredRelation('', condition=Q(blank=''))\n+\n+    def test_filtered_relation_with_prefetch_related(self):\n+        msg = (\"prefetch_related() is not supported with filtered relation 'book_title_contains_b'\")\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Author.objects.annotate(\n+                book_title_contains_b=FilteredRelation(\n+                    'book',\n+                    condition=Q(book__title__icontains='b'),\n+                )).filter(\n+                    book_title_contains_b__isnull=False\n+            ).prefetch_related('book_title_contains_b')\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Author.objects.annotate(\n+                book_title_contains_b=FilteredRelation(\n+                    'book',\n+                    condition=Q(book__title__icontains='b'),\n+                )).filter(\n+                    book_title_contains_b__isnull=False\n+            ).prefetch_related('book_title_contains_b__editor')\n+\n+\n+class FilteredRelationWithAggregationTests(TestCase):\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.author1 = Author.objects.create(name='Alice')\n+        cls.editor_a = Editor.objects.create(name='a')\n+        cls.book1 = Book.objects.create(\n+            title='Poem by Alice',\n+            editor=cls.editor_a,\n+            author=cls.author1,\n+        )\n+        cls.borrower1 = Borrower.objects.create(name='Jenny')\n+        cls.borrower2 = Borrower.objects.create(name='Kevin')\n+        # borrower 1 reserve, rent and return book1\n+        Reservation.objects.create(\n+            borrower=cls.borrower1,\n+            book=cls.book1,\n+            state=Reservation.STOPPED,\n+        )\n+        RentalSession.objects.create(\n+            borrower=cls.borrower1,\n+            book=cls.book1,\n+            state=RentalSession.STOPPED,\n+        )\n+        # borrower2 reserve, rent and return book1\n+        Reservation.objects.create(\n+            borrower=cls.borrower2,\n+            book=cls.book1,\n+            state=Reservation.STOPPED,\n+        )\n+        RentalSession.objects.create(\n+            borrower=cls.borrower2,\n+            book=cls.book1,\n+            state=RentalSession.STOPPED,\n+        )\n+\n+    def test_filtered_relation_enforce_aggregation_correctness(self):\n+        \"\"\"\n+        Test case that shows how filtered_relation not only improves\n+        performance, but also ensure correctness of results when aggregation\n+        and multiple LEFT JOIN are involved.\n+\n+        Use Case:\n+\n+            Books can be reserved then rented by a borrower.\n+            Each reservation and rental_session are recorded with\n+            Reservation and RentalSession models.\n+            Every time a reservation or a rental session is over,\n+            their state change to 'stopped'.\n+\n+        Goal: Count number of books that are either currently reserved or\n+              rented by borrower1 or available.\n+        \"\"\"\n+        qs = Book.objects.annotate(\n+            is_reserved_or_rented_by=Case(\n+                When(reservation__state=Reservation.NEW, then=F('reservation__borrower__pk')),\n+                When(rental_session__state=RentalSession.NEW, then=F('rental_session__borrower__pk')),\n+                default=None)\n+        ).filter(\n+            Q(is_reserved_or_rented_by=self.borrower1.pk) | Q(state=Book.AVAILABLE)\n+        ).distinct().order_by()  # disable implicit grouping\n+        self.assertEqual(qs.count(), 1)\n+        # If count is equal to 1 we expect also the same aggregation to return the same result\n+        # but it fails by returning 4.\n+        self.assertQuerysetEqual(qs.annotate(total=Count('pk')).values('total'), [\"{'total': 4}\"])\n+\n+        qs = Book.objects.annotate(\n+            active_reservations=FilteredRelation(\n+                'reservation', condition=Q(reservation__state=Reservation.NEW,\n+                                           reservation__borrower=self.borrower1),\n+            )).annotate(\n+                active_rental_sessions=FilteredRelation(\n+                    'rental_session', condition=Q(rental_session__state=RentalSession.NEW,\n+                                                  rental_session__borrower=self.borrower1),\n+                )).filter((Q(active_reservations__isnull=False) |\n+                           Q(active_rental_sessions__isnull=False)) |\n+                          Q(state=Book.AVAILABLE)).distinct().order_by()  # disable implicit grouping\n+        self.assertEqual(qs.count(), 1)\n+        # Thanks to FilteredRelation the aggregation is now correct\n+        self.assertQuerysetEqual(qs.annotate(total=Count('pk')).values('total'), [\"{'total': 1}\"])\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The suggestion to allow specifying join types in `filtered_relation` could enhance usability for common scenarios. However, we should aim for simplicity. Defaulting to LEFT joins makes sense, given the potential complexity with INNER joins via filters. Testing is crucial, especially for NOT NULL cases and split exclude behavior. Consider simplifying the API to promote a single join per relation. It might be best to leave `select_related` integration for future discussion once `filtered_relation` stabilizes. Let's ensure we cover necessary tests and document any limitations clearly."
      }
    ],
    "token_estimation": 5880.75
  },
  {
    "index": 24,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 86b1631f6707..187441692868 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -466,7 +466,69 @@ def _prepare_for_bulk_create(self, objs):\n                 obj.pk = obj._meta.pk.get_pk_value_on_save(obj)\n             obj._prepare_related_fields_for_save(operation_name='bulk_create')\n \n-    def bulk_create(self, objs, batch_size=None, ignore_conflicts=False):\n+    def _check_bulk_create_options(self, ignore_conflicts, update_conflicts, update_fields, unique_fields):\n+        if ignore_conflicts and update_conflicts:\n+            raise ValueError(\n+                'ignore_conflicts and update_conflicts are mutually exclusive.'\n+            )\n+        db_features = connections[self.db].features\n+        if ignore_conflicts:\n+            if not db_features.supports_ignore_conflicts:\n+                raise NotSupportedError(\n+                    'This database backend does not support ignoring conflicts.'\n+                )\n+            return OnConflict.IGNORE\n+        elif update_conflicts:\n+            if not db_features.supports_update_conflicts:\n+                raise NotSupportedError(\n+                    'This database backend does not support updating conflicts.'\n+                )\n+            if not update_fields:\n+                raise ValueError(\n+                    'Fields that will be updated when a row insertion fails '\n+                    'on conflicts must be provided.'\n+                )\n+            if unique_fields and not db_features.supports_update_conflicts_with_target:\n+                raise NotSupportedError(\n+                    'This database backend does not support updating '\n+                    'conflicts with specifying unique fields that can trigger '\n+                    'the upsert.'\n+                )\n+            if not unique_fields and db_features.supports_update_conflicts_with_target:\n+                raise ValueError(\n+                    'Unique fields that can trigger the upsert must be '\n+                    'provided.'\n+                )\n+            # Updating primary keys and non-concrete fields is forbidden.\n+            update_fields = [self.model._meta.get_field(name) for name in update_fields]\n+            if any(not f.concrete or f.many_to_many for f in update_fields):\n+                raise ValueError(\n+                    'bulk_create() can only be used with concrete fields in '\n+                    'update_fields.'\n+                )\n+            if any(f.primary_key for f in update_fields):\n+                raise ValueError(\n+                    'bulk_create() cannot be used with primary keys in '\n+                    'update_fields.'\n+                )\n+            if unique_fields:\n+                # Primary key is allowed in unique_fields.\n+                unique_fields = [\n+                    self.model._meta.get_field(name)\n+                    for name in unique_fields if name != 'pk'\n+                ]\n+                if any(not f.concrete or f.many_to_many for f in unique_fields):\n+                    raise ValueError(\n+                        'bulk_create() can only be used with concrete fields '\n+                        'in unique_fields.'\n+                    )\n+            return OnConflict.UPDATE\n+        return None\n+\n+    def bulk_create(\n+        self, objs, batch_size=None, ignore_conflicts=False,\n+        update_conflicts=False, update_fields=None, unique_fields=None,\n+    ):\n         \"\"\"\n         Insert each of the instances into the database. Do *not* call\n         save() on each of the instances, do not send any pre/post_save\n\ndiff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex 2ee54c382fcf..7e5ff323804d 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -352,3 +357,276 @@ def test_invalid_batch_size_exception(self):\n         msg = 'Batch size must be a positive integer.'\n         with self.assertRaisesMessage(ValueError, msg):\n             Country.objects.bulk_create([], batch_size=-1)\n+\n+    @skipIfDBFeature('supports_update_conflicts')\n+    def test_update_conflicts_unsupported(self):\n+        msg = 'This database backend does not support updating conflicts.'\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Country.objects.bulk_create(self.data, update_conflicts=True)\n+\n+    @skipUnlessDBFeature('supports_ignore_conflicts', 'supports_update_conflicts')\n+    def test_ignore_update_conflicts_exclusive(self):\n+        msg = 'ignore_conflicts and update_conflicts are mutually exclusive'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Country.objects.bulk_create(\n+                self.data,\n+                ignore_conflicts=True,\n+                update_conflicts=True,\n+            )\n+\n+    @skipUnlessDBFeature('supports_update_conflicts')\n+    def test_update_conflicts_no_update_fields(self):\n+        msg = (\n+            'Fields that will be updated when a row insertion fails on '\n+            'conflicts must be provided.'\n+        )\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Country.objects.bulk_create(self.data, update_conflicts=True)\n+\n+    @skipUnlessDBFeature('supports_update_conflicts')\n+    @skipIfDBFeature('supports_update_conflicts_with_target')\n+    def test_update_conflicts_unique_field_unsupported(self):\n+        msg = (\n+            'This database backend does not support updating conflicts with '\n+            'specifying unique fields that can trigger the upsert.'\n+        )\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            TwoFields.objects.bulk_create(\n+                [TwoFields(f1=1, f2=1), TwoFields(f1=2, f2=2)],\n+                update_conflicts=True,\n+                update_fields=['f2'],\n+                unique_fields=['f1'],\n+            )\n+\n+    @skipUnlessDBFeature('supports_update_conflicts')\n+    def test_update_conflicts_nonexistent_update_fields(self):\n+        unique_fields = None\n+        if connection.features.supports_update_conflicts_with_target:\n+            unique_fields = ['f1']\n+        msg = \"TwoFields has no field named 'nonexistent'\"\n+        with self.assertRaisesMessage(FieldDoesNotExist, msg):\n+            TwoFields.objects.bulk_create(\n+                [TwoFields(f1=1, f2=1), TwoFields(f1=2, f2=2)],\n+                update_conflicts=True,\n+                update_fields=['nonexistent'],\n+                unique_fields=unique_fields,\n+            )\n+\n+    @skipUnlessDBFeature(\n+        'supports_update_conflicts', 'supports_update_conflicts_with_target',\n+    )\n+    def test_update_conflicts_unique_fields_required(self):\n+        msg = 'Unique fields that can trigger the upsert must be provided.'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            TwoFields.objects.bulk_create(\n+                [TwoFields(f1=1, f2=1), TwoFields(f1=2, f2=2)],\n+                update_conflicts=True,\n+                update_fields=['f1'],\n+            )\n+\n+    @skipUnlessDBFeature(\n+        'supports_update_conflicts', 'supports_update_conflicts_with_target',\n+    )\n+    def test_update_conflicts_invalid_update_fields(self):\n+        msg = (\n+            'bulk_create() can only be used with concrete fields in '\n+            'update_fields.'\n+        )\n+        # Reverse one-to-one relationship.\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Country.objects.bulk_create(\n+                self.data,\n+                update_conflicts=True,\n+                update_fields=['relatedmodel'],\n+                unique_fields=['pk'],\n+            )\n+        # Many-to-many relationship.\n+        with self.assertRaisesMessage(ValueError, msg):\n+            RelatedModel.objects.bulk_create(\n+                [RelatedModel(country=self.data[0])],\n+                update_conflicts=True,\n+                update_fields=['big_auto_fields'],\n+                unique_fields=['country'],\n+            )\n+\n+    @skipUnlessDBFeature(\n+        'supports_update_conflicts', 'supports_update_conflicts_with_target',\n+    )\n+    def test_update_conflicts_pk_in_update_fields(self):\n+        msg = 'bulk_create() cannot be used with primary keys in update_fields.'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            BigAutoFieldModel.objects.bulk_create(\n+                [BigAutoFieldModel()],\n+                update_conflicts=True,\n+                update_fields=['id'],\n+                unique_fields=['id'],\n+            )\n+\n+    @skipUnlessDBFeature(\n+        'supports_update_conflicts', 'supports_update_conflicts_with_target',\n+    )\n+    def test_update_conflicts_invalid_unique_fields(self):\n+        msg = (\n+            'bulk_create() can only be used with concrete fields in '\n+            'unique_fields.'\n+        )\n+        # Reverse one-to-one relationship.\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Country.objects.bulk_create(\n+                self.data,\n+                update_conflicts=True,\n+                update_fields=['name'],\n+                unique_fields=['relatedmodel'],\n+            )\n+        # Many-to-many relationship.\n+        with self.assertRaisesMessage(ValueError, msg):\n+            RelatedModel.objects.bulk_create(\n+                [RelatedModel(country=self.data[0])],\n+                update_conflicts=True,\n+                update_fields=['name'],\n+                unique_fields=['big_auto_fields'],\n+            )\n+\n+    def _test_update_conflicts_two_fields(self, unique_fields):\n+        TwoFields.objects.bulk_create([\n+            TwoFields(f1=1, f2=1, name='a'),\n+            TwoFields(f1=2, f2=2, name='b'),\n+        ])\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name='c'),\n+            TwoFields(f1=2, f2=2, name='d'),\n+        ]\n+        TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=unique_fields,\n+            update_fields=['name'],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(TwoFields.objects.values('f1', 'f2', 'name'), [\n+            {'f1': 1, 'f2': 1, 'name': 'c'},\n+            {'f1': 2, 'f2': 2, 'name': 'd'},\n+        ])\n+\n+    @skipUnlessDBFeature('supports_update_conflicts', 'supports_update_conflicts_with_target')\n+    def test_update_conflicts_two_fields_unique_fields_first(self):\n+        self._test_update_conflicts_two_fields(['f1'])\n+\n+    @skipUnlessDBFeature('supports_update_conflicts', 'supports_update_conflicts_with_target')\n+    def test_update_conflicts_two_fields_unique_fields_second(self):\n+        self._test_update_conflicts_two_fields(['f2'])\n+\n+    @skipUnlessDBFeature('supports_update_conflicts', 'supports_update_conflicts_with_target')\n+    def test_update_conflicts_two_fields_unique_fields_both(self):\n+        with self.assertRaises((OperationalError, ProgrammingError)):\n+            self._test_update_conflicts_two_fields(['f1', 'f2'])\n+\n+    @skipUnlessDBFeature('supports_update_conflicts')\n+    @skipIfDBFeature('supports_update_conflicts_with_target')\n+    def test_update_conflicts_two_fields_no_unique_fields(self):\n+        self._test_update_conflicts_two_fields([])\n+\n+    def _test_update_conflicts_unique_two_fields(self, unique_fields):\n+        Country.objects.bulk_create(self.data)\n+        self.assertEqual(Country.objects.count(), 4)\n+\n+        new_data = [\n+            # Conflicting countries.\n+            Country(name='Germany', iso_two_letter='DE', description=(\n+                'Germany is a country in Central Europe.'\n+            )),\n+            Country(name='Czech Republic', iso_two_letter='CZ', description=(\n+                'The Czech Republic is a landlocked country in Central Europe.'\n+            )),\n+            # New countries.\n+            Country(name='Australia', iso_two_letter='AU'),\n+            Country(name='Japan', iso_two_letter='JP', description=(\n+                'Japan is an island country in East Asia.'\n+            )),\n+        ]\n+        Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=['description'],\n+            unique_fields=unique_fields,\n+        )\n+        self.assertEqual(Country.objects.count(), 6)\n+        self.assertCountEqual(Country.objects.values('iso_two_letter', 'description'), [\n+            {'iso_two_letter': 'US', 'description': ''},\n+            {'iso_two_letter': 'NL', 'description': ''},\n+            {'iso_two_letter': 'DE', 'description': (\n+                'Germany is a country in Central Europe.'\n+            )},\n+            {'iso_two_letter': 'CZ', 'description': (\n+                'The Czech Republic is a landlocked country in Central Europe.'\n+            )},\n+            {'iso_two_letter': 'AU', 'description': ''},\n+            {'iso_two_letter': 'JP', 'description': (\n+                'Japan is an island country in East Asia.'\n+            )},\n+        ])\n+\n+    @skipUnlessDBFeature('supports_update_conflicts', 'supports_update_conflicts_with_target')\n+    def test_update_conflicts_unique_two_fields_unique_fields_both(self):\n+        self._test_update_conflicts_unique_two_fields(['iso_two_letter', 'name'])\n+\n+    @skipUnlessDBFeature('supports_update_conflicts', 'supports_update_conflicts_with_target')\n+    def test_update_conflicts_unique_two_fields_unique_fields_one(self):\n+        with self.assertRaises((OperationalError, ProgrammingError)):\n+            self._test_update_conflicts_unique_two_fields(['iso_two_letter'])\n+\n+    @skipUnlessDBFeature('supports_update_conflicts')\n+    @skipIfDBFeature('supports_update_conflicts_with_target')\n+    def test_update_conflicts_unique_two_fields_unique_no_unique_fields(self):\n+        self._test_update_conflicts_unique_two_fields([])\n+\n+    def _test_update_conflicts(self, unique_fields):\n+        UpsertConflict.objects.bulk_create([\n+            UpsertConflict(number=1, rank=1, name='John'),\n+            UpsertConflict(number=2, rank=2, name='Mary'),\n+            UpsertConflict(number=3, rank=3, name='Hannah'),\n+        ])\n+        self.assertEqual(UpsertConflict.objects.count(), 3)\n+\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=4, name='Steve'),\n+            UpsertConflict(number=2, rank=2, name='Olivia'),\n+            UpsertConflict(number=3, rank=1, name='Hannah'),\n+        ]\n+        UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            update_fields=['name', 'rank'],\n+            unique_fields=unique_fields,\n+        )\n+        self.assertEqual(UpsertConflict.objects.count(), 3)\n+        self.assertCountEqual(UpsertConflict.objects.values('number', 'rank', 'name'), [\n+            {'number': 1, 'rank': 4, 'name': 'Steve'},\n+            {'number': 2, 'rank': 2, 'name': 'Olivia'},\n+            {'number': 3, 'rank': 1, 'name': 'Hannah'},\n+        ])\n+\n+        UpsertConflict.objects.bulk_create(\n+            conflicting_objects + [UpsertConflict(number=4, rank=4, name='Mark')],\n+            update_conflicts=True,\n+            update_fields=['name', 'rank'],\n+            unique_fields=unique_fields,\n+        )\n+        self.assertEqual(UpsertConflict.objects.count(), 4)\n+        self.assertCountEqual(UpsertConflict.objects.values('number', 'rank', 'name'), [\n+            {'number': 1, 'rank': 4, 'name': 'Steve'},\n+            {'number': 2, 'rank': 2, 'name': 'Olivia'},\n+            {'number': 3, 'rank': 1, 'name': 'Hannah'},\n+            {'number': 4, 'rank': 4, 'name': 'Mark'},\n+        ])\n+\n+    @skipUnlessDBFeature('supports_update_conflicts', 'supports_update_conflicts_with_target')\n+    def test_update_conflicts_unique_fields(self):\n+        self._test_update_conflicts(unique_fields=['number'])\n+\n+    @skipUnlessDBFeature('supports_update_conflicts')\n+    @skipIfDBFeature('supports_update_conflicts_with_target')\n+    def test_update_conflicts_no_unique_fields(self):\n+        self._test_update_conflicts([])\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The proposed approach to the API needs careful consideration. Using a boolean flag for `update_conflicts` may not provide the necessary granularity for handling unique constraints across multiple fields. Instead, a more flexible design, akin to `QuerySet.update()`, could better support varied update behaviors, like incrementing fields on conflict. Additionally, clarity around how `ON CONFLICT` interacts with different databases is crucial. Overall, enhancing the conflict handling options could significantly improve usability while maintaining alignment with SQL standards."
      }
    ],
    "token_estimation": 4182.0
  },
  {
    "index": 25,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/template/base.py b/django/template/base.py\nindex 3e8a59fbe7b7..74b39874106f 100644\n--- a/django/template/base.py\n+++ b/django/template/base.py\n@@ -288,6 +293,57 @@ def get_exception_info(self, exception, token):\n         }\n \n \n+class PartialTemplate:\n+    \"\"\"\n+    A lightweight Template lookalike used for template partials.\n+\n+    Wraps nodelist as a partial, in order to be able to bind context.\n+    \"\"\"\n+\n+    def __init__(self, nodelist, origin, name):\n+        self.nodelist = nodelist\n+        self.origin = origin\n+        self.name = name\n+\n+    def get_exception_info(self, exception, token):\n+        template = self.origin.loader.get_template(self.origin.template_name)\n+        return template.get_exception_info(exception, token)\n+\n+    def find_partial_source(self, full_source, partial_name):\n+        start_match = None\n+        nesting = 0\n+\n+        for match in combined_partial_re.finditer(full_source):\n+            if name := match[\"name\"]:  # Opening tag.\n+                if start_match is None and name == partial_name:\n+                    start_match = match\n+                if start_match is not None:\n+                    nesting += 1\n+            elif start_match is not None:\n+                nesting -= 1\n+                if nesting == 0:\n+                    return full_source[start_match.start() : match.end()]\n+\n+        return \"\"\n+\n+    @property\n+    def source(self):\n+        template = self.origin.loader.get_template(self.origin.template_name)\n+        return self.find_partial_source(template.source, self.name)\n+\n+    def _render(self, context):\n+        return self.nodelist.render(context)\n+\n+    def render(self, context):\n+        with context.render_context.push_state(self):\n+            if context.template is None:\n+                with context.bind_template(self):\n+                    context.template_name = self.name\n+                    return self._render(context)\n+            else:\n+                return self._render(context)\n+\n+\n def linebreak_iter(template_source):\n     yield 0\n     p = template_source.find(\"\\n\")\ndiff --git a/django/template/defaulttags.py b/django/template/defaulttags.py\nindex a20598152c24..121d37605050 100644\n--- a/django/template/defaulttags.py\n+++ b/django/template/defaulttags.py\n@@ -1570,3 +1572,96 @@ def do_with(parser, token):\n     nodelist = parser.parse((\"endwith\",))\n     parser.delete_first_token()\n     return WithNode(None, None, nodelist, extra_context=extra_context)\n+\n+\n+class DefinePartialNode(Node):\n+    def __init__(self, partial_name, inline, nodelist):\n+        self.partial_name = partial_name\n+        self.inline = inline\n+        self.nodelist = nodelist\n+\n+    def render(self, context):\n+        return self.nodelist.render(context) if self.inline else \"\"\n+\n+\n+class RenderPartialNode(Node):\n+    def __init__(self, partial_name, partial_mapping):\n+        # Defer lookup of nodelist to runtime.\n+        self.partial_name = partial_name\n+        self.partial_mapping = partial_mapping\n+\n+    def render(self, context):\n+        try:\n+            return self.partial_mapping[self.partial_name].render(context)\n+        except KeyError:\n+            raise TemplateSyntaxError(\n+                f\"Partial '{self.partial_name}' is not defined in the current template.\"\n+            )\n+\n+\n+@register.tag(name=\"partialdef\")\n+def partialdef_func(parser, token):\n+    \"\"\"Declare a partial that can be used later in the template.\n+\n+    Usage::\n+\n+        {% partialdef partial_name %}\n+        Partial content goes here\n+        {% endpartialdef %}\n+\n+    Stores the nodelist in the context under the key \"partial_contents\" and can\n+    be retrieved using the {% partial %} tag.\n+\n+    The optional ``inline`` argument will render the contents of the partial\n+    where it is defined.\n+    \"\"\"\n+    match token.split_contents():\n+        case \"partialdef\", partial_name, \"inline\":\n+            inline = True\n+        case \"partialdef\", partial_name, _:\n+            raise TemplateSyntaxError(\n+                \"The 'inline' argument does not have any parameters; \"\n+                \"either use 'inline' or remove it completely.\"\n+            )\n+        case \"partialdef\", partial_name:\n+            inline = False\n+        case _:\n+            raise TemplateSyntaxError(\"'partialdef' tag requires 2-3 arguments\")\n+\n+    # Parse the content until the end tag.\n+    valid_endpartials = (\"endpartialdef\", f\"endpartialdef {partial_name}\")\n+    nodelist = parser.parse(valid_endpartials)\n+    endpartial = parser.next_token()\n+    if endpartial.contents not in valid_endpartials:\n+        parser.invalid_block_tag(endpartial, \"endpartialdef\", valid_endpartials)\n+\n+    # Store the partial nodelist in the parser.extra_data attribute.\n+    parser.extra_data.setdefault(\"template-partials\", {})\n+    if partial_name in parser.extra_data[\"template-partials\"]:\n+        raise TemplateSyntaxError(\n+            f\"Partial '{partial_name}' is already defined in the \"\n+            f\"'{parser.origin.name}' template.\"\n+        )\n+    parser.extra_data[\"template-partials\"][partial_name] = PartialTemplate(\n+        nodelist, parser.origin, partial_name\n+    )\n+\n+    return DefinePartialNode(partial_name, inline, nodelist)\n+\n+\n+@register.tag(name=\"partial\")\n+def partial_func(parser, token):\n+    \"\"\"\n+    Render a partial that was declared using the {% partialdef %} tag.\n+\n+    Usage::\n+\n+        {% partial partial_name %}\n+    \"\"\"\n+    match token.split_contents():\n+        case \"partial\", partial_name:\n+            extra_data = parser.extra_data\n+            partial_mapping = SubDictionaryWrapper(extra_data, \"template-partials\")\n+            return RenderPartialNode(partial_name, partial_mapping=partial_mapping)\n+        case _:\n+            raise TemplateSyntaxError(\"'partial' tag requires a single argument\")\ndiff --git a/docs/ref/templates/builtins.txt b/docs/ref/templates/builtins.txt\nindex 1eb391d8c0f2..9265243c6adc 100644\n--- a/docs/ref/templates/builtins.txt\n+++ b/docs/ref/templates/builtins.txt\n@@ -957,6 +957,76 @@ output (as a string) inside a variable. This is useful if you want to use\n     {% now \"Y\" as current_year %}\n     {% blocktranslate %}Copyright {{ current_year }}{% endblocktranslate %}\n \n+.. templatetag:: partial\n+\n+``partial``\n+-----------\n+\n+.. versionadded:: 6.0\n+\n+Renders a partial that was defined with :ttag:`partialdef`.\n+\n+Usage:\n+\n+.. code-block:: html+django\n+\n+    {% partial partial_name %}\n+\n+The ``partial_name`` argument is the identifier of the partial to render.\n+\n+Example:\n+\n+.. code-block:: html+django\n+\n+    {% partialdef button %}\n+        <button>Submit</button>\n+    {% endpartialdef %}\n+\n+    {% partial button %}\n+    {% partial button %}\n+    {% partial button %}\n+\n+This example will define a partial named ``button`` and render it three times.\n+\n+.. templatetag:: partialdef\n+\n+``partialdef``\n+--------------\n+\n+.. versionadded:: 6.0\n+\n+Defines a reusable template fragment that can be rendered multiple times within\n+the same template or accessed directly via template loading or inclusion.\n+\n+Usage:\n+\n+.. code-block:: html+django\n+\n+    {% partialdef partial_name %}\n+        <!-- partial content -->\n+    {% endpartialdef %}\n+\n+The ``{% partialdef %}`` tag takes a required ``partial_name`` argument, which\n+is an identifier for the partial:\n+\n+.. code-block:: html+django\n+\n+    {% partialdef card %}\n+        <div class=\"card\">\n+            <h3>{{ title }}</h3>\n+            <p>{{ content }}</p>\n+        </div>\n+    {% endpartialdef %}\n+\n+To define and render a partial immediately in the same place, use the ``inline``\n+option:\n+\n+.. code-block:: html+django\n+\n+    {% partialdef header inline %}\n+        <header>Site Header</header>\n+    {% endpartialdef %}\n+\n .. templatetag:: querystring\n \n ``querystring``\ndiff --git a/docs/ref/templates/language.txt b/docs/ref/templates/language.txt\nindex 16a3682086c4..09d4d4fe6750 100644\n--- a/docs/ref/templates/language.txt\n+++ b/docs/ref/templates/language.txt\n@@ -475,6 +475,143 @@ it also defines the content that fills the hole in the *parent*. If there were\n two similarly-named :ttag:`block` tags in a template, that template's parent\n wouldn't know which one of the blocks' content to use.\n \n+.. _template-partials:\n+\n+Template partials\n+=================\n+\n+.. versionadded:: 6.0\n+\n+Template partials define reusable template fragments within a template file.\n+Partials are self-contained components that you can use multiple times within\n+the same template.\n+\n+Basic syntax\n+------------\n+\n+Define a partial using the :ttag:`partialdef` tag:\n+\n+.. code-block:: html+django\n+\n+    {% partialdef card %}\n+        <div class=\"card\">\n+            <h3>{{ title }}</h3>\n+            <p>{{ content }}</p>\n+        </div>\n+    {% endpartialdef %}\n+\n+For extra readability, you can optionally add the name to your \n+``{% endpartialdef %}`` tag:\n+\n+.. code-block:: html+django\n+\n+    {% partialdef card %}\n+        <div class=\"card\">\n+            <h3>{{ title }}</h3>\n+            <p>{{ content }}</p>\n+        </div>\n+    {% endpartialdef card %}\n+\n+Render the partial using the :ttag:`partial` tag:\n+\n+.. code-block:: html+django\n+\n+    {% partial card %}\n+\n+Fragment reuse\n+--------------\n+\n+Once defined, you can reuse a partial multiple times:\n+\n+.. code-block:: html+django\n+\n+    {% partialdef user-info %}\n+        <div class=\"user\">\n+            <span>{{ user.username }}</span>\n+            <span>{{ user.email }}</span>\n+        </div>\n+    {% endpartialdef %}\n+\n+    {% block content %}\n+        <h2>Authors</h2>\n+        {% for user in authors %}\n+            {% partial user-info %}\n+        {% endfor %}\n+\n+        <h2>Editors</h2>\n+        {% for user in editors %}\n+            {% partial user-info %}\n+        {% endfor %}\n+    {% endblock %}\n+\n+The partial content will be rendered each time the named partial is used,\n+with the current template context.\n+\n+Inline partials\n+---------------\n+\n+Define and render a partial inline using the ``inline`` argument:\n+\n+.. code-block:: html+django\n+\n+    {% partialdef header inline %}\n+        <header class=\"site-header\">\n+            <h1>{{ site_name }}</h1>\n+        </header>\n+    {% endpartialdef %}\n+\n+This defines the partial and renders it immediately in place.\n+\n+Direct partial access\n+---------------------\n+\n+Access partials directly using the ``#`` syntax. In views, use the\n+:func:`~django.shortcuts.render` shortcut:\n+\n+.. code-block:: python\n+\n+    # In views.py\n+    from django.shortcuts import render\n+\n+\n+    def product_card_partial(request, product_id):\n+        product = get_object_or_404(Product, id=product_id)\n+        return render(request, \"products/list.html#product-card\", {\"product\": product})\n+\n+This approach is useful for AJAX responses, HTMX requests, or when you need\n+only a specific part of a template. Use partials with the :ttag:`include` tag:\n+\n+.. code-block:: html+django\n+\n+    {% include \"products/list.html#product-card\" %}\n+\n+Context handling\n+----------------\n+\n+Template partials render with the current template context. They work as\n+expected in loops and with context variables:\n+\n+.. code-block:: html+django\n+\n+    {% partialdef product-card %}\n+        <div class=\"product\" data-id=\"{{ product.id }}\">\n+            <h3>{{ product.name }}</h3>\n+            <p>${{ product.price }}</p>\n+        </div>\n+    {% endpartialdef %}\n+\n+    {% for product in products %}\n+        {% partial product-card %}\n+    {% endfor %}\n+\n+If you need to adjust the context, use the :ttag:`with` tag:\n+\n+.. code-block:: html+django\n+\n+    {% with title=\"Special Offer\" price=product.sale_price %}\n+        {% partial product-card %}\n+    {% endwith %}\n+\n .. _next section: #automatic-html-escaping\n .. _automatic-html-escaping:\n \ndiff --git a/tests/template_tests/syntax_tests/test_partials.py b/tests/template_tests/syntax_tests/test_partials.py\nnew file mode 100644\nindex 000000000000..7809d2c01895\n--- /dev/null\n+++ b/tests/template_tests/syntax_tests/test_partials.py\n@@ -0,0 +1,668 @@\n+from django.template import (\n+    Context,\n+    TemplateDoesNotExist,\n+    TemplateSyntaxError,\n+    VariableDoesNotExist,\n+)\n+from django.template.base import Token, TokenType\n+from django.test import SimpleTestCase\n+from django.views.debug import ExceptionReporter\n+\n+from ..utils import setup\n+\n+partial_templates = {\n+    \"partial_base.html\": (\n+        \"<main>{% block main %}Default main content.{% endblock main %}</main>\"\n+    ),\n+    \"partial_included.html\": (\n+        \"INCLUDED TEMPLATE START\\n\"\n+        \"{% partialdef included-partial %}\\n\"\n+        \"THIS IS CONTENT FROM THE INCLUDED PARTIAL\\n\"\n+        \"{% endpartialdef %}\\n\\n\"\n+        \"Now using the partial: {% partial included-partial %}\\n\"\n+        \"INCLUDED TEMPLATE END\\n\"\n+    ),\n+}\n+\n+valid_partialdef_names = (\n+    \"dot.in.name\",\n+    \"'space in name'\",\n+    \"exclamation!\",\n+    \"@at\",\n+    \"slash/something\",\n+    \"inline\",\n+    \"inline-inline\",\n+    \"INLINE\" \"with+plus\",\n+    \"with&amp\",\n+    \"with%percent\",\n+    \"with,comma\",\n+    \"with:colon\",\n+    \"with;semicolon\",\n+    \"[brackets]\",\n+    \"(parens)\",\n+    \"{curly}\",\n+)\n+\n+\n+def gen_partial_template(name, *args, **kwargs):\n+    if args or kwargs:\n+        extra = \" \".join((args, *(\"{k}={v}\" for k, v in kwargs.items()))) + \" \"\n+    else:\n+        extra = \"\"\n+    return (\n+        f\"{{% partialdef {name} {extra}%}}TEST with {name}!{{% endpartialdef %}}\"\n+        f\"{{% partial {name} %}}\"\n+    )\n+\n+\n+class PartialTagTests(SimpleTestCase):\n+    libraries = {\"bad_tag\": \"template_tests.templatetags.bad_tag\"}\n+\n+    @setup({name: gen_partial_template(name) for name in valid_partialdef_names})\n+    def test_valid_partialdef_names(self):\n+        for template_name in valid_partialdef_names:\n+            with self.subTest(template_name=template_name):\n+                output = self.engine.render_to_string(template_name)\n+                self.assertEqual(output, f\"TEST with {template_name}!\")\n+\n+    @setup(\n+        {\n+            \"basic\": (\n+                \"{% partialdef testing-name %}\"\n+                \"HERE IS THE TEST CONTENT\"\n+                \"{% endpartialdef %}\"\n+                \"{% partial testing-name %}\"\n+            ),\n+            \"basic_inline\": (\n+                \"{% partialdef testing-name inline %}\"\n+                \"HERE IS THE TEST CONTENT\"\n+                \"{% endpartialdef %}\"\n+            ),\n+            \"inline_inline\": (\n+                \"{% partialdef inline inline %}\"\n+                \"HERE IS THE TEST CONTENT\"\n+                \"{% endpartialdef %}\"\n+            ),\n+            \"with_newlines\": (\n+                \"{% partialdef testing-name %}\\n\"\n+                \"HERE IS THE TEST CONTENT\\n\"\n+                \"{% endpartialdef testing-name %}\\n\"\n+                \"{% partial testing-name %}\"\n+            ),\n+        }\n+    )\n+    def test_basic_usage(self):\n+        for template_name in (\n+            \"basic\",\n+            \"basic_inline\",\n+            \"inline_inline\",\n+            \"with_newlines\",\n+        ):\n+            with self.subTest(template_name=template_name):\n+                output = self.engine.render_to_string(template_name)\n+                self.assertEqual(output.strip(), \"HERE IS THE TEST CONTENT\")\n+\n+    @setup(\n+        {\n+            \"inline_partial_with_context\": (\n+                \"BEFORE\\n\"\n+                \"{% partialdef testing-name inline %}\"\n+                \"HERE IS THE TEST CONTENT\"\n+                \"{% endpartialdef %}\\n\"\n+                \"AFTER\"\n+            )\n+        }\n+    )\n+    def test_partial_inline_only_with_before_and_after_content(self):\n+        output = self.engine.render_to_string(\"inline_partial_with_context\")\n+        self.assertEqual(output.strip(), \"BEFORE\\nHERE IS THE TEST CONTENT\\nAFTER\")\n+\n+    @setup(\n+        {\n+            \"inline_partial_explicit_end\": (\n+                \"{% partialdef testing-name inline %}\"\n+                \"HERE IS THE TEST CONTENT\"\n+                \"{% endpartialdef testing-name %}\\n\"\n+                \"{% partial testing-name %}\"\n+            )\n+        }\n+    )\n+    def test_partial_inline_and_used_once(self):\n+        output = self.engine.render_to_string(\"inline_partial_explicit_end\")\n+        self.assertEqual(output, \"HERE IS THE TEST CONTENT\\nHERE IS THE TEST CONTENT\")\n+\n+    @setup(\n+        {\n+            \"inline_partial_with_usage\": (\n+                \"BEFORE\\n\"\n+                \"{% partialdef content_snippet inline %}\"\n+                \"HERE IS THE TEST CONTENT\"\n+                \"{% endpartialdef %}\\n\"\n+                \"AFTER\\n\"\n+                \"{% partial content_snippet %}\"\n+            )\n+        }\n+    )\n+    def test_partial_inline_and_used_once_with_before_and_after_content(self):\n+        output = self.engine.render_to_string(\"inline_partial_with_usage\")\n+        self.assertEqual(\n+            output.strip(),\n+            \"BEFORE\\nHERE IS THE TEST CONTENT\\nAFTER\\nHERE IS THE TEST CONTENT\",\n+        )\n+\n+    @setup(\n+        {\n+            \"partial_used_before_definition\": (\n+                \"TEMPLATE START\\n\"\n+                \"{% partial testing-name %}\\n\"\n+                \"MIDDLE CONTENT\\n\"\n+                \"{% partialdef testing-name %}\\n\"\n+                \"THIS IS THE PARTIAL CONTENT\\n\"\n+                \"{% endpartialdef %}\\n\"\n+                \"TEMPLATE END\"\n+            ),\n+        }\n+    )\n+    def test_partial_used_before_definition(self):\n+        output = self.engine.render_to_string(\"partial_used_before_definition\")\n+        expected = (\n+            \"TEMPLATE START\\n\\nTHIS IS THE PARTIAL CONTENT\\n\\n\"\n+            \"MIDDLE CONTENT\\n\\nTEMPLATE END\"\n+        )\n+        self.assertEqual(output, expected)\n+\n+    @setup(\n+        {\n+            \"partial_with_extends\": (\n+                \"{% extends 'partial_base.html' %}\"\n+                \"{% partialdef testing-name %}Inside Content{% endpartialdef %}\"\n+                \"{% block main %}\"\n+                \"Main content with {% partial testing-name %}\"\n+                \"{% endblock %}\"\n+            ),\n+        },\n+        partial_templates,\n+    )\n+    def test_partial_defined_outside_main_block(self):\n+        output = self.engine.render_to_string(\"partial_with_extends\")\n+        self.assertIn(\"<main>Main content with Inside Content</main>\", output)\n+\n+    @setup(\n+        {\n+            \"partial_with_extends_and_block_super\": (\n+                \"{% extends 'partial_base.html' %}\"\n+                \"{% partialdef testing-name %}Inside Content{% endpartialdef %}\"\n+                \"{% block main %}{{ block.super }} \"\n+                \"Main content with {% partial testing-name %}\"\n+                \"{% endblock %}\"\n+            ),\n+        },\n+        partial_templates,\n+    )\n+    def test_partial_used_with_block_super(self):\n+        output = self.engine.render_to_string(\"partial_with_extends_and_block_super\")\n+        self.assertIn(\n+            \"<main>Default main content. Main content with Inside Content</main>\",\n+            output,\n+        )\n+\n+    @setup(\n+        {\n+            \"partial_with_include\": (\n+                \"MAIN TEMPLATE START\\n\"\n+                \"{% include 'partial_included.html' %}\\n\"\n+                \"MAIN TEMPLATE END\"\n+            )\n+        },\n+        partial_templates,\n+    )\n+    def test_partial_in_included_template(self):\n+        output = self.engine.render_to_string(\"partial_with_include\")\n+        expected = (\n+            \"MAIN TEMPLATE START\\nINCLUDED TEMPLATE START\\n\\n\\n\"\n+            \"Now using the partial: \\n\"\n+            \"THIS IS CONTENT FROM THE INCLUDED PARTIAL\\n\\n\"\n+            \"INCLUDED TEMPLATE END\\n\\nMAIN TEMPLATE END\"\n+        )\n+        self.assertEqual(output, expected)\n+\n+    @setup(\n+        {\n+            \"partial_as_include_in_other_template\": (\n+                \"MAIN TEMPLATE START\\n\"\n+                \"{% include 'partial_included.html#included-partial' %}\\n\"\n+                \"MAIN TEMPLATE END\"\n+            )\n+        },\n+        partial_templates,\n+    )\n+    def test_partial_as_include_in_template(self):\n+        output = self.engine.render_to_string(\"partial_as_include_in_other_template\")\n+        expected = (\n+            \"MAIN TEMPLATE START\\n\\n\"\n+            \"THIS IS CONTENT FROM THE INCLUDED PARTIAL\\n\\n\"\n+            \"MAIN TEMPLATE END\"\n+        )\n+        self.assertEqual(output, expected)\n+\n+    @setup(\n+        {\n+            \"nested_simple\": (\n+                \"{% extends 'base.html' %}\"\n+                \"{% block content %}\"\n+                \"This is my main page.\"\n+                \"{% partialdef outer inline %}\"\n+                \"    It hosts a couple of partials.\"\n+                \"    {% partialdef inner inline %}\"\n+                \"        And an inner one.\"\n+                \"    {% endpartialdef inner %}\"\n+                \"{% endpartialdef outer %}\"\n+                \"{% endblock content %}\"\n+            ),\n+            \"use_outer\": \"{% include 'nested_simple#outer' %}\",\n+            \"use_inner\": \"{% include 'nested_simple#inner' %}\",\n+        }\n+    )\n+    def test_nested_partials(self):\n+        with self.subTest(template_name=\"use_outer\"):\n+            output = self.engine.render_to_string(\"use_outer\")\n+            self.assertEqual(\n+                output.strip(),\n+                \"It hosts a couple of partials.            And an inner one.\",\n+            )\n+        with self.subTest(template_name=\"use_inner\"):\n+            output = self.engine.render_to_string(\"use_inner\")\n+            self.assertEqual(output.strip(), \"And an inner one.\")\n+\n+    @setup(\n+        {\n+            \"partial_undefined_name\": \"{% partial undefined %}\",\n+            \"partial_missing_name\": \"{% partial %}\",\n+            \"partial_closing_tag\": (\n+                \"{% partialdef testing-name %}TEST{% endpartialdef %}\"\n+                \"{% partial testing-name %}{% endpartial %}\"\n+            ),\n+            \"partialdef_opening_closing_name_mismatch\": (\n+                \"{% partialdef testing-name %}TEST{% endpartialdef invalid %}\"\n+            ),\n+            \"duplicated_names\": (\n+                \"{% partialdef testing-name %}TEST{% endpartialdef %}\"\n+                \"{% partialdef testing-name %}TEST{% endpartialdef %}\"\n+                \"{% partial testing-name %}\"\n+            ),\n+            \"duplicated_nested_names\": (\n+                \"{% partialdef testing-name %}\"\n+                \"TEST\"\n+                \"{% partialdef testing-name %}TEST{% endpartialdef %}\"\n+                \"{% endpartialdef %}\"\n+                \"{% partial testing-name %}\"\n+            ),\n+            \"partialdef_invalid_name\": gen_partial_template(\"with\\nnewline\"),\n+        }\n+    )\n+    def test_basic_parse_errors(self):\n+        for template_name, error_msg in (\n+            (\n+                \"partial_undefined_name\",\n+                \"Partial 'undefined' is not defined in the current template.\",\n+            ),\n+            (\"partial_missing_name\", \"'partial' tag requires a single argument\"),\n+            (\"partial_closing_tag\", \"Invalid block tag on line 1: 'endpartial'\"),\n+            (\n+                \"partialdef_opening_closing_name_mismatch\",\n+                \"expected 'endpartialdef' or 'endpartialdef testing-name'.\",\n+            ),\n+            (\n+                \"duplicated_names\",\n+                \"Partial 'testing-name' is already defined in the 'duplicated_names' \"\n+                \"template.\",\n+            ),\n+            (\n+                \"duplicated_nested_names\",\n+                \"Partial 'testing-name' is already defined in the \"\n+                \"'duplicated_nested_names' template.\",\n+            ),\n+            (\"partialdef_invalid_name\", \"Invalid block tag on line 3: 'endpartialdef'\"),\n+        ):\n+            with (\n+                self.subTest(template_name=template_name),\n+                self.assertRaisesMessage(TemplateSyntaxError, error_msg),\n+            ):\n+                self.engine.render_to_string(template_name)\n+\n+    @setup(\n+        {\n+            \"missing_name\": \"{% partialdef %}TEST{% endpartialdef %}\",\n+            \"missing_close_tag\": \"{% partialdef %}\",\n+            \"inconsistent_name\": \"{% partialdef %}TEST{% endpartialdef name %}\",\n+            \"extra_params\": (\n+                \"{% partialdef testing-name inline extra %}TEST{% endpartialdef %}\"\n+            ),\n+        }\n+    )\n+    def test_partialdef_missing_arguments(self):\n+        error_msg = \"'partialdef' tag requires 2-3 arguments\"\n+        for template_name in (\n+            \"missing_name\",\n+            \"missing_close_tag\",\n+            \"inconsistent_name\",\n+            \"extra_params\",\n+        ):\n+            with (\n+                self.subTest(template_name=template_name),\n+                self.assertRaisesMessage(TemplateSyntaxError, error_msg),\n+            ):\n+                self.engine.render_to_string(template_name)\n+\n+    @setup(\n+        {\n+            \"with_params\": (\n+                \"{% partialdef testing-name inline=true %}TEST{% endpartialdef %}\"\n+            ),\n+            \"uppercase\": \"{% partialdef testing-name INLINE %}TEST{% endpartialdef %}\",\n+        }\n+    )\n+    def test_partialdef_invalid_inline(self):\n+        error_msg = \"The 'inline' argument does not have any parameters\"\n+        for template_name in (\"with_params\", \"uppercase\"):\n+            with (\n+                self.subTest(template_name=template_name),\n+                self.assertRaisesMessage(TemplateSyntaxError, error_msg),\n+            ):\n+                self.engine.render_to_string(template_name)\n+\n+    @setup(\n+        {\n+            \"partial_broken_unclosed\": (\n+                \"<div>Before partial</div>\"\n+                \"{% partialdef unclosed_partial %}\"\n+                \"<p>This partial has no closing tag</p>\"\n+                \"<div>After partial content</div>\"\n+            )\n+        }\n+    )\n+    def test_broken_partial_unclosed_exception_info(self):\n+        with self.assertRaises(TemplateSyntaxError) as cm:\n+            self.engine.get_template(\"partial_broken_unclosed\")\n+\n+        self.assertIn(\"endpartialdef\", str(cm.exception))\n+        self.assertIn(\"Unclosed tag\", str(cm.exception))\n+\n+        reporter = ExceptionReporter(None, cm.exception.__class__, cm.exception, None)\n+        traceback_data = reporter.get_traceback_data()\n+\n+        exception_value = str(traceback_data.get(\"exception_value\", \"\"))\n+        self.assertIn(\"Unclosed tag\", exception_value)\n+\n+    @setup(\n+        {\n+            \"partial_with_variable_error\": (\n+                \"<h1>Title</h1>\\n\"\n+                \"{% partialdef testing-name %}\\n\"\n+                \"<p>{{ nonexistent|default:alsonotthere }}</p>\\n\"\n+                \"{% endpartialdef %}\\n\"\n+                \"<h2>Sub Title</h2>\\n\"\n+                \"{% partial testing-name %}\\n\"\n+            ),\n+        }\n+    )\n+    def test_partial_runtime_exception_has_debug_info(self):\n+        template = self.engine.get_template(\"partial_with_variable_error\")\n+        context = Context({})\n+\n+        if hasattr(self.engine, \"string_if_invalid\") and self.engine.string_if_invalid:\n+            output = template.render(context)\n+            # The variable should be replaced with INVALID\n+            self.assertIn(\"INVALID\", output)\n+        else:\n+            with self.assertRaises(VariableDoesNotExist) as cm:\n+                template.render(context)\n+\n+            if self.engine.debug:\n+                exc_info = cm.exception.template_debug\n+\n+                self.assertEqual(\n+                    exc_info[\"during\"], \"{{ nonexistent|default:alsonotthere }}\"\n+                )\n+                self.assertEqual(exc_info[\"line\"], 3)\n+                self.assertEqual(exc_info[\"name\"], \"partial_with_variable_error\")\n+                self.assertIn(\"Failed lookup\", exc_info[\"message\"])\n+\n+    @setup(\n+        {\n+            \"partial_exception_info_test\": (\n+                \"<h1>Title</h1>\\n\"\n+                \"{% partialdef testing-name %}\\n\"\n+                \"<p>Content</p>\\n\"\n+                \"{% endpartialdef %}\\n\"\n+            ),\n+        }\n+    )\n+    def test_partial_template_get_exception_info_delegation(self):\n+        if self.engine.debug:\n+            template = self.engine.get_template(\"partial_exception_info_test\")\n+\n+            partial_template = template.extra_data[\"template-partials\"][\"testing-name\"]\n+\n+            test_exc = Exception(\"Test exception\")\n+            token = Token(\n+                token_type=TokenType.VAR,\n+                contents=\"test\",\n+                position=(0, 4),\n+            )\n+\n+            exc_info = partial_template.get_exception_info(test_exc, token)\n+            self.assertIn(\"message\", exc_info)\n+            self.assertIn(\"line\", exc_info)\n+            self.assertIn(\"name\", exc_info)\n+            self.assertEqual(exc_info[\"name\"], \"partial_exception_info_test\")\n+            self.assertEqual(exc_info[\"message\"], \"Test exception\")\n+\n+    @setup(\n+        {\n+            \"partial_with_undefined_reference\": (\n+                \"<h1>Header</h1>\\n\"\n+                \"{% partial undefined %}\\n\"\n+                \"<p>After undefined partial</p>\\n\"\n+            ),\n+        }\n+    )\n+    def test_undefined_partial_exception_info(self):\n+        template = self.engine.get_template(\"partial_with_undefined_reference\")\n+        with self.assertRaises(TemplateSyntaxError) as cm:\n+            template.render(Context())\n+\n+        self.assertIn(\"undefined\", str(cm.exception))\n+        self.assertIn(\"is not defined\", str(cm.exception))\n+\n+        if self.engine.debug:\n+            exc_debug = cm.exception.template_debug\n+\n+            self.assertEqual(exc_debug[\"during\"], \"{% partial undefined %}\")\n+            self.assertEqual(exc_debug[\"line\"], 2)\n+            self.assertEqual(exc_debug[\"name\"], \"partial_with_undefined_reference\")\n+            self.assertIn(\"undefined\", exc_debug[\"message\"])\n+\n+    @setup(\n+        {\n+            \"existing_template\": (\n+                \"<h1>Header</h1><p>This template has no partials defined</p>\"\n+            ),\n+        }\n+    )\n+    def test_undefined_partial_exception_info_template_does_not_exist(self):\n+        with self.assertRaises(TemplateDoesNotExist) as cm:\n+            self.engine.get_template(\"existing_template#undefined\")\n+\n+        self.assertIn(\"undefined\", str(cm.exception))\n+\n+    @setup(\n+        {\n+            \"partial_with_syntax_error\": (\n+                \"<h1>Title</h1>\\n\"\n+                \"{% partialdef syntax_error_partial %}\\n\"\n+                \"    {% if user %}\\n\"\n+                \"        <p>User: {{ user.name }}</p>\\n\"\n+                \"    {% endif\\n\"\n+                \"    <p>Missing closing tag above</p>\\n\"\n+                \"{% endpartialdef %}\\n\"\n+                \"{% partial syntax_error_partial %}\\n\"\n+            ),\n+        }\n+    )\n+    def test_partial_with_syntax_error_exception_info(self):\n+        with self.assertRaises(TemplateSyntaxError) as cm:\n+            self.engine.get_template(\"partial_with_syntax_error\")\n+\n+        self.assertIn(\"endif\", str(cm.exception).lower())\n+\n+        if self.engine.debug:\n+            exc_debug = cm.exception.template_debug\n+\n+            self.assertIn(\"endpartialdef\", exc_debug[\"during\"])\n+            self.assertEqual(exc_debug[\"name\"], \"partial_with_syntax_error\")\n+            self.assertIn(\"endif\", exc_debug[\"message\"].lower())\n+\n+    @setup(\n+        {\n+            \"partial_with_runtime_error\": (\n+                \"<h1>Title</h1>\\n\"\n+                \"{% load bad_tag %}\\n\"\n+                \"{% partialdef runtime_error_partial %}\\n\"\n+                \"    <p>This will raise an error:</p>\\n\"\n+                \"    {% badsimpletag %}\\n\"\n+                \"{% endpartialdef %}\\n\"\n+                \"{% partial runtime_error_partial %}\\n\"\n+            ),\n+        }\n+    )\n+    def test_partial_runtime_error_exception_info(self):\n+        template = self.engine.get_template(\"partial_with_runtime_error\")\n+        context = Context()\n+\n+        with self.assertRaises(RuntimeError) as cm:\n+            template.render(context)\n+\n+        if self.engine.debug:\n+            exc_debug = cm.exception.template_debug\n+\n+            self.assertIn(\"badsimpletag\", exc_debug[\"during\"])\n+            self.assertEqual(exc_debug[\"line\"], 5)  # Line 5 is where badsimpletag is\n+            self.assertEqual(exc_debug[\"name\"], \"partial_with_runtime_error\")\n+            self.assertIn(\"bad simpletag\", exc_debug[\"message\"])\n+\n+    @setup(\n+        {\n+            \"nested_partial_with_undefined_var\": (\n+                \"<h1>Title</h1>\\n\"\n+                \"{% partialdef outer_partial %}\\n\"\n+                '    <div class=\"outer\">\\n'\n+                \"        {% partialdef inner_partial %}\\n\"\n+                \"            <p>{{ undefined_var }}</p>\\n\"\n+                \"        {% endpartialdef %}\\n\"\n+                \"        {% partial inner_partial %}\\n\"\n+                \"    </div>\\n\"\n+                \"{% endpartialdef %}\\n\"\n+                \"{% partial outer_partial %}\\n\"\n+            ),\n+        }\n+    )\n+    def test_nested_partial_error_exception_info(self):\n+        template = self.engine.get_template(\"nested_partial_with_undefined_var\")\n+        context = Context()\n+        output = template.render(context)\n+\n+        # When string_if_invalid is set, it will show INVALID\n+        # When not set, undefined variables just render as empty string\n+        if hasattr(self.engine, \"string_if_invalid\") and self.engine.string_if_invalid:\n+            self.assertIn(\"INVALID\", output)\n+        else:\n+            self.assertIn(\"<p>\", output)\n+            self.assertIn(\"</p>\", output)\n+\n+    @setup(\n+        {\n+            \"parent.html\": (\n+                \"<!DOCTYPE html>\\n\"\n+                \"<html>\\n\"\n+                \"<head>{% block title %}Default Title{% endblock %}</head>\\n\"\n+                \"<body>\\n\"\n+                \"    {% block content %}{% endblock %}\\n\"\n+                \"</body>\\n\"\n+                \"</html>\\n\"\n+            ),\n+            \"child.html\": (\n+                \"{% extends 'parent.html' %}\\n\"\n+                \"{% block content %}\\n\"\n+                \"    {% partialdef content_partial %}\\n\"\n+                \"        <p>{{ missing_variable|undefined_filter }}</p>\\n\"\n+                \"    {% endpartialdef %}\\n\"\n+                \"    {% partial content_partial %}\\n\"\n+                \"{% endblock %}\\n\"\n+            ),\n+        }\n+    )\n+    def test_partial_in_extended_template_error(self):\n+        with self.assertRaises(TemplateSyntaxError) as cm:\n+            self.engine.get_template(\"child.html\")\n+\n+        self.assertIn(\"undefined_filter\", str(cm.exception))\n+\n+        if self.engine.debug:\n+            exc_debug = cm.exception.template_debug\n+\n+            self.assertIn(\"undefined_filter\", exc_debug[\"during\"])\n+            self.assertEqual(exc_debug[\"name\"], \"child.html\")\n+            self.assertIn(\"undefined_filter\", exc_debug[\"message\"])\n+\n+    @setup(\n+        {\n+            \"partial_broken_nesting\": (\n+                \"<div>Before partial</div>\\n\"\n+                \"{% partialdef outer %}\\n\"\n+                \"{% partialdef inner %}...{% endpartialdef outer %}\\n\"\n+                \"{% endpartialdef inner %}\\n\"\n+                \"<div>After partial content</div>\"\n+            )\n+        }\n+    )\n+    def test_broken_partial_nesting(self):\n+        with self.assertRaises(TemplateSyntaxError) as cm:\n+            self.engine.get_template(\"partial_broken_nesting\")\n+\n+        self.assertIn(\"endpartialdef\", str(cm.exception))\n+        self.assertIn(\"Invalid block tag\", str(cm.exception))\n+        self.assertIn(\"'endpartialdef inner'\", str(cm.exception))\n+\n+        reporter = ExceptionReporter(None, cm.exception.__class__, cm.exception, None)\n+        traceback_data = reporter.get_traceback_data()\n+\n+        exception_value = str(traceback_data.get(\"exception_value\", \"\"))\n+        self.assertIn(\"Invalid block tag\", exception_value)\n+        self.assertIn(\"'endpartialdef inner'\", str(cm.exception))\n+\n+    @setup(\n+        {\n+            \"partial_broken_nesting_mixed\": (\n+                \"<div>Before partial</div>\\n\"\n+                \"{% partialdef outer %}\\n\"\n+                \"{% partialdef inner %}...{% endpartialdef %}\\n\"\n+                \"{% endpartialdef inner %}\\n\"\n+                \"<div>After partial content</div>\"\n+            )\n+        }\n+    )\n+    def test_broken_partial_nesting_mixed(self):\n+        with self.assertRaises(TemplateSyntaxError) as cm:\n+            self.engine.get_template(\"partial_broken_nesting_mixed\")\n+\n+        self.assertIn(\"endpartialdef\", str(cm.exception))\n+        self.assertIn(\"Invalid block tag\", str(cm.exception))\n+        self.assertIn(\"'endpartialdef outer'\", str(cm.exception))\n+\n+        reporter = ExceptionReporter(None, cm.exception.__class__, cm.exception, None)\n+        traceback_data = reporter.get_traceback_data()\n+\n+        exception_value = str(traceback_data.get(\"exception_value\", \"\"))\n+        self.assertIn(\"Invalid block tag\", exception_value)\n+        self.assertIn(\"'endpartialdef outer'\", str(cm.exception))\ndiff --git a/tests/template_tests/test_partials.py b/tests/template_tests/test_partials.py\nnew file mode 100644\nindex 000000000000..fc6a988d61c0\n--- /dev/null\n+++ b/tests/template_tests/test_partials.py\n@@ -0,0 +1,413 @@\n+import os\n+from unittest import mock\n+\n+from django.http import HttpResponse\n+from django.template import (\n+    Context,\n+    Origin,\n+    Template,\n+    TemplateDoesNotExist,\n+    TemplateSyntaxError,\n+    engines,\n+)\n+from django.template.backends.django import DjangoTemplates\n+from django.template.loader import render_to_string\n+from django.test import TestCase, override_settings\n+from django.urls import path, reverse\n+\n+engine = engines[\"django\"]\n+\n+\n+class PartialTagsTests(TestCase):\n+\n+    def test_invalid_template_name_raises_template_does_not_exist(self):\n+        for template_name in [123, None, \"\", \"#\", \"#name\"]:\n+            with (\n+                self.subTest(template_name=template_name),\n+                self.assertRaisesMessage(TemplateDoesNotExist, str(template_name)),\n+            ):\n+                engine.get_template(template_name)\n+\n+    def test_template_source_is_correct(self):\n+        partial = engine.get_template(\"partial_examples.html#test-partial\")\n+        self.assertEqual(\n+            partial.template.source,\n+            \"{% partialdef test-partial %}\\nTEST-PARTIAL-CONTENT\\n{% endpartialdef %}\",\n+        )\n+\n+    def test_template_source_inline_is_correct(self):\n+        partial = engine.get_template(\"partial_examples.html#inline-partial\")\n+        self.assertEqual(\n+            partial.template.source,\n+            \"{% partialdef inline-partial inline %}\\nINLINE-CONTENT\\n\"\n+            \"{% endpartialdef %}\",\n+        )\n+\n+    def test_full_template_from_loader(self):\n+        template = engine.get_template(\"partial_examples.html\")\n+        rendered = template.render({})\n+\n+        # Check the partial was rendered twice\n+        self.assertEqual(2, rendered.count(\"TEST-PARTIAL-CONTENT\"))\n+        self.assertEqual(1, rendered.count(\"INLINE-CONTENT\"))\n+\n+    def test_chained_exception_forwarded(self):\n+        with self.assertRaises(TemplateDoesNotExist) as ctx:\n+            engine.get_template(\"not_there.html#not-a-partial\")\n+\n+        exception = ctx.exception\n+        self.assertGreater(len(exception.tried), 0)\n+        origin, _ = exception.tried[0]\n+        self.assertEqual(origin.template_name, \"not_there.html\")\n+\n+    def test_partials_use_cached_loader_when_configured(self):\n+        template_dir = os.path.join(os.path.dirname(__file__), \"templates\")\n+        backend = DjangoTemplates(\n+            {\n+                \"NAME\": \"django\",\n+                \"DIRS\": [template_dir],\n+                \"APP_DIRS\": False,\n+                \"OPTIONS\": {\n+                    \"loaders\": [\n+                        (\n+                            \"django.template.loaders.cached.Loader\",\n+                            [\"django.template.loaders.filesystem.Loader\"],\n+                        ),\n+                    ],\n+                },\n+            }\n+        )\n+        cached_loader = backend.engine.template_loaders[0]\n+        filesystem_loader = cached_loader.loaders[0]\n+\n+        with mock.patch.object(\n+            filesystem_loader, \"get_contents\", wraps=filesystem_loader.get_contents\n+        ) as mock_get_contents:\n+            full_template = backend.get_template(\"partial_examples.html\")\n+            self.assertIn(\"TEST-PARTIAL-CONTENT\", full_template.render({}))\n+\n+            partial_template = backend.get_template(\n+                \"partial_examples.html#test-partial\"\n+            )\n+            self.assertEqual(\n+                \"TEST-PARTIAL-CONTENT\", partial_template.render({}).strip()\n+            )\n+\n+            mock_get_contents.assert_called_once()\n+\n+    def test_context_available_in_response_for_partial_template(self):\n+        def sample_view(request):\n+            return HttpResponse(\n+                render_to_string(\"partial_examples.html#test-partial\", {\"foo\": \"bar\"})\n+            )\n+\n+        class PartialUrls:\n+            urlpatterns = [path(\"sample/\", sample_view, name=\"sample-view\")]\n+\n+        with override_settings(ROOT_URLCONF=PartialUrls):\n+            response = self.client.get(reverse(\"sample-view\"))\n+\n+        self.assertContains(response, \"TEST-PARTIAL-CONTENT\")\n+        self.assertEqual(response.context.get(\"foo\"), \"bar\")\n+\n+    def test_response_with_multiple_parts(self):\n+        context = {}\n+        template_partials = [\"partial_child.html\", \"partial_child.html#extra-content\"]\n+\n+        response_whole_content_at_once = HttpResponse(\n+            \"\".join(\n+                render_to_string(template_name, context)\n+                for template_name in template_partials\n+            )\n+        )\n+\n+        response_with_multiple_writes = HttpResponse()\n+        for template_name in template_partials:\n+            response_with_multiple_writes.write(\n+                render_to_string(template_name, context)\n+            )\n+\n+        response_with_generator = HttpResponse(\n+            render_to_string(template_name, context)\n+            for template_name in template_partials\n+        )\n+\n+        for label, response in [\n+            (\"response_whole_content_at_once\", response_whole_content_at_once),\n+            (\"response_with_multiple_writes\", response_with_multiple_writes),\n+            (\"response_with_generator\", response_with_generator),\n+        ]:\n+            with self.subTest(response=label):\n+                self.assertIn(b\"Main Content\", response.content)\n+                self.assertIn(b\"Extra Content\", response.content)\n+\n+    def test_partial_engine_assignment_with_real_template(self):\n+        template_with_partial = engine.get_template(\n+            \"partial_examples.html#test-partial\"\n+        )\n+        self.assertEqual(template_with_partial.template.engine, engine.engine)\n+        rendered_content = template_with_partial.render({})\n+        self.assertEqual(\"TEST-PARTIAL-CONTENT\", rendered_content.strip())\n+\n+\n+class RobustPartialHandlingTests(TestCase):\n+\n+    def override_get_template(self, **kwargs):\n+        class TemplateWithCustomAttrs:\n+            def __init__(self, **kwargs):\n+                for k, v in kwargs.items():\n+                    setattr(self, k, v)\n+\n+            def render(self, context):\n+                return \"rendered content\"\n+\n+        template = TemplateWithCustomAttrs(**kwargs)\n+        origin = mock.Mock()\n+        return mock.patch.object(\n+            engine.engine,\n+            \"find_template\",\n+            return_value=(template, origin),\n+        )\n+\n+    def test_template_without_extra_data_attribute(self):\n+        partial_name = \"some_partial_name\"\n+        with (\n+            self.override_get_template(),\n+            self.assertRaisesMessage(TemplateDoesNotExist, partial_name),\n+        ):\n+            engine.get_template(f\"some_template.html#{partial_name}\")\n+\n+    def test_template_extract_extra_data_robust(self):\n+        partial_name = \"some_partial_name\"\n+        for extra_data in (\n+            None,\n+            0,\n+            [],\n+            {},\n+            {\"partials\": {}},\n+            {\"template-partials\": None},\n+            {\"template-partials\": {}},\n+            {\"template-partials\": []},\n+            {\"template-partials\": 0},\n+        ):\n+            with (\n+                self.subTest(extra_data=extra_data),\n+                self.override_get_template(extra_data=extra_data),\n+                self.assertRaisesMessage(TemplateDoesNotExist, partial_name),\n+            ):\n+                engine.get_template(f\"template.html#{partial_name}\")\n+\n+    def test_nested_partials_rendering_with_context(self):\n+        template_source = \"\"\"\n+        {% partialdef outer inline %}\n+            Hello {{ name }}!\n+            {% partialdef inner inline %}\n+                Your age is {{ age }}.\n+            {% endpartialdef inner %}\n+            Nice to meet you.\n+        {% endpartialdef outer %}\n+        \"\"\"\n+        template = Template(template_source, origin=Origin(name=\"template.html\"))\n+\n+        context = Context({\"name\": \"Alice\", \"age\": 25})\n+        rendered = template.render(context)\n+\n+        self.assertIn(\"Hello Alice!\", rendered)\n+        self.assertIn(\"Your age is 25.\", rendered)\n+        self.assertIn(\"Nice to meet you.\", rendered)\n+\n+\n+class FindPartialSourceTests(TestCase):\n+\n+    def test_find_partial_source_success(self):\n+        template = engine.get_template(\"partial_examples.html\").template\n+        partial_proxy = template.extra_data[\"template-partials\"][\"test-partial\"]\n+\n+        expected = \"\"\"{% partialdef test-partial %}\n+TEST-PARTIAL-CONTENT\n+{% endpartialdef %}\"\"\"\n+        self.assertEqual(partial_proxy.source.strip(), expected.strip())\n+\n+    def test_find_partial_source_with_inline(self):\n+        template = engine.get_template(\"partial_examples.html\").template\n+        partial_proxy = template.extra_data[\"template-partials\"][\"inline-partial\"]\n+\n+        expected = \"\"\"{% partialdef inline-partial inline %}\n+INLINE-CONTENT\n+{% endpartialdef %}\"\"\"\n+        self.assertEqual(partial_proxy.source.strip(), expected.strip())\n+\n+    def test_find_partial_source_nonexistent_partial(self):\n+        template = engine.get_template(\"partial_examples.html\").template\n+        partial_proxy = template.extra_data[\"template-partials\"][\"test-partial\"]\n+\n+        result = partial_proxy.find_partial_source(\n+            template.source, \"nonexistent-partial\"\n+        )\n+        self.assertEqual(result, \"\")\n+\n+    def test_find_partial_source_empty_partial(self):\n+        template_source = \"{% partialdef empty %}{% endpartialdef %}\"\n+        template = Template(template_source)\n+        partial_proxy = template.extra_data[\"template-partials\"][\"empty\"]\n+\n+        result = partial_proxy.find_partial_source(template_source, \"empty\")\n+        self.assertEqual(result, \"{% partialdef empty %}{% endpartialdef %}\")\n+\n+    def test_find_partial_source_multiple_consecutive_partials(self):\n+\n+        template_source = (\n+            \"{% partialdef empty %}{% endpartialdef %}\"\n+            \"{% partialdef other %}...{% endpartialdef %}\"\n+        )\n+        template = Template(template_source)\n+\n+        empty_proxy = template.extra_data[\"template-partials\"][\"empty\"]\n+        other_proxy = template.extra_data[\"template-partials\"][\"other\"]\n+\n+        empty_result = empty_proxy.find_partial_source(template_source, \"empty\")\n+        self.assertEqual(empty_result, \"{% partialdef empty %}{% endpartialdef %}\")\n+\n+        other_result = other_proxy.find_partial_source(template_source, \"other\")\n+        self.assertEqual(other_result, \"{% partialdef other %}...{% endpartialdef %}\")\n+\n+    def test_partials_with_duplicate_names(self):\n+        test_cases = [\n+            (\n+                \"nested\",\n+                \"\"\"\n+                {% partialdef duplicate %}{% partialdef duplicate %}\n+                CONTENT\n+                {% endpartialdef %}{% endpartialdef %}\n+                \"\"\",\n+            ),\n+            (\n+                \"conditional\",\n+                \"\"\"\n+                {% if ... %}\n+                  {% partialdef duplicate %}\n+                  CONTENT\n+                  {% endpartialdef %}\n+                {% else %}\n+                  {% partialdef duplicate %}\n+                  OTHER-CONTENT\n+                  {% endpartialdef %}\n+                {% endif %}\n+                \"\"\",\n+            ),\n+        ]\n+\n+        for test_name, template_source in test_cases:\n+            with self.subTest(test_name=test_name):\n+                with self.assertRaisesMessage(\n+                    TemplateSyntaxError,\n+                    \"Partial 'duplicate' is already defined in the \"\n+                    \"'template.html' template.\",\n+                ):\n+                    Template(template_source, origin=Origin(name=\"template.html\"))\n+\n+    def test_find_partial_source_supports_named_end_tag(self):\n+        template_source = \"{% partialdef thing %}CONTENT{% endpartialdef thing %}\"\n+        template = Template(template_source)\n+        partial_proxy = template.extra_data[\"template-partials\"][\"thing\"]\n+\n+        result = partial_proxy.find_partial_source(template_source, \"thing\")\n+        self.assertEqual(\n+            result, \"{% partialdef thing %}CONTENT{% endpartialdef thing %}\"\n+        )\n+\n+    def test_find_partial_source_supports_nested_partials(self):\n+        template_source = (\n+            \"{% partialdef outer %}\"\n+            \"{% partialdef inner %}...{% endpartialdef %}\"\n+            \"{% endpartialdef %}\"\n+        )\n+        template = Template(template_source)\n+\n+        empty_proxy = template.extra_data[\"template-partials\"][\"outer\"]\n+        other_proxy = template.extra_data[\"template-partials\"][\"inner\"]\n+\n+        outer_result = empty_proxy.find_partial_source(template_source, \"outer\")\n+        self.assertEqual(\n+            outer_result,\n+            (\n+                \"{% partialdef outer %}{% partialdef inner %}\"\n+                \"...{% endpartialdef %}{% endpartialdef %}\"\n+            ),\n+        )\n+\n+        inner_result = other_proxy.find_partial_source(template_source, \"inner\")\n+        self.assertEqual(inner_result, \"{% partialdef inner %}...{% endpartialdef %}\")\n+\n+    def test_find_partial_source_supports_nested_partials_and_named_end_tags(self):\n+        template_source = (\n+            \"{% partialdef outer %}\"\n+            \"{% partialdef inner %}...{% endpartialdef inner %}\"\n+            \"{% endpartialdef outer %}\"\n+        )\n+        template = Template(template_source)\n+\n+        empty_proxy = template.extra_data[\"template-partials\"][\"outer\"]\n+        other_proxy = template.extra_data[\"template-partials\"][\"inner\"]\n+\n+        outer_result = empty_proxy.find_partial_source(template_source, \"outer\")\n+        self.assertEqual(\n+            outer_result,\n+            (\n+                \"{% partialdef outer %}{% partialdef inner %}\"\n+                \"...{% endpartialdef inner %}{% endpartialdef outer %}\"\n+            ),\n+        )\n+\n+        inner_result = other_proxy.find_partial_source(template_source, \"inner\")\n+        self.assertEqual(\n+            inner_result, \"{% partialdef inner %}...{% endpartialdef inner %}\"\n+        )\n+\n+    def test_find_partial_source_supports_nested_partials_and_mixed_end_tags_1(self):\n+        template_source = (\n+            \"{% partialdef outer %}\"\n+            \"{% partialdef inner %}...{% endpartialdef %}\"\n+            \"{% endpartialdef outer %}\"\n+        )\n+        template = Template(template_source)\n+\n+        empty_proxy = template.extra_data[\"template-partials\"][\"outer\"]\n+        other_proxy = template.extra_data[\"template-partials\"][\"inner\"]\n+\n+        outer_result = empty_proxy.find_partial_source(template_source, \"outer\")\n+        self.assertEqual(\n+            outer_result,\n+            (\n+                \"{% partialdef outer %}{% partialdef inner %}\"\n+                \"...{% endpartialdef %}{% endpartialdef outer %}\"\n+            ),\n+        )\n+\n+        inner_result = other_proxy.find_partial_source(template_source, \"inner\")\n+        self.assertEqual(inner_result, \"{% partialdef inner %}...{% endpartialdef %}\")\n+\n+    def test_find_partial_source_supports_nested_partials_and_mixed_end_tags_2(self):\n+        template_source = (\n+            \"{% partialdef outer %}\"\n+            \"{% partialdef inner %}...{% endpartialdef inner %}\"\n+            \"{% endpartialdef %}\"\n+        )\n+        template = Template(template_source)\n+\n+        empty_proxy = template.extra_data[\"template-partials\"][\"outer\"]\n+        other_proxy = template.extra_data[\"template-partials\"][\"inner\"]\n+\n+        outer_result = empty_proxy.find_partial_source(template_source, \"outer\")\n+        self.assertEqual(\n+            outer_result,\n+            (\n+                \"{% partialdef outer %}{% partialdef inner %}\"\n+                \"...{% endpartialdef inner %}{% endpartialdef %}\"\n+            ),\n+        )\n+\n+        inner_result = other_proxy.find_partial_source(template_source, \"inner\")\n+        self.assertEqual(\n+            inner_result, \"{% partialdef inner %}...{% endpartialdef inner %}\"\n+        )\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR introduces new syntax tests and aligns them with existing ones, particularly around partial definitions. The renaming of `TemplateProxy` to `PartialTemplate` and its relocation to `base.py` improves clarity. Shifting `SubDictionaryWrapper` to `utils.py` suggests a more organized structure. However, while you've identified template exceptions, ensure the test case for `get_exception_info` truly validates error handling—adding specific asserts will enhance clarity. Additionally, test performance with larger templates to catch potential regex inefficiencies. Great progress overall!"
      }
    ],
    "token_estimation": 13443.5
  },
  {
    "index": 26,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/tests/delete/models.py b/tests/delete/models.py\nindex 4b627712bb65..540fc1db01e1 100644\n--- a/tests/delete/models.py\n+++ b/tests/delete/models.py\n@@ -241,3 +252,99 @@ class GenericDeleteBottomParent(models.Model):\n     generic_delete_bottom = models.ForeignKey(\n         GenericDeleteBottom, on_delete=models.CASCADE\n     )\n+\n+\n+class ParentModel(models.Model):\n+    pass\n+\n+\n+class ChildModel(models.Model):\n+    \"\"\"First level foreignkey child for ParentModel\n+    Implemented using database level cascading\"\"\"\n+\n+    parent_model = models.ForeignKey(ParentModel, on_delete=models.DB_CASCADE)\n+\n+\n+class GrandChild(models.Model):\n+    \"\"\"Second level foreignkey child for ParentModel\n+    Implemented using in DB cascading\"\"\"\n+\n+    child_model = models.ForeignKey(ChildModel, on_delete=models.DB_CASCADE)\n+\n+\n+class ChildFKRestrict(models.Model):\n+    \"\"\"First level child of ParentModel with cascading set to restrict\"\"\"\n+\n+    parent_model = models.ForeignKey(ParentModel, on_delete=models.DB_RESTRICT)\n+\n+\n+class GrandChildFKRestrict(models.Model):\n+    \"\"\"Second level child of ParentModel with cascading set to restrict\"\"\"\n+\n+    child_model = models.ForeignKey(ChildModel, on_delete=models.DB_RESTRICT)\n+\n+\n+class ChildFKSetNull(models.Model):\n+    \"\"\"First level child of ParentModel with cascading set to null\"\"\"\n+\n+    parent_model = models.ForeignKey(\n+        ParentModel, on_delete=models.DB_SET_NULL, null=True\n+    )\n+    another_field = models.CharField(max_length=20)\n+\n+\n+class GrandChildFKSetNull(models.Model):\n+    \"\"\"Second level child of ParentModel with cascading set to null\"\"\"\n+\n+    child_model = models.ForeignKey(\n+        ChildModel,\n+        on_delete=models.DB_SET_NULL,\n+        null=True,\n+    )\n+    another_field = models.CharField(max_length=20)\n+\n+\n+class AnotherGrandChildFKSetNull(models.Model):\n+    \"\"\"Second level child of ParentModel with cascading set to null\"\"\"\n+\n+    child_fk_set_null = models.ForeignKey(\n+        ChildFKSetNull, on_delete=models.DB_SET_NULL, null=True\n+    )\n+    another_field = models.CharField(max_length=20)\n+\n+\n+class DBLevelChild(ParentModel):\n+    grandparent_ptr = models.OneToOneField(\n+        ParentModel, primary_key=True, parent_link=True, on_delete=models.DB_RESTRICT\n+    )\n+\n+\n+class NormalParent(ParentModel):\n+    grandparent_ptr = models.OneToOneField(\n+        ParentModel, primary_key=True, parent_link=True, on_delete=models.DB_CASCADE\n+    )\n+\n+\n+class DiamondParent(ParentModel):\n+    gp_ptr = models.OneToOneField(\n+        ParentModel, primary_key=True, parent_link=True, on_delete=models.DB_CASCADE\n+    )\n+\n+\n+class DiamondChild(NormalParent, DiamondParent):\n+    parent_ptr = models.OneToOneField(\n+        NormalParent, primary_key=True, parent_link=True, on_delete=models.DB_CASCADE\n+    )\n+\n+    diamondparent_ptr = models.OneToOneField(\n+        DiamondParent, parent_link=True, on_delete=models.DB_CASCADE\n+    )\n+\n+\n+class DBDefaultsFK(models.Model):\n+    parent_model = models.ForeignKey(\n+        ParentModel, db_default=1, on_delete=models.DB_SET_DEFAULT\n+    )\n+\n+    class Meta:\n+        required_db_features = (\"has_on_delete_db_default\",)\ndiff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 01228631f4ba..f84831dea79e 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -800,3 +838,189 @@ def test_fast_delete_full_match(self):\n         with self.assertNumQueries(1):\n             User.objects.filter(~Q(pk__in=[]) | Q(avatar__desc=\"foo\")).delete()\n         self.assertFalse(User.objects.exists())\n+\n+\n+class DatabaseLevelOnDeleteTests(TestCase):\n+    def test_deletion_on_nested_cascades(self):\n+        parent = ParentModel.objects.create()\n+        child = ChildModel.objects.create(parent_model=parent)\n+        grand_child = GrandChild.objects.create(child_model=child)\n+\n+        parent.delete()\n+\n+        self.assertIs(ChildModel.objects.filter(pk=child.pk).exists(), False)\n+        self.assertIs(GrandChild.objects.filter(pk=grand_child.pk).exists(), False)\n+\n+    def test_restricted_deletion(self):\n+        parent = ParentModel.objects.create()\n+        ChildFKRestrict.objects.create(parent_model=parent)\n+\n+        with self.assertRaises(IntegrityError):\n+            parent.delete()\n+\n+    def test_restricted_deletion_by_cascade(self):\n+        parent = ParentModel.objects.create()\n+        child = ChildModel.objects.create(parent_model=parent)\n+        GrandChildFKRestrict.objects.create(child_model=child)\n+        with self.assertRaises(IntegrityError):\n+            parent.delete()\n+\n+    def test_deletion_on_set_null(self):\n+        parent = ParentModel.objects.create()\n+        child = ChildFKSetNull.objects.create(\n+            parent_model=parent, another_field=\"Some Value\"\n+        )\n+        parent.delete()\n+        orphan_child = ChildFKSetNull.objects.get(pk=child.pk)\n+        self.assertEqual(child.pk, orphan_child.pk)\n+        self.assertEqual(child.another_field, orphan_child.another_field)\n+        self.assertNotEqual(child.parent_model, orphan_child.parent_model)\n+        self.assertIsNone(orphan_child.parent_model)\n+\n+    def test_set_null_on_cascade_deletion(self):\n+        parent = ParentModel.objects.create()\n+        child = ChildModel.objects.create(parent_model=parent)\n+        grand_child = GrandChildFKSetNull.objects.create(\n+            child_model=child, another_field=\"Some Value\"\n+        )\n+        parent.delete()\n+        orphan_grand_child = GrandChildFKSetNull.objects.get(pk=grand_child.pk)\n+        self.assertEqual(grand_child.pk, orphan_grand_child.pk)\n+        self.assertEqual(grand_child.another_field, orphan_grand_child.another_field)\n+        self.assertNotEqual(grand_child.child_model, orphan_grand_child.child_model)\n+        self.assertIsNone(orphan_grand_child.child_model)\n+\n+    def test_nested_set_null_on_deletion(self):\n+        parent = ParentModel.objects.create()\n+        child = ChildFKSetNull.objects.create(parent_model=parent)\n+        grand_child = AnotherGrandChildFKSetNull.objects.create(child_fk_set_null=child)\n+        parent.delete()\n+\n+        orphan_child = ChildFKSetNull.objects.get(pk=child.pk)\n+        self.assertEqual(child.pk, orphan_child.pk)\n+        self.assertEqual(child.another_field, orphan_child.another_field)\n+        self.assertNotEqual(child.parent_model, orphan_child.parent_model)\n+        self.assertIsNone(orphan_child.parent_model)\n+\n+        orphan_grand_child = AnotherGrandChildFKSetNull.objects.get(pk=grand_child.pk)\n+        self.assertEqual(grand_child.pk, orphan_grand_child.pk)\n+        self.assertEqual(grand_child.another_field, orphan_grand_child.another_field)\n+        self.assertEqual(\n+            grand_child.child_fk_set_null, orphan_grand_child.child_fk_set_null\n+        )\n+        self.assertIsNotNone(orphan_grand_child.child_fk_set_null)\n+\n+    @skipUnlessDBFeature(\"has_on_delete_db_default\")\n+    def test_foreign_key_db_default_exists(self):\n+        # Default parent exists\n+        default_parent = ParentModel.objects.create(pk=1)\n+        parent = ParentModel.objects.create(pk=2)\n+        child1 = DBDefaultsFK.objects.create(parent_model=parent)\n+        with self.assertNumQueries(1):\n+            parent.delete()\n+        child1.refresh_from_db()\n+        self.assertEqual(child1.parent_model, default_parent)\n+        child1.delete()\n+        default_parent.delete()\n+\n+\n+class DatabaseLevelOnDeleteTransactionTests(TransactionTestCase):\n+    available_apps = [\"delete\"]\n+\n+    @skipUnlessDBFeature(\"has_on_delete_db_default\")\n+    def test_foreign_key_default_parent_deleted_before_parent(self):\n+        # Default parent does not exists\n+        # Default parent deleted before parent\n+        default_parent = ParentModel.objects.create(pk=1)\n+        parent = ParentModel.objects.create(pk=2)\n+        child1 = DBDefaultsFK.objects.create(parent_model=parent)\n+        default_parent.delete()\n+        with self.assertRaises(IntegrityError):\n+            parent.delete()\n+            child1.refresh_from_db()\n+\n+    @skipUnlessDBFeature(\"has_on_delete_db_default\")\n+    def test_foreign_key_default_parent_deleted_after_parent(self):\n+        # Default parent does not exists\n+        # Default parent deleted after parent\n+        default_parent = ParentModel.objects.create(pk=1)\n+        parent = ParentModel.objects.create(pk=2)\n+        child1 = DBDefaultsFK.objects.create(parent_model=parent)\n+        parent.delete()\n+        with self.assertRaises(IntegrityError):\n+            default_parent.delete()\n+            child1.refresh_from_db()\n+\n+\n+class DatabaseLevelOnDeleteQueryAssertionTests(TestCase):\n+    def test_queries_on_nested_cascade(self):\n+        parent = ParentModel.objects.create()\n+\n+        for i in range(3):\n+            ChildModel.objects.create(parent_model=parent)\n+\n+        for child in ChildModel.objects.all():\n+            for i in range(3):\n+                GrandChild.objects.create(child_model=child)\n+\n+        # one is the deletion\n+        with self.assertNumQueries(1):\n+            parent.delete()\n+\n+    def test_queries_on_nested_set_null(self):\n+        parent = ParentModel.objects.create()\n+\n+        for i in range(3):\n+            ChildFKSetNull.objects.create(parent_model=parent)\n+\n+        for child_fk_set_null in ChildFKSetNull.objects.all():\n+            for i in range(3):\n+                AnotherGrandChildFKSetNull.objects.create(\n+                    child_fk_set_null=child_fk_set_null\n+                )\n+\n+        # one is the deletion\n+        with self.assertNumQueries(1):\n+            parent.delete()\n+\n+    def test_queries_on_nested_set_null_cascade(self):\n+        parent = ParentModel.objects.create()\n+\n+        for i in range(3):\n+            ChildModel.objects.create(parent_model=parent)\n+\n+        for child in ChildModel.objects.all():\n+            for i in range(3):\n+                GrandChildFKSetNull.objects.create(child_model=child)\n+\n+        # one is the deletion\n+        with self.assertNumQueries(1):\n+            parent.delete()\n+\n+    def test_queries_on_inherited_model(self):\n+        gp = ParentModel.objects.create()\n+        parent = NormalParent.objects.create(grandparent_ptr=gp)\n+        diamond_parent = DiamondParent.objects.create(gp_ptr=gp)\n+\n+        dc = DiamondChild.objects.create(\n+            parent_ptr=parent, diamondparent_ptr=diamond_parent\n+        )\n+\n+        with self.assertNumQueries(1):\n+            gp.delete()\n+\n+        self.assertIs(NormalParent.objects.filter(pk=parent.pk).exists(), False)\n+        self.assertIs(\n+            DiamondParent.objects.filter(pk=diamond_parent.pk).exists(), False\n+        )\n+        self.assertIs(DiamondChild.objects.filter(pk=dc.pk).exists(), False)\n+\n+    def test_restrict_on_inherited_model(self):\n+        gp = ParentModel.objects.create()\n+        child = DBLevelChild.objects.create(grandparent_ptr=gp)\n+\n+        with transaction.atomic():\n+            with self.assertRaises(IntegrityError):\n+                gp.delete()\n+\n+        self.assertIs(DBLevelChild.objects.filter(pk=child.pk).exists(), True)\ndiff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 9b69ae415138..9f6874aa0084 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -2056,3 +2058,174 @@ class Child(models.Model):\n                 ),\n             ],\n         )\n+\n+\n+@isolate_apps(\"invalid_models_tests\")\n+class DatabaseLevelCascadeCheckTests(SimpleTestCase):\n+    def test_system_check_on_nested_db_with_non_db_cascading(self):\n+        class Foo(models.Model):\n+            pass\n+\n+        class Bar(models.Model):\n+            foo = models.ForeignKey(\n+                Foo,\n+                on_delete=models.DB_CASCADE,\n+            )\n+\n+        class BadBar(models.Model):\n+            foo = models.ForeignKey(Foo, on_delete=models.CASCADE)\n+\n+        class Baz(models.Model):\n+            \"\"\"First level child\"\"\"\n+\n+            bar = models.ForeignKey(\n+                Bar,\n+                on_delete=models.CASCADE,\n+            )\n+\n+        baz_field = Baz._meta.get_field(\"bar\")\n+        related_model_status = {\"model\": Bar, \"field\": Bar._meta.get_field(\"foo\")}\n+        self.assertEqual(\n+            baz_field.check(),\n+            [\n+                Error(\n+                    \"Using python based on_delete with database \"\n+                    \"level on_delete referenced model is prohibited \"\n+                    f\"Related field is {related_model_status.get('field')}.\",\n+                    hint=\"Use database-level cascading for foreign keys\",\n+                    obj=baz_field,\n+                    id=\"fields.E323\",\n+                ),\n+            ],\n+        )\n+\n+        bad_bar_field = BadBar._meta.get_field(\"foo\")\n+        self.assertEqual(bad_bar_field.check(), [])\n+\n+        bar_field = Bar._meta.get_field(\"foo\")\n+        self.assertEqual(bar_field.check(), [])\n+\n+    def test_null_condition_with_set_null_db(self):\n+        class Foo(models.Model):\n+            pass\n+\n+        class SetNullDbNotNullModel(models.Model):\n+            foo = models.ForeignKey(\n+                Foo,\n+                on_delete=models.DB_SET_NULL,\n+            )\n+\n+            class Meta:\n+                managed = False\n+\n+        field = SetNullDbNotNullModel._meta.get_field(\"foo\")\n+        self.assertEqual(\n+            field.check(),\n+            [\n+                Error(\n+                    \"Field specifies on_delete=DB_SET_NULL, but cannot be null.\",\n+                    hint=(\n+                        \"Set null=True argument on the field, or change the \"\n+                        \"on_delete rule.\"\n+                    ),\n+                    obj=field,\n+                    id=\"fields.E320\",\n+                )\n+            ],\n+        )\n+\n+    def test_check_on_inherited_models(self):\n+        class GrandParent(models.Model):\n+            pass\n+\n+        class Parent(GrandParent):\n+            pass\n+\n+        class DiamondParent(GrandParent):\n+            gp_ptr = models.OneToOneField(\n+                GrandParent,\n+                primary_key=True,\n+                parent_link=True,\n+                on_delete=models.DB_CASCADE,\n+            )\n+\n+        class DiamondChild(Parent, DiamondParent):\n+            parent_ptr = models.OneToOneField(\n+                Parent, primary_key=True, parent_link=True, on_delete=models.DB_CASCADE\n+            )\n+\n+        field = DiamondChild._meta.get_field(\"diamondparent_ptr\")\n+        rel_field = DiamondParent._meta.get_field(\"gp_ptr\")\n+        # error for having DB_CASCADE over normal cascade\n+        self.assertEqual(\n+            field.check(),\n+            [\n+                Error(\n+                    \"Using python based on_delete with database \"\n+                    \"level on_delete referenced model is prohibited \"\n+                    f\"Related field is {rel_field}.\",\n+                    hint=\"Use database-level cascading for foreign keys\",\n+                    obj=field,\n+                    id=\"fields.E323\",\n+                )\n+            ],\n+        )\n+        # No error for entire django cascade\n+        field = Parent._meta.get_field(\"grandparent_ptr\")\n+        self.assertEqual(\n+            field.check(),\n+            [],\n+        )\n+\n+    def test_check_on_generic_foreign_key(self):\n+        class SomeModel(models.Model):\n+            some_fk = models.ForeignKey(\n+                ContentType,\n+                on_delete=models.DB_CASCADE,\n+                related_name=\"ctcmnt\",\n+            )\n+            object_id = models.PositiveIntegerField()\n+            content_object = GenericForeignKey(\"some_fk\", \"object_id\")\n+\n+            class Meta:\n+                abstract = True\n+\n+        comment_field = SomeModel._meta.get_field(\"some_fk\")\n+        self.assertIn(\n+            Error(\n+                \"Field specifies unsupported on_delete=DB_CASCADE on model \"\n+                \"declaring a GenericForeignKey.\",\n+                hint=\"Change the on_delete rule to a non DB_* method\",\n+                obj=comment_field,\n+                id=\"fields.E322\",\n+            ),\n+            comment_field.check(),\n+        )\n+\n+    def test_check_db_default_foreign_key(self):\n+        class DBDefaultsPK(models.Model):\n+            language_code = models.CharField(\n+                primary_key=True, max_length=2, db_default=\"en\"\n+            )\n+\n+        class DBDefaultsFK(models.Model):\n+            language_code = models.ForeignKey(\n+                DBDefaultsPK, on_delete=models.DB_SET_DEFAULT\n+            )\n+\n+            class Meta:\n+                abstract = True\n+\n+        fk_field = DBDefaultsFK._meta.get_field(\"language_code\")\n+        self.assertEqual(\n+            fk_field.check(),\n+            [\n+                Error(\n+                    \"Field specifies on_delete=DB_SET_DEFAULT, but has \"\n+                    \"no db_default value.\",\n+                    hint=\"Set a db_default value, or change the on_delete rule.\",\n+                    obj=fk_field,\n+                    id=\"fields.E324\",\n+                )\n+            ],\n+        )\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex f86550082995..4dc130975dcf 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -6376,3 +6376,1265 @@ class BaseOperationTests(SimpleTestCase):\n     def test_formatted_description_no_category(self):\n         operation = Operation()\n         self.assertEqual(operation.formatted_description(), \"? Operation: ((), {})\")\n+\n+\n+class DatabaseLevelOnDeleteMigrationTests(OperationTestBase):\n+    def test_create_model_with_db_level_fk(self):\n+        app_label = \"test_cmwdblfk\"\n+        operations = [\n+            migrations.CreateModel(\n+                \"Pony\",\n+                [\n+                    (\n+                        \"id\",\n+                        models.CharField(\n+                            primary_key=True,\n+                            max_length=10,\n+                        ),\n+                    ),\n+                ],\n+            )\n+        ]\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+        # ForeignKey.\n+        new_state = project_state.clone()\n+        operation_list = [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"number\", models.IntegerField(default=1)),\n+            (\n+                \"pony_cascade\",\n+                models.ForeignKey(f\"{app_label}.Pony\", on_delete=models.DB_CASCADE),\n+            ),\n+            (\n+                \"pony_set_null\",\n+                models.ForeignKey(\n+                    f\"{app_label}.Pony\", null=True, on_delete=models.DB_SET_NULL\n+                ),\n+            ),\n+            (\n+                \"pony_restrict\",\n+                models.ForeignKey(f\"{app_label}.Pony\", on_delete=models.DB_RESTRICT),\n+            ),\n+        ]\n+        if connection.features.has_on_delete_db_default:\n+            operation_list.append(\n+                (\n+                    \"pony_default\",\n+                    models.ForeignKey(\n+                        f\"{app_label}.Pony\",\n+                        db_default=\"bn\",\n+                        on_delete=models.DB_SET_DEFAULT,\n+                    ),\n+                )\n+            )\n+        operation = migrations.CreateModel(\"Rider\", operation_list)\n+        operation.state_forwards(app_label, new_state)\n+        self.assertTableNotExists(f\"{app_label}_rider\")\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertTableExists(f\"{app_label}_rider\")\n+        self.assertColumnExists(f\"{app_label}_rider\", \"pony_cascade_id\")\n+        self.assertColumnExists(f\"{app_label}_rider\", \"pony_set_null_id\")\n+        self.assertColumnExists(f\"{app_label}_rider\", \"pony_restrict_id\")\n+        if connection.features.has_on_delete_db_default:\n+            self.assertColumnExists(f\"{app_label}_rider\", \"pony_default_id\")\n+\n+    def test_add_field_with_db_cascade(self):\n+        app_label = \"test_add_field_with_db_level_fk\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fk_parent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\n+                        \"id\",\n+                        models.CharField(\n+                            primary_key=True,\n+                            max_length=10,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                ],\n+            ),\n+        ]\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+        operation = migrations.AddField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\", on_delete=models.DB_CASCADE\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+        self.assertColumnNotExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertColumnExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance1 = fk_child_model.objects.create(**kwargs)\n+        fk_child_instance2 = fk_child_model.objects.create(**kwargs)\n+\n+        with self.assertNumQueries(1):\n+            fk_parent_instance.delete()\n+\n+        self.assertIs(\n+            fk_child_model.objects.filter(pk=fk_child_instance1.pk).exists(), False\n+        )\n+        self.assertIs(\n+            fk_child_model.objects.filter(pk=fk_child_instance2.pk).exists(), False\n+        )\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+        self.assertColumnNotExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+    def test_add_field_with_db_set_null(self):\n+        app_label = \"test_add_field_with_db_set_null\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fk_parent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\n+                        \"id\",\n+                        models.CharField(\n+                            primary_key=True,\n+                            max_length=10,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                ],\n+            ),\n+        ]\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+        operation = migrations.AddField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                null=True,\n+                on_delete=models.DB_SET_NULL,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+        self.assertColumnNotExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertColumnExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance1 = fk_child_model.objects.create(**kwargs)\n+\n+        with self.assertNumQueries(1):\n+            fk_parent_instance.delete()\n+\n+        fk_child_instance1.refresh_from_db()\n+        self.assertIsNone(getattr(fk_child_instance1, fk_fieldname))\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+        self.assertColumnNotExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+    @skipUnlessDBFeature(\"has_on_delete_db_default\")\n+    def test_add_field_with_db_set_default(self):\n+        app_label = \"test_add_field_with_db_set_default\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fk_parent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\n+                        \"id\",\n+                        models.CharField(\n+                            primary_key=True,\n+                            max_length=10,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                ],\n+            ),\n+        ]\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+        operation = migrations.AddField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                db_default=1,\n+                on_delete=models.DB_SET_DEFAULT,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+        self.assertColumnNotExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertColumnExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_default = fk_parent_model.objects.create(id=1)\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance = fk_child_model.objects.create(**kwargs)\n+\n+        fk_parent_instance.delete()\n+\n+        fk_child_instance.refresh_from_db()\n+        fk_parent_default.refresh_from_db()\n+        # After deletion it gets set to db default value\n+        self.assertEqual(getattr(fk_child_instance, fk_fieldname), fk_parent_default)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+        self.assertColumnNotExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+    def test_add_field_with_db_restrict(self):\n+        app_label = \"test_add_field_with_db_restrict\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fk_parent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\n+                        \"id\",\n+                        models.CharField(\n+                            primary_key=True,\n+                            max_length=10,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                ],\n+            ),\n+        ]\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+        operation = migrations.AddField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\", on_delete=models.DB_RESTRICT\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+        self.assertColumnNotExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertColumnExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance = fk_child_model.objects.create(**kwargs)\n+\n+        with self.assertRaises(IntegrityError):\n+            fk_parent_instance.delete()\n+\n+        self.assertIs(\n+            fk_child_model.objects.filter(pk=fk_child_instance.pk).exists(), True\n+        )\n+        self.assertIs(\n+            fk_parent_model.objects.filter(pk=fk_parent_instance.pk).exists(), True\n+        )\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+        self.assertColumnNotExists(\n+            f\"{app_label}_{fk_child_modelname.lower()}\", f\"{fk_fieldname}_id\"\n+        )\n+\n+    def change_to_db_set_null_test(\n+        self,\n+        app_label,\n+        fk_parent_modelname,\n+        fk_child_modelname,\n+        fk_fieldname,\n+        project_state,\n+    ):\n+        operation = migrations.AlterField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                null=True,\n+                on_delete=models.DB_SET_NULL,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance1 = fk_child_model.objects.create(**kwargs)\n+\n+        with self.assertNumQueries(1):\n+            fk_parent_instance.delete()\n+\n+        fk_child_instance1.refresh_from_db()\n+        self.assertIsNone(getattr(fk_child_instance1, fk_fieldname))\n+\n+        fk_parent_model.objects.all().delete()\n+        fk_child_model.objects.all().delete()\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+\n+    def change_to_db_cascade_test(\n+        self,\n+        app_label,\n+        fk_parent_modelname,\n+        fk_child_modelname,\n+        fk_fieldname,\n+        project_state,\n+    ):\n+        operation = migrations.AlterField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                on_delete=models.DB_CASCADE,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance1 = fk_child_model.objects.create(**kwargs)\n+        fk_child_instance2 = fk_child_model.objects.create(**kwargs)\n+\n+        with self.assertNumQueries(1):\n+            fk_parent_instance.delete()\n+\n+        self.assertIs(\n+            fk_child_model.objects.filter(pk=fk_child_instance1.pk).exists(), False\n+        )\n+        self.assertIs(\n+            fk_child_model.objects.filter(pk=fk_child_instance2.pk).exists(), False\n+        )\n+\n+        fk_parent_model.objects.all().delete()\n+        fk_child_model.objects.all().delete()\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+\n+    def change_to_db_restrict_test(\n+        self,\n+        app_label,\n+        fk_parent_modelname,\n+        fk_child_modelname,\n+        fk_fieldname,\n+        project_state,\n+    ):\n+        operation = migrations.AlterField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                on_delete=models.DB_RESTRICT,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance = fk_child_model.objects.create(**kwargs)\n+\n+        with self.assertRaises(IntegrityError):\n+            fk_parent_instance.delete()\n+\n+        self.assertIs(\n+            fk_child_model.objects.filter(pk=fk_child_instance.pk).exists(), True\n+        )\n+        self.assertIs(\n+            fk_parent_model.objects.filter(pk=fk_parent_instance.pk).exists(), True\n+        )\n+\n+        fk_child_model.objects.all().delete()\n+        fk_parent_model.objects.all().delete()\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+\n+    def change_to_db_set_default_test(\n+        self,\n+        app_label,\n+        fk_parent_modelname,\n+        fk_child_modelname,\n+        fk_fieldname,\n+        project_state,\n+    ):\n+        operation = migrations.AlterField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                db_default=1,\n+                on_delete=models.DB_SET_DEFAULT,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_default = fk_parent_model.objects.create(id=1)\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance = fk_child_model.objects.create(**kwargs)\n+\n+        fk_parent_instance.delete()\n+\n+        fk_child_instance.refresh_from_db()\n+        fk_parent_default.refresh_from_db()\n+        # After deletion it gets set to db default value\n+        self.assertEqual(getattr(fk_child_instance, fk_fieldname), fk_parent_default)\n+\n+        fk_child_model.objects.all().delete()\n+        fk_parent_model.objects.all().delete()\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+\n+    def change_to_non_db_set_null_test(\n+        self,\n+        app_label,\n+        fk_parent_modelname,\n+        fk_child_modelname,\n+        fk_fieldname,\n+        project_state,\n+    ):\n+        operation = migrations.AlterField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                null=True,\n+                on_delete=models.SET_NULL,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance1 = fk_child_model.objects.create(**kwargs)\n+\n+        with self.assertNumQueries(4):\n+            fk_parent_instance.delete()\n+\n+        fk_child_instance1.refresh_from_db()\n+        self.assertIsNone(getattr(fk_child_instance1, fk_fieldname))\n+\n+        fk_parent_model.objects.all().delete()\n+        fk_child_model.objects.all().delete()\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+\n+    def change_to_non_db_cascade_test(\n+        self,\n+        app_label,\n+        fk_parent_modelname,\n+        fk_child_modelname,\n+        fk_fieldname,\n+        project_state,\n+    ):\n+        operation = migrations.AlterField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                on_delete=models.CASCADE,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance1 = fk_child_model.objects.create(**kwargs)\n+        fk_child_instance2 = fk_child_model.objects.create(**kwargs)\n+\n+        with self.assertNumQueries(4):\n+            fk_parent_instance.delete()\n+\n+        self.assertIs(\n+            fk_child_model.objects.filter(pk=fk_child_instance1.pk).exists(), False\n+        )\n+        self.assertIs(\n+            fk_child_model.objects.filter(pk=fk_child_instance2.pk).exists(), False\n+        )\n+\n+        fk_parent_model.objects.all().delete()\n+        fk_child_model.objects.all().delete()\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+\n+    def change_to_non_db_restrict_test(\n+        self,\n+        app_label,\n+        fk_parent_modelname,\n+        fk_child_modelname,\n+        fk_fieldname,\n+        project_state,\n+    ):\n+        operation = migrations.AlterField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                on_delete=models.RESTRICT,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance = fk_child_model.objects.create(**kwargs)\n+\n+        with self.assertRaises(IntegrityError):\n+            fk_parent_instance.delete()\n+\n+        self.assertIs(\n+            fk_child_model.objects.filter(pk=fk_child_instance.pk).exists(), True\n+        )\n+        self.assertIs(\n+            fk_parent_model.objects.filter(pk=fk_parent_instance.pk).exists(), True\n+        )\n+\n+        fk_child_model.objects.all().delete()\n+        fk_parent_model.objects.all().delete()\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+\n+    def change_to_non_db_set_default_test(\n+        self,\n+        app_label,\n+        fk_parent_modelname,\n+        fk_child_modelname,\n+        fk_fieldname,\n+        project_state,\n+    ):\n+        operation = migrations.AlterField(\n+            fk_child_modelname,\n+            fk_fieldname,\n+            models.ForeignKey(\n+                f\"{app_label}.{fk_parent_modelname}\",\n+                default=1,\n+                on_delete=models.SET_DEFAULT,\n+            ),\n+        )\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        fk_child_model = new_state.apps.get_model(app_label, fk_child_modelname)\n+        fk_parent_model = new_state.apps.get_model(app_label, fk_parent_modelname)\n+\n+        fk_parent_default = fk_parent_model.objects.create(id=1)\n+        fk_parent_instance = fk_parent_model.objects.create()\n+        kwargs = {fk_fieldname: fk_parent_instance}\n+        fk_child_instance = fk_child_model.objects.create(**kwargs)\n+\n+        fk_parent_instance.delete()\n+\n+        fk_child_instance.refresh_from_db()\n+        fk_parent_default.refresh_from_db()\n+        # After deletion it gets set to db default value\n+        self.assertEqual(getattr(fk_child_instance, fk_fieldname), fk_parent_default)\n+\n+        fk_child_model.objects.all().delete()\n+        fk_parent_model.objects.all().delete()\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+\n+    def test_alter_field_to_db_level_fk_from_non_db_cascade(self):\n+        app_label = \"test_alter_db_level_fk_from_non_db_cascade\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fkparent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                    (\n+                        fk_fieldname,\n+                        models.ForeignKey(\n+                            f\"{app_label}.{fk_parent_modelname}\",\n+                            on_delete=models.CASCADE,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+        ]\n+\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+\n+        self.change_to_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        if connection.features.has_on_delete_db_default:\n+            self.change_to_db_set_default_test(\n+                app_label,\n+                fk_parent_modelname,\n+                fk_child_modelname,\n+                fk_fieldname,\n+                project_state,\n+            )\n+\n+    def test_alter_field_to_db_level_fk_from_non_db_restrict(self):\n+        app_label = \"test_alter_db_level_fk_from_non_db_restrict\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fkparent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                    (\n+                        fk_fieldname,\n+                        models.ForeignKey(\n+                            f\"{app_label}.{fk_parent_modelname}\",\n+                            on_delete=models.RESTRICT,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+        ]\n+\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+\n+        self.change_to_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        if connection.features.has_on_delete_db_default:\n+            self.change_to_db_set_default_test(\n+                app_label,\n+                fk_parent_modelname,\n+                fk_child_modelname,\n+                fk_fieldname,\n+                project_state,\n+            )\n+\n+    def test_alter_field_to_db_level_fk_from_non_db_set_null(self):\n+        app_label = \"test_alter_db_level_fk_from_non_db_set_null\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fkparent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                    (\n+                        fk_fieldname,\n+                        models.ForeignKey(\n+                            f\"{app_label}.{fk_parent_modelname}\",\n+                            null=True,\n+                            on_delete=models.SET_NULL,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+        ]\n+\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+\n+        self.change_to_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        if connection.features.has_on_delete_db_default:\n+            self.change_to_db_set_default_test(\n+                app_label,\n+                fk_parent_modelname,\n+                fk_child_modelname,\n+                fk_fieldname,\n+                project_state,\n+            )\n+\n+    def test_alter_field_to_db_level_fk_from_non_db_set_default(self):\n+        app_label = \"test_alter_db_level_fk_from_non_db_set_default\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fkparent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                    (\n+                        fk_fieldname,\n+                        models.ForeignKey(\n+                            f\"{app_label}.{fk_parent_modelname}\",\n+                            default=1,\n+                            on_delete=models.SET_DEFAULT,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+        ]\n+\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+\n+        self.change_to_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        if connection.features.has_on_delete_db_default:\n+            self.change_to_db_set_default_test(\n+                app_label,\n+                fk_parent_modelname,\n+                fk_child_modelname,\n+                fk_fieldname,\n+                project_state,\n+            )\n+\n+    def test_alter_field_from_db_cascade(self):\n+        app_label = \"test_alter_field_from_db_cascade\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fkparent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                    (\n+                        fk_fieldname,\n+                        models.ForeignKey(\n+                            f\"{app_label}.{fk_parent_modelname}\",\n+                            on_delete=models.DB_CASCADE,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+        ]\n+\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+\n+        self.change_to_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        if connection.features.has_on_delete_db_default:\n+            self.change_to_db_set_default_test(\n+                app_label,\n+                fk_parent_modelname,\n+                fk_child_modelname,\n+                fk_fieldname,\n+                project_state,\n+            )\n+\n+        self.change_to_non_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_set_default_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+\n+    def test_alter_field_from_db_set_null(self):\n+        app_label = \"test_alter_field_from_db_set_null\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fkparent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                    (\n+                        fk_fieldname,\n+                        models.ForeignKey(\n+                            f\"{app_label}.{fk_parent_modelname}\",\n+                            null=True,\n+                            on_delete=models.DB_SET_NULL,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+        ]\n+\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+\n+        self.change_to_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        if connection.features.has_on_delete_db_default:\n+            self.change_to_db_set_default_test(\n+                app_label,\n+                fk_parent_modelname,\n+                fk_child_modelname,\n+                fk_fieldname,\n+                project_state,\n+            )\n+        self.change_to_non_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_set_default_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+\n+    def test_alter_field_from_db_restrict(self):\n+        app_label = \"test_alter_field_from_db_restrict\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fkparent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                    (\n+                        fk_fieldname,\n+                        models.ForeignKey(\n+                            f\"{app_label}.{fk_parent_modelname}\",\n+                            on_delete=models.DB_RESTRICT,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+        ]\n+\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+\n+        self.change_to_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        if connection.features.has_on_delete_db_default:\n+            self.change_to_db_set_default_test(\n+                app_label,\n+                fk_parent_modelname,\n+                fk_child_modelname,\n+                fk_fieldname,\n+                project_state,\n+            )\n+\n+        self.change_to_non_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_set_default_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+\n+    @skipUnlessDBFeature(\"has_on_delete_db_default\")\n+    def test_alter_field_from_db_set_default(self):\n+        app_label = \"test_alter_field_from_db_set_default\"\n+        fk_parent_modelname = \"FkParent\"\n+        fk_child_modelname = \"FkChild\"\n+        fk_fieldname = \"fkparent\"\n+        operations = [\n+            migrations.CreateModel(\n+                fk_parent_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                ],\n+            ),\n+            migrations.CreateModel(\n+                fk_child_modelname,\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"number\", models.IntegerField(default=1)),\n+                    (\n+                        fk_fieldname,\n+                        models.ForeignKey(\n+                            f\"{app_label}.{fk_parent_modelname}\",\n+                            default=1,\n+                            on_delete=models.DB_SET_DEFAULT,\n+                        ),\n+                    ),\n+                ],\n+            ),\n+        ]\n+\n+        project_state = self.apply_operations(app_label, ProjectState(), operations)\n+\n+        self.change_to_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+\n+        self.change_to_non_db_set_null_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_cascade_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_restrict_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n+        self.change_to_non_db_set_default_test(\n+            app_label,\n+            fk_parent_modelname,\n+            fk_child_modelname,\n+            fk_fieldname,\n+            project_state,\n+        )\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The added tests for migrations are a positive step; however, you're facing two key issues. First, the MySQL error in `delete.tests.DatabaseLevelOnDeleteTests.test_foreign_key_db_default` likely stems from a table creation failure, potentially due to a foreign key type mismatch. Review the generated SQL closely. Secondly, for serializer testing, check `tests/migrations/test_writer.py`; it may contain relevant examples. Consider simplifying the `subTest` usage for more effective testing, particularly for backward migrations. Let’s aim for clearer tests moving forward."
      }
    ],
    "token_estimation": 15720.25
  },
  {
    "index": 27,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/tests/queries/test_explain.py b/tests/queries/test_explain.py\nnew file mode 100644\nindex 000000000000..26baf6fb30da\n--- /dev/null\n+++ b/tests/queries/test_explain.py\n@@ -0,0 +1,99 @@\n+import unittest\n+\n+from django.db import NotSupportedError, connection, transaction\n+from django.db.models import Count\n+from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n+from django.test.utils import CaptureQueriesContext\n+\n+from .models import Tag\n+\n+\n+@skipUnlessDBFeature('supports_explaining_query_execution')\n+class ExplainTests(TestCase):\n+\n+    def test_basic(self):\n+        querysets = [\n+            Tag.objects.filter(name='test'),\n+            Tag.objects.filter(name='test').select_related('parent'),\n+            Tag.objects.filter(name='test').prefetch_related('children'),\n+            Tag.objects.filter(name='test').annotate(Count('children')),\n+            Tag.objects.filter(name='test').values_list('name'),\n+            Tag.objects.order_by().union(Tag.objects.order_by().filter(name='test')),\n+            Tag.objects.all().select_for_update().filter(name='test'),\n+        ]\n+        supported_formats = connection.features.supported_explain_formats\n+        all_formats = (None,) + tuple(supported_formats) + tuple(f.lower() for f in supported_formats)\n+        for idx, queryset in enumerate(querysets):\n+            for format in all_formats:\n+                with self.subTest(format=format, queryset=idx):\n+                    if connection.vendor == 'mysql':\n+                        # This does a query and caches the result.\n+                        connection.features.needs_explain_extended\n+                    with self.assertNumQueries(1), CaptureQueriesContext(connection) as captured_queries:\n+                        result = queryset.explain(format=format)\n+                        self.assertTrue(captured_queries[0]['sql'].startswith(connection.ops.explain_prefix))\n+                        self.assertIsInstance(result, str)\n+                        self.assertTrue(result)\n+\n+    @skipUnlessDBFeature('validates_explain_options')\n+    def test_unknown_options(self):\n+        with self.assertRaisesMessage(ValueError, 'Unknown options: test, test2'):\n+            Tag.objects.all().explain(test=1, test2=1)\n+\n+    def test_unknown_format(self):\n+        msg = 'DOES NOT EXIST is not a recognized format.'\n+        if connection.features.supported_explain_formats:\n+            msg += ' Allowed formats: %s' % ', '.join(sorted(connection.features.supported_explain_formats))\n+        with self.assertRaisesMessage(ValueError, msg):\n+            Tag.objects.all().explain(format='does not exist')\n+\n+    @unittest.skipUnless(connection.vendor == 'postgresql', 'PostgreSQL specific')\n+    def test_postgres_options(self):\n+        qs = Tag.objects.filter(name='test')\n+        test_options = [\n+            {'COSTS': False, 'BUFFERS': True, 'ANALYZE': True},\n+            {'costs': False, 'buffers': True, 'analyze': True},\n+            {'verbose': True, 'timing': True, 'analyze': True},\n+            {'verbose': False, 'timing': False, 'analyze': True},\n+        ]\n+        if connection.pg_version >= 100000:\n+            test_options.append({'summary': True})\n+        for options in test_options:\n+            with self.subTest(**options), transaction.atomic():\n+                with CaptureQueriesContext(connection) as captured_queries:\n+                    qs.explain(format='text', **options)\n+                self.assertEqual(len(captured_queries), 1)\n+                for name, value in options.items():\n+                    option = '{} {}'.format(name.upper(), 'true' if value else 'false')\n+                    self.assertIn(option, captured_queries[0]['sql'])\n+\n+    @unittest.skipUnless(connection.vendor == 'mysql', 'MySQL specific')\n+    def test_mysql_text_to_traditional(self):\n+        with CaptureQueriesContext(connection) as captured_queries:\n+            Tag.objects.filter(name='test').explain(format='text')\n+        self.assertEqual(len(captured_queries), 1)\n+        self.assertIn('FORMAT=TRADITIONAL', captured_queries[0]['sql'])\n+\n+    @unittest.skipUnless(connection.vendor == 'mysql', 'MySQL < 5.7 specific')\n+    def test_mysql_extended(self):\n+        # Inner skip to avoid module level query for MySQL version.\n+        if not connection.features.needs_explain_extended:\n+            raise unittest.SkipTest('MySQL < 5.7 specific')\n+        qs = Tag.objects.filter(name='test')\n+        with CaptureQueriesContext(connection) as captured_queries:\n+            qs.explain(format='json')\n+        self.assertEqual(len(captured_queries), 1)\n+        self.assertNotIn('EXTENDED', captured_queries[0]['sql'])\n+        with CaptureQueriesContext(connection) as captured_queries:\n+            qs.explain(format='text')\n+        self.assertEqual(len(captured_queries), 1)\n+        self.assertNotIn('EXTENDED', captured_queries[0]['sql'])\n+\n+\n+@skipIfDBFeature('supports_explaining_query_execution')\n+class ExplainUnsupportedTests(TestCase):\n+\n+    def test_message(self):\n+        msg = 'This backend does not support explaining query execution.'\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Tag.objects.filter(name='test').explain()\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Overall, your implementation improvements are solid, but there are significant concerns regarding the MySQL and Oracle output formats. The MySQL explanation you propose could enhance usability, yet it might complicate the `SQLCompiler.explain` method with database-specific logic. The Oracle `EXPLAIN PLAN` challenges highlight the limitations of using parameters, leading to disabling support for Oracle completely. Make sure the unique identifier approach is well-documented, and consider alternative strategies for fetching query plans. Finally, ensure the test failures are addressed comprehensively."
      }
    ],
    "token_estimation": 1465.25
  },
  {
    "index": 28,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/contrib/postgres/constraints.py b/django/contrib/postgres/constraints.py\nnew file mode 100644\nindex 000000000000..2fcb076ecf29\n--- /dev/null\n+++ b/django/contrib/postgres/constraints.py\n@@ -0,0 +1,106 @@\n+from django.db.backends.ddl_references import Statement, Table\n+from django.db.models import F, Q\n+from django.db.models.constraints import BaseConstraint\n+from django.db.models.sql import Query\n+\n+__all__ = ['ExclusionConstraint']\n+\n+\n+class ExclusionConstraint(BaseConstraint):\n+    template = 'CONSTRAINT %(name)s EXCLUDE USING %(index_type)s (%(expressions)s)%(where)s'\n+\n+    def __init__(self, *, name, expressions, index_type=None, condition=None):\n+        if index_type and index_type.lower() not in {'gist', 'spgist'}:\n+            raise ValueError(\n+                'Exclusion constraints only support GiST or SP-GiST indexes.'\n+            )\n+        if not expressions:\n+            raise ValueError(\n+                'At least one expression is required to define an exclusion '\n+                'constraint.'\n+            )\n+        if not all(\n+            isinstance(expr, (list, tuple)) and len(expr) == 2\n+            for expr in expressions\n+        ):\n+            raise ValueError('The expressions must be a list of 2-tuples.')\n+        if not isinstance(condition, (type(None), Q)):\n+            raise ValueError(\n+                'ExclusionConstraint.condition must be a Q instance.'\n+            )\n+        self.expressions = expressions\n+        self.index_type = index_type or 'GIST'\n+        self.condition = condition\n+        super().__init__(name=name)\n+\n+    def _get_expression_sql(self, compiler, connection, query):\n+        expressions = []\n+        for expression, operator in self.expressions:\n+            if isinstance(expression, str):\n+                expression = F(expression)\n+            if isinstance(expression, F):\n+                expression = expression.resolve_expression(query=query, simple_col=True)\n+            else:\n+                expression = expression.resolve_expression(query=query)\n+            sql, params = expression.as_sql(compiler, connection)\n+            expressions.append('%s WITH %s' % (sql % params, operator))\n+        return expressions\n+\n+    def _get_condition_sql(self, compiler, schema_editor, query):\n+        if self.condition is None:\n+            return None\n+        where = query.build_where(self.condition)\n+        sql, params = where.as_sql(compiler, schema_editor.connection)\n+        return sql % tuple(schema_editor.quote_value(p) for p in params)\n+\n+    def constraint_sql(self, model, schema_editor):\n+        query = Query(model)\n+        compiler = query.get_compiler(connection=schema_editor.connection)\n+        expressions = self._get_expression_sql(compiler, schema_editor.connection, query)\n+        condition = self._get_condition_sql(compiler, schema_editor, query)\n+        return self.template % {\n+            'name': schema_editor.quote_name(self.name),\n+            'index_type': self.index_type,\n+            'expressions': ', '.join(expressions),\n+            'where': ' WHERE (%s)' % condition if condition else '',\n+        }\n+\n+    def create_sql(self, model, schema_editor):\n+        return Statement(\n+            'ALTER TABLE %(table)s ADD %(constraint)s',\n+            table=Table(model._meta.db_table, schema_editor.quote_name),\n+            constraint=self.constraint_sql(model, schema_editor),\n+        )\n+\n+    def remove_sql(self, model, schema_editor):\n+        return schema_editor._delete_constraint_sql(\n+            schema_editor.sql_delete_check,\n+            model,\n+            schema_editor.quote_name(self.name),\n+        )\n+\n+    def deconstruct(self):\n+        path, args, kwargs = super().deconstruct()\n+        kwargs['expressions'] = self.expressions\n+        if self.condition is not None:\n+            kwargs['condition'] = self.condition\n+        if self.index_type.lower() != 'gist':\n+            kwargs['index_type'] = self.index_type\n+        return path, args, kwargs\n+\n+    def __eq__(self, other):\n+        return (\n+            isinstance(other, self.__class__) and\n+            self.name == other.name and\n+            self.index_type == other.index_type and\n+            self.expressions == other.expressions and\n+            self.condition == other.condition\n+        )\n+\n+    def __repr__(self):\n+        return '<%s: index_type=%s, expressions=%s%s>' % (\n+            self.__class__.__qualname__,\n+            self.index_type,\n+            self.expressions,\n+            '' if self.condition is None else ', condition=%s' % self.condition,\n+        )\ndiff --git a/docs/ref/contrib/postgres/constraints.txt b/docs/ref/contrib/postgres/constraints.txt\nnew file mode 100644\nindex 000000000000..fe9e72e6055a\n--- /dev/null\n+++ b/docs/ref/contrib/postgres/constraints.txt\n@@ -0,0 +1,151 @@\n+========================================\n+PostgreSQL specific database constraints\n+========================================\n+\n+.. module:: django.contrib.postgres.constraints\n+   :synopsis: PostgreSQL specific database constraint\n+\n+PostgreSQL supports additional data integrity constraints available from the\n+``django.contrib.postgres.constraints`` module. They are added in the model\n+:attr:`Meta.constraints <django.db.models.Options.constraints>` option.\n+\n+``ExclusionConstraint``\n+=======================\n+\n+.. versionadded:: 3.0\n+\n+.. class:: ExclusionConstraint(*, name, expressions, index_type=None, condition=None)\n+\n+    Creates an exclusion constraint in the database. Internally, PostgreSQL\n+    implements exclusion constraints using indexes. The default index type is\n+    `GiST <https://www.postgresql.org/docs/current/gist.html>`_. To use them,\n+    you need to activate the `btree_gist extension\n+    <https://www.postgresql.org/docs/current/btree-gist.html>`_ on PostgreSQL.\n+    You can install it using the\n+    :class:`~django.contrib.postgres.operations.BtreeGistExtension` migration\n+    operation.\n+\n+    If you attempt to insert a new row that conflicts with an existing row, an\n+    :exc:`~django.db.IntegrityError` is raised. Similarly, when update\n+    conflicts with an existing row.\n+\n+``name``\n+--------\n+\n+.. attribute:: ExclusionConstraint.name\n+\n+The name of the constraint.\n+\n+``expressions``\n+---------------\n+\n+.. attribute:: ExclusionConstraint.expressions\n+\n+An iterable of 2-tuples. The first element is an expression or string. The\n+second element is a SQL operator represented as a string. To avoid typos, you\n+may use :class:`~django.contrib.postgres.fields.RangeOperators` which maps the\n+operators with strings. For example::\n+\n+    expressions=[\n+        ('timespan', RangeOperators.ADJACENT_TO),\n+        (F('room'), RangeOperators.EQUAL),\n+    ]\n+\n+.. admonition:: Restrictions on operators.\n+\n+    Only commutative operators can be used in exclusion constraints.\n+\n+``index_type``\n+--------------\n+\n+.. attribute:: ExclusionConstraint.index_type\n+\n+The index type of the constraint. Accepted values are ``GIST`` or ``SPGIST``.\n+Matching is case insensitive. If not provided, the default index type is\n+``GIST``.\n+\n+``condition``\n+-------------\n+\n+.. attribute:: ExclusionConstraint.condition\n+\n+A :class:`~django.db.models.Q` object that specifies the condition to restrict\n+a constraint to a subset of rows. For example,\n+``condition=Q(cancelled=False)``.\n+\n+These conditions have the same database restrictions as\n+:attr:`django.db.models.Index.condition`.\n+\n+Examples\n+--------\n+\n+The following example restricts overlapping reservations in the same room, not\n+taking canceled reservations into account::\n+\n+    from django.contrib.postgres.constraints import ExclusionConstraint\n+    from django.contrib.postgres.fields import DateTimeRangeField, RangeOperators\n+    from django.db import models\n+    from django.db.models import Q\n+\n+    class Room(models.Model):\n+        number = models.IntegerField()\n+\n+\n+    class Reservation(models.Model):\n+        room = models.ForeignKey('Room', on_delete=models.CASCADE)\n+        timespan = DateTimeRangeField()\n+        cancelled = models.BooleanField(default=False)\n+\n+        class Meta:\n+            constraints = [\n+                ExclusionConstraint(\n+                    name='exclude_overlapping_reservations',\n+                    expressions=[\n+                        ('timespan', RangeOperators.OVERLAPS),\n+                        ('room', RangeOperators.EQUAL),\n+                    ],\n+                    condition=Q(cancelled=False),\n+                ),\n+            ]\n+\n+In case your model defines a range using two fields, instead of the native\n+PostgreSQL range types, you should write an expression that uses the equivalent\n+function (e.g. ``TsTzRange()``), and use the delimiters for the field. Most\n+often, the delimiters will be ``'[)'``, meaning that the lower bound is\n+inclusive and the upper bound is exclusive. You may use the\n+:class:`~django.contrib.postgres.fields.RangeBoundary` that provides an\n+expression mapping for the `range boundaries <https://www.postgresql.org/docs/\n+current/rangetypes.html#RANGETYPES-INCLUSIVITY>`_. For example::\n+\n+    from django.contrib.postgres.constraints import ExclusionConstraint\n+    from django.contrib.postgres.fields import (\n+        DateTimeRangeField,\n+        RangeBoundary,\n+        RangeOperators,\n+    )\n+    from django.db import models\n+    from django.db.models import Func, Q\n+\n+\n+    class TsTzRange(Func):\n+        function = 'TSTZRANGE'\n+        output_field = DateTimeRangeField()\n+\n+\n+    class Reservation(models.Model):\n+        room = models.ForeignKey('Room', on_delete=models.CASCADE)\n+        start = models.DateTimeField()\n+        end = models.DateTimeField()\n+        cancelled = models.BooleanField(default=False)\n+\n+        class Meta:\n+            constraints = [\n+                ExclusionConstraint(\n+                    name='exclude_overlapping_reservations',\n+                    expressions=(\n+                        (TsTzRange('start', 'end', RangeBoundary()), RangeOperators.OVERLAPS),\n+                        ('room', RangeOperators.EQUAL),\n+                    ),\n+                    condition=Q(cancelled=False),\n+                ),\n+            ]\ndiff --git a/docs/ref/contrib/postgres/fields.txt b/docs/ref/contrib/postgres/fields.txt\nindex 34c4a4892d62..14cb1d00cbbb 100644\n--- a/docs/ref/contrib/postgres/fields.txt\n+++ b/docs/ref/contrib/postgres/fields.txt\n@@ -916,3 +916,54 @@ types.\n     .. attribute:: range_type\n \n         The psycopg2 range type to use.\n+\n+Range operators\n+---------------\n+\n+.. versionadded:: 3.0\n+\n+.. class:: RangeOperators\n+\n+PostgreSQL provides a set of SQL operators that can be used together with the\n+range data types (see `the PostgreSQL documentation for the full details of\n+range operators <https://www.postgresql.org/docs/current/\n+functions-range.html#RANGE-OPERATORS-TABLE>`_). This class is meant as a\n+convenient method to avoid typos. The operator names overlap with the names of\n+corresponding lookups.\n+\n+.. code-block:: python\n+\n+    class RangeOperators:\n+        EQUAL = '='\n+        NOT_EQUAL = '<>'\n+        CONTAINS = '@>'\n+        CONTAINED_BY = '<@'\n+        OVERLAPS = '&&'\n+        FULLY_LT = '<<'\n+        FULLY_GT = '>>'\n+        NOT_LT = '&>'\n+        NOT_GT = '&<'\n+        ADJACENT_TO = '-|-'\n+\n+RangeBoundary() expressions\n+---------------------------\n+\n+.. versionadded:: 3.0\n+\n+.. class:: RangeBoundary(inclusive_lower=True, inclusive_upper=False)\n+\n+    .. attribute:: inclusive_lower\n+\n+        If ``True`` (default), the lower bound is inclusive ``'['``, otherwise\n+        it's exclusive ``'('``.\n+\n+    .. attribute:: inclusive_upper\n+\n+        If ``False`` (default), the upper bound is exclusive ``')'``, otherwise\n+        it's inclusive ``']'``.\n+\n+A ``RangeBoundary()`` expression represents the range boundaries. It can be\n+used with a custom range functions that expected boundaries, for example to\n+define :class:`~django.contrib.postgres.constraints.ExclusionConstraint`. See\n+`the PostgreSQL documentation for the full details <https://www.postgresql.org/\n+docs/current/rangetypes.html#RANGETYPES-INCLUSIVITY>`_.\ndiff --git a/tests/postgres_tests/test_constraints.py b/tests/postgres_tests/test_constraints.py\nindex 3ecabcbd49f9..d8665f59f61f 100644\n--- a/tests/postgres_tests/test_constraints.py\n+++ b/tests/postgres_tests/test_constraints.py\n@@ -77,3 +81,249 @@ def test_check_constraint_datetimerange_contains(self):\n             timestamps=(datetime_1, datetime_2),\n             timestamps_inner=(datetime_1, datetime_2),\n         )\n+\n+\n+class ExclusionConstraintTests(PostgreSQLTestCase):\n+    def get_constraints(self, table):\n+        \"\"\"Get the constraints on the table using a new cursor.\"\"\"\n+        with connection.cursor() as cursor:\n+            return connection.introspection.get_constraints(cursor, table)\n+\n+    def test_invalid_condition(self):\n+        msg = 'ExclusionConstraint.condition must be a Q instance.'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            ExclusionConstraint(\n+                index_type='GIST',\n+                name='exclude_invalid_condition',\n+                expressions=[(F('datespan'), RangeOperators.OVERLAPS)],\n+                condition=F('invalid'),\n+            )\n+\n+    def test_invalid_index_type(self):\n+        msg = 'Exclusion constraints only support GiST or SP-GiST indexes.'\n+        with self.assertRaisesMessage(ValueError, msg):\n+            ExclusionConstraint(\n+                index_type='gin',\n+                name='exclude_invalid_index_type',\n+                expressions=[(F('datespan'), RangeOperators.OVERLAPS)],\n+            )\n+\n+    def test_invalid_expressions(self):\n+        msg = 'The expressions must be a list of 2-tuples.'\n+        for expressions in (['foo'], [('foo')], [('foo_1', 'foo_2', 'foo_3')]):\n+            with self.subTest(expressions), self.assertRaisesMessage(ValueError, msg):\n+                ExclusionConstraint(\n+                    index_type='GIST',\n+                    name='exclude_invalid_expressions',\n+                    expressions=expressions,\n+                )\n+\n+    def test_empty_expressions(self):\n+        msg = 'At least one expression is required to define an exclusion constraint.'\n+        for empty_expressions in (None, []):\n+            with self.subTest(empty_expressions), self.assertRaisesMessage(ValueError, msg):\n+                ExclusionConstraint(\n+                    index_type='GIST',\n+                    name='exclude_empty_expressions',\n+                    expressions=empty_expressions,\n+                )\n+\n+    def test_repr(self):\n+        constraint = ExclusionConstraint(\n+            name='exclude_overlapping',\n+            expressions=[\n+                (F('datespan'), RangeOperators.OVERLAPS),\n+                (F('room'), RangeOperators.EQUAL),\n+            ],\n+        )\n+        self.assertEqual(\n+            repr(constraint),\n+            \"<ExclusionConstraint: index_type=GIST, expressions=[\"\n+            \"(F(datespan), '&&'), (F(room), '=')]>\",\n+        )\n+        constraint = ExclusionConstraint(\n+            name='exclude_overlapping',\n+            expressions=[(F('datespan'), RangeOperators.ADJACENT_TO)],\n+            condition=Q(cancelled=False),\n+            index_type='SPGiST',\n+        )\n+        self.assertEqual(\n+            repr(constraint),\n+            \"<ExclusionConstraint: index_type=SPGiST, expressions=[\"\n+            \"(F(datespan), '-|-')], condition=(AND: ('cancelled', False))>\",\n+        )\n+\n+    def test_eq(self):\n+        constraint_1 = ExclusionConstraint(\n+            name='exclude_overlapping',\n+            expressions=[\n+                (F('datespan'), RangeOperators.OVERLAPS),\n+                (F('room'), RangeOperators.EQUAL),\n+            ],\n+            condition=Q(cancelled=False),\n+        )\n+        constraint_2 = ExclusionConstraint(\n+            name='exclude_overlapping',\n+            expressions=[\n+                ('datespan', RangeOperators.OVERLAPS),\n+                ('room', RangeOperators.EQUAL),\n+            ],\n+        )\n+        constraint_3 = ExclusionConstraint(\n+            name='exclude_overlapping',\n+            expressions=[('datespan', RangeOperators.OVERLAPS)],\n+            condition=Q(cancelled=False),\n+        )\n+        self.assertEqual(constraint_1, constraint_1)\n+        self.assertNotEqual(constraint_1, constraint_2)\n+        self.assertNotEqual(constraint_1, constraint_3)\n+        self.assertNotEqual(constraint_2, constraint_3)\n+        self.assertNotEqual(constraint_1, object())\n+\n+    def test_deconstruct(self):\n+        constraint = ExclusionConstraint(\n+            name='exclude_overlapping',\n+            expressions=[('datespan', RangeOperators.OVERLAPS), ('room', RangeOperators.EQUAL)],\n+        )\n+        path, args, kwargs = constraint.deconstruct()\n+        self.assertEqual(path, 'django.contrib.postgres.constraints.ExclusionConstraint')\n+        self.assertEqual(args, ())\n+        self.assertEqual(kwargs, {\n+            'name': 'exclude_overlapping',\n+            'expressions': [('datespan', RangeOperators.OVERLAPS), ('room', RangeOperators.EQUAL)],\n+        })\n+\n+    def test_deconstruct_index_type(self):\n+        constraint = ExclusionConstraint(\n+            name='exclude_overlapping',\n+            index_type='SPGIST',\n+            expressions=[('datespan', RangeOperators.OVERLAPS), ('room', RangeOperators.EQUAL)],\n+        )\n+        path, args, kwargs = constraint.deconstruct()\n+        self.assertEqual(path, 'django.contrib.postgres.constraints.ExclusionConstraint')\n+        self.assertEqual(args, ())\n+        self.assertEqual(kwargs, {\n+            'name': 'exclude_overlapping',\n+            'index_type': 'SPGIST',\n+            'expressions': [('datespan', RangeOperators.OVERLAPS), ('room', RangeOperators.EQUAL)],\n+        })\n+\n+    def test_deconstruct_condition(self):\n+        constraint = ExclusionConstraint(\n+            name='exclude_overlapping',\n+            expressions=[('datespan', RangeOperators.OVERLAPS), ('room', RangeOperators.EQUAL)],\n+            condition=Q(cancelled=False),\n+        )\n+        path, args, kwargs = constraint.deconstruct()\n+        self.assertEqual(path, 'django.contrib.postgres.constraints.ExclusionConstraint')\n+        self.assertEqual(args, ())\n+        self.assertEqual(kwargs, {\n+            'name': 'exclude_overlapping',\n+            'expressions': [('datespan', RangeOperators.OVERLAPS), ('room', RangeOperators.EQUAL)],\n+            'condition': Q(cancelled=False),\n+        })\n+\n+    def _test_range_overlaps(self, constraint):\n+        # Create exclusion constraint.\n+        self.assertNotIn(constraint.name, self.get_constraints(HotelReservation._meta.db_table))\n+        with connection.schema_editor() as editor:\n+            editor.add_constraint(HotelReservation, constraint)\n+        self.assertIn(constraint.name, self.get_constraints(HotelReservation._meta.db_table))\n+        # Add initial reservations.\n+        room101 = Room.objects.create(number=101)\n+        room102 = Room.objects.create(number=102)\n+        datetimes = [\n+            timezone.datetime(2018, 6, 20),\n+            timezone.datetime(2018, 6, 24),\n+            timezone.datetime(2018, 6, 26),\n+            timezone.datetime(2018, 6, 28),\n+            timezone.datetime(2018, 6, 29),\n+        ]\n+        HotelReservation.objects.create(\n+            datespan=DateRange(datetimes[0].date(), datetimes[1].date()),\n+            start=datetimes[0],\n+            end=datetimes[1],\n+            room=room102,\n+        )\n+        HotelReservation.objects.create(\n+            datespan=DateRange(datetimes[1].date(), datetimes[3].date()),\n+            start=datetimes[1],\n+            end=datetimes[3],\n+            room=room102,\n+        )\n+        # Overlap dates.\n+        with self.assertRaises(IntegrityError), transaction.atomic():\n+            reservation = HotelReservation(\n+                datespan=(datetimes[1].date(), datetimes[2].date()),\n+                start=datetimes[1],\n+                end=datetimes[2],\n+                room=room102,\n+            )\n+            reservation.save()\n+        # Valid range.\n+        HotelReservation.objects.bulk_create([\n+            # Other room.\n+            HotelReservation(\n+                datespan=(datetimes[1].date(), datetimes[2].date()),\n+                start=datetimes[1],\n+                end=datetimes[2],\n+                room=room101,\n+            ),\n+            # Cancelled reservation.\n+            HotelReservation(\n+                datespan=(datetimes[1].date(), datetimes[1].date()),\n+                start=datetimes[1],\n+                end=datetimes[2],\n+                room=room102,\n+                cancelled=True,\n+            ),\n+            # Other adjacent dates.\n+            HotelReservation(\n+                datespan=(datetimes[3].date(), datetimes[4].date()),\n+                start=datetimes[3],\n+                end=datetimes[4],\n+                room=room102,\n+            ),\n+        ])\n+\n+    def test_range_overlaps_custom(self):\n+        class TsTzRange(Func):\n+            function = 'TSTZRANGE'\n+            output_field = DateTimeRangeField()\n+\n+        constraint = ExclusionConstraint(\n+            name='exclude_overlapping_reservations_custom',\n+            expressions=[\n+                (TsTzRange('start', 'end', RangeBoundary()), RangeOperators.OVERLAPS),\n+                ('room', RangeOperators.EQUAL)\n+            ],\n+            condition=Q(cancelled=False),\n+        )\n+        self._test_range_overlaps(constraint)\n+\n+    def test_range_overlaps(self):\n+        constraint = ExclusionConstraint(\n+            name='exclude_overlapping_reservations',\n+            expressions=[\n+                (F('datespan'), RangeOperators.OVERLAPS),\n+                ('room', RangeOperators.EQUAL)\n+            ],\n+            condition=Q(cancelled=False),\n+        )\n+        self._test_range_overlaps(constraint)\n+\n+    def test_range_adjacent(self):\n+        constraint_name = 'ints_adjacent'\n+        self.assertNotIn(constraint_name, self.get_constraints(RangesModel._meta.db_table))\n+        constraint = ExclusionConstraint(\n+            name=constraint_name,\n+            expressions=[('ints', RangeOperators.ADJACENT_TO)],\n+        )\n+        with connection.schema_editor() as editor:\n+            editor.add_constraint(RangesModel, constraint)\n+        self.assertIn(constraint_name, self.get_constraints(RangesModel._meta.db_table))\n+        RangesModel.objects.create(ints=(20, 50))\n+        with self.assertRaises(IntegrityError), transaction.atomic():\n+            RangesModel.objects.create(ints=(10, 20))\n+        RangesModel.objects.create(ints=(10, 19))\n+        RangesModel.objects.create(ints=(51, 60))\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR has made substantial progress, addressing most feedback except for discussions around `&&` versus constants. While introducing `F().with()` and `Expression().with()` is appealing, it complicates the PostgreSQL backend with subclasses. Documentation reliance on PostgreSQL's operators is reasonable, given target users' familiarity. However, tests are failing on unrelated backends, and the proposed solution using `try/except` isn't effective. There's a potential issue with the condition check returning `None`, which may be unnecessary. Overall, simplifications are strong, but further testing is essential for exclusion constraints."
      }
    ],
    "token_estimation": 5865.25
  },
  {
    "index": 29,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/models/constraints.py b/django/db/models/constraints.py\nindex 3577c638ef2f..9949b50b1e4e 100644\n--- a/django/db/models/constraints.py\n+++ b/django/db/models/constraints.py\n@@ -265,3 +289,61 @@ def deconstruct(self):\n         if self.opclasses:\n             kwargs[\"opclasses\"] = self.opclasses\n         return path, self.expressions, kwargs\n+\n+    def validate(self, model, instance, exclude=None, using=DEFAULT_DB_ALIAS):\n+        queryset = model._default_manager.using(using)\n+        if self.fields:\n+            lookup_kwargs = {}\n+            for field_name in self.fields:\n+                if exclude and field_name in exclude:\n+                    return\n+                field = model._meta.get_field(field_name)\n+                lookup_value = getattr(instance, field.attname)\n+                if lookup_value is None or (\n+                    lookup_value == \"\"\n+                    and connections[using].features.interprets_empty_strings_as_nulls\n+                ):\n+                    # A composite constraint containing NULL value cannot cause\n+                    # a violation since NULL != NULL in SQL.\n+                    return\n+                lookup_kwargs[field.name] = lookup_value\n+            queryset = queryset.filter(**lookup_kwargs)\n+        else:\n+            # Ignore constraints with excluded fields.\n+            if exclude:\n+                for expression in self.expressions:\n+                    for expr in expression.flatten():\n+                        if isinstance(expr, F) and expr.name in exclude:\n+                            return\n+            replacement_map = instance._get_field_value_map(\n+                meta=model._meta, exclude=exclude\n+            )\n+            expressions = [\n+                Exact(expr, expr.replace_references(replacement_map))\n+                for expr in self.expressions\n+            ]\n+            queryset = queryset.filter(*expressions)\n+        model_class_pk = instance._get_pk_val(model._meta)\n+        if not instance._state.adding and model_class_pk is not None:\n+            queryset = queryset.exclude(pk=model_class_pk)\n+        if not self.condition:\n+            if queryset.exists():\n+                if self.expressions:\n+                    raise ValidationError(self.get_violation_error_message())\n+                # When fields are defined, use the unique_error_message() for\n+                # backward compatibility.\n+                for model, constraints in instance.get_constraints():\n+                    for constraint in constraints:\n+                        if constraint is self:\n+                            raise ValidationError(\n+                                instance.unique_error_message(model, self.fields)\n+                            )\n+        else:\n+            against = instance._get_field_value_map(meta=model._meta, exclude=exclude)\n+            try:\n+                if (self.condition & Exists(queryset.filter(self.condition))).check(\n+                    against, using=using\n+                ):\n+                    raise ValidationError(self.get_violation_error_message())\n+            except FieldError:\n+                pass\ndiff --git a/tests/constraints/tests.py b/tests/constraints/tests.py\nindex 58960fa5a3c5..d9e377438e82 100644\n--- a/tests/constraints/tests.py\n+++ b/tests/constraints/tests.py\n@@ -415,15 +478,135 @@ def test_model_validation(self):\n         with self.assertRaisesMessage(ValidationError, msg):\n             UniqueConstraintProduct(\n                 name=self.p1.name, color=self.p1.color\n-            ).validate_unique()\n+            ).validate_constraints()\n \n     @skipUnlessDBFeature(\"supports_partial_indexes\")\n     def test_model_validation_with_condition(self):\n-        \"\"\"Partial unique constraints are ignored by Model.validate_unique().\"\"\"\n+        \"\"\"\n+        Partial unique constraints are not ignored by\n+        Model.validate_constraints().\n+        \"\"\"\n         obj1 = UniqueConstraintConditionProduct.objects.create(name=\"p1\", color=\"red\")\n         obj2 = UniqueConstraintConditionProduct.objects.create(name=\"p2\")\n-        UniqueConstraintConditionProduct(name=obj1.name, color=\"blue\").validate_unique()\n-        UniqueConstraintConditionProduct(name=obj2.name).validate_unique()\n+        UniqueConstraintConditionProduct(\n+            name=obj1.name, color=\"blue\"\n+        ).validate_constraints()\n+        msg = \"Constraint “name_without_color_uniq” is violated.\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            UniqueConstraintConditionProduct(name=obj2.name).validate_constraints()\n+\n+    def test_validate(self):\n+        constraint = UniqueConstraintProduct._meta.constraints[0]\n+        msg = \"Unique constraint product with this Name and Color already exists.\"\n+        non_unique_product = UniqueConstraintProduct(\n+            name=self.p1.name, color=self.p1.color\n+        )\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(UniqueConstraintProduct, non_unique_product)\n+        # Null values are ignored.\n+        constraint.validate(\n+            UniqueConstraintProduct,\n+            UniqueConstraintProduct(name=self.p2.name, color=None),\n+        )\n+        # Existing instances have their existing row excluded.\n+        constraint.validate(UniqueConstraintProduct, self.p1)\n+        # Unique fields are excluded.\n+        constraint.validate(\n+            UniqueConstraintProduct,\n+            non_unique_product,\n+            exclude={\"name\"},\n+        )\n+        constraint.validate(\n+            UniqueConstraintProduct,\n+            non_unique_product,\n+            exclude={\"color\"},\n+        )\n+        constraint.validate(\n+            UniqueConstraintProduct,\n+            non_unique_product,\n+            exclude={\"name\", \"color\"},\n+        )\n+        # Validation on a child instance.\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(\n+                UniqueConstraintProduct,\n+                ChildUniqueConstraintProduct(name=self.p1.name, color=self.p1.color),\n+            )\n+\n+    @skipUnlessDBFeature(\"supports_partial_indexes\")\n+    def test_validate_condition(self):\n+        p1 = UniqueConstraintConditionProduct.objects.create(name=\"p1\")\n+        constraint = UniqueConstraintConditionProduct._meta.constraints[0]\n+        msg = \"Constraint “name_without_color_uniq” is violated.\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(\n+                UniqueConstraintConditionProduct,\n+                UniqueConstraintConditionProduct(name=p1.name, color=None),\n+            )\n+        # Values not matching condition are ignored.\n+        constraint.validate(\n+            UniqueConstraintConditionProduct,\n+            UniqueConstraintConditionProduct(name=p1.name, color=\"anything-but-none\"),\n+        )\n+        # Existing instances have their existing row excluded.\n+        constraint.validate(UniqueConstraintConditionProduct, p1)\n+        # Unique field is excluded.\n+        constraint.validate(\n+            UniqueConstraintConditionProduct,\n+            UniqueConstraintConditionProduct(name=p1.name, color=None),\n+            exclude={\"name\"},\n+        )\n+\n+    def test_validate_expression(self):\n+        constraint = models.UniqueConstraint(Lower(\"name\"), name=\"name_lower_uniq\")\n+        msg = \"Constraint “name_lower_uniq” is violated.\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(\n+                UniqueConstraintProduct,\n+                UniqueConstraintProduct(name=self.p1.name.upper()),\n+            )\n+        constraint.validate(\n+            UniqueConstraintProduct,\n+            UniqueConstraintProduct(name=\"another-name\"),\n+        )\n+        # Existing instances have their existing row excluded.\n+        constraint.validate(UniqueConstraintProduct, self.p1)\n+        # Unique field is excluded.\n+        constraint.validate(\n+            UniqueConstraintProduct,\n+            UniqueConstraintProduct(name=self.p1.name.upper()),\n+            exclude={\"name\"},\n+        )\n+\n+    def test_validate_expression_condition(self):\n+        constraint = models.UniqueConstraint(\n+            Lower(\"name\"),\n+            name=\"name_lower_without_color_uniq\",\n+            condition=models.Q(color__isnull=True),\n+        )\n+        non_unique_product = UniqueConstraintProduct(name=self.p2.name.upper())\n+        msg = \"Constraint “name_lower_without_color_uniq” is violated.\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(UniqueConstraintProduct, non_unique_product)\n+        # Values not matching condition are ignored.\n+        constraint.validate(\n+            UniqueConstraintProduct,\n+            UniqueConstraintProduct(name=self.p1.name, color=self.p1.color),\n+        )\n+        # Existing instances have their existing row excluded.\n+        constraint.validate(UniqueConstraintProduct, self.p2)\n+        # Unique field is excluded.\n+        constraint.validate(\n+            UniqueConstraintProduct,\n+            non_unique_product,\n+            exclude={\"name\"},\n+        )\n+        # Field from a condition is excluded.\n+        constraint.validate(\n+            UniqueConstraintProduct,\n+            non_unique_product,\n+            exclude={\"color\"},\n+        )\n \n     def test_name(self):\n         constraints = get_constraints(UniqueConstraintProduct._meta.db_table)\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 5ea830d0ecf1..08aca62850b6 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -2198,6 +2198,66 @@ class Meta:\n         ]\n         self.assertCountEqual(errors, expected_errors)\n \n+    def test_check_constraint_raw_sql_check(self):\n+        class Model(models.Model):\n+            class Meta:\n+                required_db_features = {\"supports_table_check_constraints\"}\n+                constraints = [\n+                    models.CheckConstraint(check=models.Q(id__gt=0), name=\"q_check\"),\n+                    models.CheckConstraint(\n+                        check=models.ExpressionWrapper(\n+                            models.Q(price__gt=20),\n+                            output_field=models.BooleanField(),\n+                        ),\n+                        name=\"expression_wrapper_check\",\n+                    ),\n+                    models.CheckConstraint(\n+                        check=models.expressions.RawSQL(\n+                            \"id = 0\",\n+                            params=(),\n+                            output_field=models.BooleanField(),\n+                        ),\n+                        name=\"raw_sql_check\",\n+                    ),\n+                    models.CheckConstraint(\n+                        check=models.Q(\n+                            models.ExpressionWrapper(\n+                                models.Q(\n+                                    models.expressions.RawSQL(\n+                                        \"id = 0\",\n+                                        params=(),\n+                                        output_field=models.BooleanField(),\n+                                    )\n+                                ),\n+                                output_field=models.BooleanField(),\n+                            )\n+                        ),\n+                        name=\"nested_raw_sql_check\",\n+                    ),\n+                ]\n+\n+        expected_warnings = (\n+            [\n+                Warning(\n+                    \"Check constraint 'raw_sql_check' contains RawSQL() expression and \"\n+                    \"won't be validated during the model full_clean().\",\n+                    hint=\"Silence this warning if you don't care about it.\",\n+                    obj=Model,\n+                    id=\"models.W045\",\n+                ),\n+                Warning(\n+                    \"Check constraint 'nested_raw_sql_check' contains RawSQL() \"\n+                    \"expression and won't be validated during the model full_clean().\",\n+                    hint=\"Silence this warning if you don't care about it.\",\n+                    obj=Model,\n+                    id=\"models.W045\",\n+                ),\n+            ]\n+            if connection.features.supports_table_check_constraints\n+            else []\n+        )\n+        self.assertEqual(Model.check(databases=self.databases), expected_warnings)\n+\n     def test_unique_constraint_with_condition(self):\n         class Model(models.Model):\n             age = models.IntegerField()\ndiff --git a/tests/validation/models.py b/tests/validation/models.py\nindex 6934fa017c53..8919a6931003 100644\n--- a/tests/validation/models.py\n+++ b/tests/validation/models.py\n@@ -161,3 +161,59 @@ class Meta:\n         constraints = [\n             models.UniqueConstraint(Lower(\"field\"), name=\"func_lower_field_uq\"),\n         ]\n+\n+\n+class Product(models.Model):\n+    price = models.IntegerField(null=True)\n+    discounted_price = models.IntegerField(null=True)\n+\n+    class Meta:\n+        required_db_features = {\n+            \"supports_table_check_constraints\",\n+        }\n+        constraints = [\n+            models.CheckConstraint(\n+                check=models.Q(price__gt=models.F(\"discounted_price\")),\n+                name=\"price_gt_discounted_price_validation\",\n+            ),\n+        ]\n+\n+\n+class ChildProduct(Product):\n+    class Meta:\n+        required_db_features = {\n+            \"supports_table_check_constraints\",\n+        }\n+\n+\n+class UniqueConstraintProduct(models.Model):\n+    name = models.CharField(max_length=255)\n+    color = models.CharField(max_length=32)\n+    rank = models.IntegerField()\n+\n+    class Meta:\n+        constraints = [\n+            models.UniqueConstraint(\n+                fields=[\"name\", \"color\"], name=\"name_color_uniq_validation\"\n+            ),\n+            models.UniqueConstraint(fields=[\"rank\"], name=\"rank_uniq_validation\"),\n+        ]\n+\n+\n+class ChildUniqueConstraintProduct(UniqueConstraintProduct):\n+    pass\n+\n+\n+class UniqueConstraintConditionProduct(models.Model):\n+    name = models.CharField(max_length=255)\n+    color = models.CharField(max_length=31, null=True, blank=True)\n+\n+    class Meta:\n+        required_db_features = {\"supports_partial_indexes\"}\n+        constraints = [\n+            models.UniqueConstraint(\n+                fields=[\"name\"],\n+                name=\"name_without_color_uniq_validation\",\n+                condition=models.Q(color__isnull=True),\n+            ),\n+        ]\ndiff --git a/tests/validation/test_constraints.py b/tests/validation/test_constraints.py\nnew file mode 100644\nindex 000000000000..0b1ee6518e28\n--- /dev/null\n+++ b/tests/validation/test_constraints.py\n@@ -0,0 +1,95 @@\n+from django.core.exceptions import ValidationError\n+from django.test import TestCase, skipUnlessDBFeature\n+\n+from .models import (\n+    ChildProduct,\n+    ChildUniqueConstraintProduct,\n+    Product,\n+    UniqueConstraintConditionProduct,\n+    UniqueConstraintProduct,\n+)\n+\n+\n+class PerformConstraintChecksTest(TestCase):\n+    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n+    def test_full_clean_with_check_constraints(self):\n+        product = Product(price=10, discounted_price=15)\n+        with self.assertRaises(ValidationError) as cm:\n+            product.full_clean()\n+        self.assertEqual(\n+            cm.exception.message_dict,\n+            {\n+                \"__all__\": [\n+                    \"Constraint “price_gt_discounted_price_validation” is violated.\"\n+                ]\n+            },\n+        )\n+\n+    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n+    def test_full_clean_with_check_constraints_on_child_model(self):\n+        product = ChildProduct(price=10, discounted_price=15)\n+        with self.assertRaises(ValidationError) as cm:\n+            product.full_clean()\n+        self.assertEqual(\n+            cm.exception.message_dict,\n+            {\n+                \"__all__\": [\n+                    \"Constraint “price_gt_discounted_price_validation” is violated.\"\n+                ]\n+            },\n+        )\n+\n+    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n+    def test_full_clean_with_check_constraints_disabled(self):\n+        product = Product(price=10, discounted_price=15)\n+        product.full_clean(validate_constraints=False)\n+\n+    def test_full_clean_with_unique_constraints(self):\n+        UniqueConstraintProduct.objects.create(name=\"product\", color=\"yellow\", rank=1)\n+        tests = [\n+            UniqueConstraintProduct(name=\"product\", color=\"yellow\", rank=1),\n+            # Child model.\n+            ChildUniqueConstraintProduct(name=\"product\", color=\"yellow\", rank=1),\n+        ]\n+        for product in tests:\n+            with self.subTest(model=product.__class__.__name__):\n+                with self.assertRaises(ValidationError) as cm:\n+                    product.full_clean()\n+                self.assertEqual(\n+                    cm.exception.message_dict,\n+                    {\n+                        \"__all__\": [\n+                            \"Unique constraint product with this Name and Color \"\n+                            \"already exists.\"\n+                        ],\n+                        \"rank\": [\n+                            \"Unique constraint product with this Rank already exists.\"\n+                        ],\n+                    },\n+                )\n+\n+    def test_full_clean_with_unique_constraints_disabled(self):\n+        UniqueConstraintProduct.objects.create(name=\"product\", color=\"yellow\", rank=1)\n+        product = UniqueConstraintProduct(name=\"product\", color=\"yellow\", rank=1)\n+        product.full_clean(validate_constraints=False)\n+\n+    @skipUnlessDBFeature(\"supports_partial_indexes\")\n+    def test_full_clean_with_partial_unique_constraints(self):\n+        UniqueConstraintConditionProduct.objects.create(name=\"product\")\n+        product = UniqueConstraintConditionProduct(name=\"product\")\n+        with self.assertRaises(ValidationError) as cm:\n+            product.full_clean()\n+        self.assertEqual(\n+            cm.exception.message_dict,\n+            {\n+                \"__all__\": [\n+                    \"Constraint “name_without_color_uniq_validation” is violated.\"\n+                ]\n+            },\n+        )\n+\n+    @skipUnlessDBFeature(\"supports_partial_indexes\")\n+    def test_full_clean_with_partial_unique_constraints_disabled(self):\n+        UniqueConstraintConditionProduct.objects.create(name=\"product\")\n+        product = UniqueConstraintConditionProduct(name=\"product\")\n+        product.full_clean(validate_constraints=False)\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Moving all constraint validation to a dedicated `validate_constraint` method aligns with best practices and simplifies the logic in `Model._get_unique_checks`. The validation error messages should leverage `Model.unique_error_message` for consistency, especially to pass existing tests. The handling of exclusions in the `validate()` calls appears fragmented and could benefit from clearer comments. Additionally, introducing a model parameter for constraints would enhance usability but requires broader method refactoring, which might be beyond this PR's scope. Lastly, shifting to the `WHERE` clause in generated queries should streamline SQL generation, reducing unnecessary complexity."
      }
    ],
    "token_estimation": 4852.0
  },
  {
    "index": 30,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/utils/choices.py b/django/utils/choices.py\nnew file mode 100644\nindex 000000000000..fc8267af3431\n--- /dev/null\n+++ b/django/utils/choices.py\n@@ -0,0 +1,63 @@\n+from collections.abc import Callable, Iterable, Iterator, Mapping\n+\n+from django.db.models.enums import ChoicesMeta\n+from django.utils.functional import Promise\n+\n+\n+class ChoiceIterator:\n+    \"\"\"Base class for lazy iterators for choices.\"\"\"\n+\n+\n+class CallableChoiceIterator(ChoiceIterator):\n+    \"\"\"Iterator to lazily normalize choices generated by a callable.\"\"\"\n+\n+    def __init__(self, func):\n+        self.func = func\n+\n+    def __iter__(self):\n+        yield from normalize_choices(self.func())\n+\n+\n+def normalize_choices(value, *, depth=0):\n+    \"\"\"Normalize choices values consistently for fields and widgets.\"\"\"\n+\n+    match value:\n+        case ChoiceIterator() | Promise() | bytes() | str():\n+            # Avoid prematurely normalizing iterators that should be lazy.\n+            # Because string-like types are iterable, return early to avoid\n+            # iterating over them in the guard for the Iterable case below.\n+            return value\n+        case ChoicesMeta():\n+            # Choices enumeration helpers already output in canonical form.\n+            return value.choices\n+        case Mapping() if depth < 2:\n+            value = value.items()\n+        case Iterator() if depth < 2:\n+            # Although Iterator would be handled by the Iterable case below,\n+            # the iterator would be consumed prematurely while checking that\n+            # its elements are not string-like in the guard, so we handle it\n+            # separately.\n+            pass\n+        case Iterable() if depth < 2 and not any(\n+            isinstance(x, (Promise, bytes, str)) for x in value\n+        ):\n+            # String-like types are iterable, so the guard above ensures that\n+            # they're handled by the default case below.\n+            pass\n+        case Callable() if depth == 0:\n+            # If at the top level, wrap callables to be evaluated lazily.\n+            return CallableChoiceIterator(value)\n+        case Callable() if depth < 2:\n+            value = value()\n+        case _:\n+            return value\n+\n+    try:\n+        # Recursive call to convert any nested values to a list of 2-tuples.\n+        return [(k, normalize_choices(v, depth=depth + 1)) for k, v in value]\n+    except (TypeError, ValueError):\n+        # Return original value for the system check to raise if it has items\n+        # that are not iterable or not 2-tuples:\n+        # - TypeError: cannot unpack non-iterable <type> object\n+        # - ValueError: <not enough / too many> values to unpack\n+        return value\ndiff --git a/tests/utils_tests/test_choices.py b/tests/utils_tests/test_choices.py\nnew file mode 100644\nindex 000000000000..d96c3d49c4f4\n--- /dev/null\n+++ b/tests/utils_tests/test_choices.py\n@@ -0,0 +1,305 @@\n+from unittest import mock\n+\n+from django.db.models import TextChoices\n+from django.test import SimpleTestCase\n+from django.utils.choices import CallableChoiceIterator, normalize_choices\n+from django.utils.translation import gettext_lazy as _\n+\n+\n+class NormalizeFieldChoicesTests(SimpleTestCase):\n+    expected = [\n+        (\"C\", _(\"Club\")),\n+        (\"D\", _(\"Diamond\")),\n+        (\"H\", _(\"Heart\")),\n+        (\"S\", _(\"Spade\")),\n+    ]\n+    expected_nested = [\n+        (\"Audio\", [(\"vinyl\", _(\"Vinyl\")), (\"cd\", _(\"CD\"))]),\n+        (\"Video\", [(\"vhs\", _(\"VHS Tape\")), (\"dvd\", _(\"DVD\"))]),\n+        (\"unknown\", _(\"Unknown\")),\n+    ]\n+    invalid = [\n+        1j,\n+        123,\n+        123.45,\n+        \"invalid\",\n+        b\"invalid\",\n+        _(\"invalid\"),\n+        object(),\n+        None,\n+        True,\n+        False,\n+    ]\n+    invalid_iterable = [\n+        # Special cases of a string-likes which would unpack incorrectly.\n+        [\"ab\"],\n+        [b\"ab\"],\n+        [_(\"ab\")],\n+        # Non-iterable items or iterable items with incorrect number of\n+        # elements that cannot be unpacked.\n+        [123],\n+        [(\"value\",)],\n+        [(\"value\", \"label\", \"other\")],\n+    ]\n+    invalid_nested = [\n+        # Nested choices can only be two-levels deep, so return callables,\n+        # mappings, iterables, etc. at deeper levels unmodified.\n+        [(\"Group\", [(\"Value\", lambda: \"Label\")])],\n+        [(\"Group\", [(\"Value\", {\"Label 1?\": \"Label 2?\"})])],\n+        [(\"Group\", [(\"Value\", [(\"Label 1?\", \"Label 2?\")])])],\n+    ]\n+\n+    def test_empty(self):\n+        def generator():\n+            yield from ()\n+\n+        for choices in ({}, [], (), set(), frozenset(), generator()):\n+            with self.subTest(choices=choices):\n+                self.assertEqual(normalize_choices(choices), [])\n+\n+    def test_choices(self):\n+        class Medal(TextChoices):\n+            GOLD = \"GOLD\", _(\"Gold\")\n+            SILVER = \"SILVER\", _(\"Silver\")\n+            BRONZE = \"BRONZE\", _(\"Bronze\")\n+\n+        expected = [\n+            (\"GOLD\", _(\"Gold\")),\n+            (\"SILVER\", _(\"Silver\")),\n+            (\"BRONZE\", _(\"Bronze\")),\n+        ]\n+        self.assertEqual(normalize_choices(Medal), expected)\n+\n+    def test_callable(self):\n+        def get_choices():\n+            return {\n+                \"C\": _(\"Club\"),\n+                \"D\": _(\"Diamond\"),\n+                \"H\": _(\"Heart\"),\n+                \"S\": _(\"Spade\"),\n+            }\n+\n+        get_choices_spy = mock.Mock(wraps=get_choices)\n+        output = normalize_choices(get_choices_spy)\n+\n+        get_choices_spy.assert_not_called()\n+        self.assertIsInstance(output, CallableChoiceIterator)\n+        self.assertEqual(list(output), self.expected)\n+        get_choices_spy.assert_called_once()\n+\n+    def test_mapping(self):\n+        choices = {\n+            \"C\": _(\"Club\"),\n+            \"D\": _(\"Diamond\"),\n+            \"H\": _(\"Heart\"),\n+            \"S\": _(\"Spade\"),\n+        }\n+        self.assertEqual(normalize_choices(choices), self.expected)\n+\n+    def test_iterable(self):\n+        choices = [\n+            (\"C\", _(\"Club\")),\n+            (\"D\", _(\"Diamond\")),\n+            (\"H\", _(\"Heart\")),\n+            (\"S\", _(\"Spade\")),\n+        ]\n+        self.assertEqual(normalize_choices(choices), self.expected)\n+\n+    def test_iterator(self):\n+        def generator():\n+            yield \"C\", _(\"Club\")\n+            yield \"D\", _(\"Diamond\")\n+            yield \"H\", _(\"Heart\")\n+            yield \"S\", _(\"Spade\")\n+\n+        choices = generator()\n+        self.assertEqual(normalize_choices(choices), self.expected)\n+\n+    def test_nested_callable(self):\n+        def get_audio_choices():\n+            return [(\"vinyl\", _(\"Vinyl\")), (\"cd\", _(\"CD\"))]\n+\n+        def get_video_choices():\n+            return [(\"vhs\", _(\"VHS Tape\")), (\"dvd\", _(\"DVD\"))]\n+\n+        def get_media_choices():\n+            return [\n+                (\"Audio\", get_audio_choices),\n+                (\"Video\", get_video_choices),\n+                (\"unknown\", _(\"Unknown\")),\n+            ]\n+\n+        get_media_choices_spy = mock.Mock(wraps=get_media_choices)\n+        output = normalize_choices(get_media_choices_spy)\n+\n+        get_media_choices_spy.assert_not_called()\n+        self.assertIsInstance(output, CallableChoiceIterator)\n+        self.assertEqual(list(output), self.expected_nested)\n+        get_media_choices_spy.assert_called_once()\n+\n+    def test_nested_mapping(self):\n+        choices = {\n+            \"Audio\": {\"vinyl\": _(\"Vinyl\"), \"cd\": _(\"CD\")},\n+            \"Video\": {\"vhs\": _(\"VHS Tape\"), \"dvd\": _(\"DVD\")},\n+            \"unknown\": _(\"Unknown\"),\n+        }\n+        self.assertEqual(normalize_choices(choices), self.expected_nested)\n+\n+    def test_nested_iterable(self):\n+        choices = [\n+            (\"Audio\", [(\"vinyl\", _(\"Vinyl\")), (\"cd\", _(\"CD\"))]),\n+            (\"Video\", [(\"vhs\", _(\"VHS Tape\")), (\"dvd\", _(\"DVD\"))]),\n+            (\"unknown\", _(\"Unknown\")),\n+        ]\n+        self.assertEqual(normalize_choices(choices), self.expected_nested)\n+\n+    def test_nested_iterator(self):\n+        def generate_audio_choices():\n+            yield \"vinyl\", _(\"Vinyl\")\n+            yield \"cd\", _(\"CD\")\n+\n+        def generate_video_choices():\n+            yield \"vhs\", _(\"VHS Tape\")\n+            yield \"dvd\", _(\"DVD\")\n+\n+        def generate_media_choices():\n+            yield \"Audio\", generate_audio_choices()\n+            yield \"Video\", generate_video_choices()\n+            yield \"unknown\", _(\"Unknown\")\n+\n+        choices = generate_media_choices()\n+        self.assertEqual(normalize_choices(choices), self.expected_nested)\n+\n+    def test_callable_non_canonical(self):\n+        # Canonical form is list of 2-tuple, but nested lists should work.\n+        def get_choices():\n+            return [\n+                [\"C\", _(\"Club\")],\n+                [\"D\", _(\"Diamond\")],\n+                [\"H\", _(\"Heart\")],\n+                [\"S\", _(\"Spade\")],\n+            ]\n+\n+        get_choices_spy = mock.Mock(wraps=get_choices)\n+        output = normalize_choices(get_choices_spy)\n+\n+        get_choices_spy.assert_not_called()\n+        self.assertIsInstance(output, CallableChoiceIterator)\n+        self.assertEqual(list(output), self.expected)\n+        get_choices_spy.assert_called_once()\n+\n+    def test_iterable_non_canonical(self):\n+        # Canonical form is list of 2-tuple, but nested lists should work.\n+        choices = [\n+            [\"C\", _(\"Club\")],\n+            [\"D\", _(\"Diamond\")],\n+            [\"H\", _(\"Heart\")],\n+            [\"S\", _(\"Spade\")],\n+        ]\n+        self.assertEqual(normalize_choices(choices), self.expected)\n+\n+    def test_iterator_non_canonical(self):\n+        # Canonical form is list of 2-tuple, but nested lists should work.\n+        def generator():\n+            yield [\"C\", _(\"Club\")]\n+            yield [\"D\", _(\"Diamond\")]\n+            yield [\"H\", _(\"Heart\")]\n+            yield [\"S\", _(\"Spade\")]\n+\n+        choices = generator()\n+        self.assertEqual(normalize_choices(choices), self.expected)\n+\n+    def test_nested_callable_non_canonical(self):\n+        # Canonical form is list of 2-tuple, but nested lists should work.\n+\n+        def get_audio_choices():\n+            return [[\"vinyl\", _(\"Vinyl\")], [\"cd\", _(\"CD\")]]\n+\n+        def get_video_choices():\n+            return [[\"vhs\", _(\"VHS Tape\")], [\"dvd\", _(\"DVD\")]]\n+\n+        def get_media_choices():\n+            return [\n+                [\"Audio\", get_audio_choices],\n+                [\"Video\", get_video_choices],\n+                [\"unknown\", _(\"Unknown\")],\n+            ]\n+\n+        get_media_choices_spy = mock.Mock(wraps=get_media_choices)\n+        output = normalize_choices(get_media_choices_spy)\n+\n+        get_media_choices_spy.assert_not_called()\n+        self.assertIsInstance(output, CallableChoiceIterator)\n+        self.assertEqual(list(output), self.expected_nested)\n+        get_media_choices_spy.assert_called_once()\n+\n+    def test_nested_iterable_non_canonical(self):\n+        # Canonical form is list of 2-tuple, but nested lists should work.\n+        choices = [\n+            [\"Audio\", [[\"vinyl\", _(\"Vinyl\")], [\"cd\", _(\"CD\")]]],\n+            [\"Video\", [[\"vhs\", _(\"VHS Tape\")], [\"dvd\", _(\"DVD\")]]],\n+            [\"unknown\", _(\"Unknown\")],\n+        ]\n+        self.assertEqual(normalize_choices(choices), self.expected_nested)\n+\n+    def test_nested_iterator_non_canonical(self):\n+        # Canonical form is list of 2-tuple, but nested lists should work.\n+        def generator():\n+            yield [\"Audio\", [[\"vinyl\", _(\"Vinyl\")], [\"cd\", _(\"CD\")]]]\n+            yield [\"Video\", [[\"vhs\", _(\"VHS Tape\")], [\"dvd\", _(\"DVD\")]]]\n+            yield [\"unknown\", _(\"Unknown\")]\n+\n+        choices = generator()\n+        self.assertEqual(normalize_choices(choices), self.expected_nested)\n+\n+    def test_nested_mixed_mapping_and_iterable(self):\n+        # Although not documented, as it's better to stick to either mappings\n+        # or iterables, nesting of mappings within iterables and vice versa\n+        # works and is likely to occur in the wild. This is supported by the\n+        # recursive call to `normalize_choices()` which will normalize nested\n+        # choices.\n+        choices = {\n+            \"Audio\": [(\"vinyl\", _(\"Vinyl\")), (\"cd\", _(\"CD\"))],\n+            \"Video\": [(\"vhs\", _(\"VHS Tape\")), (\"dvd\", _(\"DVD\"))],\n+            \"unknown\": _(\"Unknown\"),\n+        }\n+        self.assertEqual(normalize_choices(choices), self.expected_nested)\n+        choices = [\n+            (\"Audio\", {\"vinyl\": _(\"Vinyl\"), \"cd\": _(\"CD\")}),\n+            (\"Video\", {\"vhs\": _(\"VHS Tape\"), \"dvd\": _(\"DVD\")}),\n+            (\"unknown\", _(\"Unknown\")),\n+        ]\n+        self.assertEqual(normalize_choices(choices), self.expected_nested)\n+\n+    def test_iterable_set(self):\n+        # Although not documented, as sets are unordered which results in\n+        # randomised order in form fields, passing a set of 2-tuples works.\n+        # Consistent ordering of choices on model fields in migrations is\n+        # enforced by the migrations serializer.\n+        choices = {\n+            (\"C\", _(\"Club\")),\n+            (\"D\", _(\"Diamond\")),\n+            (\"H\", _(\"Heart\")),\n+            (\"S\", _(\"Spade\")),\n+        }\n+        self.assertEqual(sorted(normalize_choices(choices)), sorted(self.expected))\n+\n+    def test_unsupported_values_returned_unmodified(self):\n+        # Unsupported values must be returned unmodified for model system check\n+        # to work correctly.\n+        for value in self.invalid + self.invalid_iterable + self.invalid_nested:\n+            with self.subTest(value=value):\n+                self.assertEqual(normalize_choices(value), value)\n+\n+    def test_unsupported_values_from_callable_returned_unmodified(self):\n+        for value in self.invalid_iterable + self.invalid_nested:\n+            with self.subTest(value=value):\n+                self.assertEqual(list(normalize_choices(lambda: value)), value)\n+\n+    def test_unsupported_values_from_iterator_returned_unmodified(self):\n+        for value in self.invalid_nested:\n+            with self.subTest(value=value):\n+                self.assertEqual(\n+                    list(normalize_choices((lambda: (yield from value))())),\n+                    value,\n+                )\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR introduces significant improvements to `normalize_choices()`, including explicit tests and renaming for clarity. However, the removal of callable support for model fields has led to regressions: passing a callable now bypasses validation checks, and `makemigrations` generates infinite migrations. To address this while preserving existing functionality, consider reintroducing handling for callable choices without full unrolling, potentially updating the `deconstruct` method to return wrapped functions. This preserves compatibility and avoids further complications related to ticket-24561. Let's prioritize stability before the feature freeze."
      }
    ],
    "token_estimation": 3699.75
  },
  {
    "index": 31,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/tests/csrf_tests/tests.py b/tests/csrf_tests/tests.py\nindex cd7ea8fbc606..a326df7f1afc 100644\n--- a/tests/csrf_tests/tests.py\n+++ b/tests/csrf_tests/tests.py\n@@ -107,77 +106,6 @@ def _check_token_present(self, response, csrf_id=None):\n             \"Could not find csrfmiddlewaretoken to match %s\" % csrf_token\n         )\n \n-    def test_process_view_token_too_long(self):\n-        \"\"\"\n-        If the token is longer than expected, it is ignored and a new token is\n-        created.\n-        \"\"\"\n-        req = self._get_GET_no_csrf_cookie_request()\n-        req.COOKIES[settings.CSRF_COOKIE_NAME] = 'x' * 100000\n-        CsrfViewMiddleware().process_view(req, token_view, (), {})\n-        resp = token_view(req)\n-        resp2 = CsrfViewMiddleware().process_response(req, resp)\n-        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n-        self.assertEqual(len(csrf_cookie.value), CSRF_TOKEN_LENGTH)\n-\n-    def test_process_view_token_invalid_chars(self):\n-        \"\"\"\n-        If the token contains non-alphanumeric characters, it is ignored and a\n-        new token is created.\n-        \"\"\"\n-        token = ('!@#' + self._csrf_id)[:CSRF_TOKEN_LENGTH]\n-        req = self._get_GET_no_csrf_cookie_request()\n-        req.COOKIES[settings.CSRF_COOKIE_NAME] = token\n-        CsrfViewMiddleware().process_view(req, token_view, (), {})\n-        resp = token_view(req)\n-        resp2 = CsrfViewMiddleware().process_response(req, resp)\n-        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n-        self.assertEqual(len(csrf_cookie.value), CSRF_TOKEN_LENGTH)\n-        self.assertNotEqual(csrf_cookie.value, token)\n-\n-    def test_process_view_token_invalid_bytes(self):\n-        \"\"\"\n-        If the token contains improperly encoded unicode, it is ignored and a\n-        new token is created.\n-        \"\"\"\n-        token = (b\"<1>\\xc2\\xa1\" + force_bytes(self._csrf_id, 'ascii'))[:CSRF_TOKEN_LENGTH]\n-        req = self._get_GET_no_csrf_cookie_request()\n-        req.COOKIES[settings.CSRF_COOKIE_NAME] = token\n-        # We expect a UnicodeWarning here, because we used broken utf-8 on purpose\n-        with warnings.catch_warnings():\n-            warnings.filterwarnings(\"ignore\", category=UnicodeWarning)\n-            CsrfViewMiddleware().process_view(req, token_view, (), {})\n-        resp = token_view(req)\n-        resp2 = CsrfViewMiddleware().process_response(req, resp)\n-        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n-        self.assertEqual(len(csrf_cookie.value), CSRF_TOKEN_LENGTH)\n-        self.assertNotEqual(csrf_cookie.value, token)\n-\n-    def test_process_response_get_token_used(self):\n-        \"\"\"\n-        When get_token is used, check that the cookie is created and headers\n-        patched.\n-        \"\"\"\n-        req = self._get_GET_no_csrf_cookie_request()\n-\n-        # Put tests for CSRF_COOKIE_* settings here\n-        with self.settings(CSRF_COOKIE_NAME='myname',\n-                           CSRF_COOKIE_DOMAIN='.example.com',\n-                           CSRF_COOKIE_PATH='/test/',\n-                           CSRF_COOKIE_SECURE=True,\n-                           CSRF_COOKIE_HTTPONLY=True):\n-            # token_view calls get_token() indirectly\n-            CsrfViewMiddleware().process_view(req, token_view, (), {})\n-            resp = token_view(req)\n-            resp2 = CsrfViewMiddleware().process_response(req, resp)\n-        csrf_cookie = resp2.cookies.get('myname', False)\n-        self.assertIsNot(csrf_cookie, False)\n-        self.assertEqual(csrf_cookie['domain'], '.example.com')\n-        self.assertIs(csrf_cookie['secure'], True)\n-        self.assertIs(csrf_cookie['httponly'], True)\n-        self.assertEqual(csrf_cookie['path'], '/test/')\n-        self.assertIn('Cookie', resp2.get('Vary', ''))\n-\n     def test_process_response_get_token_not_used(self):\n         \"\"\"\n         If get_token() is not called, the view middleware does not\n@@ -535,21 +435,98 @@ def test_https_good_referer_matches_cookie_domain_with_different_port(self):\n         response = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n         self.assertIsNone(response)\n \n-    @override_settings(CSRF_COOKIE_DOMAIN='.example.com', DEBUG=True)\n-    def test_https_reject_insecure_referer(self):\n+    def test_ensures_csrf_cookie_no_logging(self):\n         \"\"\"\n-        A POST HTTPS request from an insecure referer should be rejected.\n+        ensure_csrf_cookie() doesn't log warnings (#19436).\n         \"\"\"\n-        req = self._get_POST_request_with_token()\n-        req._is_secure_override = True\n-        req.META['HTTP_REFERER'] = 'http://example.com/'\n-        req.META['SERVER_PORT'] = '443'\n-        response = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n-        self.assertContains(\n-            response,\n-            'Referer checking failed - Referer is insecure while host is secure.',\n-            status_code=403,\n-        )\n+        @ensure_csrf_cookie\n+        def view(request):\n+            # Doesn't insert a token or anything\n+            return HttpResponse(content=\"\")\n+\n+        class TestHandler(logging.Handler):\n+            def emit(self, record):\n+                raise Exception(\"This shouldn't have happened!\")\n+\n+        logger = logging.getLogger('django.request')\n+        test_handler = TestHandler()\n+        old_log_level = logger.level\n+        try:\n+            logger.addHandler(test_handler)\n+            logger.setLevel(logging.WARNING)\n+\n+            req = self._get_GET_no_csrf_cookie_request()\n+            view(req)\n+        finally:\n+            logger.removeHandler(test_handler)\n+            logger.setLevel(old_log_level)\n+\n+    def test_post_data_read_failure(self):\n+        \"\"\"\n+        #20128 -- IOErrors during POST data reading should be caught and\n+        treated as if the POST data wasn't there.\n+        \"\"\"\n+        class CsrfPostRequest(HttpRequest):\n+            \"\"\"\n+            HttpRequest that can raise an IOError when accessing POST data\n+            \"\"\"\n+            def __init__(self, token, raise_error):\n+                super(CsrfPostRequest, self).__init__()\n+                self.method = 'POST'\n+\n+                self.raise_error = False\n+                self.COOKIES[settings.CSRF_COOKIE_NAME] = token\n+\n+                # We handle both cases here to prevent a lot of duplicate code\n+                # in the session tests\n+                self.session = {}\n+                self.session[CSRF_SESSION_KEY] = token\n+\n+                self.POST['csrfmiddlewaretoken'] = token\n+                self.raise_error = raise_error\n+\n+            def _load_post_and_files(self):\n+                raise IOError('error reading input data')\n+\n+            def _get_post(self):\n+                if self.raise_error:\n+                    self._load_post_and_files()\n+                return self._post\n+\n+            def _set_post(self, post):\n+                self._post = post\n+\n+            POST = property(_get_post, _set_post)\n+\n+        token = ('ABC' + self._csrf_id)[:CSRF_TOKEN_LENGTH]\n+\n+        req = CsrfPostRequest(token, raise_error=False)\n+        resp = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n+        self.assertIsNone(resp)\n+\n+        req = CsrfPostRequest(token, raise_error=True)\n+        with patch_logger('django.security.csrf', 'warning') as logger_calls:\n+            resp = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n+            self.assertEqual(resp.status_code, 403)\n+            self.assertEqual(logger_calls[0], 'Forbidden (%s): ' % REASON_BAD_TOKEN)\n+\n+\n+class CsrfViewMiddlewareTests(CsrfViewMiddlewareTestMixin, SimpleTestCase):\n+\n+    def _get_GET_csrf_cookie_request(self):\n+        req = TestingHttpRequest()\n+        req.COOKIES[settings.CSRF_COOKIE_NAME] = self._csrf_id_cookie\n+        return req\n+\n+    def _get_POST_bare_secret_csrf_cookie_request(self):\n+        req = self._get_POST_no_csrf_cookie_request()\n+        req.COOKIES[settings.CSRF_COOKIE_NAME] = self._csrf_id_cookie[:32]\n+        return req\n+\n+    def _get_POST_bare_secret_csrf_cookie_request_with_token(self):\n+        req = self._get_POST_bare_secret_csrf_cookie_request()\n+        req.POST['csrfmiddlewaretoken'] = self._csrf_id_cookie[:32]\n+        return req\n \n     def test_ensures_csrf_cookie_no_middleware(self):\n         \"\"\"\n@@ -651,45 +602,206 @@ def test_csrf_cookie_age_none(self):\n             max_age = resp2.cookies.get('csrfcookie').get('max-age')\n             self.assertEqual(max_age, '')\n \n-    def test_post_data_read_failure(self):\n+    def test_process_view_token_too_long(self):\n         \"\"\"\n-        #20128 -- IOErrors during POST data reading should be caught and\n-        treated as if the POST data wasn't there.\n+        If the token is longer than expected, it is ignored and a new token is\n+        created.\n         \"\"\"\n-        class CsrfPostRequest(HttpRequest):\n-            \"\"\"\n-            HttpRequest that can raise an IOError when accessing POST data\n-            \"\"\"\n-            def __init__(self, token, raise_error):\n-                super(CsrfPostRequest, self).__init__()\n-                self.method = 'POST'\n+        req = self._get_GET_no_csrf_cookie_request()\n+        req.COOKIES[settings.CSRF_COOKIE_NAME] = 'x' * 100000\n+        CsrfViewMiddleware().process_view(req, token_view, (), {})\n+        resp = token_view(req)\n+        resp2 = CsrfViewMiddleware().process_response(req, resp)\n+        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n+        self.assertEqual(len(csrf_cookie.value), CSRF_TOKEN_LENGTH)\n \n-                self.raise_error = False\n-                self.COOKIES[settings.CSRF_COOKIE_NAME] = token\n-                self.POST['csrfmiddlewaretoken'] = token\n-                self.raise_error = raise_error\n+    def test_process_view_token_invalid_bytes(self):\n+        \"\"\"\n+        If the token contains improperly encoded unicode, it is ignored and a\n+        new token is created.\n+        \"\"\"\n+        token = (b\"<1>\\xc2\\xa1\" + force_bytes(self._csrf_id, 'ascii'))[:CSRF_TOKEN_LENGTH]\n+        req = self._get_GET_no_csrf_cookie_request()\n+        req.COOKIES[settings.CSRF_COOKIE_NAME] = token\n+        # We expect a UnicodeWarning here, because we used broken utf-8 on purpose\n+        with warnings.catch_warnings():\n+            warnings.filterwarnings(\"ignore\", category=UnicodeWarning)\n+            CsrfViewMiddleware().process_view(req, token_view, (), {})\n+        resp = token_view(req)\n+        resp2 = CsrfViewMiddleware().process_response(req, resp)\n+        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n+        self.assertEqual(len(csrf_cookie.value), CSRF_TOKEN_LENGTH)\n+        self.assertNotEqual(csrf_cookie.value, token)\n \n-            def _load_post_and_files(self):\n-                raise IOError('error reading input data')\n+    def test_process_view_token_invalid_chars(self):\n+        \"\"\"\n+        If the token contains non-alphanumeric characters, it is ignored and a\n+        new token is created.\n+        \"\"\"\n+        token = ('!@#' + self._csrf_id)[:CSRF_TOKEN_LENGTH]\n+        req = self._get_GET_no_csrf_cookie_request()\n+        req.COOKIES[settings.CSRF_COOKIE_NAME] = token\n+        CsrfViewMiddleware().process_view(req, token_view, (), {})\n+        resp = token_view(req)\n+        resp2 = CsrfViewMiddleware().process_response(req, resp)\n+        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, False)\n+        self.assertEqual(len(csrf_cookie.value), CSRF_TOKEN_LENGTH)\n+        self.assertNotEqual(csrf_cookie.value, token)\n \n-            def _get_post(self):\n-                if self.raise_error:\n-                    self._load_post_and_files()\n-                return self._post\n+    def test_bare_secret_accepted_and_replaced(self):\n+        \"\"\"\n+        The csrf token is reset from a bare secret.\n+        \"\"\"\n+        req = self._get_POST_bare_secret_csrf_cookie_request_with_token()\n+        req2 = CsrfViewMiddleware().process_view(req, token_view, (), {})\n+        self.assertIsNone(req2)\n+        resp = token_view(req)\n+        resp = CsrfViewMiddleware().process_response(req, resp)\n+        self.assertIn(settings.CSRF_COOKIE_NAME, resp.cookies, \"Cookie was not reset from bare secret\")\n+        csrf_cookie = resp.cookies[settings.CSRF_COOKIE_NAME]\n+        self.assertEqual(len(csrf_cookie.value), CSRF_TOKEN_LENGTH)\n+        self._check_token_present(resp, csrf_id=csrf_cookie.value)\n \n-            def _set_post(self, post):\n-                self._post = post\n+    @override_settings(ALLOWED_HOSTS=['www.example.com'], CSRF_COOKIE_DOMAIN='.example.com', USE_X_FORWARDED_PORT=True)\n+    def test_https_good_referer_behind_proxy(self):\n+        \"\"\"\n+        A POST HTTPS request is accepted when USE_X_FORWARDED_PORT=True.\n+        \"\"\"\n+        self._test_https_good_referer_behind_proxy()\n \n-            POST = property(_get_post, _set_post)\n+    @override_settings(ALLOWED_HOSTS=['www.example.com'], CSRF_COOKIE_DOMAIN='.example.com')\n+    def test_https_good_referer_matches_cookie_domain(self):\n+        \"\"\"\n+        A POST HTTPS request with a good referer should be accepted from a\n+        subdomain that's allowed by CSRF_COOKIE_DOMAIN.\n+        \"\"\"\n+        self._test_https_good_referer_matches_cookie_domain()\n \n-        token = ('ABC' + self._csrf_id)[:CSRF_TOKEN_LENGTH]\n+    @override_settings(ALLOWED_HOSTS=['www.example.com'], CSRF_COOKIE_DOMAIN='.example.com')\n+    def test_https_good_referer_matches_cookie_domain_with_different_port(self):\n+        \"\"\"\n+        A POST HTTPS request with a good referer should be accepted from a\n+        subdomain that's allowed by CSRF_COOKIE_DOMAIN and a non-443 port.\n+        \"\"\"\n+        self._test_https_good_referer_matches_cookie_domain_with_different_port()\n \n-        req = CsrfPostRequest(token, raise_error=False)\n-        resp = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n-        self.assertIsNone(resp)\n+    @override_settings(CSRF_COOKIE_DOMAIN='.example.com', DEBUG=True)\n+    def test_https_reject_insecure_referer(self):\n+        \"\"\"\n+        A POST HTTPS request from an insecure referer should be rejected.\n+        \"\"\"\n+        req = self._get_POST_request_with_token()\n+        req._is_secure_override = True\n+        req.META['HTTP_REFERER'] = 'http://example.com/'\n+        req.META['SERVER_PORT'] = '443'\n+        response = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n+        self.assertContains(\n+            response,\n+            'Referer checking failed - Referer is insecure while host is secure.',\n+            status_code=403,\n+        )\n \n-        req = CsrfPostRequest(token, raise_error=True)\n-        with patch_logger('django.security.csrf', 'warning') as logger_calls:\n-            resp = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n-            self.assertEqual(resp.status_code, 403)\n-            self.assertEqual(logger_calls[0], 'Forbidden (%s): ' % REASON_BAD_TOKEN)\n+\n+@override_settings(CSRF_USE_SESSIONS=True, CSRF_COOKIE_DOMAIN=None)\n+class CsrfViewMiddlewareUseSessionsTests(CsrfViewMiddlewareTestMixin, SimpleTestCase):\n+    \"\"\"\n+    CSRF tests with CSRF_USE_SESSIONS=True.\n+    \"\"\"\n+\n+    def _get_POST_bare_secret_csrf_cookie_request(self):\n+        req = self._get_POST_no_csrf_cookie_request()\n+        req.session[CSRF_SESSION_KEY] = self._csrf_id_cookie[:32]\n+        return req\n+\n+    def _get_GET_csrf_cookie_request(self):\n+        req = TestingHttpRequest()\n+        req.session[CSRF_SESSION_KEY] = self._csrf_id_cookie\n+        return req\n+\n+    def test_no_session_on_request(self):\n+        def view(request):\n+            # Doesn't insert a token or anything\n+            return HttpResponse(content=\"\")\n+\n+        request = HttpRequest()\n+        with self.assertRaises(ImproperlyConfigured):\n+            CsrfViewMiddleware().process_view(request, view, (), {})\n+\n+    def test_process_response_get_token_used(self):\n+        \"\"\"The ensure_csrf_cookie() decorator works without middleware.\"\"\"\n+        @ensure_csrf_cookie\n+        def view(request):\n+            # Doesn't insert a token or anything\n+            return HttpResponse(content=\"\")\n+\n+        req = self._get_GET_no_csrf_cookie_request()\n+        view(req)\n+        self.assertTrue(req.session.get(CSRF_SESSION_KEY, False))\n+\n+    def test_ensures_csrf_cookie_with_middleware(self):\n+        \"\"\"\n+        The ensure_csrf_cookie() decorator works with the CsrfViewMiddleware\n+        enabled.\n+        \"\"\"\n+        @ensure_csrf_cookie\n+        def view(request):\n+            # Doesn't insert a token or anything\n+            return HttpResponse(content=\"\")\n+\n+        req = self._get_GET_no_csrf_cookie_request()\n+        CsrfViewMiddleware().process_view(req, view, (), {})\n+        resp = view(req)\n+        CsrfViewMiddleware().process_response(req, resp)\n+        self.assertTrue(req.session.get(CSRF_SESSION_KEY, False))\n+\n+    def test_token_node_with_new_csrf_cookie(self):\n+        \"\"\"\n+        CsrfTokenNode works when a CSRF cookie is created by the middleware\n+        (when one was not already present).\n+        \"\"\"\n+        req = self._get_GET_no_csrf_cookie_request()\n+        CsrfViewMiddleware().process_view(req, token_view, (), {})\n+        resp = token_view(req)\n+        CsrfViewMiddleware().process_response(req, resp)\n+        csrf_cookie = req.session[CSRF_SESSION_KEY]\n+        self._check_token_present(resp, csrf_id=csrf_cookie)\n+\n+    @override_settings(ALLOWED_HOSTS=['www.example.com'], SESSION_COOKIE_DOMAIN='.example.com',\n+                       USE_X_FORWARDED_PORT=True, DEBUG=True)\n+    def test_https_good_referer_behind_proxy(self):\n+        \"\"\"\n+        A POST HTTPS request is accepted when USE_X_FORWARDED_PORT=True.\n+        \"\"\"\n+        self._test_https_good_referer_behind_proxy()\n+\n+    @override_settings(ALLOWED_HOSTS=['www.example.com'], SESSION_COOKIE_DOMAIN='.example.com')\n+    def test_https_good_referer_matches_cookie_domain(self):\n+        \"\"\"\n+        A POST HTTPS request with a good referer should be accepted from a\n+        subdomain that's allowed by SESSION_COOKIE_DOMAIN.\n+        \"\"\"\n+        self._test_https_good_referer_matches_cookie_domain()\n+\n+    @override_settings(ALLOWED_HOSTS=['www.example.com'], SESSION_COOKIE_DOMAIN='.example.com')\n+    def test_https_good_referer_matches_cookie_domain_with_different_port(self):\n+        \"\"\"\n+        A POST HTTPS request with a good referer should be accepted from a\n+        subdomain that's allowed by SESSION_COOKIE_DOMAIN and a non-443 port.\n+        \"\"\"\n+        self._test_https_good_referer_matches_cookie_domain_with_different_port()\n+\n+    @override_settings(SESSION_COOKIE_DOMAIN='.example.com', DEBUG=True)\n+    def test_https_reject_insecure_referer(self):\n+        \"\"\"\n+        A POST HTTPS request from an insecure referer should be rejected.\n+        \"\"\"\n+        req = self._get_POST_request_with_token()\n+        req._is_secure_override = True\n+        req.META['HTTP_REFERER'] = 'http://example.com/'\n+        req.META['SERVER_PORT'] = '443'\n+        response = CsrfViewMiddleware().process_view(req, post_form_view, (), {})\n+        self.assertContains(\n+            response,\n+            'Referer checking failed - Referer is insecure while host is secure.',\n+            status_code=403,\n+        )\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR addresses CSRF token handling and enhances compliance with common frameworks, which is beneficial for audits. The addition of `CSRF_SESSION_KEY` and adjustments to referer checks are solid improvements. However, the current AJAX examples are workarounds and fail with multiple forms—consider an enhanced solution like an optional argument for `csrf_token`. The testing strategy also needs more clarity; testing both session and cookie configurations is vital to avoid assumptions. Overall, thoughtful changes, but further refinement is necessary for wider applicability and robustness."
      }
    ],
    "token_estimation": 4996.75
  },
  {
    "index": 32,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 1ff4cd77353d..36c2b969db12 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -873,6 +900,128 @@ def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_\n         return sql, sql_params\n \n \n+class Subquery(Expression):\n+    \"\"\"\n+    An explicit subquery. It may contain OuterRef() references to the outer\n+    query which will be resolved when it is applied to that query.\n+    \"\"\"\n+    template = '(%(subquery)s)'\n+\n+    def __init__(self, queryset, output_field=None, **extra):\n+        self.queryset = queryset\n+        self.extra = extra\n+        if output_field is None and len(self.queryset.query.select) == 1:\n+            output_field = self.queryset.query.select[0].field\n+        super(Subquery, self).__init__(output_field)\n+\n+    def copy(self):\n+        clone = super(Subquery, self).copy()\n+        clone.queryset = clone.queryset.all()\n+        return clone\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        clone = self.copy()\n+        clone.is_summary = summarize\n+        clone.queryset.query.bump_prefix(query)\n+\n+        # Need to recursively resolve these.\n+        def resolve_all(child):\n+            if hasattr(child, 'children'):\n+                [resolve_all(_child) for _child in child.children]\n+            if hasattr(child, 'rhs'):\n+                child.rhs = resolve(child.rhs)\n+\n+        def resolve(child):\n+            if hasattr(child, 'resolve_expression'):\n+                return child.resolve_expression(\n+                    query=query, allow_joins=allow_joins, reuse=reuse,\n+                    summarize=summarize, for_save=for_save,\n+                )\n+            return child\n+\n+        resolve_all(clone.queryset.query.where)\n+\n+        for key, value in clone.queryset.query.annotations.items():\n+            if isinstance(value, Subquery):\n+                clone.queryset.query.annotations[key] = resolve(value)\n+\n+        return clone\n+\n+    def get_source_expressions(self):\n+        return [\n+            x for x in [\n+                getattr(expr, 'lhs', None)\n+                for expr in self.queryset.query.where.children\n+            ] if x\n+        ]\n+\n+    def relabeled_clone(self, change_map):\n+        clone = self.copy()\n+        clone.queryset.query = clone.queryset.query.relabeled_clone(change_map)\n+        clone.queryset.query.external_aliases.update(\n+            alias for alias in change_map.values()\n+            if alias not in clone.queryset.query.tables\n+        )\n+        return clone\n+\n+    def as_sql(self, compiler, connection, template=None, **extra_context):\n+        connection.ops.check_expression_support(self)\n+        template_params = self.extra.copy()\n+        template_params.update(extra_context)\n+        template_params['subquery'], sql_params = self.queryset.query.get_compiler(connection=connection).as_sql()\n+\n+        template = template or template_params.get('template', self.template)\n+        sql = template % template_params\n+        sql = connection.ops.unification_cast_sql(self.output_field) % sql\n+        return sql, sql_params\n+\n+    def _prepare(self, output_field):\n+        # This method will only be called if this instance is the \"rhs\" in an\n+        # expression: the wrapping () must be removed (as the expression that\n+        # contains this will provide them). SQLite evaluates ((subquery))\n+        # differently than the other databases.\n+        if self.template == '(%(subquery)s)':\n+            clone = self.copy()\n+            clone.template = '%(subquery)s'\n+            return clone\n+        return self\n+\n+\n+class Exists(Subquery):\n+    template = 'EXISTS(%(subquery)s)'\n+\n+    def __init__(self, *args, **kwargs):\n+        self.negated = kwargs.pop('negated', False)\n+        super(Exists, self).__init__(*args, **kwargs)\n+\n+    def __invert__(self):\n+        return type(self)(self.queryset, self.output_field, negated=(not self.negated), **self.extra)\n+\n+    @property\n+    def output_field(self):\n+        return fields.BooleanField()\n+\n+    def resolve_expression(self, query=None, **kwargs):\n+        # As a performance optimization, remove ordering since EXISTS doesn't\n+        # care about it, just whether or not a row matches.\n+        self.queryset = self.queryset.order_by()\n+        return super(Exists, self).resolve_expression(query, **kwargs)\n+\n+    def as_sql(self, compiler, connection, template=None, **extra_context):\n+        sql, params = super(Exists, self).as_sql(compiler, connection, template, **extra_context)\n+        if self.negated:\n+            sql = 'NOT {}'.format(sql)\n+        return sql, params\n+\n+    def as_oracle(self, compiler, connection, template=None, **extra_context):\n+        # Oracle doesn't allow EXISTS() in the SELECT list, so wrap it with a\n+        # CASE WHEN expression. Change the template since the When expression\n+        # requires a left hand side (column) to compare against.\n+        sql, params = self.as_sql(compiler, connection, template, **extra_context)\n+        sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n+        return sql, params\n+\n+\n class OrderBy(BaseExpression):\n     template = '%(expression)s %(ordering)s'\n \ndiff --git a/docs/ref/models/expressions.txt b/docs/ref/models/expressions.txt\nindex e46df22f9828..01db10375878 100644\n--- a/docs/ref/models/expressions.txt\n+++ b/docs/ref/models/expressions.txt\n@@ -450,6 +450,178 @@ Conditional expressions allow you to use :keyword:`if` ... :keyword:`elif` ...\n :keyword:`else` logic in queries. Django natively supports SQL ``CASE``\n expressions. For more details see :doc:`conditional-expressions`.\n \n+``Subquery()`` expressions\n+--------------------------\n+\n+.. class:: Subquery(queryset, output_field=None)\n+\n+.. versionadded:: 1.11\n+\n+You can add an explicit subquery to a ``QuerySet`` using the ``Subquery``\n+expression.\n+\n+For example, to annotate each post with the email address of the author of the\n+newest comment on that post::\n+\n+    >>> from django.db.models import OuterRef, Subquery\n+    >>> newest = Comment.objects.filter(post=OuterRef('pk')).order_by('-created_at')\n+    >>> Post.objects.annotate(newest_commenter_email=Subquery(newest.values('email')[:1]))\n+\n+On PostgreSQL, the SQL looks like:\n+\n+.. code-block:: sql\n+\n+    SELECT \"post\".\"id\", (\n+        SELECT U0.\"email\"\n+        FROM \"comment\" U0\n+        WHERE U0.\"post_id\" = (\"post\".\"id\")\n+        ORDER BY U0.\"created_at\" DESC LIMIT 1\n+    ) AS \"newest_commenter_email\" FROM \"post\"\n+\n+.. note::\n+\n+    The examples in this section are designed to show how to force\n+    Django to execute a subquery. In some cases it may be possible to\n+    write an equivalent queryset that performs the same task more\n+    clearly or efficiently.\n+\n+Referencing columns from the outer queryset\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+.. class:: OuterRef(field)\n+\n+.. versionadded:: 1.11\n+\n+Use ``OuterRef`` when a queryset in a ``Subquery`` needs to refer to a field\n+from the outer query. It acts like an :class:`F` expression except that the\n+check to see if it refers to a valid field isn't made until the outer queryset\n+is resolved.\n+\n+Instances of ``OuterRef`` may be used in conjunction with nested instances\n+of ``Subquery`` to refer to a containing queryset that isn't the immediate\n+parent. For example, this queryset would need to be within a nested pair of\n+``Subquery`` instances to resolve correctly::\n+\n+    >>> Book.objects.filter(author=OuterRef(OuterRef('pk')))\n+\n+Limiting a subquery to a single column\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+There are times when a single column must be returned from a ``Subquery``, for\n+instance, to use a ``Subquery`` as the target of an ``__in`` lookup. To return\n+all comments for posts published within the last day::\n+\n+    >>> from datetime import timedelta\n+    >>> from django.utils import timezone\n+    >>> one_day_ago = timezone.now() - timedelta(days=1)\n+    >>> posts = Post.objects.filter(published_at__gte=one_day_ago)\n+    >>> Comment.objects.filter(post__in=Subquery(posts.values('pk')))\n+\n+In this case, the subquery must use :meth:`~.QuerySet.values`\n+to return only a single column: the primary key of the post.\n+\n+Limiting the subquery to a single row\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+To prevent a subquery from returning multiple rows, a slice (``[:1]``) of the\n+queryset is used::\n+\n+    >>> subquery = Subquery(newest.values('email')[:1])\n+    >>> Post.objects.annotate(newest_commenter_email=subquery)\n+\n+In this case, the subquery must only return a single column *and* a single\n+row: the email address of the most recently created comment.\n+\n+(Using :meth:`~.QuerySet.get` instead of a slice would fail because the\n+``OuterRef`` cannot be resolved until the queryset is used within a\n+``Subquery``.)\n+\n+``Exists()`` subqueries\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+.. class:: Exists(queryset)\n+\n+.. versionadded:: 1.11\n+\n+``Exists`` is a ``Subquery`` subclass that uses an SQL ``EXISTS`` statement. In\n+many cases it will perform better than a subquery since the database is able to\n+stop evaluation of the subquery when a first matching row is found.\n+\n+For example, to annotate each post with whether or not it has a comment from\n+within the last day::\n+\n+    >>> from django.db.models import Exists, OuterRef\n+    >>> from datetime import timedelta\n+    >>> from django.utils import timezone\n+    >>> one_day_ago = timezone.now() - timedelta(days=1)\n+    >>> recent_comments = Comment.objects.filter(\n+    ...     post=OuterRef('pk'),\n+    ...     created_at__gte=one_day_ago,\n+    ... )\n+    >>> Post.objects.annotate(recent_comment=Exists(recent_comments)\n+\n+On PostgreSQL, the SQL looks like:\n+\n+.. code-block:: sql\n+\n+    SELECT \"post\".\"id\", \"post\".\"published_at\", EXISTS(\n+        SELECT U0.\"id\", U0.\"post_id\", U0.\"email\", U0.\"created_at\"\n+        FROM \"comment\" U0\n+        WHERE (\n+            U0.\"created_at\" >= YYYY-MM-DD HH:MM:SS AND\n+            U0.\"post_id\" = (\"post\".\"id\")\n+        )\n+    ) AS \"recent_comment\" FROM \"post\"\n+\n+It's unnecessary to force ``Exists`` to refer to a single column, since the\n+columns are discarded and a boolean result is returned. Similarly, since\n+ordering is unimportant within an SQL ``EXISTS`` subquery and would only\n+degrade performance, it's automatically removed.\n+\n+You can query using ``NOT EXISTS`` with ``~Exists()``.\n+\n+Filtering on a ``Subquery`` expression\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+It's not possible to filter directly using ``Subquery`` and ``Exists``, e.g.::\n+\n+    >>> Post.objects.filter(Exists(recent_comments))\n+    ...\n+    TypeError: 'Exists' object is not iterable\n+\n+\n+You must filter on a subquery expression by first annotating the queryset\n+and then filtering based on that annotation::\n+\n+    >>> Post.objects.annotate(\n+    ...     recent_comment=Exists(recent_comments),\n+    ... ).filter(recent_comment=True)\n+\n+Using aggregates within a ``Subquery`` expression\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Aggregates may be used within a ``Subquery``, but they require a specific\n+combination of :meth:`~.QuerySet.filter`, :meth:`~.QuerySet.values`, and\n+:meth:`~.QuerySet.annotate` to get the subquery grouping correct.\n+\n+Assuming both models have a ``length`` field, to find posts where the post\n+length is greater than the total length of all combined comments::\n+\n+    >>> from django.db.models import OuterRef, Subquery, Sum\n+    >>> comments = Comment.objects.filter(post=OuterRef('pk')).values('post')\n+    >>> total_comments = comments.annotate(total=Sum('length')).values('total')\n+    >>> Post.objects.filter(length__gt=Subquery(total_comments))\n+\n+The initial ``filter(...)`` limits the subquery to the relevant parameters.\n+``values('post')`` aggregates comments by ``Post``. Finally, ``annotate(...)``\n+performs the aggregation. The order in which these queryset methods are applied\n+is important. In this case, since the subquery must be limited to a single\n+column, ``values('total')`` is required.\n+\n+This is the only way to perform an aggregation within a ``Subquery``, as\n+using :meth:`~.QuerySet.aggregate` attempts to evaluate the queryset (and if\n+there is an ``OuterRef``, this will not be possible to resolve).\n+\n Raw SQL expressions\n -------------------\n \ndiff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 18d003d57d74..8399e3c0a92c 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -387,6 +387,136 @@ def test_ticket_18375_chained_filters(self):\n         )\n         self.assertEqual(str(qs.query).count('JOIN'), 2)\n \n+    def test_outerref(self):\n+        inner = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        msg = (\n+            'This queryset contains a reference to an outer query and may only '\n+            'be used in a subquery.'\n+        )\n+        with self.assertRaisesMessage(ValueError, msg):\n+            inner.exists()\n+\n+        outer = Employee.objects.annotate(is_point_of_contact=Exists(inner))\n+        self.assertIs(outer.exists(), True)\n+\n+    def test_subquery(self):\n+        Company.objects.filter(name='Example Inc.').update(\n+            point_of_contact=Employee.objects.get(firstname='Joe', lastname='Smith'),\n+            ceo=Employee.objects.get(firstname='Max', lastname='Mustermann'),\n+        )\n+        Employee.objects.create(firstname='Bob', lastname='Brown', salary=40)\n+        qs = Employee.objects.annotate(\n+            is_point_of_contact=Exists(Company.objects.filter(point_of_contact=OuterRef('pk'))),\n+            is_not_point_of_contact=~Exists(Company.objects.filter(point_of_contact=OuterRef('pk'))),\n+            is_ceo_of_small_company=Exists(Company.objects.filter(num_employees__lt=200, ceo=OuterRef('pk'))),\n+            is_ceo_small_2=~~Exists(Company.objects.filter(num_employees__lt=200, ceo=OuterRef('pk'))),\n+            largest_company=Subquery(Company.objects.order_by('-num_employees').filter(\n+                models.Q(ceo=OuterRef('pk')) | models.Q(point_of_contact=OuterRef('pk'))\n+            ).values('name')[:1], output_field=models.CharField())\n+        ).values(\n+            'firstname',\n+            'is_point_of_contact',\n+            'is_not_point_of_contact',\n+            'is_ceo_of_small_company',\n+            'is_ceo_small_2',\n+            'largest_company',\n+        ).order_by('firstname')\n+\n+        results = list(qs)\n+        # Could use Coalesce(subq, Value('')) instead except for the bug in\n+        # cx_Oracle mentioned in #23843.\n+        bob = results[0]\n+        if bob['largest_company'] == '' and connection.features.interprets_empty_strings_as_nulls:\n+            bob['largest_company'] = None\n+\n+        self.assertEqual(results, [\n+            {\n+                'firstname': 'Bob',\n+                'is_point_of_contact': False,\n+                'is_not_point_of_contact': True,\n+                'is_ceo_of_small_company': False,\n+                'is_ceo_small_2': False,\n+                'largest_company': None,\n+            },\n+            {\n+                'firstname': 'Frank',\n+                'is_point_of_contact': False,\n+                'is_not_point_of_contact': True,\n+                'is_ceo_of_small_company': True,\n+                'is_ceo_small_2': True,\n+                'largest_company': 'Foobar Ltd.',\n+            },\n+            {\n+                'firstname': 'Joe',\n+                'is_point_of_contact': True,\n+                'is_not_point_of_contact': False,\n+                'is_ceo_of_small_company': False,\n+                'is_ceo_small_2': False,\n+                'largest_company': 'Example Inc.',\n+            },\n+            {\n+                'firstname': 'Max',\n+                'is_point_of_contact': False,\n+                'is_not_point_of_contact': True,\n+                'is_ceo_of_small_company': True,\n+                'is_ceo_small_2': True,\n+                'largest_company': 'Example Inc.'\n+            }\n+        ])\n+        # A less elegant way to write the same query: this uses a LEFT OUTER\n+        # JOIN and an IS NULL, inside a WHERE NOT IN which is probably less\n+        # efficient than EXISTS.\n+        self.assertCountEqual(\n+            qs.filter(is_point_of_contact=True).values('pk'),\n+            Employee.objects.exclude(company_point_of_contact_set=None).values('pk')\n+        )\n+\n+    def test_in_subquery(self):\n+        # This is a contrived test (and you really wouldn't write this query),\n+        # but it is a succinct way to test the __in=Subquery() construct.\n+        small_companies = Company.objects.filter(num_employees__lt=200).values('pk')\n+        subquery_test = Company.objects.filter(pk__in=Subquery(small_companies))\n+        self.assertCountEqual(subquery_test, [self.foobar_ltd, self.gmbh])\n+        subquery_test2 = Company.objects.filter(pk=Subquery(small_companies.filter(num_employees=3)))\n+        self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n+\n+    def test_nested_subquery(self):\n+        inner = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        outer = Employee.objects.annotate(is_point_of_contact=Exists(inner))\n+        contrived = Employee.objects.annotate(\n+            is_point_of_contact=Subquery(\n+                outer.filter(pk=OuterRef('pk')).values('is_point_of_contact'),\n+                output_field=models.BooleanField(),\n+            ),\n+        )\n+        self.assertCountEqual(contrived.values_list(), outer.values_list())\n+\n+    def test_nested_subquery_outer_ref_2(self):\n+        first = Time.objects.create(time='09:00')\n+        second = Time.objects.create(time='17:00')\n+        third = Time.objects.create(time='21:00')\n+        SimulationRun.objects.bulk_create([\n+            SimulationRun(start=first, end=second, midpoint='12:00'),\n+            SimulationRun(start=first, end=third, midpoint='15:00'),\n+            SimulationRun(start=second, end=first, midpoint='00:00'),\n+        ])\n+        inner = Time.objects.filter(time=OuterRef(OuterRef('time')), pk=OuterRef('start')).values('time')\n+        middle = SimulationRun.objects.annotate(other=Subquery(inner)).values('other')[:1]\n+        outer = Time.objects.annotate(other=Subquery(middle, output_field=models.TimeField()))\n+        # This is a contrived example. It exercises the double OuterRef form.\n+        self.assertCountEqual(outer, [first, second, third])\n+\n+    def test_annotations_within_subquery(self):\n+        Company.objects.filter(num_employees__lt=50).update(ceo=Employee.objects.get(firstname='Frank'))\n+        inner = Company.objects.filter(\n+            ceo=OuterRef('pk')\n+        ).values('ceo').annotate(total_employees=models.Sum('num_employees')).values('total_employees')\n+        outer = Employee.objects.annotate(total_employees=Subquery(inner)).filter(salary__lte=Subquery(inner))\n+        self.assertSequenceEqual(\n+            outer.order_by('-total_employees').values('salary', 'total_employees'),\n+            [{'salary': 10, 'total_employees': 2300}, {'salary': 20, 'total_employees': 35}],\n+        )\n+\n \n class IterableLookupInnerExpressionsTests(TestCase):\n     @classmethod\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Good work on tackling the `EXISTS()` implementation! It's clear this enhances usability, especially with your idea of allowing boolean values for `__exists` lookups. However, your sentiment against `.exclude()` is valid; it complicates queries unnecessarily. The handling of negated filters is indeed problematic, particularly with multivalued relations. Your suggestion to revise query generation to avoid joins is crucial, and implementing `F('outerq__')` for subqueries could simplify complexity significantly. Consider adding `NotExists()` as a companion to streamline negated conditions. Overall, strong progress, but focus on refining the exclude handling."
      }
    ],
    "token_estimation": 4978.25
  },
  {
    "index": 33,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/backends/utils.py b/django/db/backends/utils.py\nindex 568f510a670e..608226c7de97 100644\n--- a/django/db/backends/utils.py\n+++ b/django/db/backends/utils.py\n@@ -114,6 +114,98 @@ def _executemany(self, sql, param_list, *ignored_wrapper_args):\n             return self.cursor.executemany(sql, param_list)\n \n \n+class AsyncCursorCtx:\n+    \"\"\"\n+    Asynchronous context manager to hold an async cursor.\n+    \"\"\"\n+\n+    def __init__(self, db, name=None):\n+        self.db = db\n+        self.name = name\n+        self.wrap_database_errors = self.db.wrap_database_errors\n+\n+    async def __aenter__(self):\n+        await self.db.aclose_if_health_check_failed()\n+        await self.db.aensure_connection()\n+        self.wrap_database_errors.__enter__()\n+        return self.db._aprepare_cursor(self.db.create_async_cursor(self.name))\n+\n+    async def __aexit__(self, type, value, traceback):\n+        self.wrap_database_errors.__exit__(type, value, traceback)\n+\n+\n+class AsyncCursorWrapper(CursorWrapper):\n+    async def _aexecute(self, sql, params, *ignored_wrapper_args):\n+        # Raise a warning during app initialization (stored_app_configs is only\n+        # ever set during testing).\n+        if not apps.ready and not apps.stored_app_configs:\n+            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)\n+        self.db.validate_no_broken_transaction()\n+        with self.db.wrap_database_errors:\n+            if params is None:\n+                # params default might be backend specific.\n+                return await self.cursor.execute(sql)\n+            else:\n+                return await self.cursor.execute(sql, params)\n+\n+    async def _aexecute_with_wrappers(self, sql, params, many, executor):\n+        context = {\"connection\": self.db, \"cursor\": self}\n+        for wrapper in reversed(self.db.execute_wrappers):\n+            executor = functools.partial(wrapper, executor)\n+        return await executor(sql, params, many, context)\n+\n+    async def aexecute(self, sql, params=None):\n+        return await self._aexecute_with_wrappers(\n+            sql, params, many=False, executor=self._aexecute\n+        )\n+\n+    async def _aexecutemany(self, sql, param_list, *ignored_wrapper_args):\n+        # Raise a warning during app initialization (stored_app_configs is only\n+        # ever set during testing).\n+        if not apps.ready and not apps.stored_app_configs:\n+            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)\n+        self.db.validate_no_broken_transaction()\n+        with self.db.wrap_database_errors:\n+            return await self.cursor.executemany(sql, param_list)\n+\n+    async def aexecutemany(self, sql, param_list):\n+        return await self._aexecute_with_wrappers(\n+            sql, param_list, many=True, executor=self._aexecutemany\n+        )\n+\n+    async def afetchone(self, *args, **kwargs):\n+        return await self.cursor.fetchone(*args, **kwargs)\n+\n+    async def afetchmany(self, *args, **kwargs):\n+        return await self.cursor.fetchmany(*args, **kwargs)\n+\n+    async def afetchall(self, *args, **kwargs):\n+        return await self.cursor.fetchall(*args, **kwargs)\n+\n+    def acopy(self, *args, **kwargs):\n+        return self.cursor.copy(*args, **kwargs)\n+\n+    def astream(self, *args, **kwargs):\n+        return self.cursor.stream(*args, **kwargs)\n+\n+    async def ascroll(self, *args, **kwargs):\n+        return await self.cursor.scroll(*args, **kwargs)\n+\n+    async def __aenter__(self):\n+        return self\n+\n+    async def __aexit__(self, type, value, traceback):\n+        try:\n+            await self.close()\n+        except self.db.Database.Error:\n+            pass\n+\n+    async def __aiter__(self):\n+        with self.db.wrap_database_errors:\n+            async for item in self.cursor:\n+                yield item\n+\n+\n class CursorDebugWrapper(CursorWrapper):\n     # XXX callproc isn't instrumented at this time.\n \n@@ -163,6 +255,57 @@ def debug_sql(\n             )\n \n \n+class AsyncCursorDebugWrapper(AsyncCursorWrapper):\n+    # XXX callproc isn't instrumented at this time.\n+\n+    async def aexecute(self, sql, params=None):\n+        with self.debug_sql(sql, params, use_last_executed_query=True):\n+            return await super().aexecute(sql, params)\n+\n+    async def aexecutemany(self, sql, param_list):\n+        with self.debug_sql(sql, param_list, many=True):\n+            return await super().aexecutemany(sql, param_list)\n+\n+    @contextmanager\n+    def debug_sql(\n+        self, sql=None, params=None, use_last_executed_query=False, many=False\n+    ):\n+        start = time.monotonic()\n+        try:\n+            yield\n+        finally:\n+            stop = time.monotonic()\n+            duration = stop - start\n+            if use_last_executed_query:\n+                sql = self.db.ops.last_executed_query(self.cursor, sql, params)\n+            try:\n+                times = len(params) if many else \"\"\n+            except TypeError:\n+                # params could be an iterator.\n+                times = \"?\"\n+            self.db.queries_log.append(\n+                {\n+                    \"sql\": \"%s times: %s\" % (times, sql) if many else sql,\n+                    \"time\": \"%.3f\" % duration,\n+                    \"async\": True,\n+                }\n+            )\n+            logger.debug(\n+                \"(%.3f) %s; args=%s; alias=%s; async=True\",\n+                duration,\n+                sql,\n+                params,\n+                self.db.alias,\n+                extra={\n+                    \"duration\": duration,\n+                    \"sql\": sql,\n+                    \"params\": params,\n+                    \"alias\": self.db.alias,\n+                    \"async\": True,\n+                },\n+            )\n+\n+\n @contextmanager\n def debug_transaction(connection, sql):\n     start = time.monotonic()\n\ndiff --git a/django/db/utils.py b/django/db/utils.py\nindex faaf3bf862fe..c767ed7b8542 100644\n--- a/django/db/utils.py\n+++ b/django/db/utils.py\n@@ -197,6 +199,89 @@ def create_connection(self, alias):\n         return backend.DatabaseWrapper(db, alias)\n \n \n+class AsyncAlias:\n+    \"\"\"\n+    A Context-aware list of connections.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self._connections = Local()\n+        setattr(self._connections, \"_stack\", [])\n+\n+    @property\n+    def connections(self):\n+        return getattr(self._connections, \"_stack\", [])\n+\n+    def __len__(self):\n+        return len(self.connections)\n+\n+    def __iter__(self):\n+        return iter(self.connections)\n+\n+    def __str__(self):\n+        return \", \".join([str(id(conn)) for conn in self.connections])\n+\n+    def __repr__(self):\n+        return f\"<{self.__class__.__name__}: {len(self.connections)} connections>\"\n+\n+    def add_connection(self, connection):\n+        setattr(self._connections, \"_stack\", self.connections + [connection])\n+\n+    def pop(self):\n+        conns = self.connections\n+        conns.pop()\n+        setattr(self._connections, \"_stack\", conns)\n+\n+\n+class AsyncConnectionHandler:\n+    \"\"\"\n+    Context-aware class to store async connections, mapped by alias name.\n+    \"\"\"\n+\n+    _from_testcase = False\n+\n+    def __init__(self) -> None:\n+        self._aliases = Local()\n+        self._connection_count = Local()\n+        setattr(self._connection_count, \"value\", 0)\n+\n+    def __getitem__(self, alias):\n+        try:\n+            async_alias = getattr(self._aliases, alias)\n+        except AttributeError:\n+            async_alias = AsyncAlias()\n+            setattr(self._aliases, alias, async_alias)\n+        return async_alias\n+\n+    def __repr__(self) -> str:\n+        return f\"<{self.__class__.__name__}: {self.count} connections>\"\n+\n+    @property\n+    def count(self):\n+        return getattr(self._connection_count, \"value\", 0)\n+\n+    @property\n+    def empty(self):\n+        return self.count == 0\n+\n+    def add_connection(self, using, connection):\n+        self[using].add_connection(connection)\n+        setattr(self._connection_count, \"value\", self.count + 1)\n+\n+    async def pop_connection(self, using):\n+        await self[using].connections[-1].aclose_pool()\n+        self[using].connections.pop()\n+        setattr(self._connection_count, \"value\", self.count - 1)\n+\n+    def get_connection(self, using):\n+        alias = self[using]\n+        if len(alias.connections) == 0:\n+            raise ConnectionDoesNotExist(\n+                f\"There are no async connections using the '{using}' alias.\"\n+            )\n+        return alias.connections[-1]\n+\n+\n class ConnectionRouter:\n     def __init__(self, routers=None):\n         \"\"\"\ndiff --git a/tests/async/test_async_cursor.py b/tests/async/test_async_cursor.py\nnew file mode 100644\nindex 000000000000..b1beea856884\n--- /dev/null\n+++ b/tests/async/test_async_cursor.py\n@@ -0,0 +1,133 @@\n+from django.db import new_connection\n+from django.test import SimpleTestCase, skipUnlessDBFeature\n+\n+\n+@skipUnlessDBFeature(\"supports_async\")\n+class AsyncCursorTests(SimpleTestCase):\n+    databases = {\"default\", \"other\"}\n+\n+    async def test_aexecute(self):\n+        async with new_connection() as conn:\n+            async with conn.acursor() as cursor:\n+                await cursor.aexecute(\"SELECT 1\")\n+\n+    async def test_aexecutemany(self):\n+        async with new_connection() as conn:\n+            async with conn.acursor() as cursor:\n+                await cursor.aexecute(\"CREATE TABLE numbers (number SMALLINT)\")\n+                await cursor.aexecutemany(\n+                    \"INSERT INTO numbers VALUES (%s)\", [(1,), (2,), (3,)]\n+                )\n+                await cursor.aexecute(\"SELECT * FROM numbers\")\n+                result = await cursor.afetchall()\n+                self.assertEqual(result, [(1,), (2,), (3,)])\n+\n+    async def test_afetchone(self):\n+        async with new_connection() as conn:\n+            async with conn.acursor() as cursor:\n+                await cursor.aexecute(\"SELECT 1\")\n+                result = await cursor.afetchone()\n+            self.assertEqual(result, (1,))\n+\n+    async def test_afetchmany(self):\n+        async with new_connection() as conn:\n+            async with conn.acursor() as cursor:\n+                await cursor.aexecute(\n+                    \"\"\"\n+                    SELECT *\n+                    FROM (VALUES\n+                        ('BANANA'),\n+                        ('STRAWBERRY'),\n+                        ('MELON')\n+                    ) AS v (NAME)\"\"\"\n+                )\n+                result = await cursor.afetchmany(size=2)\n+            self.assertEqual(result, [(\"BANANA\",), (\"STRAWBERRY\",)])\n+\n+    async def test_afetchall(self):\n+        async with new_connection() as conn:\n+            async with conn.acursor() as cursor:\n+                await cursor.aexecute(\n+                    \"\"\"\n+                    SELECT *\n+                    FROM (VALUES\n+                        ('BANANA'),\n+                        ('STRAWBERRY'),\n+                        ('MELON')\n+                    ) AS v (NAME)\"\"\"\n+                )\n+                result = await cursor.afetchall()\n+            self.assertEqual(result, [(\"BANANA\",), (\"STRAWBERRY\",), (\"MELON\",)])\n+\n+    async def test_aiter(self):\n+        result = []\n+        async with new_connection() as conn:\n+            async with conn.acursor() as cursor:\n+                await cursor.aexecute(\n+                    \"\"\"\n+                    SELECT *\n+                    FROM (VALUES\n+                        ('BANANA'),\n+                        ('STRAWBERRY'),\n+                        ('MELON')\n+                    ) AS v (NAME)\"\"\"\n+                )\n+                async for record in cursor:\n+                    result.append(record)\n+            self.assertEqual(result, [(\"BANANA\",), (\"STRAWBERRY\",), (\"MELON\",)])\n+\n+    async def test_acopy(self):\n+        result = []\n+        async with new_connection() as conn:\n+            async with conn.acursor() as cursor:\n+                async with cursor.acopy(\n+                    \"\"\"\n+                    COPY (\n+                        SELECT *\n+                        FROM (VALUES\n+                            ('BANANA'),\n+                            ('STRAWBERRY'),\n+                            ('MELON')\n+                        ) AS v (NAME)\n+                    ) TO STDOUT\"\"\"\n+                ) as copy:\n+                    async for row in copy.rows():\n+                        result.append(row)\n+            self.assertEqual(result, [(\"BANANA\",), (\"STRAWBERRY\",), (\"MELON\",)])\n+\n+    async def test_astream(self):\n+        result = []\n+        async with new_connection() as conn:\n+            async with conn.acursor() as cursor:\n+                async for record in cursor.astream(\n+                    \"\"\"\n+                    SELECT *\n+                    FROM (VALUES\n+                        ('BANANA'),\n+                        ('STRAWBERRY'),\n+                        ('MELON')\n+                    ) AS v (NAME)\"\"\"\n+                ):\n+                    result.append(record)\n+            self.assertEqual(result, [(\"BANANA\",), (\"STRAWBERRY\",), (\"MELON\",)])\n+\n+    async def test_ascroll(self):\n+        result = []\n+        async with new_connection() as conn:\n+            async with conn.acursor() as cursor:\n+                await cursor.aexecute(\n+                    \"\"\"\n+                    SELECT *\n+                    FROM (VALUES\n+                        ('BANANA'),\n+                        ('STRAWBERRY'),\n+                        ('MELON')\n+                    ) AS v (NAME)\"\"\"\n+                )\n+                await cursor.ascroll(1, \"absolute\")\n+\n+                result = await cursor.afetchall()\n+                self.assertEqual(result, [(\"STRAWBERRY\",), (\"MELON\",)])\n+                await cursor.ascroll(0, \"absolute\")\n+                result = await cursor.afetchall()\n+                self.assertEqual(result, [(\"BANANA\",), (\"STRAWBERRY\",), (\"MELON\",)])\ndiff --git a/tests/db_utils/tests.py b/tests/db_utils/tests.py\nindex 4028a8acdf3e..aa1028690486 100644\n--- a/tests/db_utils/tests.py\n+++ b/tests/db_utils/tests.py\n@@ -90,3 +105,82 @@ def test_load_backend_invalid_name(self):\n         with self.assertRaisesMessage(ImproperlyConfigured, msg) as cm:\n             load_backend(\"foo\")\n         self.assertEqual(str(cm.exception.__cause__), \"No module named 'foo'\")\n+\n+\n+class AsyncConnectionTests(SimpleTestCase):\n+    databases = {\"default\", \"other\"}\n+\n+    def run_pool(self, coro, count=2):\n+        def fn():\n+            asyncio.run(coro())\n+\n+        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:\n+            futures = []\n+            for _ in range(count):\n+                futures.append(executor.submit(fn))\n+\n+            for future in concurrent.futures.as_completed(futures):\n+                exc = future.exception()\n+                if exc is not None:\n+                    raise exc\n+\n+    def test_async_alias(self):\n+        alias = AsyncAlias()\n+        assert len(alias) == 0\n+        assert alias.connections == []\n+\n+        async def coro():\n+            assert len(alias) == 0\n+            alias.add_connection(mock.Mock())\n+            alias.pop()\n+\n+        self.run_pool(coro)\n+\n+    def test_async_connection_handler(self):\n+        aconns = AsyncConnectionHandler()\n+        assert aconns.empty is True\n+        assert aconns[\"default\"].connections == []\n+\n+        async def coro():\n+            assert aconns[\"default\"].connections == []\n+            aconns.add_connection(\"default\", mock.Mock())\n+            aconns.pop_connection(\"default\")\n+\n+        self.run_pool(coro)\n+\n+    @skipUnlessDBFeature(\"supports_async\")\n+    def test_new_connection_threading(self):\n+        async def coro():\n+            assert async_connections.empty is True\n+            async with new_connection() as connection:\n+                async with connection.acursor() as c:\n+                    await c.execute(\"SELECT 1\")\n+\n+        self.run_pool(coro)\n+\n+    @skipUnlessDBFeature(\"supports_async\")\n+    async def test_new_connection(self):\n+        with self.assertRaises(ConnectionDoesNotExist):\n+            async_connections.get_connection(DEFAULT_DB_ALIAS)\n+\n+        async with new_connection():\n+            conn1 = async_connections.get_connection(DEFAULT_DB_ALIAS)\n+            self.assertIsNotNone(conn1.aconnection)\n+            async with new_connection():\n+                conn2 = async_connections.get_connection(DEFAULT_DB_ALIAS)\n+                self.assertIsNotNone(conn1.aconnection)\n+                self.assertIsNotNone(conn2.aconnection)\n+                self.assertNotEqual(conn1.aconnection, conn2.aconnection)\n+\n+            self.assertIsNotNone(conn1.aconnection)\n+            self.assertIsNone(conn2.aconnection)\n+        self.assertIsNone(conn1.aconnection)\n+\n+        with self.assertRaises(ConnectionDoesNotExist):\n+            async_connections.get_connection(DEFAULT_DB_ALIAS)\n+\n+    @skipUnlessDBFeature(\"supports_async\")\n+    async def test_new_connection_on_sync(self):\n+        with self.assertRaises(NotSupportedError):\n+            async with new_connection():\n+                async_connections.get_connection(DEFAULT_DB_ALIAS)\ndiff --git a/tests/transactions/tests.py b/tests/transactions/tests.py\nindex 9fe8c58593bb..6cf6d54348f5 100644\n--- a/tests/transactions/tests.py\n+++ b/tests/transactions/tests.py\n@@ -577,3 +578,93 @@ class DurableTransactionTests(DurableTestsBase, TransactionTestCase):\n \n class DurableTests(DurableTestsBase, TestCase):\n     pass\n+\n+\n+@skipUnlessDBFeature(\"uses_savepoints\", \"supports_async\")\n+class AsyncTransactionTestCase(TransactionTestCase):\n+    available_apps = [\"transactions\"]\n+\n+    async def test_new_connection_nested(self):\n+        async with new_connection() as connection:\n+            async with new_connection() as connection2:\n+                await connection2.aset_autocommit(False)\n+                async with connection2.acursor() as cursor2:\n+                    await cursor2.aexecute(\n+                        \"INSERT INTO transactions_reporter \"\n+                        \"(first_name, last_name, email) \"\n+                        \"VALUES (%s, %s, %s)\",\n+                        (\"Sarah\", \"Hatoff\", \"\"),\n+                    )\n+                    await cursor2.aexecute(\"SELECT * FROM transactions_reporter\")\n+                    result = await cursor2.afetchmany()\n+                    assert len(result) == 1\n+\n+            async with connection.acursor() as cursor:\n+                await cursor.aexecute(\"SELECT * FROM transactions_reporter\")\n+                result = await cursor.afetchmany()\n+                assert len(result) == 1\n+\n+    async def test_new_connection_nested2(self):\n+        async with new_connection() as connection:\n+            async with connection.acursor() as cursor:\n+                await cursor.aexecute(\n+                    \"INSERT INTO transactions_reporter (first_name, last_name, email) \"\n+                    \"VALUES (%s, %s, %s)\",\n+                    (\"Sarah\", \"Hatoff\", \"\"),\n+                )\n+                await cursor.aexecute(\"SELECT * FROM transactions_reporter\")\n+                result = await cursor.afetchmany()\n+                assert len(result) == 1\n+\n+            async with new_connection() as connection2:\n+                await connection2.aset_autocommit(False)\n+                async with connection2.acursor() as cursor2:\n+                    await cursor2.aexecute(\"SELECT * FROM transactions_reporter\")\n+                    result = await cursor2.afetchmany()\n+                    # This connection won't see any rows, because the outer one\n+                    # hasn't committed yet.\n+                    assert len(result) == 0\n+\n+    async def test_new_connection_nested3(self):\n+        async with new_connection() as connection:\n+            async with new_connection() as connection2:\n+                await connection2.aset_autocommit(False)\n+                assert id(connection) != id(connection2)\n+                async with connection2.acursor() as cursor2:\n+                    await cursor2.aexecute(\n+                        \"INSERT INTO transactions_reporter \"\n+                        \"(first_name, last_name, email) \"\n+                        \"VALUES (%s, %s, %s)\",\n+                        (\"Sarah\", \"Hatoff\", \"\"),\n+                    )\n+                    await cursor2.aexecute(\"SELECT * FROM transactions_reporter\")\n+                    result = await cursor2.afetchmany()\n+                    assert len(result) == 1\n+\n+                # Outermost connection doesn't see what the innermost did, because the\n+                # innermost connection hasn't exited yet.\n+                async with connection.acursor() as cursor:\n+                    await cursor.aexecute(\"SELECT * FROM transactions_reporter\")\n+                    result = await cursor.afetchmany()\n+                    assert len(result) == 0\n+\n+    async def test_asavepoint(self):\n+        async with new_connection() as connection:\n+            async with connection.acursor() as cursor:\n+                sid = await connection.asavepoint()\n+                assert sid is not None\n+\n+                await cursor.aexecute(\n+                    \"INSERT INTO transactions_reporter (first_name, last_name, email) \"\n+                    \"VALUES (%s, %s, %s)\",\n+                    (\"Archibald\", \"Haddock\", \"\"),\n+                )\n+                await cursor.aexecute(\"SELECT * FROM transactions_reporter\")\n+                result = await cursor.afetchmany(size=5)\n+                assert len(result) == 1\n+                assert result[0][1:] == (\"Archibald\", \"Haddock\", \"\")\n+\n+                await connection.asavepoint_rollback(sid)\n+                await cursor.aexecute(\"SELECT * FROM transactions_reporter\")\n+                result = await cursor.fetchmany(size=5)\n+                assert len(result) == 0\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR introduces code generation for converting async functions to sync versions, leveraging `libcst`. While it's promising, it parallels existing work in psycopg3, which benefits from existing patterns. Careful consideration is needed for the `ConnectionHandler`'s threading behavior, especially regarding sync and async context visibility. The suggestion to use context variables to manage active sync connections is intriguing but could complicate transaction handling. Furthermore, splitting the database wrappers for sync and async may introduce duplication, but prioritizes clarity. It’s worth revisiting how deadlock prevention and connection management are handled in async contexts."
      }
    ],
    "token_estimation": 5641.75
  },
  {
    "index": 34,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py\nindex ea16cc440c46..a791593508f5 100644\n--- a/django/db/models/aggregates.py\n+++ b/django/db/models/aggregates.py\n@@ -218,6 +293,88 @@ def _get_repr_options(self):\n         return {**super()._get_repr_options(), \"sample\": self.function == \"STDDEV_SAMP\"}\n \n \n+class StringAggDelimiter(Func):\n+    arity = 1\n+    template = \"%(expressions)s\"\n+\n+    def __init__(self, value):\n+        self.value = value\n+        super().__init__(value)\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        template = \" SEPARATOR %(expressions)s\"\n+\n+        return self.as_sql(\n+            compiler,\n+            connection,\n+            template=template,\n+            **extra_context,\n+        )\n+\n+\n+class StringAgg(Aggregate):\n+    template = \"%(function)s(%(distinct)s%(expressions)s%(order_by)s)%(filter)s\"\n+    function = \"STRING_AGG\"\n+    name = \"StringAgg\"\n+    allow_distinct = True\n+    allow_order_by = True\n+    output_field = TextField()\n+\n+    def __init__(self, expression, delimiter, **extra):\n+        self.delimiter = StringAggDelimiter(delimiter)\n+        super().__init__(expression, self.delimiter, **extra)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if self.order_by:\n+            template = (\n+                \"%(function)s(%(distinct)s%(expressions)s) WITHIN GROUP (%(order_by)s)\"\n+                \"%(filter)s\"\n+            )\n+        else:\n+            template = \"%(function)s(%(distinct)s%(expressions)s)%(filter)s\"\n+\n+        return self.as_sql(\n+            compiler,\n+            connection,\n+            function=\"LISTAGG\",\n+            template=template,\n+            **extra_context,\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        extra_context[\"function\"] = \"GROUP_CONCAT\"\n+\n+        template = \"%(function)s(%(distinct)s%(expressions)s%(order_by)s%(delimiter)s)\"\n+        extra_context[\"template\"] = template\n+\n+        c = self.copy()\n+        # The creation of the delimiter SQL and the ordering of the parameters must be\n+        # handled explicitly, as MySQL puts the delimiter at the end of the aggregate\n+        # using the `SEPARATOR` declaration (rather than treating as an expression like\n+        # other database backends).\n+        delimiter_params = []\n+        if c.delimiter:\n+            delimiter_sql, delimiter_params = compiler.compile(c.delimiter)\n+            # Drop the delimiter from the source expressions.\n+            c.source_expressions = c.source_expressions[:-1]\n+            extra_context[\"delimiter\"] = delimiter_sql\n+\n+        sql, params = c.as_sql(compiler, connection, **extra_context)\n+\n+        return sql, (*params, *delimiter_params)\n+\n+    def as_sqlite(self, compiler, connection, **extra_context):\n+        if connection.get_database_version() < (3, 44):\n+            return self.as_sql(\n+                compiler,\n+                connection,\n+                function=\"GROUP_CONCAT\",\n+                **extra_context,\n+            )\n+\n+        return self.as_sql(compiler, connection, **extra_context)\n+\n+\n class Sum(FixDurationInputMixin, Aggregate):\n     function = \"SUM\"\n     name = \"Sum\"\ndiff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 86151000b52b..8caefc060c5a 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -2202,6 +2250,167 @@ def test_aggregate_arity(self):\n                 with self.assertRaisesMessage(TypeError, msg):\n                     super(function, func_instance).__init__(Value(1), Value(2))\n \n+    def test_string_agg_requires_delimiter(self):\n+        with self.assertRaises(TypeError):\n+            Book.objects.aggregate(stringagg=StringAgg(\"name\"))\n+\n+    def test_string_agg_escapes_delimiter(self):\n+        values = Publisher.objects.aggregate(\n+            stringagg=StringAgg(\"name\", delimiter=Value(\"'\"))\n+        )\n+\n+        self.assertEqual(\n+            values,\n+            {\n+                \"stringagg\": \"Apress'Sams'Prentice Hall'Morgan Kaufmann'Jonno's House \"\n+                \"of Books\",\n+            },\n+        )\n+\n+    @skipUnlessDBFeature(\"supports_aggregate_order_by_clause\")\n+    def test_string_agg_order_by(self):\n+        order_by_test_cases = (\n+            (\n+                F(\"original_opening\").desc(),\n+                \"Books.com;Amazon.com;Mamma and Pappa's Books\",\n+            ),\n+            (\n+                F(\"original_opening\").asc(),\n+                \"Mamma and Pappa's Books;Amazon.com;Books.com\",\n+            ),\n+            (F(\"original_opening\"), \"Mamma and Pappa's Books;Amazon.com;Books.com\"),\n+            (\"original_opening\", \"Mamma and Pappa's Books;Amazon.com;Books.com\"),\n+            (\"-original_opening\", \"Books.com;Amazon.com;Mamma and Pappa's Books\"),\n+            (\n+                Concat(\"original_opening\", Value(\"@\")),\n+                \"Mamma and Pappa's Books;Amazon.com;Books.com\",\n+            ),\n+            (\n+                Concat(\"original_opening\", Value(\"@\")).desc(),\n+                \"Books.com;Amazon.com;Mamma and Pappa's Books\",\n+            ),\n+        )\n+        for order_by, expected_output in order_by_test_cases:\n+            with self.subTest(order_by=order_by, expected_output=expected_output):\n+                values = Store.objects.aggregate(\n+                    stringagg=StringAgg(\"name\", delimiter=Value(\";\"), order_by=order_by)\n+                )\n+                self.assertEqual(values, {\"stringagg\": expected_output})\n+\n+    @skipIfDBFeature(\"supports_aggregate_order_by_clause\")\n+    def test_string_agg_order_by_is_not_supported(self):\n+        message = (\n+            \"This database backend does not support specifying an order on aggregates.\"\n+        )\n+        with self.assertRaisesMessage(NotSupportedError, message):\n+            Store.objects.aggregate(\n+                stringagg=StringAgg(\n+                    \"name\",\n+                    delimiter=Value(\";\"),\n+                    order_by=\"original_opening\",\n+                )\n+            )\n+\n+    def test_string_agg_filter(self):\n+        values = Book.objects.aggregate(\n+            stringagg=StringAgg(\n+                \"name\",\n+                delimiter=Value(\";\"),\n+                filter=Q(name__startswith=\"P\"),\n+            )\n+        )\n+\n+        expected_values = {\n+            \"stringagg\": \"Practical Django Projects;\"\n+            \"Python Web Development with Django;Paradigms of Artificial \"\n+            \"Intelligence Programming: Case Studies in Common Lisp\",\n+        }\n+        self.assertEqual(values, expected_values)\n+\n+    @skipUnlessDBFeature(\"supports_json_field\", \"supports_aggregate_order_by_clause\")\n+    def test_string_agg_jsonfield_order_by(self):\n+        Employee.objects.bulk_create(\n+            [\n+                Employee(work_day_preferences={\"Monday\": \"morning\"}),\n+                Employee(work_day_preferences={\"Monday\": \"afternoon\"}),\n+            ]\n+        )\n+        values = Employee.objects.aggregate(\n+            stringagg=StringAgg(\n+                KeyTextTransform(\"Monday\", \"work_day_preferences\"),\n+                delimiter=Value(\",\"),\n+                order_by=KeyTextTransform(\n+                    \"Monday\",\n+                    \"work_day_preferences\",\n+                ),\n+                output_field=CharField(),\n+            ),\n+        )\n+        self.assertEqual(values, {\"stringagg\": \"afternoon,morning\"})\n+\n+    def test_string_agg_filter_in_subquery(self):\n+        aggregate = StringAgg(\n+            \"authors__name\",\n+            delimiter=Value(\";\"),\n+            filter=~Q(authors__name__startswith=\"J\"),\n+        )\n+        subquery = (\n+            Book.objects.filter(\n+                pk=OuterRef(\"pk\"),\n+            )\n+            .annotate(agg=aggregate)\n+            .values(\"agg\")\n+        )\n+        values = list(\n+            Book.objects.annotate(\n+                agg=Subquery(subquery),\n+            ).values_list(\"agg\", flat=True)\n+        )\n+\n+        expected_values = [\n+            \"Adrian Holovaty\",\n+            \"Brad Dayley\",\n+            \"Paul Bissex;Wesley J. Chun\",\n+            \"Peter Norvig;Stuart Russell\",\n+            \"Peter Norvig\",\n+            \"\" if connection.features.interprets_empty_strings_as_nulls else None,\n+        ]\n+\n+        self.assertQuerySetEqual(expected_values, values, ordered=False)\n+\n+    @skipUnlessDBFeature(\"supports_aggregate_order_by_clause\")\n+    def test_order_by_in_subquery(self):\n+        aggregate = StringAgg(\n+            \"authors__name\",\n+            delimiter=Value(\";\"),\n+            order_by=\"authors__name\",\n+        )\n+        subquery = (\n+            Book.objects.filter(\n+                pk=OuterRef(\"pk\"),\n+            )\n+            .annotate(agg=aggregate)\n+            .values(\"agg\")\n+        )\n+        values = list(\n+            Book.objects.annotate(\n+                agg=Subquery(subquery),\n+            )\n+            .order_by(\"agg\")\n+            .values_list(\"agg\", flat=True)\n+        )\n+\n+        expected_values = [\n+            \"Adrian Holovaty;Jacob Kaplan-Moss\",\n+            \"Brad Dayley\",\n+            \"James Bennett\",\n+            \"Jeffrey Forcier;Paul Bissex;Wesley J. Chun\",\n+            \"Peter Norvig\",\n+            \"Peter Norvig;Stuart Russell\",\n+        ]\n+\n+        self.assertEqual(expected_values, values)\n+\n \n class AggregateAnnotationPruningTests(TestCase):\n     @classmethod\ndiff --git a/tests/postgres_tests/test_aggregates.py b/tests/postgres_tests/test_aggregates.py\nindex ddd3b6bbd047..56544d99e5f7 100644\n--- a/tests/postgres_tests/test_aggregates.py\n+++ b/tests/postgres_tests/test_aggregates.py\n@@ -425,66 +439,6 @@ def test_bool_or_q_object(self):\n         )\n         self.assertEqual(values, {\"boolor\": False})\n \n-    def test_string_agg_requires_delimiter(self):\n-        with self.assertRaises(TypeError):\n-            AggregateTestModel.objects.aggregate(stringagg=StringAgg(\"char_field\"))\n-\n-    def test_string_agg_delimiter_escaping(self):\n-        values = AggregateTestModel.objects.aggregate(\n-            stringagg=StringAgg(\"char_field\", delimiter=\"'\")\n-        )\n-        self.assertEqual(values, {\"stringagg\": \"Foo1'Foo2'Foo4'Foo3\"})\n-\n-    def test_string_agg_charfield(self):\n-        values = AggregateTestModel.objects.aggregate(\n-            stringagg=StringAgg(\"char_field\", delimiter=\";\")\n-        )\n-        self.assertEqual(values, {\"stringagg\": \"Foo1;Foo2;Foo4;Foo3\"})\n-\n-    def test_string_agg_default_output_field(self):\n-        values = AggregateTestModel.objects.aggregate(\n-            stringagg=StringAgg(\"text_field\", delimiter=\";\"),\n-        )\n-        self.assertEqual(values, {\"stringagg\": \"Text1;Text2;Text4;Text3\"})\n-\n-    def test_string_agg_charfield_order_by(self):\n-        order_by_test_cases = (\n-            (F(\"char_field\").desc(), \"Foo4;Foo3;Foo2;Foo1\"),\n-            (F(\"char_field\").asc(), \"Foo1;Foo2;Foo3;Foo4\"),\n-            (F(\"char_field\"), \"Foo1;Foo2;Foo3;Foo4\"),\n-            (\"char_field\", \"Foo1;Foo2;Foo3;Foo4\"),\n-            (\"-char_field\", \"Foo4;Foo3;Foo2;Foo1\"),\n-            (Concat(\"char_field\", Value(\"@\")), \"Foo1;Foo2;Foo3;Foo4\"),\n-            (Concat(\"char_field\", Value(\"@\")).desc(), \"Foo4;Foo3;Foo2;Foo1\"),\n-        )\n-        for order_by, expected_output in order_by_test_cases:\n-            with self.subTest(order_by=order_by, expected_output=expected_output):\n-                values = AggregateTestModel.objects.aggregate(\n-                    stringagg=StringAgg(\"char_field\", delimiter=\";\", order_by=order_by)\n-                )\n-                self.assertEqual(values, {\"stringagg\": expected_output})\n-\n-    def test_string_agg_jsonfield_order_by(self):\n-        values = AggregateTestModel.objects.aggregate(\n-            stringagg=StringAgg(\n-                KeyTextTransform(\"lang\", \"json_field\"),\n-                delimiter=\";\",\n-                order_by=KeyTextTransform(\"lang\", \"json_field\"),\n-                output_field=CharField(),\n-            ),\n-        )\n-        self.assertEqual(values, {\"stringagg\": \"en;pl\"})\n-\n-    def test_string_agg_filter(self):\n-        values = AggregateTestModel.objects.aggregate(\n-            stringagg=StringAgg(\n-                \"char_field\",\n-                delimiter=\";\",\n-                filter=Q(char_field__endswith=\"3\") | Q(char_field__endswith=\"1\"),\n-            )\n-        )\n-        self.assertEqual(values, {\"stringagg\": \"Foo1;Foo3\"})\n-\n     def test_orderable_agg_alternative_fields(self):\n         values = AggregateTestModel.objects.aggregate(\n             arrayagg=ArrayAgg(\"integer_field\", order_by=F(\"char_field\").asc())\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR shows good progress, with commits structured by phase and documentation added. However, you encountered issues with SQLite's version constraints limiting ordering functionality and challenges with `distinct` behavior combined with delimiters. For SQLite, consider using `LD_PRELOAD` instead of recompiling Python. Regarding MySQL, the handling of delimiters and filtering complicates SQL generation; encapsulating logic in `as_mysql` could simplify this. You might need a feature toggle for unsupported behaviors on Oracle. Great work on enhancing cross-backend support; keep refining these areas."
      }
    ],
    "token_estimation": 3309.0
  },
  {
    "index": 35,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 934dab20f028..516964c34154 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -632,6 +653,137 @@ def generate_renamed_models(self):\n                             self.old_model_keys.add((app_label, model_name))\n                             break\n \n+    def generate_moved_models(self):\n+        \"\"\"\n+        Find any moved models, generate the operations for them, and remove\n+        the old entry from the model lists. Must be run before other\n+        model-level generation.\n+        \"\"\"\n+        added_models = self.new_model_keys - self.old_model_keys\n+        for app_label, model_name in added_models:\n+            model_state = self.to_state.models[app_label, model_name]\n+            model_fields_def = self.only_relation_agnostic_fields(model_state.fields)\n+            removed_models = self.old_model_keys - self.new_model_keys\n+            for rem_app_label, rem_model_name in removed_models:\n+                if rem_app_label == app_label:\n+                    continue\n+                rem_model_state = self.from_state.models[rem_app_label, rem_model_name]\n+                rem_model_fields_def = self.only_relation_agnostic_fields(\n+                    rem_model_state.fields\n+                )\n+                if (\n+                    model_fields_def == rem_model_fields_def\n+                    and not self.questioner.ask_move_model(\n+                        rem_model_state,\n+                        model_state,\n+                    )\n+                ):\n+                    continue\n+                dependencies = []\n+                old_table_name = rem_model_state.options.get(\n+                    \"db_table\", f\"{rem_app_label}_{rem_model_name}\"\n+                )\n+                new_table_name = model_state.options.get(\n+                    \"db_table\", f\"{app_label}_{model_name}\"\n+                )\n+                # If moved model has same table name as it was in old app,\n+                # then don't rename table.\n+                if old_table_name != new_table_name:\n+                    self.add_operation(\n+                        rem_app_label,\n+                        operations.AlterModelTable(\n+                            name=model_name,\n+                            table=new_table_name,\n+                        ),\n+                        beginning=True,\n+                    )\n+                    dependencies.append(\n+                        OperationDependency(\n+                            rem_app_label,\n+                            model_name,\n+                            None,\n+                            OperationDependency.Type.ALTER_MODEL_TABLE,\n+                        )\n+                    )\n+                model_state.options[\"managed\"] = False\n+                model_state.options[\"old_app_label\"] = rem_app_label\n+                self.add_operation(\n+                    app_label,\n+                    operations.CreateModel(\n+                        name=model_name,\n+                        fields=[d for d in model_state.fields.items()],\n+                        options=model_state.options,\n+                        bases=model_state.bases,\n+                        managers=model_state.managers,\n+                    ),\n+                    dependencies=dependencies,\n+                )\n+                dependencies = list(dependencies) + self._alter_options_for_moved_model(\n+                    rem_app_label, app_label, model_name, dependencies\n+                )\n+                # If there are any base models, then add dependencies for them\n+                # so that they are created before the model(s) inheriting it.\n+                if model_state.bases:\n+                    for base in model_state.bases:\n+                        if isinstance(base, str) and \".\" in base:\n+                            base_app_label, base_name = base.split(\".\", 1)\n+                            if (base_app_label, base_name) in added_models:\n+                                dependencies.append(\n+                                    OperationDependency(\n+                                        base_app_label,\n+                                        base_name,\n+                                        None,\n+                                        OperationDependency.Type.CREATE,\n+                                    )\n+                                )\n+                self.add_operation(\n+                    rem_app_label,\n+                    operations.DeleteModel(name=model_name),\n+                    dependencies=dependencies,\n+                )\n+                self.old_model_keys.remove((rem_app_label, rem_model_name))\n+                self.old_model_keys.add((app_label, model_name))\n+                self.from_state.add_model(model_state)\n+                break\n+\n+    def _alter_options_for_moved_model(\n+        self, rem_app_label, app_label, model_name, dependencies\n+    ):\n+        dependencies = list(dependencies) + [\n+            OperationDependency(\n+                app_label, model_name, None, OperationDependency.Type.CREATE\n+            )\n+        ]\n+        # Make a model unmanaged before deleting it.\n+        self.add_operation(\n+            rem_app_label,\n+            operations.AlterModelOptions(name=model_name, options={\"managed\": False}),\n+            dependencies=dependencies,\n+        )\n+        dependencies = list(dependencies) + [\n+            OperationDependency(\n+                rem_app_label,\n+                model_name,\n+                None,\n+                OperationDependency.Type.ALTER_MODEL_OPTIONS,\n+            )\n+        ]\n+        # Switch moved model (which was created un-managed) back to managed.\n+        self.add_operation(\n+            app_label,\n+            operations.AlterModelOptions(name=model_name, options={}),\n+            dependencies=dependencies,\n+        )\n+        dependencies = list(dependencies) + [\n+            OperationDependency(\n+                app_label,\n+                model_name,\n+                None,\n+                OperationDependency.Type.ALTER_MODEL_OPTIONS,\n+            )\n+        ]\n+        return dependencies\n+\n     def generate_created_models(self):\n         \"\"\"\n         Find all new models (both managed and unmanaged) and make create\ndiff --git a/tests/contenttypes_tests/test_operations.py b/tests/contenttypes_tests/test_operations.py\nindex d44648d9fe6e..16e4889e90cb 100644\n--- a/tests/contenttypes_tests/test_operations.py\n+++ b/tests/contenttypes_tests/test_operations.py\n@@ -189,3 +189,188 @@ def test_content_type_rename_conflict(self):\n                 app_label=\"contenttypes_tests\", model=\"renamedfoo\"\n             ).exists()\n         )\n+\n+\n+@override_settings(\n+    INSTALLED_APPS=[\n+        \"contenttypes_tests.target_app\",\n+        \"contenttypes_tests.source_app\",\n+        \"django.contrib.contenttypes\",\n+    ],\n+)\n+class MoveContentTypeOperationsTests(TransactionTestCase):\n+    databases = {\"default\", \"other\"}\n+    available_apps = [\n+        \"contenttypes_tests.source_app\",\n+        \"contenttypes_tests.target_app\",\n+        \"django.contrib.contenttypes\",\n+    ]\n+\n+    class TestRouter:\n+        def db_for_write(self, model, **hints):\n+            return \"default\"\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"source_app\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+        self.addCleanup(\n+            models.signals.post_migrate.disconnect,\n+            self.assertOperationsInjected,\n+            sender=app_config,\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.CreateModel):\n+                    next_operation = next(operations)\n+                    self.assertIsInstance(\n+                        next_operation, contenttypes_management.MoveContentType\n+                    )\n+                    self.assertEqual(next_operation.new_app_label, migration.app_label)\n+                    self.assertEqual(\n+                        next_operation.old_app_label, operation.options[\"old_app_label\"]\n+                    )\n+                    self.assertEqual(next_operation.model_name, operation.name_lower)\n+\n+    def test_move_model_content_type_change(self):\n+        ContentType.objects.create(app_label=\"source_app\", model=\"simplebar\")\n+        call_command(\n+            \"migrate\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(\n+            ContentType.objects.filter(\n+                app_label=\"source_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+        self.assertTrue(\n+            ContentType.objects.filter(\n+                app_label=\"target_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+        call_command(\n+            \"migrate\",\n+            \"source_app\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(\n+            ContentType.objects.filter(\n+                app_label=\"source_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+        self.assertFalse(\n+            ContentType.objects.filter(\n+                app_label=\"target_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+\n+    @override_settings(DATABASE_ROUTERS=[TestRouter()])\n+    def test_content_type_move_model_other_database(self):\n+        ContentType.objects.using(\"other\").create(\n+            app_label=\"source_app\", model=\"simplebar\"\n+        )\n+        other_content_types = ContentType.objects.using(\"other\").filter(\n+            model=\"simplebar\"\n+        )\n+        call_command(\n+            \"migrate\",\n+            database=\"other\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(other_content_types.filter(app_label=\"source_app\").exists())\n+        self.assertTrue(other_content_types.filter(app_label=\"target_app\").exists())\n+        call_command(\n+            \"migrate\",\n+            \"source_app\",\n+            \"zero\",\n+            database=\"other\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(other_content_types.filter(app_label=\"source_app\").exists())\n+        self.assertFalse(other_content_types.filter(app_label=\"target_app\").exists())\n+\n+    def test_missing_content_type_move_ignore(self):\n+        ContentType.objects.create(app_label=\"target_app\", model=\"simplebar\")\n+        call_command(\n+            \"migrate\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(\n+            ContentType.objects.filter(\n+                app_label=\"source_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+        self.assertTrue(\n+            ContentType.objects.filter(\n+                app_label=\"target_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+        call_command(\n+            \"migrate\",\n+            \"source_app\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(\n+            ContentType.objects.filter(\n+                app_label=\"source_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+        self.assertFalse(\n+            ContentType.objects.filter(\n+                app_label=\"target_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+\n+    def test_content_type_move_conflict(self):\n+        ContentType.objects.create(app_label=\"source_app\", model=\"simplebar\")\n+        ContentType.objects.create(app_label=\"target_app\", model=\"simplebar\")\n+        call_command(\n+            \"migrate\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(\n+            ContentType.objects.filter(\n+                app_label=\"source_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+        self.assertTrue(\n+            ContentType.objects.filter(\n+                app_label=\"target_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+        call_command(\n+            \"migrate\",\n+            \"source_app\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(\n+            ContentType.objects.filter(\n+                app_label=\"source_app\", model=\"simplebar\"\n+            ).exists()\n+        )\n+        self.assertTrue(\n+            ContentType.objects.filter(\n+                app_label=\"target_app\", model=\"simplebar\"\n+            ).exists()\n+        )\ndiff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex ac725d317e01..50ba7b3eee2d 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2317,6 +2317,251 @@ def test_rename_model_reverse_relation_dependencies(self):\n             changes, \"testapp\", 0, 0, old_name=\"EntityA\", new_name=\"RenamedEntityA\"\n         )\n \n+    def test_move_model_with_no_db_table(self):\n+        before = [self.author_name, self.book]\n+        after = [\n+            ModelState(\n+                \"otherapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"name\", models.CharField(max_length=200)),\n+                ],\n+            ),\n+            ModelState(\n+                \"otherapp\",\n+                \"Book\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"author\", models.ForeignKey(\"otherapp.Author\", models.CASCADE)),\n+                    (\"title\", models.CharField(max_length=200)),\n+                ],\n+            ),\n+        ]\n+        changes = self.get_changes(\n+            before, after, MigrationQuestioner({\"ask_move_model\": True})\n+        )\n+        self.assertNumberMigrations(changes, \"otherapp\", 2)\n+\n+        self.assertMigrationDependencies(\n+            changes, \"otherapp\", 0, [(\"testapp\", \"auto_1\")]\n+        )\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"CreateModel\"])\n+        self.assertMigrationDependencies(\n+            changes, \"otherapp\", 1, [(\"otherapp\", \"auto_1\"), (\"testapp\", \"auto_2\")]\n+        )\n+        self.assertOperationTypes(\n+            changes, \"otherapp\", 1, [\"AlterModelOptions\", \"AlterField\"]\n+        )\n+\n+        self.assertNumberMigrations(changes, \"testapp\", 3)\n+\n+        self.assertMigrationDependencies(changes, \"testapp\", 0, [])\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelTable\"])\n+        self.assertMigrationDependencies(\n+            changes, \"testapp\", 1, [(\"otherapp\", \"auto_1\"), (\"testapp\", \"auto_1\")]\n+        )\n+        self.assertOperationTypes(changes, \"testapp\", 1, [\"AlterModelOptions\"])\n+        self.assertMigrationDependencies(\n+            changes, \"testapp\", 2, [(\"otherapp\", \"auto_2\"), (\"testapp\", \"auto_2\")]\n+        )\n+        self.assertOperationTypes(changes, \"testapp\", 2, [\"DeleteModel\"])\n+\n+    def test_ask_move_model(self):\n+        before = [self.author_name, self.book]\n+        after = [\n+            ModelState(\n+                \"otherapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"name\", models.CharField(max_length=200)),\n+                ],\n+            ),\n+            ModelState(\n+                \"otherapp\",\n+                \"Book\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"author\", models.ForeignKey(\"otherapp.Author\", models.CASCADE)),\n+                    (\"title\", models.CharField(max_length=200)),\n+                ],\n+            ),\n+        ]\n+        changes = self.get_changes(\n+            before, after, MigrationQuestioner({\"ask_move_model\": False})\n+        )\n+        # if ask_move_model input is false, it will consider\n+        # the changes as deleting 'Author' model from testapp\n+        # and creating it in otherapp.\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"CreateModel\", \"AlterField\"])\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"DeleteModel\"])\n+\n+    def test_move_model_with_db_table_changed(self):\n+        before = [self.author_with_db_table_options, self.book]\n+        after = [\n+            ModelState(\n+                \"otherapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"name\", models.CharField(max_length=200)),\n+                ],\n+                {\"db_table\": \"changed_db_table\"},\n+            ),\n+            ModelState(\n+                \"otherapp\",\n+                \"Book\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"author\", models.ForeignKey(\"otherapp.Author\", models.CASCADE)),\n+                    (\"title\", models.CharField(max_length=200)),\n+                ],\n+            ),\n+        ]\n+        changes = self.get_changes(\n+            before, after, MigrationQuestioner({\"ask_move_model\": True})\n+        )\n+        self.assertNumberMigrations(changes, \"otherapp\", 2)\n+\n+        self.assertMigrationDependencies(\n+            changes, \"otherapp\", 0, [(\"testapp\", \"auto_1\")]\n+        )\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(\n+            changes,\n+            \"otherapp\",\n+            0,\n+            0,\n+            name=\"author\",\n+            options={\n+                \"db_table\": \"changed_db_table\",\n+                \"indexes\": [],\n+                \"constraints\": [],\n+                \"managed\": False,\n+                \"old_app_label\": \"testapp\",\n+            },\n+        )\n+        self.assertMigrationDependencies(\n+            changes, \"otherapp\", 1, [(\"otherapp\", \"auto_1\"), (\"testapp\", \"auto_2\")]\n+        )\n+        self.assertOperationTypes(\n+            changes, \"otherapp\", 1, [\"AlterModelOptions\", \"AlterField\"]\n+        )\n+\n+        self.assertNumberMigrations(changes, \"testapp\", 3)\n+\n+        self.assertMigrationDependencies(changes, \"testapp\", 0, [])\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelTable\"])\n+        self.assertMigrationDependencies(\n+            changes, \"testapp\", 1, [(\"otherapp\", \"auto_1\"), (\"testapp\", \"auto_1\")]\n+        )\n+        self.assertOperationTypes(changes, \"testapp\", 1, [\"AlterModelOptions\"])\n+        self.assertMigrationDependencies(\n+            changes, \"testapp\", 2, [(\"otherapp\", \"auto_2\"), (\"testapp\", \"auto_2\")]\n+        )\n+        self.assertOperationTypes(changes, \"testapp\", 2, [\"DeleteModel\"])\n+\n+    def test_move_model_with_explicit_db_table(self):\n+        before = [self.author_name, self.book]\n+        after = [\n+            ModelState(\n+                \"otherapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"name\", models.CharField(max_length=200)),\n+                ],\n+                options={\"db_table\": \"testapp_author\"},\n+            ),\n+            ModelState(\n+                \"otherapp\",\n+                \"Book\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"author\", models.ForeignKey(\"otherapp.Author\", models.CASCADE)),\n+                    (\"title\", models.CharField(max_length=200)),\n+                ],\n+            ),\n+        ]\n+        changes = self.get_changes(\n+            before, after, MigrationQuestioner({\"ask_move_model\": True})\n+        )\n+        self.assertNumberMigrations(changes, \"otherapp\", 2)\n+\n+        self.assertMigrationDependencies(changes, \"otherapp\", 0, [])\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\"CreateModel\"])\n+        self.assertMigrationDependencies(\n+            changes, \"otherapp\", 1, [(\"otherapp\", \"auto_1\"), (\"testapp\", \"auto_1\")]\n+        )\n+        self.assertOperationTypes(\n+            changes, \"otherapp\", 1, [\"AlterModelOptions\", \"AlterField\"]\n+        )\n+\n+        self.assertNumberMigrations(changes, \"testapp\", 2)\n+\n+        self.assertMigrationDependencies(\n+            changes, \"testapp\", 0, [(\"otherapp\", \"auto_1\")]\n+        )\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"AlterModelOptions\"])\n+        self.assertMigrationDependencies(\n+            changes, \"testapp\", 1, [(\"otherapp\", \"auto_2\"), (\"testapp\", \"auto_1\")]\n+        )\n+        self.assertOperationTypes(changes, \"testapp\", 1, [\"DeleteModel\"])\n+\n+    def test_move_mti_models_operations(self):\n+        before = [self.author_name, self.aardvark_based_on_author]\n+        after = [\n+            ModelState(\n+                \"targetapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"name\", models.CharField(max_length=200)),\n+                ],\n+            ),\n+            ModelState(\"targetapp\", \"Aardvark\", [], bases=(\"targetapp.Author\",)),\n+        ]\n+        changes = self.get_changes(\n+            before, after, MigrationQuestioner({\"ask_move_model\": True})\n+        )\n+        self.assertNumberMigrations(changes, \"targetapp\", 2)\n+\n+        self.assertMigrationDependencies(\n+            changes, \"targetapp\", 0, [(\"testapp\", \"auto_1\")]\n+        )\n+        self.assertOperationTypes(\n+            changes, \"targetapp\", 0, [\"CreateModel\", \"CreateModel\"]\n+        )\n+        # self.assertOperationAttributes(changes, \"targetapp\", 0, 0, name=\"author\")\n+\n+        self.assertMigrationDependencies(\n+            changes, \"targetapp\", 1, [(\"targetapp\", \"auto_1\"), (\"testapp\", \"auto_2\")]\n+        )\n+        self.assertOperationTypes(\n+            changes, \"targetapp\", 1, [\"AlterModelOptions\", \"AlterModelOptions\"]\n+        )\n+\n+        self.assertNumberMigrations(changes, \"testapp\", 3)\n+\n+        self.assertMigrationDependencies(changes, \"testapp\", 0, [])\n+        self.assertOperationTypes(\n+            changes, \"testapp\", 0, [\"AlterModelTable\", \"AlterModelTable\"]\n+        )\n+        self.assertMigrationDependencies(\n+            changes, \"testapp\", 1, [(\"targetapp\", \"auto_1\"), (\"testapp\", \"auto_1\")]\n+        )\n+        self.assertOperationTypes(\n+            changes, \"testapp\", 1, [\"AlterModelOptions\", \"AlterModelOptions\"]\n+        )\n+\n+        self.assertMigrationDependencies(\n+            changes, \"testapp\", 2, [(\"targetapp\", \"auto_2\"), (\"testapp\", \"auto_2\")]\n+        )\n+        self.assertOperationTypes(changes, \"testapp\", 2, [\"DeleteModel\", \"DeleteModel\"])\n+\n     def test_fk_dependency(self):\n         \"\"\"Having a ForeignKey automatically adds a dependency.\"\"\"\n         # Note that testapp (author) has no dependencies,\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex e92b1c450658..cc51f5134b6f 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1428,6 +1428,218 @@ def test_rename_m2m_field_with_2_references(self):\n         self.assertTableNotExists(app_label + \"_person\")\n         self.assertTableExists(app_label + \"_other\")\n \n+    def test_move_model_with_fk(self):\n+        app_label_1 = \"test_mmw_fk_1\"\n+        app_label_2 = \"test_mmw_fk_2\"\n+        project_state = self.apply_operations(\n+            app_label_1,\n+            ProjectState(),\n+            operations=[\n+                migrations.CreateModel(\n+                    \"Rider\",\n+                    fields=[\n+                        (\"id\", models.AutoField(primary_key=True)),\n+                    ],\n+                ),\n+                migrations.CreateModel(\n+                    \"TempRider\",\n+                    fields=[\n+                        (\"id\", models.AutoField(primary_key=True)),\n+                    ],\n+                ),\n+            ],\n+        )\n+        project_state = self.apply_operations(\n+            app_label_2,\n+            project_state,\n+            operations=[\n+                migrations.CreateModel(\n+                    \"Pony\",\n+                    fields=[\n+                        (\"id\", models.AutoField(primary_key=True)),\n+                        (\n+                            \"riders\",\n+                            models.ForeignKey(\n+                                f\"{app_label_1}.TempRider\", on_delete=models.CASCADE\n+                            ),\n+                        ),\n+                    ],\n+                ),\n+            ],\n+        )\n+\n+        self.assertTableExists(f\"{app_label_1}_temprider\")\n+        self.assertTableExists(f\"{app_label_2}_pony\")\n+        temp_rider = project_state.apps.get_model(app_label_1, \"TempRider\")\n+        pony = project_state.apps.get_model(app_label_2, \"Pony\")\n+        pony.objects.create(riders=temp_rider.objects.create())\n+\n+        project_state = self.apply_operations(\n+            app_label_1,\n+            project_state,\n+            operations=[\n+                migrations.AlterModelTable(\n+                    \"TempRider\",\n+                    f\"{app_label_2}_temprider\",\n+                ),\n+            ],\n+        )\n+        project_state = self.apply_operations(\n+            app_label_2,\n+            project_state,\n+            operations=[\n+                migrations.CreateModel(\n+                    \"TempRider\",\n+                    fields=[\n+                        (\"id\", models.AutoField(primary_key=True)),\n+                    ],\n+                    options={\n+                        \"managed\": False,\n+                    },\n+                ),\n+            ],\n+        )\n+        project_state = self.apply_operations(\n+            app_label_1,\n+            project_state,\n+            operations=[\n+                migrations.AlterModelOptions(\"TempRider\", {\"managed\": False}),\n+            ],\n+        )\n+        project_state = self.apply_operations(\n+            app_label_2,\n+            project_state,\n+            operations=[\n+                migrations.AlterModelOptions(\"TempRider\", {}),\n+                migrations.AlterField(\n+                    \"pony\",\n+                    name=\"riders\",\n+                    field=models.ForeignKey(\n+                        on_delete=models.CASCADE, to=f\"{app_label_2}.temprider\"\n+                    ),\n+                ),\n+            ],\n+        )\n+        project_state = self.apply_operations(\n+            app_label_1,\n+            project_state,\n+            operations=[\n+                migrations.DeleteModel(\"TempRider\"),\n+            ],\n+        )\n+        self.assertTableExists(f\"{app_label_2}_temprider\")\n+        self.assertTableExists(f\"{app_label_2}_pony\")\n+        temp_rider = project_state.apps.get_model(app_label_2, \"TempRider\")\n+        pony = project_state.apps.get_model(app_label_2, \"Pony\")\n+        pony.objects.create(riders=temp_rider.objects.create())\n+        self.assertEqual(temp_rider.objects.count(), 2)\n+        self.assertEqual(pony.objects.count(), 2)\n+\n+    def test_move_model_with_inheritance_and_m2m_field(self):\n+        app_label_1 = \"test_mmw_i_m2m_1\"\n+        app_label_2 = \"test_mmw_i_m2m_2\"\n+        project_state = self.set_up_test_model(app_label_1, mti_model=True)\n+        project_state = self.apply_operations(\n+            app_label_2,\n+            project_state,\n+            operations=[\n+                migrations.CreateModel(\n+                    \"Rider\",\n+                    fields=[\n+                        (\"id\", models.AutoField(primary_key=True)),\n+                        (\n+                            \"shetlandpony_fk\",\n+                            models.ForeignKey(\n+                                f\"{app_label_1}.ShetlandPony\", on_delete=models.CASCADE\n+                            ),\n+                        ),\n+                    ],\n+                ),\n+            ],\n+        )\n+\n+        self.assertTableExists(f\"{app_label_1}_shetlandpony\")\n+        self.assertTableExists(f\"{app_label_1}_pony\")\n+        self.assertTableExists(f\"{app_label_2}_rider\")\n+        shetlandpony = project_state.apps.get_model(app_label_1, \"ShetlandPony\")\n+        rider = project_state.apps.get_model(app_label_2, \"Rider\")\n+        rider.objects.create(shetlandpony_fk=shetlandpony.objects.create(weight=2))\n+\n+        project_state = self.apply_operations(\n+            app_label_1,\n+            project_state,\n+            operations=[\n+                migrations.AlterModelTable(\n+                    \"ShetlandPony\",\n+                    f\"{app_label_2}_shetlandpony\",\n+                ),\n+            ],\n+        )\n+        project_state = self.apply_operations(\n+            app_label_2,\n+            project_state,\n+            operations=[\n+                migrations.CreateModel(\n+                    \"ShetlandPony\",\n+                    fields=[\n+                        (\n+                            \"pony_ptr\",\n+                            models.OneToOneField(\n+                                f\"{app_label_1}.Pony\",\n+                                models.CASCADE,\n+                                auto_created=True,\n+                                parent_link=True,\n+                                primary_key=True,\n+                                to_field=\"id\",\n+                                serialize=False,\n+                            ),\n+                        ),\n+                        (\"cuteness\", models.IntegerField(default=1)),\n+                    ],\n+                    bases=[\"%s.Pony\" % app_label_1],\n+                    options={\n+                        \"managed\": False,\n+                    },\n+                ),\n+            ],\n+        )\n+        project_state = self.apply_operations(\n+            app_label_1,\n+            project_state,\n+            operations=[\n+                migrations.AlterModelOptions(\"ShetlandPony\", {\"managed\": False}),\n+            ],\n+        )\n+        project_state = self.apply_operations(\n+            app_label_2,\n+            project_state,\n+            operations=[\n+                migrations.AlterModelOptions(\"ShetlandPony\", {}),\n+                migrations.AlterField(\n+                    \"Rider\",\n+                    name=\"shetlandpony_fk\",\n+                    field=models.ForeignKey(\n+                        on_delete=models.CASCADE, to=f\"{app_label_2}.ShetlandPony\"\n+                    ),\n+                ),\n+            ],\n+        )\n+        project_state = self.apply_operations(\n+            app_label_1,\n+            project_state,\n+            operations=[\n+                migrations.DeleteModel(\"ShetlandPony\"),\n+            ],\n+        )\n+        self.assertTableExists(f\"{app_label_2}_shetlandpony\")\n+        self.assertTableExists(f\"{app_label_1}_pony\")\n+        self.assertTableExists(f\"{app_label_2}_rider\")\n+        shetlandpony = project_state.apps.get_model(app_label_2, \"ShetlandPony\")\n+        rider = project_state.apps.get_model(app_label_2, \"Rider\")\n+        rider.objects.create(shetlandpony_fk=shetlandpony.objects.create(weight=2))\n+        self.assertEqual(shetlandpony.objects.count(), 2)\n+        self.assertEqual(rider.objects.count(), 2)\n+\n     def test_add_field(self):\n         \"\"\"\n         Tests the AddField operation.\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR needs more comprehensive tests in `tests/migrations/test_operations` to ensure data integrity during model moves. Existing tests primarily focus on creation and deletion, but we should validate that references and relationships are intact post-move. The approach of managing models using subclasses instead of state-only operations improves clarity, but ensure this works seamlessly for both SQLite and MySQL. Additionally, consider testing edge cases like model inheritance and generic relationships, particularly concerning ContentType updates after moves."
      }
    ],
    "token_estimation": 8061.75
  },
  {
    "index": 36,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/manimlib/constants.py b/manimlib/constants.py\nindex 82d2298df8..817467e5ec 100644\n--- a/manimlib/constants.py\n+++ b/manimlib/constants.py\n@@ -275,3 +275,107 @@ class MyText(Text):\n >>> c = Circle()\n >>> manim.play(ShowCreation(c))\n \"\"\"\n+code_languages_list = {\"abap\": \"abap\", \"as\": \"as\", \"as3\": \"as3\", \"ada\": \"ada\", \"antlr\": \"antlr\",\n+                       \"antlr_as\": \"antlr-as\",\n+                       \"antlr_csharp\": \"antlr-csharp\", \"antlr_cpp\": \"antlr-cpp\", \"antlr_java\": \"antlr-java\",\n+                       \"antlr_objc\": \"antlr-objc\", \"antlr_perl\": \"antlr-perl\", \"antlr_python\": \"antlr-python\",\n+                       \"antlr_ruby\": \"antlr-ruby\", \"apacheconf\": \"apacheconf\", \"applescript\": \"applescript\",\n+                       \"aspectj\": \"aspectj\",\n+                       \"aspx_cs\": \"aspx-cs\", \"aspx_vb\": \"aspx-vb\", \"asy\": \"asy\", \"ahk\": \"ahk\", \"autoit\": \"autoit\",\n+                       \"awk\": \"awk\",\n+                       \"basemake\": \"basemake\", \"bash\": \"bash\", \"console\": \"console\", \"bat\": \"bat\",\n+                       \"bbcode\": \"bbcode\",\n+                       \"befunge\": \"befunge\", \"blitzmax\": \"blitzmax\", \"boo\": \"boo\", \"brainfuck\": \"brainfuck\",\n+                       \"bro\": \"bro\",\n+                       \"bugs\": \"bugs\", \"c\": \"c\", \"csharp\": \"csharp\", \"cpp\": \"cpp\", \"c_objdump\": \"c-objdump\",\n+                       \"ca65\": \"ca65\",\n+                       \"cbmbas\": \"cbmbas\", \"ceylon\": \"ceylon\", \"cfengine3\": \"cfengine3\", \"cfs\": \"cfs\",\n+                       \"cheetah\": \"cheetah\",\n+                       \"clojure\": \"clojure\", \"cmake\": \"cmake\", \"cobol\": \"cobol\", \"cobolfree\": \"cobolfree\",\n+                       \"coffee_script\": \"coffee-script\", \"cfm\": \"cfm\", \"common_lisp\": \"common-lisp\", \"coq\": \"coq\",\n+                       \"cpp_objdump\": \"cpp-objdump\", \"croc\": \"croc\", \"css\": \"css\", \"css_django\": \"css+django\",\n+                       \"css_genshitext\": \"css+genshitext\", \"css_lasso\": \"css+lasso\", \"css_mako\": \"css+mako\",\n+                       \"css_myghty\": \"css+myghty\", \"css_php\": \"css+php\", \"css_erb\": \"css+erb\",\n+                       \"css_smarty\": \"css+smarty\",\n+                       \"cuda\": \"cuda\", \"cython\": \"cython\", \"d\": \"d\", \"d_objdump\": \"d-objdump\", \"dpatch\": \"dpatch\",\n+                       \"dart\": \"dart\",\n+                       \"control\": \"control\", \"sourceslist\": \"sourceslist\", \"delphi\": \"delphi\", \"dg\": \"dg\",\n+                       \"diff\": \"diff\",\n+                       \"django\": \"django\", \"dtd\": \"dtd\", \"duel\": \"duel\", \"dylan\": \"dylan\",\n+                       \"dylan_console\": \"dylan-console\",\n+                       \"dylan_lid\": \"dylan-lid\", \"ec\": \"ec\", \"ecl\": \"ecl\", \"elixir\": \"elixir\", \"iex\": \"iex\",\n+                       \"ragel_em\": \"ragel-em\",\n+                       \"erb\": \"erb\", \"erlang\": \"erlang\", \"erl\": \"erl\", \"evoque\": \"evoque\", \"factor\": \"factor\",\n+                       \"fancy\": \"fancy\",\n+                       \"fan\": \"fan\", \"felix\": \"felix\", \"fortran\": \"fortran\", \"Clipper\": \"Clipper\",\n+                       \"fsharp\": \"fsharp\", \"gas\": \"gas\",\n+                       \"genshi\": \"genshi\", \"genshitext\": \"genshitext\", \"pot\": \"pot\", \"Cucumber\": \"Cucumber\",\n+                       \"glsl\": \"glsl\",\n+                       \"gnuplot\": \"gnuplot\", \"go\": \"go\", \"gooddata_cl\": \"gooddata-cl\", \"gosu\": \"gosu\", \"gst\": \"gst\",\n+                       \"groff\": \"groff\",\n+                       \"groovy\": \"groovy\", \"haml\": \"haml\", \"haskell\": \"haskell\", \"hx\": \"hx\", \"html\": \"html\",\n+                       \"html_cheetah\": \"html+cheetah\", \"html_django\": \"html+django\", \"html_evoque\": \"html+evoque\",\n+                       \"html_genshi\": \"html+genshi\", \"html_lasso\": \"html+lasso\", \"html_mako\": \"html+mako\",\n+                       \"html_myghty\": \"html+myghty\", \"html_php\": \"html+php\", \"html_smarty\": \"html+smarty\",\n+                       \"html_velocity\": \"html+velocity\", \"http\": \"http\", \"haxeml\": \"haxeml\", \"hybris\": \"hybris\",\n+                       \"idl\": \"idl\",\n+                       \"ini\": \"ini\", \"io\": \"io\", \"ioke\": \"ioke\", \"irc\": \"irc\", \"jade\": \"jade\", \"jags\": \"jags\",\n+                       \"java\": \"java\",\n+                       \"jsp\": \"jsp\", \"js\": \"js\", \"js_cheetah\": \"js+cheetah\", \"js_django\": \"js+django\",\n+                       \"js_genshitext\": \"js+genshitext\", \"js_lasso\": \"js+lasso\", \"js_mako\": \"js+mako\",\n+                       \"js_myghty\": \"js+myghty\",\n+                       \"js_php\": \"js+php\", \"js_erb\": \"js+erb\", \"js_smarty\": \"js+smarty\", \"json\": \"json\",\n+                       \"julia\": \"julia\",\n+                       \"jlcon\": \"jlcon\", \"kconfig\": \"kconfig\", \"koka\": \"koka\", \"kotlin\": \"kotlin\", \"lasso\": \"lasso\",\n+                       \"lighty\": \"lighty\", \"lhs\": \"lhs\", \"live_script\": \"live-script\", \"llvm\": \"llvm\",\n+                       \"logos\": \"logos\",\n+                       \"logtalk\": \"logtalk\", \"lua\": \"lua\", \"make\": \"make\", \"mako\": \"mako\", \"maql\": \"maql\",\n+                       \"mason\": \"mason\",\n+                       \"matlab\": \"matlab\", \"matlabsession\": \"matlabsession\", \"minid\": \"minid\",\n+                       \"modelica\": \"modelica\",\n+                       \"modula2\": \"modula2\", \"trac_wiki\": \"trac-wiki\", \"monkey\": \"monkey\", \"moocode\": \"moocode\",\n+                       \"moon\": \"moon\",\n+                       \"mscgen\": \"mscgen\", \"mupad\": \"mupad\", \"mxml\": \"mxml\", \"myghty\": \"myghty\", \"mysql\": \"mysql\",\n+                       \"nasm\": \"nasm\",\n+                       \"nemerle\": \"nemerle\", \"newlisp\": \"newlisp\", \"newspeak\": \"newspeak\", \"nginx\": \"nginx\",\n+                       \"nimrod\": \"nimrod\",\n+                       \"nsis\": \"nsis\", \"numpy\": \"numpy\", \"objdump\": \"objdump\", \"objective_c\": \"objective-c\",\n+                       \"objective_c_+\": \"objective-c++\", \"objective_j\": \"objective-j\", \"ocaml\": \"ocaml\",\n+                       \"octave\": \"octave\",\n+                       \"ooc\": \"ooc\", \"opa\": \"opa\", \"openedge\": \"openedge\", \"perl\": \"perl\", \"php\": \"php\",\n+                       \"plpgsql\": \"plpgsql\",\n+                       \"psql\": \"psql\", \"postgresql\": \"postgresql\", \"postscript\": \"postscript\", \"pov\": \"pov\",\n+                       \"powershell\": \"powershell\", \"prolog\": \"prolog\", \"properties\": \"properties\",\n+                       \"protobuf\": \"protobuf\",\n+                       \"puppet\": \"puppet\", \"pypylog\": \"pypylog\", \"python\": \"python\", \"python3\": \"python3\",\n+                       \"py3tb\": \"py3tb\",\n+                       \"pycon\": \"pycon\", \"pytb\": \"pytb\", \"qml\": \"qml\", \"racket\": \"racket\", \"ragel\": \"ragel\",\n+                       \"ragel_c\": \"ragel-c\",\n+                       \"ragel_cpp\": \"ragel-cpp\", \"ragel_d\": \"ragel-d\", \"ragel_java\": \"ragel-java\",\n+                       \"ragel_objc\": \"ragel-objc\",\n+                       \"ragel_ruby\": \"ragel-ruby\", \"raw\": \"raw\", \"rconsole\": \"rconsole\", \"rd\": \"rd\",\n+                       \"rebol\": \"rebol\",\n+                       \"redcode\": \"redcode\", \"registry\": \"registry\", \"rst\": \"rst\", \"rhtml\": \"rhtml\",\n+                       \"RobotFramework\": \"RobotFramework\", \"spec\": \"spec\", \"rb\": \"rb\", \"rbcon\": \"rbcon\",\n+                       \"rust\": \"rust\",\n+                       \"splus\": \"splus\", \"sass\": \"sass\", \"scala\": \"scala\", \"ssp\": \"ssp\", \"scaml\": \"scaml\",\n+                       \"scheme\": \"scheme\",\n+                       \"scilab\": \"scilab\", \"scss\": \"scss\", \"shell_session\": \"shell-session\", \"smali\": \"smali\",\n+                       \"smalltalk\": \"smalltalk\", \"smarty\": \"smarty\", \"snobol\": \"snobol\", \"sp\": \"sp\", \"sql\": \"sql\",\n+                       \"sqlite3\": \"sqlite3\", \"squidconf\": \"squidconf\", \"stan\": \"stan\", \"sml\": \"sml\",\n+                       \"systemverilog\": \"systemverilog\",\n+                       \"tcl\": \"tcl\", \"tcsh\": \"tcsh\", \"tea\": \"tea\", \"tex\": \"tex\", \"text\": \"text\",\n+                       \"treetop\": \"treetop\", \"ts\": \"ts\",\n+                       \"urbiscript\": \"urbiscript\", \"vala\": \"vala\", \"vb.net\": \"vb.net\", \"velocity\": \"velocity\",\n+                       \"verilog\": \"verilog\",\n+                       \"vgl\": \"vgl\", \"vhdl\": \"vhdl\", \"vim\": \"vim\", \"xml\": \"xml\", \"xml_cheetah\": \"xml+cheetah\",\n+                       \"xml_django\": \"xml+django\", \"xml_evoque\": \"xml+evoque\", \"xml_lasso\": \"xml+lasso\",\n+                       \"xml_mako\": \"xml+mako\",\n+                       \"xml_myghty\": \"xml+myghty\", \"xml_php\": \"xml+php\", \"xml_erb\": \"xml+erb\",\n+                       \"xml_smarty\": \"xml+smarty\",\n+                       \"xml_velocity\": \"xml+velocity\", \"xquery\": \"xquery\", \"xslt\": \"xslt\", \"xtend\": \"xtend\",\n+                       \"yaml\": \"yaml\"}\n+\n+code_styles_list = {0: \"autumn\", 1: \"borland\", 2: \"bw\", 3: \"colorful\", 4: \"default\", 5: \"emacs\",\n+                    6: \"friendly\", 7: \"fruity\", 8: \"manni\", 9: \"monokai\", 10: \"murphy\", 11: \"native\",\n+                    12: \"pastie\", 13: \"perldoc\", 14: \"rrt\", 15: \"tango\", 16: \"trac\", 17: \"vim\", 18: \"vs\"}\ndiff --git a/manimlib/mobject/code_mobject.py b/manimlib/mobject/code_mobject.py\nnew file mode 100644\nindex 0000000000..94c6871049\n--- /dev/null\n+++ b/manimlib/mobject/code_mobject.py\n@@ -0,0 +1,313 @@\n+import html\r\n+from manimlib.constants import *\r\n+from manimlib.container.container import Container\r\n+from manimlib.mobject.geometry import Rectangle, Dot, RoundedRectangle\r\n+from manimlib.mobject.shape_matchers import SurroundingRectangle\r\n+from manimlib.mobject.svg.text_mobject import Text\r\n+from manimlib.mobject.types.vectorized_mobject import VGroup\r\n+\r\n+import re\r\n+from pygments import highlight\r\n+from pygments.lexers import get_lexer_by_name\r\n+from pygments.formatters.html import HtmlFormatter\r\n+\r\n+'''\r\n+1) Code is VGroup() with three things\r\n+    1.1) Code[0] is Code.background_mobject\r\n+        which can be a \r\n+            1.1.1) Rectangle() if background == \"rectangle\" \r\n+            1.1.2) VGroup() of Rectangle() and Dot() for three buttons\r\n+    1.2) Code[1] is Code.line_numbers\r\n+        1.2.1) Which is a VGroup() of Text() objects with line numbers as a text, \r\n+        1.2.2) this mean you can use \r\n+                Code.line_numbers[0] or Code[1][0] to access first line number \r\n+    1.3) Code[2] is Code.code\r\n+        1.3.1) Which is a VGroup() of lines with color highlighted, this mean you can use \r\n+            Code.code[1] or Code[2][1] \r\n+                line number 1\r\n+            Code.code[1][0] or Code.code[1][0] \r\n+                first character of line number 1\r\n+            Code.code[1][0:5] or Code.code[1][0:5] \r\n+                first five characters of line number 1\r\n+'''\r\n+\r\n+\r\n+class Code(VGroup):\r\n+    CONFIG = {\r\n+        \"tab_width\": 4,\r\n+        \"line_spacing\": 0.1,\r\n+        \"scale_factor\": 0.5,\r\n+        \"run_time\": 1,\r\n+        \"font\": 'Monospac821 BT',\r\n+        'stroke_width': 0,\r\n+        'margin': 0.3,\r\n+        'indentation_char': \"  \",\r\n+        \"background\": \"rectangle\",  # or window\r\n+        \"corner_radius\": 0.2,\r\n+        'insert_line_no': True,\r\n+        'line_no_from': 1,\r\n+        \"line_no_buff\": 0.4,\r\n+        'style': 'vim',\r\n+        'language': 'cpp',\r\n+        'generate_html_file': False\r\n+    }\r\n+\r\n+    def __init__(self, file_name=None, **kwargs):\r\n+        Container.__init__(self, **kwargs)\r\n+        self.file_name = file_name or self.file_name\r\n+        self.ensure_valid_file()\r\n+        self.style = self.style.lower()\r\n+        self.gen_html_string()\r\n+        strati = self.html_string.find(\"background:\")\r\n+        self.background_color = self.html_string[strati + 12:strati + 19]\r\n+        self.gen_code_json()\r\n+        self.temp_char = Text(\"(\").scale(self.scale_factor)\r\n+\r\n+        self.code = self.gen_colored_lines()\r\n+        if self.insert_line_no:\r\n+            self.line_numbers = self.gen_line_numbers()\r\n+            self.line_numbers.next_to(self.code, direction=LEFT, buff=self.line_no_buff)\r\n+\r\n+        if self.background == \"rectangle\":\r\n+            if self.insert_line_no:\r\n+                forground = VGroup(self.code, self.line_numbers)\r\n+            else:\r\n+                forground = self.code\r\n+            self.background_mobject = SurroundingRectangle(forground, buff=self.margin,\r\n+                                                           color=self.background_color,\r\n+                                                           fill_color=self.background_color,\r\n+                                                           stroke_width=0,\r\n+                                                           fill_opacity=1, )\r\n+            self.background_mobject.round_corners(self.corner_radius)\r\n+        else:\r\n+            if self.insert_line_no:\r\n+                forground = VGroup(self.code, self.line_numbers)\r\n+            else:\r\n+                forground = self.code\r\n+\r\n+            height = forground.get_height() + 0.1 * 3 + 2 * self.margin\r\n+            width = forground.get_width() + 0.1 * 3 + 2 * self.margin\r\n+\r\n+            rrect = RoundedRectangle(corner_radius=self.corner_radius, height=height, width=width,\r\n+                                     stroke_width=0,\r\n+                                     color=self.background_color, fill_opacity=1)\r\n+            red_button = Dot(radius=0.1, stroke_width=0, color='#ff5f56')\r\n+            red_button.shift(LEFT * 0.1 * 3)\r\n+            yellow_button = Dot(radius=0.1, stroke_width=0, color='#ffbd2e')\r\n+            green_button = Dot(radius=0.1, stroke_width=0, color='#27c93f')\r\n+            green_button.shift(RIGHT * 0.1 * 3)\r\n+            buttons = VGroup(red_button, yellow_button, green_button)\r\n+            buttons.shift(\r\n+                UP * (height / 2 - 0.1 * 2 - 0.05) + LEFT * (width / 2 - 0.1 * 5 - self.corner_radius / 2 - 0.05))\r\n+\r\n+            self.background_mobject = VGroup(rrect, buttons)\r\n+            x = (height - forground.get_height()) / 2 - 0.1 * 3\r\n+            self.background_mobject.shift(forground.get_center())\r\n+            self.background_mobject.shift(UP * x)\r\n+\r\n+        if self.insert_line_no:\r\n+            VGroup.__init__(self, self.background_mobject, self.line_numbers, *self.code, **kwargs)\r\n+        else:\r\n+            VGroup.__init__(self, self.background_mobject, Dot(fill_opacity=0, stroke_opacity=0), *self.code, **kwargs)\r\n+\r\n+        self.move_to(np.array([0, 0, 0]))\r\n+\r\n+    def apply_points_function_about_point(self, func, about_point=None, about_edge=None):\r\n+        if about_point is None:\r\n+            if about_edge is None:\r\n+                about_edge = self.get_corner(UP + LEFT)\r\n+            about_point = self.get_critical_point(about_edge)\r\n+        for mob in self.family_members_with_points():\r\n+            mob.points -= about_point\r\n+            mob.points = func(mob.points)\r\n+            mob.points += about_point\r\n+        return self\r\n+\r\n+    def ensure_valid_file(self):\r\n+        if self.file_name is None:\r\n+            raise Exception(\"Must specify file for Code\")\r\n+        possible_paths = [\r\n+            os.path.join(os.path.join(\"assets\", \"codes\"), self.file_name),\r\n+            self.file_name,\r\n+        ]\r\n+        for path in possible_paths:\r\n+            if os.path.exists(path):\r\n+                self.file_path = path\r\n+                return\r\n+        raise IOError(\"No file matching %s in codes directory\" %\r\n+                      self.file_name)\r\n+\r\n+    def gen_line_numbers(self):\r\n+        line_numbers_array = []\r\n+        for line_no in range(0, self.code_json.__len__()):\r\n+            number = str(self.line_no_from + line_no)\r\n+            line_numbers_array.append(number)\r\n+        line_numbers = Text(*[i for i in line_numbers_array], line_spacing=self.line_spacing,\r\n+                            alignment=\"right\", font=self.font, stroke_width=self.stroke_width).scale(self.scale_factor)\r\n+        return line_numbers\r\n+\r\n+    def gen_colored_lines(self):\r\n+        lines_text = []\r\n+        for line_no in range(0, self.code_json.__len__()):\r\n+            line_str = \"\"\r\n+            for word_index in range(self.code_json[line_no].__len__()):\r\n+                line_str = line_str + self.code_json[line_no][word_index][0]\r\n+            lines_text.append(self.tab_spaces[line_no] * \"\\t\" + line_str)\r\n+        code = Text(*[i for i in lines_text], line_spacing=self.line_spacing, tab_width=self.tab_width,\r\n+                    alignment=\"left\", font=self.font, stroke_width=self.stroke_width).scale(self.scale_factor)\r\n+        for line_no in range(code.__len__()):\r\n+            line = code[line_no]\r\n+            line_char_index = self.tab_spaces[line_no]\r\n+            for word_index in range(self.code_json[line_no].__len__()):\r\n+                line[line_char_index:line_char_index + self.code_json[line_no][word_index][0].__len__()].set_color(\r\n+                    self.code_json[line_no][word_index][1])\r\n+                line_char_index += self.code_json[line_no][word_index][0].__len__()\r\n+        return code\r\n+\r\n+    def gen_html_string(self):\r\n+        file = open(self.file_path, \"r\")\r\n+        code_str = file.read()\r\n+        file.close()\r\n+        self.html_string = hilite_me(code_str, self.language, {}, self.style, self.insert_line_no,\r\n+                                     \"border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\")\r\n+        if self.generate_html_file:\r\n+            os.makedirs(os.path.join(\"assets\", \"codes\", \"generated_html_files\"), exist_ok=True)\r\n+            file = open(os.path.join(\"assets\", \"codes\", \"generated_html_files\", self.file_name + \".html\"), \"w\")\r\n+            file.write(self.html_string)\r\n+            file.close()\r\n+\r\n+    def gen_code_json(self):\r\n+        if self.background_color == \"#111111\" or \\\r\n+                self.background_color == \"#272822\" or \\\r\n+                self.background_color == \"#202020\" or \\\r\n+                self.background_color == \"#000000\":\r\n+            self.default_color = \"#ffffff\"\r\n+        else:\r\n+            self.default_color = \"#000000\"\r\n+        for i in range(3, -1, -1):\r\n+            self.html_string = self.html_string.replace(\"</\" + \" \" * i, \"</\")\r\n+        for i in range(10, -1, -1):\r\n+            self.html_string = self.html_string.replace(\"</span>\" + \" \" * i, \" \" * i + \"</span>\")\r\n+        self.html_string = self.html_string.replace(\"background-color:\", \"background:\")\r\n+\r\n+        if self.insert_line_no:\r\n+            start_point = self.html_string.find(\"</td><td><pre\")\r\n+            start_point = start_point + 9\r\n+        else:\r\n+            start_point = self.html_string.find(\"<pre\")\r\n+        self.html_string = self.html_string[start_point:]\r\n+        # print(self.html_string)\r\n+        lines = self.html_string.split(\"\\n\")\r\n+        lines = lines[0:lines.__len__() - 2]\r\n+        start_point = lines[0].find(\">\")\r\n+        lines[0] = lines[0][start_point + 1:]\r\n+        # print(lines)\r\n+        self.code_json = []\r\n+        self.tab_spaces = []\r\n+        code_json_line_index = -1\r\n+        for line_index in range(0, lines.__len__()):\r\n+            if lines[line_index].__len__() == 0:\r\n+                continue\r\n+            # print(lines[line_index])\r\n+            self.code_json.append([])\r\n+            code_json_line_index = code_json_line_index + 1\r\n+            if lines[line_index].startswith(self.indentation_char):\r\n+                start_point = lines[line_index].find(\"<\")\r\n+                starting_string = lines[line_index][:start_point]\r\n+                indentation_char_count = lines[line_index][:start_point].count(self.indentation_char)\r\n+                if starting_string.__len__() != indentation_char_count * self.indentation_char.__len__():\r\n+                    lines[line_index] = \"\\t\" * indentation_char_count + starting_string[starting_string.rfind(\r\n+                        self.indentation_char) + self.indentation_char.__len__():] + \\\r\n+                                        lines[line_index][start_point:]\r\n+                else:\r\n+                    lines[line_index] = \"\\t\" * indentation_char_count + lines[line_index][start_point:]\r\n+\r\n+            indentation_char_count = 0\r\n+            while lines[line_index][indentation_char_count] == '\\t':\r\n+                indentation_char_count = indentation_char_count + 1\r\n+            self.tab_spaces.append(indentation_char_count)\r\n+            # print(lines[line_index])\r\n+            lines[line_index] = self.correct_non_span(lines[line_index])\r\n+            # print(lines[line_index])\r\n+            words = lines[line_index].split(\"<span\")\r\n+            for word_index in range(1, words.__len__()):\r\n+                color_index = words[word_index].find(\"color:\")\r\n+                if color_index == -1:\r\n+                    color = self.default_color\r\n+                else:\r\n+                    starti = words[word_index][color_index:].find(\"#\")\r\n+                    color = words[word_index][color_index + starti:color_index + starti + 7]\r\n+\r\n+                start_point = words[word_index].find(\">\")\r\n+                end_point = words[word_index].find(\"</span>\")\r\n+                text = words[word_index][start_point + 1:end_point]\r\n+                text = html.unescape(text)\r\n+                if text != \"\":\r\n+                    # print(text, \"'\" + color + \"'\")\r\n+                    self.code_json[code_json_line_index].append([text, color])\r\n+        # print(self.code_json)\r\n+\r\n+    def correct_non_span(self, line_str):\r\n+        words = line_str.split(\"</span>\")\r\n+        line_str = \"\"\r\n+        for i in range(0, words.__len__()):\r\n+            if i != words.__len__() - 1:\r\n+                j = words[i].find(\"<span\")\r\n+            else:\r\n+                j = words[i].__len__()\r\n+            temp = \"\"\r\n+            starti = -1\r\n+            for k in range(0, j):\r\n+                if words[i][k] == \"\\t\" and starti == -1:\r\n+                    continue\r\n+                else:\r\n+                    if starti == -1: starti = k\r\n+                    temp = temp + words[i][k]\r\n+            if temp != \"\":\r\n+                if i != words.__len__() - 1:\r\n+                    temp = '<span style=\"color:' + self.default_color + '\">' + words[i][starti:j] + \"</span>\"\r\n+                else:\r\n+                    temp = '<span style=\"color:' + self.default_color + '\">' + words[i][starti:j]\r\n+                temp = temp + words[i][j:]\r\n+                words[i] = temp\r\n+            if words[i] != \"\":\r\n+                line_str = line_str + words[i] + \"</span>\"\r\n+        return line_str\r\n+\r\n+\r\n+def hilite_me(code, lexer, options, style, linenos, divstyles):\r\n+    lexer = lexer or 'python'\r\n+    style = style or 'colorful'\r\n+    defstyles = 'overflow:auto;width:auto;'\r\n+\r\n+    formatter = HtmlFormatter(style=style,\r\n+                              linenos=False,\r\n+                              noclasses=True,\r\n+                              cssclass='',\r\n+                              cssstyles=defstyles + divstyles,\r\n+                              prestyles='margin: 0')\r\n+    html = highlight(code, get_lexer_by_name(lexer, **options), formatter)\r\n+    if linenos:\r\n+        html = insert_line_numbers(html)\r\n+    html = \"<!-- HTML generated using hilite.me -->\" + html\r\n+    return html\r\n+\r\n+\r\n+def get_default_style():\r\n+    return 'border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;'\r\n+\r\n+\r\n+def insert_line_numbers(html):\r\n+    match = re.search('(<pre[^>]*>)(.*)(</pre>)', html, re.DOTALL)\r\n+    if not match: return html\r\n+\r\n+    pre_open = match.group(1)\r\n+    pre = match.group(2)\r\n+    pre_close = match.group(3)\r\n+\r\n+    html = html.replace(pre_close, '</pre></td></tr></table>')\r\n+    numbers = range(1, pre.count('\\n') + 1)\r\n+    format = '%' + str(len(str(numbers[-1]))) + 'i'\r\n+    lines = '\\n'.join(format % i for i in numbers)\r\n+    html = html.replace(pre_open, '<table><tr><td>' + pre_open + lines + '</pre></td><td>' + pre_open)\r\n+    return html\r\ndiff --git a/manimlib/mobject/svg/text_mobject.py b/manimlib/mobject/svg/text_mobject.py\nindex 456e7e469e..1e9b0b2e93 100644\n--- a/manimlib/mobject/svg/text_mobject.py\n+++ b/manimlib/mobject/svg/text_mobject.py\n@@ -148,68 +193,18 @@ def text2hash(self):\n         settings = self.font + self.slant + self.weight\n         settings += str(self.t2f) + str(self.t2s) + str(self.t2w)\n         settings += str(self.lsh) + str(self.size)\n-        id_str = self.text+settings\n+        id_str = self.text + settings\n         hasher = hashlib.sha256()\n         hasher.update(id_str.encode())\n         return hasher.hexdigest()[:16]\n \n-    def text2settings(self):\n-        settings = []\n-        t2x = [self.t2f, self.t2s, self.t2w]\n-        for i in range(len(t2x)):\n-            fsw = [self.font, self.slant, self.weight]\n-            if t2x[i]:\n-                for word, x in list(t2x[i].items()):\n-                    for start, end in self.find_indexes(word):\n-                        fsw[i] = x\n-                        settings.append(TextSetting(start, end, *fsw))\n-\n-        # Set All text settings(default font slant weight)\n-        fsw = [self.font, self.slant, self.weight]\n-        settings.sort(key=lambda setting: setting.start)\n-        temp_settings = settings.copy()\n-        start = 0\n-        for setting in settings:\n-            if setting.start != start:\n-                temp_settings.append(TextSetting(start, setting.start, *fsw))\n-            start = setting.end\n-        if start != len(self.text):\n-            temp_settings.append(TextSetting(start, len(self.text), *fsw))\n-        settings = sorted(temp_settings, key=lambda setting: setting.start)\n-\n-        if re.search(r'\\n', self.text):\n-            line_num = 0\n-            for start, end in self.find_indexes('\\n'):\n-                for setting in settings:\n-                    if setting.line_num == -1:\n-                        setting.line_num = line_num\n-                    if start < setting.end:\n-                        line_num += 1\n-                        new_setting = copy.copy(setting)\n-                        setting.end = end\n-                        new_setting.start = end\n-                        new_setting.line_num = line_num\n-                        settings.append(new_setting)\n-                        settings.sort(key=lambda setting: setting.start)\n-                        break\n-\n-        for setting in settings:\n-            if setting.line_num == -1:\n-                setting.line_num = 0\n-\n-        return settings\n-\n     def text2svg(self):\n         # anti-aliasing\n         size = self.size * 10\n-        lsh = self.lsh * 10\n-\n-        if self.font == '':\n-            print(NOT_SETTING_FONT_MSG)\n \n         dir_name = consts.TEXT_DIR\n         hash_name = self.text2hash()\n-        file_name = os.path.join(dir_name, hash_name)+'.svg'\n+        file_name = os.path.join(dir_name, hash_name) + '.svg'\n         if os.path.exists(file_name):\n             return file_name\n \n@@ -217,22 +212,92 @@ def text2svg(self):\n         context = cairo.Context(surface)\n         context.set_font_size(size)\n         context.move_to(START_X, START_Y)\n-\n-        settings = self.text2settings()\n-        offset_x = 0\n-        last_line_num = 0\n-        for setting in settings:\n-            font = setting.font\n-            slant = self.str2slant(setting.slant)\n-            weight = self.str2weight(setting.weight)\n-            text = self.text[setting.start:setting.end].replace('\\n', ' ')\n-\n-            context.select_font_face(font, slant, weight)\n-            if setting.line_num != last_line_num:\n-                offset_x = 0\n-                last_line_num = setting.line_num\n-            context.move_to(START_X + offset_x, START_Y + lsh*setting.line_num)\n-            context.show_text(text)\n-            offset_x += context.text_extents(text)[4]\n+        text = self.text\n+        context.select_font_face(self.font, self.str2slant(self.slant), self.str2weight(self.weight))\n+        context.move_to(START_X, START_Y)\n+        context.show_text(text)\n \n         return file_name\n+\n+\n+class SingleStringTextWithFixHeight(SingleStringTextMobject):\n+    def __init__(self, text, **kwargs):\n+        SingleStringTextMobject.__init__(self,text,**kwargs)\n+        max_height = SingleStringTextMobject(\"(gyt{[/QW\", **kwargs).get_height()\n+        rectangle = Rectangle(width=0, height=max_height, fill_opacity=0,\n+                              stroke_opacity=0,\n+                              stroke_width=0)\n+        self.submobjects.append(rectangle)\n+\n+\n+class Text(VGroup):\n+    CONFIG = {\n+        \"line_spacing\": 0.1,\n+        \"alignment\": \"center\"\n+    }\n+\n+    def __init__(self, *text, **config):\n+        Container.__init__(self, **config)\n+        self.lines_list = list(text)\n+        self.lines = []\n+        self.lines.append([])\n+        for line_no in range(self.lines_list.__len__()):\n+            if \"\\n\" in self.lines_list[line_no]:\n+                self.lines_list[line_no:line_no + 1] = self.lines_list[line_no].split(\"\\n\")\n+        for line_no in range(self.lines_list.__len__()):\n+            self.lines[0].append(SingleStringTextWithFixHeight(self.lines_list[line_no], **config))\n+        self.char_height = SingleStringTextWithFixHeight(\"(\", **config).get_height()\n+        self.lines.append([])\n+        self.lines[1].extend([self.alignment for _ in range(self.lines_list.__len__())])\n+        self.lines[0][0].move_to(np.array([0, 0, 0]))\n+        self.align_lines()\n+\n+        self.text = VGroup(*[self.lines[0][i] for i in range(self.lines[0].__len__())])\n+        self.config = config\n+        VGroup.__init__(self, *self.text, **config)\n+        self.move_to(np.array([0, 0, 0]))\n+\n+    def set_all_lines_alignment(self, alignment):\n+        self.lines[1].extend([alignment for _ in range(self.lines_list.__len__())])\n+        for line_no in range(0, self.lines[0].__len__()):\n+            self.change_alignment_for_a_line(alignment, line_no)\n+        self.move_to(np.array([0, 0, 0]))\n+\n+    def align_lines(self):\n+        for line_no in range(0, self.lines[0].__len__()):\n+            if self.lines[1][line_no] == \"center\":\n+                self.lines[0][line_no].move_to(\n+                    np.array([0, 0, 0]) + np.array([0, - line_no * (self.char_height + self.line_spacing), 0]))\n+            elif self.lines[1][line_no] == \"left\":\n+                self.lines[0][line_no].move_to(np.array([0, 0, 0]) +\n+                                               np.array([self.lines[0][line_no].get_width() / 2,\n+                                                         - line_no * (self.char_height + self.line_spacing), 0])\n+                                               )\n+            elif self.lines[1][line_no] == \"right\":\n+                self.lines[0][line_no].move_to(np.array([0, 0, 0]) +\n+                                               np.array([- self.lines[0][line_no].get_width() / 2,\n+                                                         - line_no * (self.char_height + self.line_spacing), 0])\n+                                               )\n+\n+    def set_alignment(self, alignment, line_no):\n+        self.change_alignment_for_a_line(alignment, line_no)\n+        self.move_to(np.array([0, 0, 0]))\n+\n+    def change_alignment_for_a_line(self, alignment, line_no):\n+        self.lines[1][line_no] = alignment\n+        if self.lines[1][line_no] == \"center\":\n+            self.lines[0][line_no].move_to(self.get_top() +\n+                                           np.array([0, -self.char_height / 2, 0]) +\n+                                           np.array([0, - line_no * (self.char_height + self.line_spacing), 0]))\n+        elif self.lines[1][line_no] == \"left\":\n+            self.lines[0][line_no].move_to(self.get_top() +\n+                                           np.array([0, -self.char_height / 2, 0]) +\n+                                           np.array([self.get_width() / 2 - self.lines[0][line_no].get_width() / 2,\n+                                                     - line_no * (self.char_height + self.line_spacing), 0])\n+                                           )\n+        elif self.lines[1][line_no] == \"right\":\n+            self.lines[0][line_no].move_to(self.get_top() +\n+                                           np.array([0, -self.char_height / 2, 0]) +\n+                                           np.array([- self.get_width() / 2 + self.lines[0][line_no].get_width() / 2,\n+                                                     - line_no * (self.char_height + self.line_spacing), 0])\n+                                           )\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR has a few critical areas for improvement. First, add `CodeMobject` to `imports.py` for completeness. Renaming variables to more descriptive names will enhance readability, as current abbreviations can be confusing. Address the issue on line 125 where whitespace before `</pre>` leads to index errors; consider using `strip()` for more reliable matching. While the proposed user file conversion is promising, splitting this into a separate PR is advisable to expedite merging and ensure focused testing. Overall, the core functionality looks solid."
      }
    ],
    "token_estimation": 8199.25
  },
  {
    "index": 37,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/manimlib/__init__.py b/manimlib/__init__.py\nindex 9b3b3f288e..b440aaa343 100644\n--- a/manimlib/__init__.py\n+++ b/manimlib/__init__.py\n@@ -1,12 +1,73 @@\n-#!/usr/bin/env python\n-import manimlib.config\n-import manimlib.extract_scene\n+from manimlib.constants import *\n \n+from manimlib.animation.animation import *\n+from manimlib.animation.composition import *\n+from manimlib.animation.creation import *\n+from manimlib.animation.fading import *\n+from manimlib.animation.growing import *\n+from manimlib.animation.indication import *\n+from manimlib.animation.movement import *\n+from manimlib.animation.numbers import *\n+from manimlib.animation.rotation import *\n+from manimlib.animation.specialized import *\n+from manimlib.animation.transform import *\n+from manimlib.animation.transform_matching_parts import *\n+from manimlib.animation.update import *\n \n-def main():\n-    args = manimlib.config.parse_cli()\n-    config = manimlib.config.get_configuration(args)\n-    scenes = manimlib.extract_scene.main(config)\n+from manimlib.camera.camera import *\n \n-    for scene in scenes:\n-        scene.run()\n+from manimlib.mobject.coordinate_systems import *\n+from manimlib.mobject.changing import *\n+from manimlib.mobject.frame import *\n+from manimlib.mobject.functions import *\n+from manimlib.mobject.geometry import *\n+from manimlib.mobject.matrix import *\n+from manimlib.mobject.mobject import *\n+from manimlib.mobject.number_line import *\n+from manimlib.mobject.numbers import *\n+from manimlib.mobject.probability import *\n+from manimlib.mobject.shape_matchers import *\n+from manimlib.mobject.interactive import *\n+from manimlib.mobject.svg.brace import *\n+from manimlib.mobject.svg.drawings import *\n+from manimlib.mobject.svg.svg_mobject import *\n+from manimlib.mobject.svg.tex_mobject import *\n+from manimlib.mobject.svg.text_mobject import *\n+from manimlib.mobject.three_dimensions import *\n+from manimlib.mobject.types.image_mobject import *\n+from manimlib.mobject.types.point_cloud_mobject import *\n+from manimlib.mobject.types.surface import *\n+from manimlib.mobject.types.vectorized_mobject import *\n+from manimlib.mobject.types.dot_cloud import *\n+from manimlib.mobject.mobject_update_utils import *\n+from manimlib.mobject.value_tracker import *\n+from manimlib.mobject.vector_field import *\n+\n+from manimlib.once_useful_constructs.arithmetic import *\n+from manimlib.once_useful_constructs.combinatorics import *\n+from manimlib.once_useful_constructs.complex_transformation_scene import *\n+from manimlib.once_useful_constructs.counting import *\n+from manimlib.once_useful_constructs.fractals import *\n+from manimlib.once_useful_constructs.graph_theory import *\n+from manimlib.once_useful_constructs.light import *\n+\n+from manimlib.scene.scene import *\n+from manimlib.scene.sample_space_scene import *\n+from manimlib.scene.three_d_scene import *\n+from manimlib.scene.vector_space_scene import *\n+\n+from manimlib.utils.bezier import *\n+from manimlib.utils.color import *\n+from manimlib.utils.config_ops import *\n+from manimlib.utils.customization import *\n+from manimlib.utils.debug import *\n+from manimlib.utils.directories import *\n+from manimlib.utils.images import *\n+from manimlib.utils.iterables import *\n+from manimlib.utils.file_ops import *\n+from manimlib.utils.paths import *\n+from manimlib.utils.rate_functions import *\n+from manimlib.utils.simple_functions import *\n+from manimlib.utils.sounds import *\n+from manimlib.utils.space_ops import *\n+from manimlib.utils.strings import *\ndiff --git a/manimlib/defaults.yml b/manimlib/defaults.yml\ndeleted file mode 100644\nindex 7b89767c62..0000000000\n--- a/manimlib/defaults.yml\n+++ /dev/null\n@@ -1,56 +0,0 @@\n-directories:\n-  # Set this to true if you want the path to video files\n-  # to match the directory structure of the path to the\n-  # sourcecode generating that video\n-  mirror_module_path: False\n-  # Where should manim output video and image files?\n-  output: \"\"\n-  # If you want to use images, manim will look to these folders to find them\n-  raster_images: \"\"\n-  vector_images: \"\"\n-  # If you want to use sounds, manim will look here to find it.\n-  sounds: \"\"\n-  # Manim often generates tex_files or other kinds of serialized data\n-  # to keep from having to generate the same thing too many times.  By\n-  # default, these will be stored at tempfile.gettempdir(), e.g. this might\n-  # return whatever is at to the TMPDIR environment variable.  If you want to\n-  # specify them elsewhere,\n-  temporary_storage: \"\"\n-tex:\n-  executable: \"latex\"\n-  template_file: \"tex_template.tex\" \n-  intermediate_filetype: \"dvi\"\n-  text_to_replace: \"[tex_expression]\"\n-  # # For ctex, use the following configuration\n-  # executable: \"xelatex -no-pdf\"\n-  # template_file: \"ctex_template.tex\"\n-  # intermediate_filetype: \"xdv\"\n-universal_import_line: \"from manimlib.imports import *\"\n-style:\n-  font: \"Consolas\"\n-  background_color: \"#333333\"\n-# Set the position of preview window, you can use directions, e.g. UL/DR/OL/OO/...\n-# also, you can also specify the position(pixel) of the upper left corner of \n-# the window on the monitor, e.g. \"960,540\"\n-window_position: UR\n-# If break_into_partial_movies is set to True, then many small\n-# files will be written corresponding to each Scene.play and\n-# Scene.wait call, and these files will then be combined\n-# to form the full scene.  Sometimes video-editing is made\n-# easier when working with the broken up scene, which\n-# effectively has cuts at all the places you might want.\n-break_into_partial_movies: False\n-camera_qualities:\n-  low:\n-    resolution: \"854x480\"\n-    frame_rate: 15\n-  medium:\n-    resolution: \"1280x720\"\n-    frame_rate: 30\n-  high:\n-    resolution: \"1920x1080\"\n-    frame_rate: 30\n-  ultra_high:\n-    resolution: \"3840x2160\"\n-    frame_rate: 60\n-  default_quality: \"high\"\ndiff --git a/manimlib/imports.py b/manimlib/imports.py\ndeleted file mode 100644\nindex 2237bfaff2..0000000000\n--- a/manimlib/imports.py\n+++ /dev/null\n@@ -1,106 +0,0 @@\n-\"\"\"\n-I won't pretend like this is best practice, but in creating animations for a video,\n-it can be very nice to simply have all of the Mobjects, Animations, Scenes, etc.\n-of manim available without having to worry about what namespace they come from.\n-\n-Rather than having a large pile of \"from <module> import *\" at the top of every such\n-script, the intent of this file is to make it so that one can just include\n-\"from manimlib.imports import *\".  The effects of adding more modules\n-or refactoring the library on current or older scene scripts should be entirely\n-addressible by changing this file.\n-\n-Note: One should NOT import from this file for main library code, it is meant only\n-as a convenience for scripts creating scenes for videos.\n-\"\"\"\n-\n-\n-from manimlib.constants import *\n-\n-from manimlib.animation.animation import *\n-from manimlib.animation.composition import *\n-from manimlib.animation.creation import *\n-from manimlib.animation.fading import *\n-from manimlib.animation.growing import *\n-from manimlib.animation.indication import *\n-from manimlib.animation.movement import *\n-from manimlib.animation.numbers import *\n-from manimlib.animation.rotation import *\n-from manimlib.animation.specialized import *\n-from manimlib.animation.transform import *\n-from manimlib.animation.transform_matching_parts import *\n-from manimlib.animation.update import *\n-\n-from manimlib.camera.camera import *\n-\n-from manimlib.mobject.coordinate_systems import *\n-from manimlib.mobject.changing import *\n-from manimlib.mobject.frame import *\n-from manimlib.mobject.functions import *\n-from manimlib.mobject.geometry import *\n-from manimlib.mobject.matrix import *\n-from manimlib.mobject.mobject import *\n-from manimlib.mobject.number_line import *\n-from manimlib.mobject.numbers import *\n-from manimlib.mobject.probability import *\n-from manimlib.mobject.shape_matchers import *\n-from manimlib.mobject.interactive import *\n-from manimlib.mobject.svg.brace import *\n-from manimlib.mobject.svg.drawings import *\n-from manimlib.mobject.svg.svg_mobject import *\n-from manimlib.mobject.svg.tex_mobject import *\n-from manimlib.mobject.svg.text_mobject import *\n-from manimlib.mobject.three_dimensions import *\n-from manimlib.mobject.types.image_mobject import *\n-from manimlib.mobject.types.point_cloud_mobject import *\n-from manimlib.mobject.types.surface import *\n-from manimlib.mobject.types.vectorized_mobject import *\n-from manimlib.mobject.types.dot_cloud import *\n-from manimlib.mobject.mobject_update_utils import *\n-from manimlib.mobject.value_tracker import *\n-from manimlib.mobject.vector_field import *\n-\n-from manimlib.once_useful_constructs.arithmetic import *\n-from manimlib.once_useful_constructs.combinatorics import *\n-from manimlib.once_useful_constructs.complex_transformation_scene import *\n-from manimlib.once_useful_constructs.counting import *\n-from manimlib.once_useful_constructs.fractals import *\n-from manimlib.once_useful_constructs.graph_theory import *\n-from manimlib.once_useful_constructs.light import *\n-\n-from manimlib.scene.scene import *\n-from manimlib.scene.sample_space_scene import *\n-from manimlib.scene.three_d_scene import *\n-from manimlib.scene.vector_space_scene import *\n-\n-from manimlib.utils.bezier import *\n-from manimlib.utils.color import *\n-from manimlib.utils.config_ops import *\n-from manimlib.utils.customization import *\n-from manimlib.utils.debug import *\n-from manimlib.utils.directories import *\n-from manimlib.utils.images import *\n-from manimlib.utils.iterables import *\n-from manimlib.utils.file_ops import *\n-from manimlib.utils.paths import *\n-from manimlib.utils.rate_functions import *\n-from manimlib.utils.simple_functions import *\n-from manimlib.utils.sounds import *\n-from manimlib.utils.space_ops import *\n-from manimlib.utils.strings import *\n-\n-# Non manim libraries that are also nice to have without thinking\n-\n-import inspect\n-import itertools as it\n-import numpy as np\n-import operator as op\n-import os\n-import random\n-import re\n-import string\n-import sys\n-import math\n-import sympy\n-\n-from PIL import Image\n-from colour import Color\ndiff --git a/manimlib/utils/init_config.py b/manimlib/utils/init_config.py\nnew file mode 100644\nindex 0000000000..064db879cc\n--- /dev/null\n+++ b/manimlib/utils/init_config.py\n@@ -0,0 +1,84 @@\n+import yaml\n+import os\n+\n+def init_customization():\n+    configuration = {\n+        \"directories\": {\n+            \"mirror_module_path\": False,\n+            \"output\": \"\",\n+            \"raster_images\": \"\",\n+            \"vector_images\": \"\",\n+            \"sounds\": \"\",\n+            \"temporary_storage\": \"\",\n+        },\n+        \"tex\": {\n+            \"executable\": \"\",\n+            \"template_file\": \"\",\n+            \"intermediate_filetype\": \"\",\n+            \"text_to_replace\": \"[tex_expression]\",\n+        },\n+        \"universal_import_line\": \"from manimlib import *\",\n+        \"style\": {\n+            \"font\": \"Consolas\",\n+            \"background_color\": \"\",\n+        },\n+        \"window_position\": \"UR\",\n+        \"break_into_partial_movies\": False,\n+        \"camera_qualities\": {\n+            \"low\": {\n+                \"resolution\": \"854x480\",\n+                \"frame_rate\": 15,\n+            },\n+            \"medium\": {\n+                \"resolution\": \"1280x720\",\n+                \"frame_rate\": 30,\n+            },\n+            \"high\": {\n+                \"resolution\": \"1920x1080\",\n+                \"frame_rate\": 60,\n+            },\n+            \"ultra_high\": {\n+                \"resolution\": \"3840x2160\",\n+                \"frame_rate\": 60,\n+            },\n+            \"default_quality\": \"\",\n+        }\n+    }\n+\n+    scope = input(\" Please select the scope of the configuration [global/local]: \")\n+    if scope == \"global\":\n+        from manimlib.config import get_manim_dir\n+        file_name = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\")\n+    else:\n+        file_name = os.path.join(os.getcwd(), \"custom_config.yml\")\n+\n+    print(\"\\n directories:\")\n+    configuration[\"directories\"][\"output\"] = input(\"  [1/8] Where should manim output video and image files place: \")\n+    configuration[\"directories\"][\"raster_images\"] = input(\"  [2/8] Which folder should manim find raster images (.jpg .png .gif) in (optional): \")\n+    configuration[\"directories\"][\"vector_images\"] = input(\"  [3/8] Which folder should manim find vector images (.svg .xdv) in (optional): \")\n+    configuration[\"directories\"][\"sounds\"] = input(\"  [4/8] Which folder should manim find sound files (.mp3 .wav) in (optional): \")\n+    configuration[\"directories\"][\"temporary_storage\"] = input(\"  [5/8] Which folder should manim storage temporary files: \")\n+\n+    print(\"\\n tex:\")\n+    tex = input(\"  [6/8] Which executable file to use to compile [latex/xelatex]: \")\n+    if tex == \"latex\":\n+        configuration[\"tex\"][\"executable\"] = \"latex\"\n+        configuration[\"tex\"][\"template_file\"] = \"tex_template.tex\"\n+        configuration[\"tex\"][\"intermediate_filetype\"] = \"dvi\"\n+    else:\n+        configuration[\"tex\"][\"executable\"] = \"xelatex -no-pdf\"\n+        configuration[\"tex\"][\"template_file\"] = \"ctex_template.tex\"\n+        configuration[\"tex\"][\"intermediate_filetype\"] = \"xdv\"\n+\n+    print(\"\\n style:\")\n+    configuration[\"style\"][\"background_color\"] = input(\"  [7/8] Which background color do you want (hex code): \")\n+\n+    print(\"\\n camera_qualities:\")\n+    print(\"  Four defined qualities: low: 480p15  medium: 720p30  high: 1080p60  ultra_high: 2160p60\")\n+    configuration[\"camera_qualities\"][\"default_quality\"] = input(\"  [8/8] Which one to choose as the default rendering quality [low/medium/high/ultra_high]: \")\n+\n+    with open(file_name, 'w', encoding=\"utf_8\") as file:\n+        yaml.dump(configuration, file)\n+\n+    print(f\"\\nYou have set up a {scope} configuration file\")\n+    print(f\"You can manually modify it again in: {file_name}\\n\")\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR is on the right path but raises some concerns about user experience and best practices. Using `from manimlib import *` to include `imports.py` could lead to unexpected behavior, especially if it contains non-manim imports. Encourage explicit imports instead. Regarding configuration, default values should be in place for a smoother initial user experience. Be wary of issues arising on different OS setups, such as OpenGL context errors, which might necessitate import order adjustments. Further investigation into these environment-specific problems is advisable."
      }
    ],
    "token_estimation": 3594.75
  },
  {
    "index": 38,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/docs/async-await.rst b/docs/async-await.rst\nnew file mode 100644\nindex 0000000000..c8981f886a\n--- /dev/null\n+++ b/docs/async-await.rst\n@@ -0,0 +1,81 @@\n+.. _async_await:\n+\n+Using ``async`` and ``await``\n+=============================\n+\n+.. versionadded:: 2.0\n+\n+Routes, error handlers, before request, after request, and teardown\n+functions can all be coroutine functions if Flask is installed with the\n+``async`` extra (``pip install flask[async]``). This allows views to be\n+defined with ``async def`` and use ``await``.\n+\n+.. code-block:: python\n+\n+    @app.route(\"/get-data\")\n+    async def get_data():\n+        data = await async_db_query(...)\n+        return jsonify(data)\n+\n+\n+Performance\n+-----------\n+\n+Async functions require an event loop to run. Flask, as a WSGI\n+application, uses one worker to handle one request/response cycle.\n+When a request comes in to an async view, Flask will start an event loop\n+in a thread, run the view function there, then return the result.\n+\n+Each request still ties up one worker, even for async views. The upside\n+is that you can run async code within a view, for example to make\n+multiple concurrent database queries, HTTP requests to an external API,\n+etc. However, the number of requests your application can handle at one\n+time will remain the same.\n+\n+**Async is not inherently faster than sync code.** Async is beneficial\n+when performing concurrent IO-bound tasks, but will probably not improve\n+CPU-bound tasks. Traditional Flask views will still be appropriate for\n+most use cases, but Flask's async support enables writing and using\n+code that wasn't possible natively before.\n+\n+\n+When to use Quart instead\n+-------------------------\n+\n+Flask's async support is less performant than async-first frameworks due\n+to the way it is implemented. If you have a mainly async codebase it\n+would make sense to consider `Quart`_. Quart is a reimplementation of\n+Flask based on the `ASGI`_ standard instead of WSGI. This allows it to\n+handle many concurrent requests, long running requests, and websockets\n+without requiring individual worker processes or threads.\n+\n+It has also already been possible to run Flask with Gevent or Eventlet\n+to get many of the benefits of async request handling. These libraries\n+patch low-level Python functions to accomplish this, whereas ``async``/\n+``await`` and ASGI use standard, modern Python capabilities. Deciding\n+whether you should use Flask, Quart, or something else is ultimately up\n+to understanding the specific needs of your project.\n+\n+.. _Quart: https://gitlab.com/pgjones/quart\n+.. _ASGI: https://asgi.readthedocs.io/en/latest/\n+\n+\n+Extensions\n+----------\n+\n+Existing Flask extensions only expect views to be synchronous. If they\n+provide decorators to add functionality to views, those will probably\n+not work with async views because they will not await the function or be\n+awaitable. Other functions they provide will not be awaitable either and\n+will probably be blocking if called within an async view.\n+\n+Check the changelog of the extension you want to use to see if they've\n+implemented async support, or make a feature request or PR to them.\n+\n+\n+Other event loops\n+-----------------\n+\n+At the moment Flask only supports :mod:`asyncio`. It's possible to\n+override :meth:`flask.Flask.ensure_sync` to change how async functions\n+are wrapped to use a different library.\ndiff --git a/tests/test_async.py b/tests/test_async.py\nnew file mode 100644\nindex 0000000000..5893ff6954\n--- /dev/null\n+++ b/tests/test_async.py\n@@ -0,0 +1,139 @@\n+import asyncio\n+import sys\n+\n+import pytest\n+\n+from flask import Blueprint\n+from flask import Flask\n+from flask import request\n+from flask.helpers import run_async\n+\n+pytest.importorskip(\"asgiref\")\n+\n+\n+class AppError(Exception):\n+    pass\n+\n+\n+class BlueprintError(Exception):\n+    pass\n+\n+\n+@pytest.fixture(name=\"async_app\")\n+def _async_app():\n+    app = Flask(__name__)\n+\n+    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n+    async def index():\n+        await asyncio.sleep(0)\n+        return request.method\n+\n+    @app.errorhandler(AppError)\n+    async def handle(_):\n+        return \"\", 412\n+\n+    @app.route(\"/error\")\n+    async def error():\n+        raise AppError()\n+\n+    blueprint = Blueprint(\"bp\", __name__)\n+\n+    @blueprint.route(\"/\", methods=[\"GET\", \"POST\"])\n+    async def bp_index():\n+        await asyncio.sleep(0)\n+        return request.method\n+\n+    @blueprint.errorhandler(BlueprintError)\n+    async def bp_handle(_):\n+        return \"\", 412\n+\n+    @blueprint.route(\"/error\")\n+    async def bp_error():\n+        raise BlueprintError()\n+\n+    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n+\n+    return app\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\n+@pytest.mark.parametrize(\"path\", [\"/\", \"/bp/\"])\n+def test_async_route(path, async_app):\n+    test_client = async_app.test_client()\n+    response = test_client.get(path)\n+    assert b\"GET\" in response.get_data()\n+    response = test_client.post(path)\n+    assert b\"POST\" in response.get_data()\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\n+@pytest.mark.parametrize(\"path\", [\"/error\", \"/bp/error\"])\n+def test_async_error_handler(path, async_app):\n+    test_client = async_app.test_client()\n+    response = test_client.get(path)\n+    assert response.status_code == 412\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 7), reason=\"requires Python >= 3.7\")\n+def test_async_before_after_request():\n+    app_first_called = False\n+    app_before_called = False\n+    app_after_called = False\n+    bp_before_called = False\n+    bp_after_called = False\n+\n+    app = Flask(__name__)\n+\n+    @app.route(\"/\")\n+    def index():\n+        return \"\"\n+\n+    @app.before_first_request\n+    async def before_first():\n+        nonlocal app_first_called\n+        app_first_called = True\n+\n+    @app.before_request\n+    async def before():\n+        nonlocal app_before_called\n+        app_before_called = True\n+\n+    @app.after_request\n+    async def after(response):\n+        nonlocal app_after_called\n+        app_after_called = True\n+        return response\n+\n+    blueprint = Blueprint(\"bp\", __name__)\n+\n+    @blueprint.route(\"/\")\n+    def bp_index():\n+        return \"\"\n+\n+    @blueprint.before_request\n+    async def bp_before():\n+        nonlocal bp_before_called\n+        bp_before_called = True\n+\n+    @blueprint.after_request\n+    async def bp_after(response):\n+        nonlocal bp_after_called\n+        bp_after_called = True\n+        return response\n+\n+    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n+\n+    test_client = app.test_client()\n+    test_client.get(\"/\")\n+    assert app_first_called\n+    assert app_before_called\n+    assert app_after_called\n+    test_client.get(\"/bp/\")\n+    assert bp_before_called\n+    assert bp_after_called\n+\n+\n+@pytest.mark.skipif(sys.version_info >= (3, 7), reason=\"should only raise Python < 3.7\")\n+def test_async_runtime_error():\n+    with pytest.raises(RuntimeError):\n+        run_async(None)\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Phil, while I appreciate your approach, it lacks the scalability benefits of utilizing asynchronous servers, which is a crucial advantage. The current implementation seems to restrict concurrent async view functions to run on a single loop, limiting performance. It might be better to leverage a shared loop for multiple async routes. Additionally, the note on performance should include scaling limitations. Waiting for a future release before merging seems prudent to ensure robustness and avoid unnecessary complexity. There's potential in exploring integrations with asgiref and SQLAlchemy for better async support."
      }
    ],
    "token_estimation": 1912.75
  },
  {
    "index": 39,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/docs/security.rst b/docs/security.rst\nindex 55ac91fee5..3e97834dcc 100644\n--- a/docs/security.rst\n+++ b/docs/security.rst\n@@ -95,81 +95,12 @@ the form validation framework, which does not exist in Flask.\n JSON Security\n -------------\n \n-.. admonition:: ECMAScript 5 Changes\n-\n-   Starting with ECMAScript 5 the behavior of literals changed.  Now they\n-   are not constructed with the constructor of ``Array`` and others, but\n-   with the builtin constructor of ``Array`` which closes this particular\n-   attack vector.\n-\n-JSON itself is a high-level serialization format, so there is barely\n-anything that could cause security problems, right?  You can't declare\n-recursive structures that could cause problems and the only thing that\n-could possibly break are very large responses that can cause some kind of\n-denial of service at the receiver's side.\n-\n-However there is a catch.  Due to how browsers work the CSRF issue comes\n-up with JSON unfortunately.  Fortunately there is also a weird part of the\n-JavaScript specification that can be used to solve that problem easily and\n-Flask is kinda doing that for you by preventing you from doing dangerous\n-stuff.  Unfortunately that protection is only there for\n-:func:`~flask.jsonify` so you are still at risk when using other ways to\n-generate JSON.\n-\n-So what is the issue and how to avoid it?  The problem are arrays at\n-top-level in JSON.  Imagine you send the following data out in a JSON\n-request.  Say that's exporting the names and email addresses of all your\n-friends for a part of the user interface that is written in JavaScript.\n-Not very uncommon:\n-\n-.. sourcecode:: javascript\n-\n-    [\n-        {\"username\": \"admin\",\n-         \"email\": \"admin@localhost\"}\n-    ]\n-\n-And it is doing that of course only as long as you are logged in and only\n-for you.  And it is doing that for all ``GET`` requests to a certain URL,\n-say the URL for that request is\n-``http://example.com/api/get_friends.json``.\n-\n-So now what happens if a clever hacker is embedding this to his website\n-and social engineers a victim to visiting his site:\n-\n-.. sourcecode:: html\n-\n-    <script type=text/javascript>\n-    var captured = [];\n-    var oldArray = Array;\n-    function Array() {\n-      var obj = this, id = 0, capture = function(value) {\n-        obj.__defineSetter__(id++, capture);\n-        if (value)\n-          captured.push(value);\n-      };\n-      capture();\n-    }\n-    </script>\n-    <script type=text/javascript\n-      src=http://example.com/api/get_friends.json></script>\n-    <script type=text/javascript>\n-    Array = oldArray;\n-    // now we have all the data in the captured array.\n-    </script>\n-\n-If you know a bit of JavaScript internals you might know that it's\n-possible to patch constructors and register callbacks for setters.  An\n-attacker can use this (like above) to get all the data you exported in\n-your JSON file.  The browser will totally ignore the :mimetype:`application/json`\n-mimetype if :mimetype:`text/javascript` is defined as content type in the script\n-tag and evaluate that as JavaScript.  Because top-level array elements are\n-allowed (albeit useless) and we hooked in our own constructor, after that\n-page loaded the data from the JSON response is in the `captured` array.\n-\n-Because it is a syntax error in JavaScript to have an object literal\n-(``{...}``) toplevel an attacker could not just do a request to an\n-external URL with the script tag to load up the data.  So what Flask does\n-is to only allow objects as toplevel elements when using\n-:func:`~flask.jsonify`.  Make sure to do the same when using an ordinary\n-JSON generate function.\n+In Flask 0.10 and lower, :func:`~flask.jsonify` did not serialize top-level\n+arrays to JSON. This was because of a security vulnerability in ECMAScript 4.\n+\n+ECMAScript 5 closed this vulnerability, so only extremely old browsers are\n+still vulnerable. All of these browsers have `other more serious\n+vulnerabilities\n+<https://github.com/mitsuhiko/flask/issues/248#issuecomment-59934857>`_, so\n+this behavior was changed and :func:`~flask.jsonify` now supports serializing\n+arrays.\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The implementation regarding `jsonify()` requires clarity on how `args` and `kwargs` are handled. You're right that the current behavior can be confusing, especially with the divergence from `json.dumps()`. It’s good that you added tests and improved documentation, as both are crucial for user understanding. However, consider making `jsonify()` reject simultaneous `args` and `kwargs`, as it aligns with suggested best practices and reduces ambiguity. This change should strengthen usability while maintaining the existing functionality that users are accustomed to."
      }
    ],
    "token_estimation": 1173.25
  },
  {
    "index": 40,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/scripts/flaskext_migrate.py b/scripts/flaskext_migrate.py\nnew file mode 100644\nindex 0000000000..e24ab95cf9\n--- /dev/null\n+++ b/scripts/flaskext_migrate.py\n@@ -0,0 +1,160 @@\n+# Script which modifies source code away from the deprecated \"flask.ext\"\n+# format.\n+#\n+# Run in the terminal by typing: `python flaskext_migrate.py <source_file.py>`\n+#\n+# Author: Keyan Pishdadian 2015\n+\n+from redbaron import RedBaron\n+import sys\n+\n+\n+def read_source(input_file):\n+    \"\"\"Parses the input_file into a RedBaron FST.\"\"\"\n+    with open(input_file, \"r\") as source_code:\n+        red = RedBaron(source_code.read())\n+    return red\n+\n+\n+def write_source(red, input_file):\n+    \"\"\"Overwrites the input_file once the FST has been modified.\"\"\"\n+    with open(input_file, \"w\") as source_code:\n+        source_code.write(red.dumps())\n+\n+\n+def fix_imports(red):\n+    \"\"\"Wrapper which fixes \"from\" style imports and then \"import\" style.\"\"\"\n+    red = fix_standard_imports(red)\n+    red = fix_from_imports(red)\n+    return red\n+\n+\n+def fix_from_imports(red):\n+    \"\"\"\n+    Converts \"from\" style imports to not use \"flask.ext\".\n+\n+    Handles:\n+    Case 1: from flask.ext.foo import bam --> from flask_foo import bam\n+    Case 2: from flask.ext import foo --> import flask_foo as foo\n+    \"\"\"\n+    from_imports = red.find_all(\"FromImport\")\n+    for x, node in enumerate(from_imports):\n+        values = node.value\n+        if (values[0].value == 'flask') and (values[1].value == 'ext'):\n+            # Case 1\n+            if len(node.value) == 3:\n+                package = values[2].value\n+                modules = node.modules()\n+                module_string = _get_modules(modules)\n+                if len(modules) > 1:\n+                    node.replace(\"from flask_%s import %s\"\n+                                 % (package, module_string))\n+                else:\n+                    name = node.names()[0]\n+                    node.replace(\"from flask_%s import %s as %s\"\n+                                 % (package, module_string, name))\n+            # Case 2\n+            else:\n+                module = node.modules()[0]\n+                node.replace(\"import flask_%s as %s\"\n+                             % (module, module))\n+    return red\n+\n+\n+def fix_standard_imports(red):\n+    \"\"\"\n+    Handles import modification in the form:\n+    import flask.ext.foo\" --> import flask_foo\n+    \"\"\"\n+    imports = red.find_all(\"ImportNode\")\n+    for x, node in enumerate(imports):\n+        try:\n+            if (node.value[0].value[0].value == 'flask' and\n+               node.value[0].value[1].value == 'ext'):\n+                package = node.value[0].value[2].value\n+                name = node.names()[0].split('.')[-1]\n+                if name == package:\n+                    node.replace(\"import flask_%s\" % (package))\n+                else:\n+                    node.replace(\"import flask_%s as %s\" % (package, name))\n+        except IndexError:\n+            pass\n+\n+    return red\n+\n+\n+def _get_modules(module):\n+    \"\"\"\n+    Takes a list of modules and converts into a string.\n+\n+    The module list can include parens, this function checks each element in\n+    the list, if there is a paren then it does not add a comma before the next\n+    element. Otherwise a comma and space is added. This is to preserve module\n+    imports which are multi-line and/or occur within parens. While also not\n+    affecting imports which are not enclosed.\n+    \"\"\"\n+    modules_string = [cur + ', ' if cur.isalnum() and next.isalnum()\n+                      else cur\n+                      for (cur, next) in zip(module, module[1:]+[''])]\n+\n+    return ''.join(modules_string)\n+\n+\n+def fix_function_calls(red):\n+    \"\"\"\n+    Modifies function calls in the source to reflect import changes.\n+\n+    Searches the AST for AtomtrailerNodes and replaces them.\n+    \"\"\"\n+    atoms = red.find_all(\"Atomtrailers\")\n+    for x, node in enumerate(atoms):\n+        try:\n+            if (node.value[0].value == 'flask' and\n+               node.value[1].value == 'ext'):\n+                params = _form_function_call(node)\n+                node.replace(\"flask_%s%s\" % (node.value[2], params))\n+        except IndexError:\n+            pass\n+\n+    return red\n+\n+\n+def _form_function_call(node):\n+    \"\"\"\n+    Reconstructs function call strings when making attribute access calls.\n+    \"\"\"\n+    node_vals = node.value\n+    output = \".\"\n+    for x, param in enumerate(node_vals[3::]):\n+        if param.dumps()[0] == \"(\":\n+            output = output[0:-1] + param.dumps()\n+            return output\n+        else:\n+            output += param.dumps() + \".\"\n+\n+\n+def check_user_input():\n+    \"\"\"Exits and gives error message if no argument is passed in the shell.\"\"\"\n+    if len(sys.argv) < 2:\n+        sys.exit(\"No filename was included, please try again.\")\n+\n+\n+def fix_tester(ast):\n+    \"\"\"Wrapper which allows for testing when not running from shell.\"\"\"\n+    ast = fix_imports(ast)\n+    ast = fix_function_calls(ast)\n+    return ast.dumps()\n+\n+\n+def fix():\n+    \"\"\"Wrapper for user argument checking and import fixing.\"\"\"\n+    check_user_input()\n+    input_file = sys.argv[1]\n+    ast = read_source(input_file)\n+    ast = fix_imports(ast)\n+    ast = fix_function_calls(ast)\n+    write_source(ast, input_file)\n+\n+\n+if __name__ == \"__main__\":\n+    fix()\ndiff --git a/scripts/test_import_migration.py b/scripts/test_import_migration.py\nnew file mode 100644\nindex 0000000000..0220e70a03\n--- /dev/null\n+++ b/scripts/test_import_migration.py\n@@ -0,0 +1,71 @@\n+# Tester for the flaskext_migrate.py module located in flask/scripts/\n+#\n+# Author: Keyan Pishdadian\n+import pytest\n+from redbaron import RedBaron\n+import flaskext_migrate as migrate\n+\n+\n+def test_simple_from_import():\n+    red = RedBaron(\"from flask.ext import foo\")\n+    output = migrate.fix_tester(red)\n+    assert output == \"import flask_foo as foo\"\n+\n+\n+def test_from_to_from_import():\n+    red = RedBaron(\"from flask.ext.foo import bar\")\n+    output = migrate.fix_tester(red)\n+    assert output == \"from flask_foo import bar as bar\"\n+\n+\n+def test_multiple_import():\n+    red = RedBaron(\"from flask.ext.foo import bar, foobar, something\")\n+    output = migrate.fix_tester(red)\n+    assert output == \"from flask_foo import bar, foobar, something\"\n+\n+\n+def test_multiline_import():\n+    red = RedBaron(\"from flask.ext.foo import \\\n+                    bar,\\\n+                    foobar,\\\n+                    something\")\n+    output = migrate.fix_tester(red)\n+    assert output == \"from flask_foo import bar, foobar, something\"\n+\n+\n+def test_module_import():\n+    red = RedBaron(\"import flask.ext.foo\")\n+    output = migrate.fix_tester(red)\n+    assert output == \"import flask_foo\"\n+\n+\n+def test_named_module_import():\n+    red = RedBaron(\"import flask.ext.foo as foobar\")\n+    output = migrate.fix_tester(red)\n+    assert output == \"import flask_foo as foobar\"\n+\n+\n+def test__named_from_import():\n+    red = RedBaron(\"from flask.ext.foo import bar as baz\")\n+    output = migrate.fix_tester(red)\n+    assert output == \"from flask_foo import bar as baz\"\n+\n+\n+def test_parens_import():\n+    red = RedBaron(\"from flask.ext.foo import (bar, foo, foobar)\")\n+    output = migrate.fix_tester(red)\n+    assert output == \"from flask_foo import (bar, foo, foobar)\"\n+\n+\n+def test_function_call_migration():\n+    red = RedBaron(\"flask.ext.foo(var)\")\n+    output = migrate.fix_tester(red)\n+    assert output == \"flask_foo(var)\"\n+\n+\n+def test_nested_function_call_migration():\n+    red = RedBaron(\"import flask.ext.foo\\n\\n\"\n+                   \"flask.ext.foo.bar(var)\")\n+    output = migrate.fix_tester(red)\n+    assert output == (\"import flask_foo\\n\\n\"\n+                      \"flask_foo.bar(var)\")\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The script effectively supports single imports but has issues with edge cases that could cause breakage. It's wise to delegate parsing to a robust library like RedBaron, which has proven useful, although it doesn’t cover all scenarios. Adding tests was a good move, but ensure that RedBaron is included as a Travis dependency for the build to pass. Additionally, consider moving tests to the same directory as the script for easier integration. Address the remaining edge cases and clarify how to replace function calls without excessive refactoring. Overall, solid attention to detail!"
      }
    ],
    "token_estimation": 2075.0
  },
  {
    "index": 41,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/keras/engine/training.py b/keras/engine/training.py\nindex eca655d5d4fe..a9c4878ed35b 100644\n--- a/keras/engine/training.py\n+++ b/keras/engine/training.py\n@@ -579,101 +580,6 @@ def _standardize_weights(y, sample_weight=None, class_weight=None,\n             return np.ones((y.shape[0], y.shape[1]), dtype=K.floatx())\n \n \n-class GeneratorEnqueuer(object):\n-    \"\"\"Builds a queue out of a data generator.\n-\n-    Used in `fit_generator`, `evaluate_generator`, `predict_generator`.\n-\n-    # Arguments\n-        generator: a generator function which endlessly yields data\n-        pickle_safe: use multiprocessing if True, otherwise threading\n-    \"\"\"\n-\n-    def __init__(self, generator, pickle_safe=False):\n-        self._generator = generator\n-        self._pickle_safe = pickle_safe\n-        self._threads = []\n-        self._stop_event = None\n-        self.queue = None\n-\n-    def start(self, workers=1, max_q_size=10, wait_time=0.05):\n-        \"\"\"Kicks off threads which add data from the generator into the queue.\n-\n-        # Arguments\n-            workers: number of worker threads\n-            max_q_size: queue size (when full, threads could block on put())\n-            wait_time: time to sleep in-between calls to put()\n-        \"\"\"\n-\n-        def data_generator_task():\n-            while not self._stop_event.is_set():\n-                try:\n-                    if self._pickle_safe or self.queue.qsize() < max_q_size:\n-                        generator_output = next(self._generator)\n-                        self.queue.put(generator_output)\n-                    else:\n-                        time.sleep(wait_time)\n-                except Exception:\n-                    self._stop_event.set()\n-                    raise\n-\n-        try:\n-            if self._pickle_safe:\n-                self.queue = multiprocessing.Queue(maxsize=max_q_size)\n-                self._stop_event = multiprocessing.Event()\n-                if hasattr(data_generator_task, 'lock'):\n-                    # We should replace the threading lock of the iterator\n-                    # with a process-safe lock.\n-                    data_generator_task.lock = multiprocessing.Lock()\n-            else:\n-                self.queue = queue.Queue()\n-                self._stop_event = threading.Event()\n-\n-            for _ in range(workers):\n-                if self._pickle_safe:\n-                    # Reset random seed else all children processes\n-                    # share the same seed\n-                    np.random.seed()\n-                    thread = multiprocessing.Process(target=data_generator_task)\n-                    thread.daemon = True\n-                else:\n-                    thread = threading.Thread(target=data_generator_task)\n-                self._threads.append(thread)\n-                thread.start()\n-        except:\n-            self.stop()\n-            raise\n-\n-    def is_running(self):\n-        return self._stop_event is not None and not self._stop_event.is_set()\n-\n-    def stop(self, timeout=None):\n-        \"\"\"Stop running threads and wait for them to exit, if necessary.\n-\n-        Should be called by the same thread which called start().\n-\n-        # Arguments\n-            timeout: maximum time to wait on thread.join()\n-        \"\"\"\n-        if self.is_running():\n-            self._stop_event.set()\n-\n-        for thread in self._threads:\n-            if thread.is_alive():\n-                if self._pickle_safe:\n-                    thread.terminate()\n-                else:\n-                    thread.join(timeout)\n-\n-        if self._pickle_safe:\n-            if self.queue is not None:\n-                self.queue.close()\n-\n-        self._threads = []\n-        self._stop_event = None\n-        self.queue = None\n-\n-\n class Model(Container):\n     \"\"\"The `Model` class adds training & evaluation routines to a `Container`.\n     \"\"\"\n\ndiff --git a/keras/utils/data_utils.py b/keras/utils/data_utils.py\nindex 0928f47b1029..d3caddc10d48 100644\n--- a/keras/utils/data_utils.py\n+++ b/keras/utils/data_utils.py\n@@ -282,3 +295,323 @@ def validate_file(fpath, file_hash, algorithm='auto', chunk_size=65535):\n         return True\n     else:\n         return False\n+\n+\n+class Sequence(object):\n+    \"\"\"Base object for fitting to a sequence of data, such as a dataset.\n+    Every `Sequence` must implements the `__getitem__` and the `__len__` methods.\n+\n+    # Examples\n+\n+    ```python\n+    from skimage.io import imread\n+    from skimage.transform import resize\n+    import numpy as np\n+\n+    # Here, `x_set` is list of path to the images\n+    # and `y_set` are the associated classes.\n+\n+    class CIFAR10Sequence(Sequence):\n+        def __init__(self, x_set, y_set, batch_size):\n+            self.X,self.y = x_set,y_set\n+            self.batch_size = batch_size\n+\n+        def __len__(self):\n+            return len(self.X) // self.batch_size\n+\n+        def __getitem__(self,idx):\n+            batch_x = self.X[idx*self.batch_size:(idx+1)*self.batch_size]\n+            batch_y = self.y[idx*self.batch_size:(idx+1)*self.batch_size]\n+\n+            return np.array([\n+                resize(imread(file_name), (200,200))\n+                   for file_name in batch_x]), np.array(batch_y)\n+    ```\n+    \"\"\"\n+\n+    @abstractmethod\n+    def __getitem__(self, index):\n+        \"\"\"Gets batch at position `index`.\n+\n+        # Arguments\n+            index: position of the batch in the Sequence.\n+\n+        # Returns\n+            A batch\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def __len__(self):\n+        \"\"\"Number of batch in the Sequence.\n+\n+        # Returns\n+            The number of batches in the Sequence.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+\n+def get_index(ds, i):\n+    \"\"\"Quick fix for Python2, otherwise, it cannot be pickled.\n+\n+    # Arguments\n+        ds: a Sequence object\n+        i: index\n+\n+    # Returns\n+        The value at index `i`.\n+    \"\"\"\n+    return ds[i]\n+\n+\n+class SequenceEnqueuer(object):\n+    \"\"\"Base class to enqueue inputs.\n+    The task of an Enqueuer is to use parallelism to speed up the preprocessing.\n+    This is done with processes or threads.\n+\n+    # Examples\n+\n+    ```python\n+    enqueuer = SequenceEnqueuer(...)\n+    enqueuer.start()\n+    datas = enqueuer.get()\n+    for data in datas:\n+        # Use the inputs; training, evaluating, predicting.\n+        # ... stop sometime.\n+    enqueuer.close()\n+    ```\n+\n+    The `enqueuer.get()` should be an infinite stream of datas.\n+\n+    \"\"\"\n+\n+    @abstractmethod\n+    def is_running(self):\n+        raise NotImplemented\n+\n+    @abstractmethod\n+    def start(self, workers=1, max_queue_size=10):\n+        \"\"\"Starts the handler's workers.\n+\n+        # Arguments\n+            workers: number of worker threads\n+            max_queue_size: queue size (when full, threads could block on `put()`)\n+        \"\"\"\n+        raise NotImplemented\n+\n+    @abstractmethod\n+    def stop(self, timeout=None):\n+        \"\"\"Stop running threads and wait for them to exit, if necessary.\n+\n+        Should be called by the same thread which called start().\n+\n+        # Arguments\n+            timeout: maximum time to wait on thread.join()\n+        \"\"\"\n+        raise NotImplemented\n+\n+    @abstractmethod\n+    def get(self):\n+        \"\"\"Creates a generator to extract data from the queue. Skip the data if it's None.\n+\n+        # Returns\n+            Generator yielding tuples (inputs, targets)\n+                or (inputs, targets, sample_weights)\n+        \"\"\"\n+        raise NotImplemented\n+\n+\n+class OrderedEnqueuer(SequenceEnqueuer):\n+    \"\"\"Builds a Enqueuer from a Sequence.\n+\n+    Used in `fit_generator`, `evaluate_generator`, `predict_generator`.\n+\n+    # Arguments\n+        sequence: A `keras.utils.data_utils.Sequence` object.\n+        use_multiprocessing: use multiprocessing if True, otherwise threading\n+        scheduling: Sequential querying of datas if 'sequential', random otherwise.\n+    \"\"\"\n+\n+    def __init__(self, sequence, use_multiprocessing=False, scheduling='sequential'):\n+        self.sequence = sequence\n+        self.use_multiprocessing = use_multiprocessing\n+        self.scheduling = scheduling\n+        self.workers = 0\n+        self.executor = None\n+        self.queue = None\n+        self.run_thread = None\n+        self.stop_signal = None\n+\n+    def is_running(self):\n+        return self.stop_signal is not None and not self.stop_signal.is_set()\n+\n+    def start(self, workers=1, max_queue_size=10):\n+        \"\"\"Start the handler's workers.\n+\n+        # Arguments\n+            workers: number of worker threads\n+            max_queue_size: queue size (when full, workers could block on put())\n+        \"\"\"\n+        if self.use_multiprocessing:\n+            self.executor = multiprocessing.Pool(workers)\n+        else:\n+            self.executor = ThreadPool(workers)\n+        self.queue = queue.Queue(max_queue_size)\n+        self.stop_signal = threading.Event()\n+        self.run_thread = threading.Thread(target=self._run)\n+        self.run_thread.daemon = True\n+        self.run_thread.start()\n+\n+    def _run(self):\n+        \"\"\"Function to submit request to the executor and queue the `Future` objects.\"\"\"\n+        sequence = list(range(len(self.sequence)))\n+        while True:\n+            if self.scheduling is not 'sequential':\n+                random.shuffle(sequence)\n+            for i in sequence:\n+                if self.stop_signal.is_set():\n+                    return\n+                self.queue.put(\n+                    self.executor.apply_async(get_index, (self.sequence, i)), block=True)\n+\n+    def get(self):\n+        \"\"\"Creates a generator to extract data from the queue. Skip the data if it's None.\n+\n+        # Returns\n+            Generator yielding tuples (inputs, targets)\n+                or (inputs, targets, sample_weights)\n+        \"\"\"\n+        try:\n+            while self.is_running():\n+                inputs = self.queue.get(block=True).get()\n+                if inputs is not None:\n+                    yield inputs\n+        except Exception as e:\n+            self.stop()\n+            raise StopIteration(e)\n+\n+    def stop(self, timeout=None):\n+        \"\"\"Stops running threads and wait for them to exit, if necessary.\n+\n+        Should be called by the same thread which called start().\n+\n+        # Arguments\n+            timeout: maximum time to wait on thread.join()\n+        \"\"\"\n+        self.stop_signal.set()\n+        with self.queue.mutex:\n+            self.queue.queue.clear()\n+            self.queue.unfinished_tasks = 0\n+            self.queue.not_full.notify()\n+        self.executor.close()\n+        self.run_thread.join(timeout)\n+\n+\n+class GeneratorEnqueuer(SequenceEnqueuer):\n+    \"\"\"Builds a queue out of a data generator.\n+\n+    Used in `fit_generator`, `evaluate_generator`, `predict_generator`.\n+\n+    # Arguments\n+        generator: a generator function which endlessly yields data\n+        use_multiprocessing: use multiprocessing if True, otherwise threading\n+        wait_time: time to sleep in-between calls to `put()`\n+        random_seed: Initial seed for workers, will be incremented by one for each workers.\n+    \"\"\"\n+\n+    def __init__(self, generator, use_multiprocessing=False, wait_time=0.05, random_seed=None):\n+        self.wait_time = wait_time\n+        self._generator = generator\n+        self._use_multiprocessing = use_multiprocessing\n+        self._threads = []\n+        self._stop_event = None\n+        self.queue = None\n+        self.random_seed = random_seed\n+\n+    def start(self, workers=1, max_queue_size=10):\n+        \"\"\"Kicks off threads which add data from the generator into the queue.\n+\n+        # Arguments\n+            workers: number of worker threads\n+            max_queue_size: queue size (when full, threads could block on put())\n+        \"\"\"\n+\n+        def data_generator_task():\n+            while not self._stop_event.is_set():\n+                try:\n+                    if self._use_multiprocessing or self.queue.qsize() < max_queue_size:\n+                        generator_output = next(self._generator)\n+                        self.queue.put(generator_output)\n+                    else:\n+                        time.sleep(self.wait_time)\n+                except Exception:\n+                    self._stop_event.set()\n+                    raise\n+\n+        try:\n+            if self._use_multiprocessing:\n+                self.queue = multiprocessing.Queue(maxsize=max_queue_size)\n+                self._stop_event = multiprocessing.Event()\n+            else:\n+                self.queue = queue.Queue()\n+                self._stop_event = threading.Event()\n+\n+            for _ in range(workers):\n+                if self._use_multiprocessing:\n+                    # Reset random seed else all children processes\n+                    # share the same seed\n+                    np.random.seed(self.random_seed)\n+                    thread = multiprocessing.Process(target=data_generator_task)\n+                    thread.daemon = True\n+                    if self.random_seed is not None:\n+                        self.random_seed += 1\n+                else:\n+                    thread = threading.Thread(target=data_generator_task)\n+                self._threads.append(thread)\n+                thread.start()\n+        except:\n+            self.stop()\n+            raise\n+\n+    def is_running(self):\n+        return self._stop_event is not None and not self._stop_event.is_set()\n+\n+    def stop(self, timeout=None):\n+        \"\"\"Stops running threads and wait for them to exit, if necessary.\n+\n+        Should be called by the same thread which called start().\n+\n+        # Arguments\n+            timeout: maximum time to wait on thread.join()\n+        \"\"\"\n+        if self.is_running():\n+            self._stop_event.set()\n+\n+        for thread in self._threads:\n+            if thread.is_alive():\n+                if self._use_multiprocessing:\n+                    thread.terminate()\n+                else:\n+                    thread.join(timeout)\n+\n+        if self._use_multiprocessing:\n+            if self.queue is not None:\n+                self.queue.close()\n+\n+        self._threads = []\n+        self._stop_event = None\n+        self.queue = None\n+\n+    def get(self):\n+        \"\"\"Creates a generator to extract data from the queue. Skip the data if it's None.\n+\n+        # Returns\n+            A generator\n+        \"\"\"\n+        while self.is_running():\n+            if not self.queue.empty():\n+                inputs = self.queue.get()\n+                if inputs is not None:\n+                    yield inputs\n+            else:\n+                time.sleep(self.wait_time)\ndiff --git a/tests/keras/utils/data_utils_test.py b/tests/keras/utils/data_utils_test.py\nindex f3088c22e1b1..716d7e8af097 100644\n--- a/tests/keras/utils/data_utils_test.py\n+++ b/tests/keras/utils/data_utils_test.py\n@@ -64,5 +77,154 @@ def test_data_utils(in_tmpdir):\n     os.remove('test.txt')\n     os.remove('test.zip')\n \n+\n+\"\"\"Enqueuers Tests\"\"\"\n+\n+\n+class threadsafe_iter:\n+    \"\"\"Takes an iterator/generator and makes it thread-safe by\n+    serializing call to the `next` method of given iterator/generator.\n+    \"\"\"\n+\n+    def __init__(self, it):\n+        self.it = it\n+        self.lock = threading.Lock()\n+\n+    def __iter__(self):\n+        return self\n+\n+    def __next__(self):\n+        return self.next()\n+\n+    def next(self):\n+        with self.lock:\n+            return next(self.it)\n+\n+\n+def threadsafe_generator(f):\n+    \"\"\"A decorator that takes a generator function and makes it thread-safe.\n+    \"\"\"\n+\n+    def g(*a, **kw):\n+        return threadsafe_iter(f(*a, **kw))\n+\n+    return g\n+\n+\n+class TestSequence(Sequence):\n+    def __init__(self, shape):\n+        self.shape = shape\n+\n+    def __getitem__(self, item):\n+        return np.ones(self.shape, dtype=np.uint8) * item\n+\n+    def __len__(self):\n+        return 100\n+\n+\n+class FaultSequence(Sequence):\n+    def __getitem__(self, item):\n+        raise IndexError(item, 'is not present')\n+\n+    def __len__(self):\n+        return 100\n+\n+\n+@threadsafe_generator\n+def create_generator_from_sequence_threads(ds):\n+    for i in cycle(range(len(ds))):\n+        yield ds[i]\n+\n+\n+def create_generator_from_sequence_pcs(ds):\n+    for i in cycle(range(len(ds))):\n+        yield ds[i]\n+\n+\n+def test_generator_enqueuer_threads():\n+    enqueuer = GeneratorEnqueuer(create_generator_from_sequence_threads(\n+        TestSequence([3, 200, 200, 3])), use_multiprocessing=False)\n+    enqueuer.start(3, 10)\n+    gen_output = enqueuer.get()\n+    acc = []\n+    for i in range(100):\n+        acc.append(int(next(gen_output)[0, 0, 0, 0]))\n+\n+    \"\"\"\n+     Not comparing the order since it is not guarantee.\n+     It may get ordered, but not a lot, one thread can take the GIL before he was supposed to.\n+    \"\"\"\n+    assert len(set(acc) - set(range(100))) == 0, \"Output is not the same\"\n+    enqueuer.stop()\n+\n+\n+def test_generator_enqueuer_processes():\n+    enqueuer = GeneratorEnqueuer(create_generator_from_sequence_pcs(\n+        TestSequence([3, 200, 200, 3])), use_multiprocessing=True)\n+    enqueuer.start(3, 10)\n+    gen_output = enqueuer.get()\n+    acc = []\n+    for i in range(100):\n+        acc.append(int(next(gen_output)[0, 0, 0, 0]))\n+    assert acc != list(range(100)), \"Order was keep in GeneratorEnqueuer with processes\"\n+    enqueuer.stop()\n+\n+\n+def test_generator_enqueuer_fail_threads():\n+    enqueuer = GeneratorEnqueuer(create_generator_from_sequence_threads(\n+        FaultSequence()), use_multiprocessing=False)\n+    enqueuer.start(3, 10)\n+    gen_output = enqueuer.get()\n+    with pytest.raises(StopIteration):\n+        next(gen_output)\n+\n+\n+def test_generator_enqueuer_fail_processes():\n+    enqueuer = GeneratorEnqueuer(create_generator_from_sequence_pcs(\n+        FaultSequence()), use_multiprocessing=True)\n+    enqueuer.start(3, 10)\n+    gen_output = enqueuer.get()\n+    with pytest.raises(StopIteration):\n+        next(gen_output)\n+\n+\n+def test_ordered_enqueuer_threads():\n+    enqueuer = OrderedEnqueuer(TestSequence([3, 200, 200, 3]), use_multiprocessing=False)\n+    enqueuer.start(3, 10)\n+    gen_output = enqueuer.get()\n+    acc = []\n+    for i in range(100):\n+        acc.append(next(gen_output)[0, 0, 0, 0])\n+    assert acc == list(range(100)), \"Order was not keep in GeneratorEnqueuer with threads\"\n+    enqueuer.stop()\n+\n+\n+def test_ordered_enqueuer_processes():\n+    enqueuer = OrderedEnqueuer(TestSequence([3, 200, 200, 3]), use_multiprocessing=True)\n+    enqueuer.start(3, 10)\n+    gen_output = enqueuer.get()\n+    acc = []\n+    for i in range(100):\n+        acc.append(next(gen_output)[0, 0, 0, 0])\n+    assert acc == list(range(100)), \"Order was not keep in GeneratorEnqueuer with processes\"\n+    enqueuer.stop()\n+\n+\n+def test_ordered_enqueuer_fail_threads():\n+    enqueuer = OrderedEnqueuer(FaultSequence(), use_multiprocessing=False)\n+    enqueuer.start(3, 10)\n+    gen_output = enqueuer.get()\n+    with pytest.raises(StopIteration):\n+        next(gen_output)\n+\n+\n+def test_ordered_enqueuer_fail_processes():\n+    enqueuer = OrderedEnqueuer(FaultSequence(), use_multiprocessing=True)\n+    enqueuer.start(3, 10)\n+    gen_output = enqueuer.get()\n+    with pytest.raises(StopIteration):\n+        next(gen_output)\n+\n+\n if __name__ == '__main__':\n     pytest.main([__file__])\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR suggests preserving the order in `predict_generator` with multi-processing, which is crucial for certain use cases. However, we should improve the generator-writing experience for users instead of just requiring them to implement their own. This can be achieved through a more structured Dataset API, but must remain backward-compatible. Adding `futures` as an optional dependency would help, but let's avoid unnecessary complexity in the API. The current design should focus on simplicity while addressing pickling issues effectively. Would appreciate thoughts from @PavlosMelissinos on dataset complexities."
      }
    ],
    "token_estimation": 4988.75
  },
  {
    "index": 42,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/examples/mnist_tfrecord_recordinput.py b/examples/mnist_tfrecord_recordinput.py\nnew file mode 100644\nindex 000000000000..0972763c4ac7\n--- /dev/null\n+++ b/examples/mnist_tfrecord_recordinput.py\n@@ -0,0 +1,227 @@\n+'''Optimized MNIST dataset with TFRecords, the standard TensorFlow data format.\n+\n+TFRecord is a data format supported throughout TensorFlow.\n+For a straightforward usage example see mnist_tfrecord.py.\n+This example demonstrates how to write and read TFRecord data using\n+Input Tensors in a way that is better optimized for high performance\n+on large datasets with Keras.\n+\n+Gets to 99.25% test accuracy after 12 epochs\n+(there is still some margin for parameter tuning).\n+'''\n+import os\n+import copy\n+import time\n+\n+import numpy as np\n+\n+import tensorflow as tf\n+from tensorflow.python.ops import data_flow_ops\n+from keras import backend as K\n+from keras.models import Model\n+from keras import layers\n+from keras.utils.generic_utils import Progbar\n+\n+from keras.datasets import mnist\n+\n+if K.backend() != 'tensorflow':\n+    raise RuntimeError('This example can only run with the '\n+                       'TensorFlow backend for the time being, '\n+                       'because it requires TFRecords, which '\n+                       'are not supported on other platforms.')\n+\n+\n+def images_to_tfrecord(images, labels, filename):\n+    \"\"\"Write images and their labels to a TFRecord file.\n+\n+    # Arguments\n+        images: A numpy array or list of image data with\n+            shape (images, rows, cols, depth).\n+        labels: A numpy array of labels, with one for each image.\n+        filename: Path and name for the output dataset TFRecord file.\n+            An example is `'path/to/mnist_train.tfrecord'`\n+    \"\"\"\n+    def _int64_feature(value):\n+        return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))\n+\n+    def _bytes_feature(value):\n+        return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))\n+\n+    \"\"\" Save data into TFRecord \"\"\"\n+    if not os.path.isfile(filename):\n+        num_examples = images.shape[0]\n+\n+        rows = images.shape[1]\n+        cols = images.shape[2]\n+        depth = images.shape[3]\n+\n+        print('Writing', filename)\n+        writer = tf.python_io.TFRecordWriter(filename)\n+        for index in range(num_examples):\n+            image_raw = images[index].tostring()\n+            example = tf.train.Example(features=tf.train.Features(feature={\n+                'height': _int64_feature(rows),\n+                'width': _int64_feature(cols),\n+                'depth': _int64_feature(depth),\n+                'label': _int64_feature(int(labels[index])),\n+                'image_raw': _bytes_feature(image_raw)}))\n+            writer.write(example.SerializeToString())\n+        writer.close()\n+    else:\n+        print('tfrecord %s already exists' % filename)\n+\n+\n+def read_and_decode_recordinput(tf_glob, one_hot=True,\n+                                classes=None,\n+                                batch_shape=None, parallelism=1):\n+    \"\"\"Get a TF Tensor that supplies shuffled batches of images.\n+\n+    # Arguments\n+        tf_glob: File path for selecting one or more tfrecord files.\n+            Examples are `'path/to/data.tfrecord'` and `'path/to/*.tfrecord'`.\n+        one_hot: Use one hot encoding for labels, also known as categorical.\n+        batch_shape: Specify the desired image batch shape, where the first\n+            entry is the batch size. MNIST might be (128, 28, 28, 1).\n+        parallelism: The number of threads to use for loading new data.\n+            A reasonable value is the number of logical cores on your processor.\n+    \"\"\"\n+    if batch_shape is None:\n+        batch_shape = [1000, 28, 28, 1]\n+    print 'Creating graph for loading %s TFRecords...' % tf_glob\n+    with tf.variable_scope(\"TFRecords\"):\n+        record_input = data_flow_ops.RecordInput(\n+            tf_glob, batch_size=batch_shape[0], parallelism=parallelism)\n+        records_op = record_input.get_yield_op()\n+        records_op = tf.split(records_op, batch_shape[0], 0)\n+        records_op = [tf.reshape(record, []) for record in records_op]\n+        progbar = Progbar(len(records_op))\n+\n+        images = []\n+        labels = []\n+        for i, serialized_example in enumerate(records_op):\n+            progbar.update(i)\n+            with tf.variable_scope(\"parse_images\", reuse=True):\n+                features = tf.parse_single_example(\n+                    serialized_example,\n+                    features={\n+                        'label': tf.FixedLenFeature([], tf.int64),\n+                        'image_raw': tf.FixedLenFeature([], tf.string),\n+                    })\n+                img = tf.decode_raw(features['image_raw'], tf.uint8)\n+                img.set_shape(batch_shape[1] * batch_shape[2])\n+                img = tf.reshape(img, [1] + batch_shape[1:])\n+\n+                img = tf.cast(img, tf.float32) * (1. / 255) - 0.5\n+\n+                label = tf.cast(features['label'], tf.int32)\n+                if one_hot and classes:\n+                    label = tf.one_hot(label, classes)\n+\n+                images.append(img)\n+                labels.append(label)\n+\n+        images = tf.parallel_stack(images, 0)\n+        labels = tf.parallel_stack(labels, 0)\n+        images = tf.cast(images, tf.float32)\n+        images = tf.reshape(images, shape=batch_shape)\n+\n+        return images, labels\n+\n+\n+def save_mnist_as_tfrecord():\n+    \"\"\"Save one tfrecord file for each of the train and test mnist datasets.\n+    \"\"\"\n+    (x_train, y_train), (x_test, y_test) = mnist.load_data()\n+    x_train = x_train[..., np.newaxis]\n+    x_test = x_test[..., np.newaxis]\n+    images_to_tfrecord(images=x_train, labels=y_train, filename='train.mnist.tfrecord')\n+    images_to_tfrecord(images=x_test, labels=y_test, filename='test.mnist.tfrecord')\n+\n+\n+def cnn_layers(x_train_input):\n+    \"\"\"Create the CNN layers for use with either numpy inputs or tensor inputs.\n+    \"\"\"\n+    x = layers.Conv2D(32, (3, 3), activation='relu', padding='valid')(x_train_input)\n+    x = layers.Conv2D(64, (3, 3), activation='relu')(x)\n+    x = layers.MaxPooling2D(pool_size=(2, 2))(x)\n+    x = layers.Dropout(0.25)(x)\n+    x = layers.Flatten()(x)\n+    x = layers.Dense(128, activation='relu')(x)\n+    x = layers.Dropout(0.5)(x)\n+    x_train_out = layers.Dense(classes,\n+                               activation='softmax',\n+                               name='x_train_out')(x)\n+    return x_train_out\n+\n+\n+sess = K.get_session()\n+\n+save_mnist_as_tfrecord()\n+\n+batch_size = 100\n+batch_shape = [batch_size, 28, 28, 1]\n+epochs = 12\n+steps_per_epoch = 1000\n+classes = 10\n+parallelism = 10\n+\n+x_train_batch, y_train_batch = read_and_decode_recordinput(\n+    'train.mnist.tfrecord',\n+    one_hot=True,\n+    classes=classes,\n+    batch_shape=batch_shape,\n+    parallelism=parallelism)\n+\n+x_batch_shape = x_train_batch.get_shape().as_list()\n+y_batch_shape = y_train_batch.get_shape().as_list()\n+\n+# The input tensors are provided directly into the Model network.\n+# The network is fixed once it is initialized, so it must be\n+# reconstructed every time a new input data source is needed.\n+# This is substantially different from typical\n+# Keras numpy array inputs, and is more like TensorFlow.\n+x_train_in = layers.Input(tensor=x_train_batch, batch_shape=x_batch_shape)\n+x_train_out = cnn_layers(x_train_in)\n+y_train_in = layers.Input(tensor=y_train_batch, batch_shape=y_batch_shape, name='y_labels')\n+train_model = Model(inputs=[x_train_in], outputs=[x_train_out])\n+train_model.compile(optimizer='rmsprop',\n+                    loss='categorical_crossentropy',\n+                    metrics=['accuracy'])\n+\n+# The input data was created with x_train_input,\n+# so only the label data needs to be provided.\n+train_model.fit(y=y_train_in,\n+                batch_size=None,\n+                epochs=epochs,\n+                steps_per_epoch=steps_per_epoch)\n+train_model.save_weights('saved_wt.h5')\n+\n+K.clear_session()\n+\n+# Second Session, test data\n+x_test_batch, y_test_batch = read_and_decode_recordinput(\n+    'test.mnist.tfrecord',\n+    one_hot=True,\n+    classes=classes,\n+    batch_shape=batch_shape,\n+    parallelism=parallelism)\n+\n+x_batch_shape = x_test_batch.get_shape().as_list()\n+y_batch_shape = y_test_batch.get_shape().as_list()\n+\n+# Create a completely new network for new input data.\n+x_test_in = layers.Input(tensor=x_test_batch, batch_shape=x_batch_shape)\n+x_test_out = cnn_layers(x_test_in)\n+y_test_in = layers.Input(tensor=y_test_batch, batch_shape=y_batch_shape, name='y_labels')\n+test_model = Model(inputs=[x_test_in], outputs=[x_test_out])\n+test_model.compile(optimizer='rmsprop',\n+                   loss='categorical_crossentropy',\n+                   metrics=['accuracy'])\n+test_model.load_weights('saved_wt.h5')\n+test_model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])\n+\n+# Take steps for each element of validation data.\n+validation_samples = 10000\n+evaluate_steps = validation_samples / batch_size\n+loss, acc = test_model.evaluate(y=y_test_in, steps=evaluate_steps)\n+print('\\nTest accuracy: {0}'.format(np.mean(acc)))\ndiff --git a/keras/engine/training.py b/keras/engine/training.py\nindex 7b487d34f511..0a31574ba659 100644\n--- a/keras/engine/training.py\n+++ b/keras/engine/training.py\n@@ -923,56 +916,213 @@ def append_metric(layer_num, metric_name, metric_tensor):\n         trainable_weights = self.trainable_weights\n         self._collected_trainable_weights = trainable_weights\n \n-    def _make_train_function(self):\n-        if not hasattr(self, 'train_function'):\n+    def _prepare_sample_weights(self, sample_weight_mode, skip_indices):\n+        \"\"\"Prepares and verifies sample weight member variables during compilation.\n+        \"\"\"\n+        # Prepare sample weights.\n+        if self._tensor_inputs:\n+            if not all(l is None for l in self.target_configuration):\n+                if sample_weight_mode is not None:\n+                    # tensor + sample weights not yet implemented\n+                    raise NotImplementedError\n+                if self.loss_weights is not None:\n+                    # tensor + loss weights not yet implemented\n+                    raise NotImplementedError\n+            self.sample_weight_mode = 'disabled'\n+            return [], self.sample_weight_mode\n+\n+        self.sample_weight_mode = sample_weight_mode\n+        sample_weights = []\n+        sample_weight_modes = []\n+        if isinstance(sample_weight_mode, dict):\n+            for name in sample_weight_mode:\n+                if name not in self.output_names:\n+                    raise ValueError('Unknown entry in '\n+                                     'sample_weight_mode dictionary: \"' +\n+                                     name + '\". '\n+                                     'Only expected the following keys: ' +\n+                                     str(self.output_names))\n+            for i, name in enumerate(self.output_names):\n+                if i in skip_indices:\n+                    weight = None\n+                    sample_weight_modes.append(None)\n+                else:\n+                    if name not in sample_weight_mode:\n+                        raise ValueError('Output \"' + name +\n+                                         '\" missing from sample_weight_modes '\n+                                         'dictionary')\n+                    if sample_weight_mode.get(name) == 'temporal':\n+                        weight = K.placeholder(ndim=2,\n+                                               name=name + '_sample_weights')\n+                        sample_weight_modes.append('temporal')\n+                    else:\n+                        weight = K.placeholder(ndim=1,\n+                                               name=name + '_sample_weights')\n+                        sample_weight_modes.append(None)\n+                sample_weights.append(weight)\n+        elif isinstance(sample_weight_mode, list):\n+            if len(sample_weight_mode) != len(self.outputs):\n+                raise ValueError('When passing a list as sample_weight_mode, '\n+                                 'it should have one entry per model outputs. '\n+                                 'The model has ' + str(len(self.outputs)) +\n+                                 ' outputs, but you passed '\n+                                 'sample_weight_mode=' +\n+                                 str(sample_weight_mode))\n+            for i in range(len(self.output_names)):\n+                if i in skip_indices:\n+                    weight = None\n+                    sample_weight_modes.append(None)\n+                else:\n+                    mode = sample_weight_mode[i]\n+                    name = self.output_names[i]\n+                    if mode == 'temporal':\n+                        weight = K.placeholder(ndim=2,\n+                                               name=name + '_sample_weights')\n+                        sample_weight_modes.append('temporal')\n+                    else:\n+                        weight = K.placeholder(ndim=1,\n+                                               name=name + '_sample_weights')\n+                        sample_weight_modes.append(None)\n+                sample_weights.append(weight)\n+        else:\n+            for i, name in enumerate(self.output_names):\n+                if i in skip_indices:\n+                    sample_weight_modes.append(None)\n+                    sample_weights.append(None)\n+                else:\n+                    if sample_weight_mode == 'temporal':\n+                        sample_weights.append(\n+                            K.placeholder(ndim=2,\n+                                          name=name + '_sample_weights'))\n+                        sample_weight_modes.append('temporal')\n+                    else:\n+                        sample_weights.append(\n+                            K.placeholder(ndim=1,\n+                                          name=name + '_sample_weights'))\n+                        sample_weight_modes.append(None)\n+        self.sample_weight_modes = sample_weight_modes\n+        self._feed_sample_weight_modes = []\n+        for i in range(len(self.outputs)):\n+            if i not in skip_indices:\n+                self._feed_sample_weight_modes.append(self.sample_weight_modes[i])\n+        return sample_weights, sample_weight_mode\n+\n+    def _make_ins(self, x=None, y=None, sample_weights=None, learning_phase_value=None):\n+        \"\"\"Create the list of inputs to the backend in a consistent manner.\n+\n+        # Arguments\n+            x: Numpy array of input data preprocessed to exclude tensors.\n+            y: Numpy array of target data preprocessed to exclude tensors.\n+            sample_weights: optional arrays of the same length as x, containing\n+               weights to apply to the model's loss for each sample.\n+        \"\"\"\n+        def add_if_valid(x):\n+            \"\"\"Ensures concatenation of inputs results in a list.\n+\n+            Inputs are assembled into a list for execution, but if all\n+            elements are `None`, adding them will result in a runtime\n+            error instead of a list of `None` values. Therefore,\n+            add_if_valid converts `None` values into [`None`],\n+            while leaving valid values alone.\n+            \"\"\"\n+            # In a worst case return an empty list\n+            return [None] if x is None else x\n+        ins = add_if_valid(x) + add_if_valid(y) + add_if_valid(sample_weights)\n+        if learning_phase_value and self.uses_learning_phase and not isinstance(K.learning_phase(), int):\n+            ins = ins + add_if_valid(learning_phase_value)\n+        return ins\n+\n+    def _make_function(self, function_name):\n+        \"\"\"Create a backend function based on the current model configuration.\n+\n+        Checks the state of all relevant member variables and inputs based on\n+        the backend function type given by the `function_name` parameter,\n+        and assemble the correct variables for this use. Includes additional\n+        verification steps to prevent user error, such as forgetting to call\n+        `compile()`.\n+\n+        # Arguments\n+            function_name: The name of the backend function type that is needed.\n+                Options are `'predict_function'`, `'train_function'`, and\n+                `'test_function'`.\n+        \"\"\"\n+        if function_name is 'predict_function':\n+            if not hasattr(self, 'predict_function'):\n+                self.predict_function = None\n+            if self.predict_function is None:\n+                if self.uses_learning_phase and not isinstance(K.learning_phase(), int):\n+                    inputs = self._feed_inputs + [K.learning_phase()]\n+                else:\n+                    inputs = self._feed_inputs\n+                outputs = self.outputs\n+        elif not hasattr(self, function_name):\n             raise RuntimeError('You must compile your model before using it.')\n-        if self.train_function is None:\n-            inputs = self._feed_inputs + self._feed_targets + self._feed_sample_weights\n+\n+        function = getattr(self, function_name)\n+        if function is not None:\n+            return function\n+        elif function_name is not 'predict_function':\n+            inputs = [] + self._feed_inputs\n+            if hasattr(self, '_feed_targets'):\n+                inputs = inputs + self._feed_targets\n+            if (hasattr(self, 'sample_weight_mode') and\n+                    self.sample_weight_mode is not 'disabled'):\n+                inputs = inputs + self._feed_sample_weights\n             if self.uses_learning_phase and not isinstance(K.learning_phase(), int):\n-                inputs += [K.learning_phase()]\n+                inputs = inputs + [K.learning_phase()]\n \n+            outputs = [self.total_loss] + self.metrics_tensors\n+\n+        if function_name is 'train_function':\n             training_updates = self.optimizer.get_updates(\n                 params=self._collected_trainable_weights,\n                 loss=self.total_loss)\n             updates = self.updates + training_updates\n-            # Gets loss and metrics. Updates weights at each call.\n-            self.train_function = K.function(inputs,\n-                                             [self.total_loss] + self.metrics_tensors,\n-                                             updates=updates,\n-                                             name='train_function',\n-                                             **self._function_kwargs)\n-\n-    def _make_test_function(self):\n-        if not hasattr(self, 'test_function'):\n-            raise RuntimeError('You must compile your model before using it.')\n-        if self.test_function is None:\n-            inputs = self._feed_inputs + self._feed_targets + self._feed_sample_weights\n-            if self.uses_learning_phase and not isinstance(K.learning_phase(), int):\n-                inputs += [K.learning_phase()]\n-            # Return loss and metrics, no gradient updates.\n-            # Does update the network states.\n-            self.test_function = K.function(inputs,\n-                                            [self.total_loss] + self.metrics_tensors,\n-                                            updates=self.state_updates,\n-                                            name='test_function',\n-                                            **self._function_kwargs)\n-\n-    def _make_predict_function(self):\n-        if not hasattr(self, 'predict_function'):\n-            self.predict_function = None\n-        if self.predict_function is None:\n-            if self.uses_learning_phase and not isinstance(K.learning_phase(), int):\n-                inputs = self._feed_inputs + [K.learning_phase()]\n-            else:\n-                inputs = self._feed_inputs\n-            # Gets network outputs. Does not update weights.\n-            # Does update the network states.\n-            kwargs = getattr(self, '_function_kwargs', {})\n-            self.predict_function = K.function(inputs,\n-                                               self.outputs,\n-                                               updates=self.state_updates,\n-                                               name='predict_function',\n-                                               **kwargs)\n+        else:\n+            updates = self.state_updates\n+\n+        kwargs = getattr(self, '_function_kwargs', {})\n+        # Gets loss and metrics. Updates weights at each call.\n+        return K.function(inputs,\n+                          outputs,\n+                          updates=updates,\n+                          name=function_name,\n+                          **kwargs)\n+\n+    def _check_for_recompile(self, y):\n+        \"\"\"Calls `_compile()` if new Input Tensors were provided by the user.\n+\n+        Also inserts Input Tensors into `self.target_configuration` and removing\n+        them from `y`, so that the tensors are not incorrectly executed as input\n+        feed values.\n+\n+        # Arguments\n+            y: List or array containing heterogeneous input tensors and numpy arrays.\n+\n+        # Returns\n+\n+        `y` with all entries that are input tensors replaced with `None`.\n+        For example, `[numpy_array, tensor, tensor]`\n+        becomes `[numpy_array, None, None]`.\n+        \"\"\"\n+        if K.is_keras_tensor(y, expect_other_types=True):\n+            self.target_configuration = [y]\n+            y = None\n+            self._compile(*self._saved_args, **self._saved_kwargs)\n+        elif y is not None:\n+            recompile = False\n+            self.target_configuration = []\n+            for i, y_i in enumerate(y):\n+                if K.is_keras_tensor(y_i, expect_other_types=True):\n+                    self.target_configuration.append(y_i)\n+                    y[i] = None\n+                    recompile = True\n+                else:\n+                    self.target_configuration.append(None)\n+\n+            if recompile:\n+                self._compile(*self._saved_args, **self._saved_kwargs)\n+        return y\n \n     def _check_num_samples(self, ins, batch_size=None, steps=None, steps_name='steps'):\n         \"\"\"Determine the number of samples provided for training and evaluation.\n\ndiff --git a/tests/keras/engine/test_training.py b/tests/keras/engine/test_training.py\nindex a17187f5a319..9f906cdaabbc 100644\n--- a/tests/keras/engine/test_training.py\n+++ b/tests/keras/engine/test_training.py\n@@ -35,6 +40,57 @@ def on_epoch_end(self):\n         pass\n \n \n+@keras_test\n+def test_standardize_input_data():\n+    a_np = np.random.random((4, 3))\n+    a_shape = a_np.shape\n+    a_name = 'input_a'\n+    p = K.placeholder(a_shape)\n+    a = Input(shape=a_shape, name='a_name')\n+    x = _standardize_input_data(\n+        [a_np], [a_name], [a_shape],\n+        check_batch_axis=False,\n+        exception_prefix='input',\n+        input_tensors=[p])\n+    x = _standardize_input_data(\n+        [None], [a_name], [a_shape],\n+        exception_prefix='input',\n+        input_tensors=[p])\n+\n+\n+def call_model_methods(model, x, y, batch_size=10,\n+                       epochs=1, steps_per_epoch=None):\n+\n+    # train_on_batch\n+    out = model.train_on_batch(x, y)\n+    out = model.train_on_batch(x, y)\n+\n+    # test_on_batch\n+    out = model.test_on_batch(x, y)\n+\n+    # predict_on_batch\n+    out = model.predict_on_batch(x)\n+\n+    # fit\n+    out = model.fit(x, y, epochs=1, batch_size=batch_size,\n+                    steps_per_epoch=steps_per_epoch)\n+    out = model.fit(x, y, epochs=1, batch_size=batch_size,\n+                    steps_per_epoch=steps_per_epoch)\n+\n+    # evaluate\n+    out = model.evaluate(x, y, batch_size=batch_size,\n+                         steps=steps_per_epoch)\n+    out = model.evaluate(x, y, batch_size=batch_size,\n+                         steps=steps_per_epoch)\n+\n+    # predict\n+    out = model.predict(x, batch_size=batch_size,\n+                        steps=steps_per_epoch)\n+    out = model.predict(x, batch_size=batch_size,\n+                        steps=steps_per_epoch)\n+    return out\n+\n+\n @keras_test\n def test_check_array_lengths():\n     _check_array_lengths(None, None, None)\n@@ -598,35 +618,159 @@ def test_model_with_input_feed_tensor():\n     loss = 'mse'\n     model.compile(optimizer, loss, metrics=['mean_squared_error'])\n \n-    # test train_on_batch\n-    out = model.train_on_batch(None,\n-                               output_a_np)\n-    out = model.train_on_batch(None,\n-                               output_a_np)\n-    out = model.test_on_batch(None,\n-                              output_a_np)\n-    out = model.predict_on_batch(None)\n+    # train_on_batch\n     out = model.train_on_batch([],\n                                output_a_np)\n     out = model.train_on_batch({},\n                                output_a_np)\n \n-    # test fit\n-    out = model.fit(None,\n-                    output_a_np, epochs=1, batch_size=10)\n-    out = model.fit(None,\n-                    output_a_np, epochs=1, batch_size=10)\n+    out = call_model_methods(model, None, output_a_np)\n \n-    # test evaluate\n-    out = model.evaluate(None,\n-                         output_a_np, batch_size=10)\n-    out = model.evaluate(None,\n-                         output_a_np, batch_size=10)\n \n-    # test predict\n-    out = model.predict(None, batch_size=10)\n-    out = model.predict(None, batch_size=10)\n-    assert out.shape == (10, 4)\n+@pytest.mark.skipif(K.backend() != 'tensorflow', reason='Requires TF backend')\n+@keras_test\n+def test_model_with_input_yield_op():\n+    \"\"\"We test building a model with a RecordInput as input.\n+    We should be able to call fit, evaluate, predict,\n+    by only passing them data for the placeholder inputs\n+    in the model.\n+    \"\"\"\n+    import tensorflow as tf\n+\n+    batch_size = 1\n+    input_rows = 20\n+    cols = 20\n+    depth = 1\n+    classes = 2\n+    sess = K.get_session()\n+\n+    # first batch size 1\n+    img_batch_shape = [batch_size, input_rows, cols, depth]\n+    input_a_np, input_a_tf, output_a_np, output_b_np, output_b_tf = create_tensor_data(\n+        img_batch_shape, classes)\n+\n+    coord = tf.train.Coordinator()\n+    threads = tf.train.start_queue_runners(sess, coord)\n+    # tensor input, numpy output\n+    input_only_tfrecord_model(input_a_tf, output_b_np, img_batch_shape, classes)\n+    # tensor input, tensor output\n+    input_label_tfrecord_model(input_a_tf, output_b_tf, img_batch_shape, classes)\n+\n+    coord.request_stop()\n+    coord.join(threads)\n+    K.clear_session()\n+\n+    sess = K.get_session()\n+    # next batch size 3\n+    batch_size = 3\n+    img_batch_shape = [batch_size, input_rows, cols, depth]\n+    input_a_np, input_a_tf, output_a_np, output_b_np, output_b_tf = create_tensor_data(\n+        img_batch_shape, classes)\n+    coord = tf.train.Coordinator()\n+    threads = tf.train.start_queue_runners(sess, coord)\n+    # tensor input, numpy output\n+    input_only_tfrecord_model(input_a_tf, output_b_np, img_batch_shape, classes)\n+    # tensor input, tensor output\n+    input_label_tfrecord_model(input_a_tf, output_b_tf, img_batch_shape, classes)\n+    coord.request_stop()\n+    coord.join(threads)\n+\n+\n+def cnn_layers(x_train_input, classes):\n+    x = Conv2D(32, (1, 1), activation='relu', padding='valid')(x_train_input)\n+    x = Dropout(0.25)(x)\n+    x = Flatten()(x)\n+    x = Dense(128, activation='relu')(x)\n+    x = Dropout(0.5)(x)\n+    x_train_out = Dense(classes,\n+                        activation='softmax',\n+                        name='x_train_out')(x)\n+    return x_train_out\n+\n+\n+def input_only_tfrecord_model(input_a_tf, output_b_np, img_batch_shape, classes):\n+    a = Input(tensor=input_a_tf, batch_shape=img_batch_shape)\n+    b = cnn_layers(a, classes)\n+    model = Model([a], [b])\n+    model.summary()\n+\n+    optimizer = 'rmsprop'\n+    loss = 'mse'\n+    loss_weights = [1., 2.]\n+    with pytest.raises(ValueError) as exc:\n+        model.compile(optimizer, loss, metrics=['mean_squared_error'],\n+                      loss_weights=loss_weights,\n+                      sample_weight_mode=None)\n+\n+    model.compile(optimizer, loss, metrics=['mean_squared_error'],\n+                  sample_weight_mode=None)\n+\n+    call_model_methods(model, None, output_b_np, batch_size=None, steps_per_epoch=2)\n+\n+\n+def input_label_tfrecord_model(input_a_tf, output_b_tf, img_batch_shape, classes):\n+    a = Input(tensor=input_a_tf, batch_shape=img_batch_shape)\n+    b = cnn_layers(a, classes)\n+    y_train_in_out = Input(\n+        tensor=output_b_tf,\n+        batch_shape=[img_batch_shape[0], classes],\n+        name='y_labels')\n+    b = cnn_layers(a, classes)\n+    cce = K.categorical_crossentropy(b, y_train_in_out)\n+    model = Model(inputs=[a], outputs=[b])\n+    model.add_loss(cce)\n+    model.summary()\n+\n+    optimizer = 'rmsprop'\n+    loss = None\n+    loss_weights = [1., 2.]\n+    with pytest.raises(ValueError) as exc:\n+        model.compile(optimizer, loss, metrics=['mean_squared_error'],\n+                      loss_weights=loss_weights)\n+\n+    model.compile(optimizer, loss, metrics=['mean_squared_error'])\n+\n+    call_model_methods(model, None, None,\n+                       batch_size=None, steps_per_epoch=1)\n+\n+    model.compile(optimizer,\n+                  loss='categorical_crossentropy',\n+                  metrics=['mean_squared_error'])\n+\n+    call_model_methods(model, None, y_train_in_out,\n+                       batch_size=None, steps_per_epoch=1)\n+\n+\n+def create_tensor_data(img_batch_shape, classes, batch_count=1):\n+    import tensorflow as tf\n+    [batch_size, input_rows, cols, depth] = img_batch_shape\n+    img_count = batch_size * batch_count\n+    imgs_shape = [img_count, input_rows, cols, depth]\n+    labels_shape = [img_count, classes]\n+    input_a_np = np.multiply(np.random.random(imgs_shape), batch_size)\n+    input_a_np = input_a_np.astype('uint8')\n+    output_a_np = np.multiply(np.random.random([img_count]), classes)\n+    output_a_np = output_a_np.astype('int')\n+    output_b_np = np.random.random(labels_shape)\n+\n+    from tensorflow.contrib.learn.python.learn.datasets import mnist\n+\n+    input_a_tf, output_b_tf = tf.train.shuffle_batch(\n+        tensors=[input_a_np, output_a_np.astype(np.int32)],\n+        batch_size=batch_size,\n+        capacity=batch_size * 2,\n+        min_after_dequeue=1,\n+        enqueue_many=True,\n+        num_threads=1,\n+        name='create_tensor_data_shuffle_batch')\n+\n+    input_a_tf = tf.cast(input_a_tf, tf.float32, name='input_a_tf_cast')\n+    input_a_tf = tf.reshape(input_a_tf, shape=img_batch_shape, name='input_a_tf_reshape')\n+\n+    output_b_tf = tf.cast(output_a_np, tf.int32, name='output_b_tf_cast')\n+    output_b_tf = tf.one_hot(output_b_tf, classes, name='output_b_tf_one_hot')\n+\n+    return input_a_np, input_a_tf, output_a_np, output_b_np, output_b_tf\n \n \n @keras_test\n\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The proposed PR aims to add TFRecords support in the `model.fit()` API, which is beneficial for users needing efficient data handling with TensorFlow operations. However, the implementation suggests modifying `model.fit()` to accept tensors directly, which complicates the API without clear advantages. Using placeholders might be a better option for more generic use cases. Consider focusing on utility improvements and maintaining backward compatibility while exploring alternative approaches, like a dedicated layer for targets, rather than introducing potentially confusing modifications."
      }
    ],
    "token_estimation": 7850.25
  },
  {
    "index": 43,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/keras/applications/mobilenet.py b/keras/applications/mobilenet.py\nnew file mode 100644\nindex 000000000000..f6631214186f\n--- /dev/null\n+++ b/keras/applications/mobilenet.py\n@@ -0,0 +1,616 @@\n+\"\"\"MobileNet v1 models for Keras.\n+\n+MobileNet is a general architecture and can be used for multiple use cases.\n+Depending on the use case, it can use different input layer size and\n+different width factors. This allows different width models to reduce\n+the number of multiply-adds and thereby reduce inference cost on mobile devices.\n+\n+MobileNets support any input size greater than 32 x 32, with larger image sizes\n+offering better performance. The number of parameters and number of multiply-adds\n+can be modified by using the `alpha` parameter, which increases/decreases the number\n+of filters in each layer. By altering the image size and `alpha` parameter,\n+all 16 models from the paper can be built, with ImageNet weights provided.\n+\n+The paper demonstrates the performance of MobileNets using `alpha` values of\n+1.0 (also called 100 % MobileNet), 0.75, 0.5 and 0.25. For each of these `alpha`\n+values, weights for 4 different input image sizes are provided (224, 192, 160, 128).\n+\n+The following table describes the size and accuracy of the 100% MobileNet on size 224 x 224\n+-----------------------------------------------------------------------------------------\n+Width Multiplier (alpha) | ImageNet Accuracy | Million Multiply-Adds | Million Parameters\n+-----------------------------------------------------------------------------------------\n+|   1.0 MobileNet-224    |      70.6 %       |          529          |        4.2       |\n+|   0.75 MobileNet-224   |      68.4 %       |          325          |        2.6       |\n+|   0.50 MobileNet-224   |      63.7 %       |          149          |        1.3       |\n+|   0.25 MobileNet-224   |      50.6 %       |          41           |        0.5       |\n+-----------------------------------------------------------------------------------------\n+\n+The following table describes the performance of the 100 % MobileNet on various input sizes\n+-----------------------------------------------------------------------------------------\n+        Resolution       | ImageNet Accuracy | Million Multiply-Adds | Million Parameters\n+-----------------------------------------------------------------------------------------\n+|   1.0 MobileNet-224    |      70.6 %       |          529          |        4.2       |\n+|   1.0 MobileNet-192    |      69.1 %       |          529          |        4.2       |\n+|   1.0 MobileNet-160    |      67.2 %       |          529          |        4.2       |\n+|   1.0 MobileNet-128    |      64.4 %       |          529          |        4.2       |\n+-----------------------------------------------------------------------------------------\n+\n+The weights for all 16 models are obtained and translated from Tensorflow checkpoints\n+found in https://github.com/tensorflow/models/blob/master/slim/nets/mobilenet_v1.md\n+\n+# Reference\n+- [MobileNets: Efficient Convolutional Neural Networks for\n+   Mobile Vision Applications](https://arxiv.org/pdf/1704.04861.pdf))\n+\"\"\"\n+from __future__ import print_function\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import warnings\n+\n+from ..models import Model\n+from ..layers import Input\n+from ..layers import Activation\n+from ..layers import Dropout\n+from ..layers import Reshape\n+from ..layers import BatchNormalization\n+from ..layers import Convolution2D\n+from ..layers import GlobalAveragePooling2D\n+from ..layers import GlobalMaxPooling2D\n+from ..layers import Conv2D\n+from .. import initializers\n+from .. import regularizers\n+from .. import constraints\n+from ..utils import conv_utils\n+from ..utils.data_utils import get_file\n+from ..engine.topology import get_source_inputs\n+from ..engine import InputSpec\n+from ..applications.imagenet_utils import _obtain_input_shape\n+from ..applications.imagenet_utils import preprocess_input\n+from ..applications.imagenet_utils import decode_predictions\n+from .. import backend as K\n+\n+\n+BASE_WEIGHT_PATH = 'https://github.com/titu1994/MobileNetworks/releases/download/v1.0/'\n+\n+\n+def relu6(x):\n+    return K.relu(x, max_value=6)\n+\n+\n+class DepthwiseConv2D(Conv2D):\n+    \"\"\"Depthwise separable 2D convolution.\n+    Depthwise Separable convolutions consists in performing\n+    just the first step in a depthwise spatial convolution\n+    (which acts on each input channel separately).\n+    The `depth_multiplier` argument controls how many\n+    output channels are generated per input channel in the depthwise step.\n+\n+    # Arguments\n+        kernel_size: An integer or tuple/list of 2 integers, specifying the\n+            width and height of the 2D convolution window.\n+            Can be a single integer to specify the same value for\n+            all spatial dimensions.\n+        strides: An integer or tuple/list of 2 integers,\n+            specifying the strides of the convolution along the width and height.\n+            Can be a single integer to specify the same value for\n+            all spatial dimensions.\n+            Specifying any stride value != 1 is incompatible with specifying\n+            any `dilation_rate` value != 1.\n+        padding: one of `\"valid\"` or `\"same\"` (case-insensitive).\n+        depth_multiplier: The number of depthwise convolution output channels\n+            for each input channel.\n+            The total number of depthwise convolution output\n+            channels will be equal to `filters_in * depth_multiplier`.\n+        data_format: A string,\n+            one of `channels_last` (default) or `channels_first`.\n+            The ordering of the dimensions in the inputs.\n+            `channels_last` corresponds to inputs with shape\n+            `(batch, height, width, channels)` while `channels_first`\n+            corresponds to inputs with shape\n+            `(batch, channels, height, width)`.\n+            It defaults to the `image_data_format` value found in your\n+            Keras config file at `~/.keras/keras.json`.\n+            If you never set it, then it will be \"channels_last\".\n+        activation: Activation function to use\n+            (see [activations](../activations.md)).\n+            If you don't specify anything, no activation is applied\n+            (ie. \"linear\" activation: `a(x) = x`).\n+        use_bias: Boolean, whether the layer uses a bias vector.\n+        depthwise_initializer: Initializer for the depthwise kernel matrix\n+            (see [initializers](../initializers.md)).\n+        bias_initializer: Initializer for the bias vector\n+            (see [initializers](../initializers.md)).\n+        depthwise_regularizer: Regularizer function applied to\n+            the depthwise kernel matrix\n+            (see [regularizer](../regularizers.md)).\n+        bias_regularizer: Regularizer function applied to the bias vector\n+            (see [regularizer](../regularizers.md)).\n+        activity_regularizer: Regularizer function applied to\n+            the output of the layer (its \"activation\").\n+            (see [regularizer](../regularizers.md)).\n+        depthwise_constraint: Constraint function applied to\n+            the depthwise kernel matrix\n+            (see [constraints](../constraints.md)).\n+        bias_constraint: Constraint function applied to the bias vector\n+            (see [constraints](../constraints.md)).\n+\n+    # Input shape\n+        4D tensor with shape:\n+        `[batch, channels, rows, cols]` if data_format='channels_first'\n+        or 4D tensor with shape:\n+        `[batch, rows, cols, channels]` if data_format='channels_last'.\n+\n+    # Output shape\n+        4D tensor with shape:\n+        `[batch, filters, new_rows, new_cols]` if data_format='channels_first'\n+        or 4D tensor with shape:\n+        `[batch, new_rows, new_cols, filters]` if data_format='channels_last'.\n+        `rows` and `cols` values might have changed due to padding.\n+    \"\"\"\n+\n+    def __init__(self,\n+                 kernel_size,\n+                 strides=(1, 1),\n+                 padding='valid',\n+                 depth_multiplier=1,\n+                 data_format=None,\n+                 activation=None,\n+                 use_bias=True,\n+                 depthwise_initializer='glorot_uniform',\n+                 bias_initializer='zeros',\n+                 depthwise_regularizer=None,\n+                 bias_regularizer=None,\n+                 activity_regularizer=None,\n+                 depthwise_constraint=None,\n+                 bias_constraint=None,\n+                 **kwargs):\n+        super(DepthwiseConv2D, self).__init__(\n+            filters=None,\n+            kernel_size=kernel_size,\n+            strides=strides,\n+            padding=padding,\n+            data_format=data_format,\n+            activation=activation,\n+            use_bias=use_bias,\n+            bias_regularizer=bias_regularizer,\n+            activity_regularizer=activity_regularizer,\n+            bias_constraint=bias_constraint,\n+            **kwargs)\n+        self.depth_multiplier = depth_multiplier\n+        self.depthwise_initializer = initializers.get(depthwise_initializer)\n+        self.depthwise_regularizer = regularizers.get(depthwise_regularizer)\n+        self.depthwise_constraint = constraints.get(depthwise_constraint)\n+        self.bias_initializer = initializers.get(bias_initializer)\n+\n+    def build(self, input_shape):\n+        if len(input_shape) < 4:\n+            raise ValueError('Inputs to `DepthwiseConv2D` should have rank 4. '\n+                             'Received input shape:', str(input_shape))\n+        if self.data_format == 'channels_first':\n+            channel_axis = 1\n+        else:\n+            channel_axis = 3\n+        if input_shape[channel_axis] is None:\n+            raise ValueError('The channel dimension of the inputs to '\n+                             '`DepthwiseConv2D` '\n+                             'should be defined. Found `None`.')\n+        input_dim = int(input_shape[channel_axis])\n+        depthwise_kernel_shape = (self.kernel_size[0],\n+                                  self.kernel_size[1],\n+                                  input_dim,\n+                                  self.depth_multiplier)\n+\n+        self.depthwise_kernel = self.add_weight(\n+            shape=depthwise_kernel_shape,\n+            initializer=self.depthwise_initializer,\n+            name='depthwise_kernel',\n+            regularizer=self.depthwise_regularizer,\n+            constraint=self.depthwise_constraint)\n+\n+        if self.use_bias:\n+            self.bias = self.add_weight(shape=(input_dim * self.depth_multiplier,),\n+                                        initializer=self.bias_initializer,\n+                                        name='bias',\n+                                        regularizer=self.bias_regularizer,\n+                                        constraint=self.bias_constraint)\n+        else:\n+            self.bias = None\n+        # Set input spec.\n+        self.input_spec = InputSpec(ndim=4, axes={channel_axis: input_dim})\n+        self.built = True\n+\n+    def call(self, inputs, training=None):\n+        outputs = K.depthwise_conv2d(\n+            inputs,\n+            self.depthwise_kernel,\n+            strides=self.strides,\n+            padding=self.padding,\n+            dilation_rate=self.dilation_rate,\n+            data_format=self.data_format)\n+\n+        if self.bias:\n+            outputs = K.bias_add(\n+                outputs,\n+                self.bias,\n+                data_format=self.data_format)\n+\n+        if self.activation is not None:\n+            return self.activation(outputs)\n+\n+        return outputs\n+\n+    def compute_output_shape(self, input_shape):\n+        if self.data_format == 'channels_first':\n+            rows = input_shape[2]\n+            cols = input_shape[3]\n+            out_filters = input_shape[1] * self.depth_multiplier\n+        elif self.data_format == 'channels_last':\n+            rows = input_shape[1]\n+            cols = input_shape[2]\n+            out_filters = input_shape[3] * self.depth_multiplier\n+\n+        rows = conv_utils.conv_output_length(rows, self.kernel_size[0],\n+                                             self.padding,\n+                                             self.strides[0])\n+        cols = conv_utils.conv_output_length(cols, self.kernel_size[1],\n+                                             self.padding,\n+                                             self.strides[1])\n+\n+        if self.data_format == 'channels_first':\n+            return (input_shape[0], out_filters, rows, cols)\n+        elif self.data_format == 'channels_last':\n+            return (input_shape[0], rows, cols, out_filters)\n+\n+    def get_config(self):\n+        config = super(DepthwiseConv2D, self).get_config()\n+        config.pop('filters')\n+        config.pop('kernel_initializer')\n+        config.pop('kernel_regularizer')\n+        config.pop('kernel_constraint')\n+        config['depth_multiplier'] = self.depth_multiplier\n+        config['depthwise_initializer'] = initializers.serialize(self.depthwise_initializer)\n+        config['depthwise_regularizer'] = regularizers.serialize(self.depthwise_regularizer)\n+        config['depthwise_constraint'] = constraints.serialize(self.depthwise_constraint)\n+        return config\n+\n+\n+def MobileNet(input_shape=None,\n+              alpha=1.0,\n+              depth_multiplier=1,\n+              dropout=1e-3,\n+              include_top=True,\n+              weights='imagenet',\n+              input_tensor=None,\n+              pooling=None,\n+              classes=1000):\n+    \"\"\"\n+    Instantiate the MobileNet architecture.\n+    Note that only TensorFlow is supported for now,\n+    therefore it only works with the data format\n+    `image_data_format='channels_last'` in your Keras config\n+    at `~/.keras/keras.json`.\n+\n+    To load a MobileNet model via `load_model`, import the custom\n+    objects `relu6` and `DepthwiseConv2D` and pass them to the\n+    `custom_objects` parameter.\n+    E.g.\n+    model = load_model('mobilenet.h5', custom_objects={\n+                       'relu6': mobilenet.relu6,\n+                       'DepthwiseConv2D': mobilenet.DepthwiseConv2D})\n+\n+    # Arguments\n+        input_shape: optional shape tuple, only to be specified\n+            if `include_top` is False (otherwise the input shape\n+            has to be `(224, 224, 3)` (with `channels_last` data format)\n+            or (3, 224, 224) (with `channels_first` data format).\n+            It should have exactly 3 inputs channels,\n+            and width and height should be no smaller than 32.\n+            E.g. `(200, 200, 3)` would be one valid value.\n+        alpha: controls the width of the network.\n+            - If `alpha` < 1.0, proportionally decreases the number\n+                of filters in each layer.\n+            - If `alpha` > 1.0, proportionally increases the number\n+                of filters in each layer.\n+            - If `alpha` = 1, default number of filters from the paper\n+                 are used at each layer.\n+        depth_multiplier: depth multiplier for depthwise convolution\n+            (also called the resolution multiplier)\n+        dropout: dropout rate\n+        include_top: whether to include the fully-connected\n+            layer at the top of the network.\n+        weights: `None` (random initialization) or\n+            `imagenet` (ImageNet weights)\n+        input_tensor: optional Keras tensor (i.e. output of\n+            `layers.Input()`)\n+            to use as image input for the model.\n+        pooling: Optional pooling mode for feature extraction\n+            when `include_top` is `False`.\n+            - `None` means that the output of the model\n+                will be the 4D tensor output of the\n+                last convolutional layer.\n+            - `avg` means that global average pooling\n+                will be applied to the output of the\n+                last convolutional layer, and thus\n+                the output of the model will be a\n+                2D tensor.\n+            - `max` means that global max pooling will\n+                be applied.\n+        classes: optional number of classes to classify images\n+            into, only to be specified if `include_top` is True, and\n+            if no `weights` argument is specified.\n+\n+    # Returns\n+        A Keras model instance.\n+\n+    # Raises\n+        ValueError: in case of invalid argument for `weights`,\n+            or invalid input shape.\n+        RuntimeError: If attempting to run this model with a\n+            backend that does not support separable convolutions.\n+    \"\"\"\n+\n+    if K.backend() != 'tensorflow':\n+        raise RuntimeError('Only Tensorflow backend is currently supported, '\n+                           'as other backends do not support depthwise convolution.')\n+\n+    if weights not in {'imagenet', None}:\n+        raise ValueError('The `weights` argument should be either '\n+                         '`None` (random initialization) or `imagenet` '\n+                         '(pre-training on ImageNet).')\n+\n+    if weights == 'imagenet' and include_top and classes != 1000:\n+        raise ValueError('If using `weights` as ImageNet with `include_top`'\n+                         ' as true, `classes` should be 1000')\n+\n+    if weights == 'imagenet' and depth_multiplier != 1:\n+        if depth_multiplier != 1:\n+            raise ValueError('If imagenet weights are being loaded, '\n+                             'depth multiplier must be 1')\n+\n+        if alpha not in [0.25, 0.50, 0.75, 1.0]:\n+            raise ValueError('If imagenet weights are being loaded, alpha can be one of'\n+                             '`0.25`, `0.50`, `0.75` or `1.0` only.')\n+\n+        rows, cols = (0, 1) if K.image_data_format() == 'channels_last' else (1, 2)\n+        rows = int(input_shape[rows])\n+        cols = int(input_shape[cols])\n+\n+        if rows != cols or rows not in [128, 160, 192, 224]:\n+            raise ValueError('If imagenet weights are being loaded,'\n+                             'image must have a square shape (one of '\n+                             '(128,128), (160,160), (192,192), or (224, 224)).'\n+                             'Image shape provided = (%d, %d)' % (rows, cols))\n+\n+    if K.image_data_format() != 'channels_last':\n+        warnings.warn('The MobileNet family of models is only available '\n+                      'for the input data format \"channels_last\" '\n+                      '(width, height, channels). '\n+                      'However your settings specify the default '\n+                      'data format \"channels_first\" (channels, width, height). '\n+                      'You should set `image_data_format=\"channels_last\"` in your Keras '\n+                      'config located at ~/.keras/keras.json. '\n+                      'The model being returned right now will expect inputs '\n+                      'to follow the \"channels_last\" data format.')\n+        K.set_image_data_format('channels_last')\n+        old_data_format = 'channels_first'\n+    else:\n+        old_data_format = None\n+\n+    # Determine proper input shape. Note, include_top is False by default, as\n+    # input shape can be anything larger than 32x32 and the same number of parameters\n+    # will be used.\n+    input_shape = _obtain_input_shape(input_shape,\n+                                      default_size=224,\n+                                      min_size=32,\n+                                      data_format=K.image_data_format(),\n+                                      include_top=False)\n+\n+    if input_tensor is None:\n+        img_input = Input(shape=input_shape)\n+    else:\n+        if not K.is_keras_tensor(input_tensor):\n+            img_input = Input(tensor=input_tensor, shape=input_shape)\n+        else:\n+            img_input = input_tensor\n+\n+    x = _conv_block(img_input, 32, alpha, strides=(2, 2))\n+    x = _depthwise_conv_block(x, 64, alpha, depth_multiplier, id=1)\n+\n+    x = _depthwise_conv_block(x, 128, alpha, depth_multiplier, strides=(2, 2), id=2)\n+    x = _depthwise_conv_block(x, 128, alpha, depth_multiplier, id=3)\n+\n+    x = _depthwise_conv_block(x, 256, alpha, depth_multiplier, strides=(2, 2), id=4)\n+    x = _depthwise_conv_block(x, 256, alpha, depth_multiplier, id=5)\n+\n+    x = _depthwise_conv_block(x, 512, alpha, depth_multiplier, strides=(2, 2), id=6)\n+    x = _depthwise_conv_block(x, 512, alpha, depth_multiplier, id=7)\n+    x = _depthwise_conv_block(x, 512, alpha, depth_multiplier, id=8)\n+    x = _depthwise_conv_block(x, 512, alpha, depth_multiplier, id=9)\n+    x = _depthwise_conv_block(x, 512, alpha, depth_multiplier, id=10)\n+    x = _depthwise_conv_block(x, 512, alpha, depth_multiplier, id=11)\n+\n+    x = _depthwise_conv_block(x, 1024, alpha, depth_multiplier, strides=(2, 2), id=12)\n+    x = _depthwise_conv_block(x, 1024, alpha, depth_multiplier, id=13)\n+\n+    if include_top:\n+        if K.image_data_format() == 'channels_first':\n+            shape = (int(1024 * alpha), 1, 1)\n+        else:\n+            shape = (1, 1, int(1024 * alpha))\n+\n+        x = GlobalAveragePooling2D()(x)\n+        x = Reshape(shape, name='reshape_1')(x)\n+        x = Dropout(dropout, name='dropout')(x)\n+        x = Convolution2D(classes, (1, 1), padding='same', name='conv_preds')(x)\n+        x = Activation('softmax', name='act_softmax')(x)\n+        x = Reshape((classes,), name='reshape_2')(x)\n+    else:\n+        if pooling == 'avg':\n+            x = GlobalAveragePooling2D()(x)\n+        elif pooling == 'max':\n+            x = GlobalMaxPooling2D()(x)\n+\n+    # Ensure that the model takes into account\n+    # any potential predecessors of `input_tensor`.\n+    if input_tensor is not None:\n+        inputs = get_source_inputs(input_tensor)\n+    else:\n+        inputs = img_input\n+\n+    rows, cols = (0, 1) if K.image_data_format() == 'channels_last' else (1, 2)\n+    if input_shape[rows] is None:\n+        size = 'None'\n+    else:\n+        size = str(input_shape[rows])\n+\n+    # Create model.\n+    model = Model(inputs, x, name='mobilenet_%0.2f_%s' % (alpha, size))\n+\n+    # load weights\n+    if weights == 'imagenet':\n+        if K.image_data_format() == 'channels_first':\n+            raise AttributeError('Weights for Channels Last format are not available')\n+\n+        if alpha == 1.0:\n+            alpha_text = '1_0'\n+        elif alpha == 0.75:\n+            alpha_text = '7_5'\n+        elif alpha == 0.50:\n+            alpha_text = '5_0'\n+        else:\n+            alpha_text = '2_5'\n+\n+        if include_top:\n+            model_name = 'mobilenet_%s_%d_tf.h5' % (alpha_text, rows)\n+            weigh_path = BASE_WEIGHT_PATH + model_name\n+            weights_path = get_file(model_name,\n+                                    weigh_path,\n+                                    cache_subdir='models')\n+        else:\n+            model_name = 'mobilenet_%s_%d_tf_no_top.h5' % (alpha_text, rows)\n+            weigh_path = BASE_WEIGHT_PATH + model_name\n+            weights_path = get_file(model_name,\n+                                    weigh_path,\n+                                    cache_subdir='models')\n+\n+        model.load_weights(weights_path)\n+\n+    if old_data_format:\n+        K.set_image_data_format(old_data_format)\n+\n+    return model\n+\n+\n+def _conv_block(input, filters, alpha, kernel=(3, 3), strides=(1, 1)):\n+    \"\"\"Adds an initial convolution layer (with batch normalization and relu6).\n+\n+    # Arguments\n+        input: Input tensor of shape `(rows, cols, 3)`\n+            (with `channels_last` data format) or\n+            (3, rows, cols) (with `channels_first` data format).\n+            It should have exactly 3 inputs channels,\n+            and width and height should be no smaller than 32.\n+            E.g. `(224, 224, 3)` would be one valid value.\n+        filters: Integer, the dimensionality of the output space\n+            (i.e. the number output of filters in the convolution).\n+        alpha: controls the width of the network.\n+            - If `alpha` < 1.0, proportionally decreases the number\n+                of filters in each layer.\n+            - If `alpha` > 1.0, proportionally increases the number\n+                of filters in each layer.\n+            - If `alpha` = 1, default number of filters from the paper\n+                 are used at each layer.\n+        kernel: An integer or tuple/list of 2 integers, specifying the\n+            width and height of the 2D convolution window.\n+            Can be a single integer to specify the same value for\n+            all spatial dimensions.\n+        strides: An integer or tuple/list of 2 integers,\n+            specifying the strides of the convolution along the width and height.\n+            Can be a single integer to specify the same value for\n+            all spatial dimensions.\n+            Specifying any stride value != 1 is incompatible with specifying\n+            any `dilation_rate` value != 1.\n+\n+    # Input shape\n+        4D tensor with shape:\n+        `(samples, channels, rows, cols)` if data_format='channels_first'\n+        or 4D tensor with shape:\n+        `(samples, rows, cols, channels)` if data_format='channels_last'.\n+\n+    # Output shape\n+        4D tensor with shape:\n+        `(samples, filters, new_rows, new_cols)` if data_format='channels_first'\n+        or 4D tensor with shape:\n+        `(samples, new_rows, new_cols, filters)` if data_format='channels_last'.\n+        `rows` and `cols` values might have changed due to stride.\n+    \"\"\"\n+    channel_axis = 1 if K.image_data_format() == 'channels_first' else -1\n+    filters = int(filters * alpha)\n+\n+    x = Convolution2D(filters, kernel, padding='same', use_bias=False, strides=strides,\n+                      name='conv1')(input)\n+    x = BatchNormalization(axis=channel_axis, name='conv1_bn')(x)\n+    x = Activation(relu6, name='conv1_relu')(x)\n+\n+    return x\n+\n+\n+def _depthwise_conv_block(input, pointwise_conv_filters, alpha,\n+                          depth_multiplier=1, strides=(1, 1), id=1):\n+    \"\"\"\n+    Adds a depthwise convolution block (depthwise conv, batch normalization, relu6,\n+    pointwise convolution, batch normalization and relu6).\n+\n+    # Arguments\n+        input: Input tensor of shape `(rows, cols, channels)`\n+            (with `channels_last` data format) or\n+            (channels, rows, cols) (with `channels_first` data format).\n+        pointwise_conv_filters: Integer, the dimensionality of the output space\n+            (i.e. the number output of filters in the pointwise convolution).\n+        alpha: controls the width of the network.\n+            - If `alpha` < 1.0, proportionally decreases the number\n+                of filters in each layer.\n+            - If `alpha` > 1.0, proportionally increases the number\n+                of filters in each layer.\n+            - If `alpha` = 1, default number of filters from the paper\n+                 are used at each layer.\n+        depth_multiplier: The number of depthwise convolution output channels\n+            for each input channel.\n+            The total number of depthwise convolution output\n+            channels will be equal to `filters_in * depth_multiplier`.\n+        strides: An integer or tuple/list of 2 integers,\n+            specifying the strides of the convolution along the width and height.\n+            Can be a single integer to specify the same value for\n+            all spatial dimensions.\n+            Specifying any stride value != 1 is incompatible with specifying\n+            any `dilation_rate` value != 1.\n+        id: Integer, a unique identification designating  the block number.\n+\n+    # Input shape\n+        4D tensor with shape:\n+        `(batch, channels, rows, cols)` if data_format='channels_first'\n+        or 4D tensor with shape:\n+        `(batch, rows, cols, channels)` if data_format='channels_last'.\n+\n+    # Output shape\n+        4D tensor with shape:\n+        `(batch, filters, new_rows, new_cols)` if data_format='channels_first'\n+        or 4D tensor with shape:\n+        `(batch, new_rows, new_cols, filters)` if data_format='channels_last'.\n+        `rows` and `cols` values might have changed due to stride.\n+    \"\"\"\n+    channel_axis = 1 if K.image_data_format() == 'channels_first' else -1\n+    pointwise_conv_filters = int(pointwise_conv_filters * alpha)\n+\n+    x = DepthwiseConv2D(kernel_size=(3, 3), padding='same', depth_multiplier=depth_multiplier,\n+                        strides=strides, use_bias=False, name='conv_dw_%d' % id)(input)\n+    x = BatchNormalization(axis=channel_axis, name='conv_dw_%d_bn' % id)(x)\n+    x = Activation(relu6, name='conv_dw_%d_relu' % id)(x)\n+\n+    x = Convolution2D(pointwise_conv_filters, (1, 1), padding='same', use_bias=False, strides=(1, 1),\n+                      name='conv_pw_%d' % id)(x)\n+    x = BatchNormalization(axis=channel_axis, name='conv_pw_%d_bn' % id)(x)\n+    x = Activation(relu6, name='conv_pw_%d_relu' % id)(x)\n+\n+    return x\ndiff --git a/tests/keras/applications/applications_test.py b/tests/keras/applications/applications_test.py\nindex fc432762b258..ab3585c0cf6e 100644\n--- a/tests/keras/applications/applications_test.py\n+++ b/tests/keras/applications/applications_test.py\n@@ -166,5 +169,73 @@ def test_inceptionv3_pooling():\n     assert model.output_shape == (None, 2048)\n \n \n+@keras_test\n+@pytest.mark.skipif((K.backend() != 'tensorflow'),\n+                    reason=\"MobileNets are supported only on Tensorflow\")\n+def test_mobilenet():\n+    model = applications.MobileNet(weights=None)\n+    assert model.output_shape == (None, 1000)\n+\n+\n+@keras_test\n+@pytest.mark.skipif((K.backend() != 'tensorflow'),\n+                    reason=\"MobileNets are supported only on Tensorflow\")\n+def test_mobilenet_no_top():\n+    model = applications.MobileNet(weights=None, include_top=False)\n+    assert model.output_shape == (None, None, None, 1024)\n+\n+\n+@keras_test\n+@pytest.mark.skipif((K.backend() != 'tensorflow'),\n+                    reason=\"MobileNets are supported only on Tensorflow\")\n+def test_mobilenet_pooling():\n+    model = applications.MobileNet(weights=None, include_top=False, pooling='avg')\n+    assert model.output_shape == (None, 1024)\n+\n+\n+@pytest.mark.skipif(K.backend() != 'tensorflow', reason='Requires TF backend')\n+@keras_test\n+def test_depthwise_conv_2d():\n+    _convolution_paddings = ['valid', 'same']\n+    num_samples = 2\n+    stack_size = 3\n+    num_row = 7\n+    num_col = 6\n+\n+    with CustomObjectScope({'relu6': applications.mobilenet.relu6,\n+                            'DepthwiseConv2D': applications.mobilenet.DepthwiseConv2D}):\n+        for padding in _convolution_paddings:\n+            for strides in [(1, 1), (2, 2)]:\n+                for multiplier in [1, 2]:\n+                    if padding == 'same' and strides != (1, 1):\n+                        continue\n+\n+                    layer_test(applications.mobilenet.DepthwiseConv2D,\n+                               kwargs={'kernel_size': (3, 3),\n+                                       'padding': padding,\n+                                       'strides': strides,\n+                                       'depth_multiplier': multiplier},\n+                               input_shape=(num_samples, num_row, num_col, stack_size))\n+\n+        layer_test(applications.mobilenet.DepthwiseConv2D,\n+                   kwargs={'kernel_size': 3,\n+                           'padding': padding,\n+                           'data_format': 'channels_first',\n+                           'activation': None,\n+                           'depthwise_regularizer': 'l2',\n+                           'bias_regularizer': 'l2',\n+                           'activity_regularizer': 'l2',\n+                           'depthwise_constraint': 'unit_norm',\n+                           'strides': strides,\n+                           'depth_multiplier': multiplier},\n+                   input_shape=(num_samples, stack_size, num_row, num_col))\n+\n+        # Test invalid use case\n+        with pytest.raises(ValueError):\n+            model = Sequential([applications.mobilenet.DepthwiseConv2D(kernel_size=3,\n+                                                                       padding=padding,\n+                                                                       batch_input_shape=(None, None, 5, None))])\n+\n+\n if __name__ == '__main__':\n     pytest.main([__file__])\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR has build errors related to `TimeDistributed` in CNTK and Theano, along with a pip install issue for integration tests, but the model tests pass. While you’ve made efforts to conform to Keras documentation, the private model-building functions deviate slightly. The inclusion of `relu6` in Keras might introduce unnecessary complexity since it could be defined locally. Modifying the tests to correctly handle custom objects would be beneficial. Overall, the code structure appears solid, but ensure thorough comparison with the source paper to validate implementations."
      }
    ],
    "token_estimation": 8239.5
  },
  {
    "index": 44,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/keras/applications/regnet.py b/keras/applications/regnet.py\nnew file mode 100644\nindex 000000000000..213a58f09d09\n--- /dev/null\n+++ b/keras/applications/regnet.py\n@@ -0,0 +1,1549 @@\n+# Copyright 2021 The TensorFlow Authors. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+# pylint: disable=invalid-name\n+# pylint: disable=missing-docstring\n+\"\"\"RegNet models for Keras.\n+\n+References:\n+\n+- [Designing Network Design Spaces](https://arxiv.org/abs/2003.13678)\n+  (CVPR 2020)\n+- [Fast and Accurate Model Scaling](https://arxiv.org/abs/2103.06877)\n+  (CVPR 2021)\n+\"\"\"\n+\n+import tensorflow as tf\n+\n+from keras import backend\n+from keras import layers\n+from keras.applications import imagenet_utils\n+from keras.engine import training\n+from keras.utils import layer_utils\n+from keras.utils import data_utils\n+from tensorflow.python.util.tf_export import keras_export\n+\n+BASE_WEIGHTS_PATH = \"\"\n+\n+WEIGHTS_HASHES = {\n+    \"x002\": (\"\", \"\"),\n+    \"x004\": (\"\", \"\"),\n+    \"x006\": (\"\", \"\"),\n+    \"x008\": (\"\", \"\"),\n+    \"x016\": (\"\", \"\"),\n+    \"x032\": (\"\", \"\"),\n+    \"x040\": (\"\", \"\"),\n+    \"x064\": (\"\", \"\"),\n+    \"x080\": (\"\", \"\"),\n+    \"x120\": (\"\", \"\"),\n+    \"x160\": (\"\", \"\"),\n+    \"x320\": (\"\", \"\"),\n+    \"y002\": (\"\", \"\"),\n+    \"y004\": (\"\", \"\"),\n+    \"y006\": (\"\", \"\"),\n+    \"y008\": (\"\", \"\"),\n+    \"y016\": (\"\", \"\"),\n+    \"y032\": (\"\", \"\"),\n+    \"y040\": (\"\", \"\"),\n+    \"y064\": (\"\", \"\"),\n+    \"y080\": (\"\", \"\"),\n+    \"y120\": (\"\", \"\"),\n+    \"y160\": (\"\", \"\"),\n+    \"y320\": (\"\", \"\")\n+}\n+\n+# The widths and depths are deduced from a quantized linear function. For\n+# more information, please refer to \"Designing Network Design Spaces\" by\n+# Radosavovic et al.\n+\n+# BatchNorm momentum and epsilon values taken from original implementation.\n+\n+MODEL_CONFIGS = {\n+    \"x002\": {\n+        \"depths\": [1, 1, 4, 7],\n+        \"widths\": [24, 56, 152, 368],\n+        \"group_width\": 8,\n+        \"default_size\": 224\n+    },\n+    \"x004\": {\n+        \"depths\": [1, 2, 7, 12],\n+        \"widths\": [32, 64, 160, 384],\n+        \"group_width\": 16,\n+        \"default_size\": 224\n+    },\n+    \"x006\": {\n+        \"depths\": [1, 3, 5, 7],\n+        \"widths\": [48, 96, 240, 528],\n+        \"group_width\": 24,\n+        \"default_size\": 224\n+    },\n+    \"x008\": {\n+        \"depths\": [1, 3, 7, 5],\n+        \"widths\": [64, 128, 288, 672],\n+        \"group_width\": 16,\n+        \"default_size\": 224\n+    },\n+    \"x016\": {\n+        \"depths\": [2, 4, 10, 2],\n+        \"widths\": [72, 168, 408, 912],\n+        \"group_width\": 24,\n+        \"default_size\": 224\n+    },\n+    \"x032\": {\n+        \"depths\": [2, 6, 15, 2],\n+        \"widths\": [96, 192, 432, 1008],\n+        \"group_width\": 48,\n+        \"default_size\": 224\n+    },\n+    \"x040\": {\n+        \"depths\": [2, 5, 14, 2],\n+        \"widths\": [80, 240, 560, 1360],\n+        \"group_width\": 40,\n+        \"default_size\": 224\n+    },\n+    \"x064\": {\n+        \"depths\": [2, 4, 10, 1],\n+        \"widths\": [168, 392, 784, 1624],\n+        \"group_width\": 56,\n+        \"default_size\": 224\n+    },\n+    \"x080\": {\n+        \"depths\": [2, 5, 15, 1],\n+        \"widths\": [80, 240, 720, 1920],\n+        \"group_width\": 120,\n+        \"default_size\": 224\n+    },\n+    \"x120\": {\n+        \"depths\": [2, 5, 11, 1],\n+        \"widths\": [224, 448, 896, 2240],\n+        \"group_width\": 112,\n+        \"default_size\": 224\n+    },\n+    \"x160\": {\n+        \"depths\": [2, 6, 13, 1],\n+        \"widths\": [256, 512, 896, 2048],\n+        \"group_width\": 128,\n+        \"default_size\": 224\n+    },\n+    \"x320\": {\n+        \"depths\": [2, 7, 13, 1],\n+        \"widths\": [336, 672, 1344, 2520],\n+        \"group_width\": 168,\n+        \"default_size\": 224\n+    },\n+    \"y002\": {\n+        \"depths\": [1, 1, 4, 7],\n+        \"widths\": [24, 56, 152, 368],\n+        \"group_width\": 8,\n+        \"default_size\": 224\n+    },\n+    \"y004\": {\n+        \"depths\": [1, 3, 6, 6],\n+        \"widths\": [48, 104, 208, 440],\n+        \"group_width\": 8,\n+        \"default_size\": 224\n+    },\n+    \"y006\": {\n+        \"depths\": [1, 3, 7, 4],\n+        \"widths\": [48, 112, 256, 608],\n+        \"group_width\": 16,\n+        \"default_size\": 224\n+    },\n+    \"y008\": {\n+        \"depths\": [1, 3, 8, 2],\n+        \"widths\": [64, 128, 320, 768],\n+        \"group_width\": 16,\n+        \"default_size\": 224\n+    },\n+    \"y016\": {\n+        \"depths\": [2, 6, 17, 2],\n+        \"widths\": [48, 120, 336, 888],\n+        \"group_width\": 24,\n+        \"default_size\": 224\n+    },\n+    \"y032\": {\n+        \"depths\": [2, 5, 13, 1],\n+        \"widths\": [72, 216, 576, 1512],\n+        \"group_width\": 24,\n+        \"default_size\": 224\n+    },\n+    \"y040\": {\n+        \"depths\": [2, 6, 12, 2],\n+        \"widths\": [128, 192, 512, 1088],\n+        \"group_width\": 64,\n+        \"default_size\": 224\n+    },\n+    \"y064\": {\n+        \"depths\": [2, 7, 14, 2],\n+        \"widths\": [144, 288, 576, 1296],\n+        \"group_width\": 72,\n+        \"default_size\": 224\n+    },\n+    \"y080\": {\n+        \"depths\": [2, 4, 10, 1],\n+        \"widths\": [168, 448, 896, 2016],\n+        \"group_width\": 56,\n+        \"default_size\": 224\n+    },\n+    \"y120\": {\n+        \"depths\": [2, 5, 11, 1],\n+        \"widths\": [224, 448, 896, 2240],\n+        \"group_width\": 112,\n+        \"default_size\": 224\n+    },\n+    \"y160\": {\n+        \"depths\": [2, 4, 11, 1],\n+        \"widths\": [224, 448, 1232, 3024],\n+        \"group_width\": 112,\n+        \"default_size\": 224\n+    },\n+    \"y320\": {\n+        \"depths\": [2, 5, 12, 1],\n+        \"widths\": [232, 696, 1392, 3712],\n+        \"group_width\": 232,\n+        \"default_size\": 224\n+    }\n+}\n+\n+BASE_DOCSTRING = \"\"\"Instantiates Regnet architecture.\n+\n+  References:\n+    - [Designing Network Design Spaces](https://arxiv.org/abs/2003.13678)\n+    (CVPR 2020)\n+    - [Fast and Accurate Model Scaling](https://arxiv.org/abs/2103.06877)\n+    (CVPR 2021)\n+\n+  For image classification use cases, see\n+  [this page for detailed examples](\n+  https://keras.io/api/applications/#usage-examples-for-image-classification-models).\n+\n+  For transfer learning use cases, make sure to read the\n+  [guide to transfer learning & fine-tuning](\n+    https://keras.io/guides/transfer_learning/).\n+\n+  Note: Each Keras Application expects a specific kind of input preprocessing.\n+  For Regnets, preprocessing is included in the model using a `Rescaling` layer.\n+  RegNet models expect their inputs to be float or uint8 tensors of pixels with \n+  values in the [0-255] range.\n+\n+  The naming of models is as follows: `RegNet{block_type}{flops}` where \n+  `block_type` is one of `(Y, Z)` and `flops` signifies hundred million \n+  floating point operations. For example RegNetY64 corresponds to RegNet with \n+  Y block and 6.4 giga flops (64 hundred million flops). \n+\n+  Args:\n+    include_top: Whether to include the fully-connected\n+        layer at the top of the network. Defaults to True.\n+    weights: One of `None` (random initialization),\n+          \"imagenet\" (pre-training on ImageNet),\n+          or the path to the weights file to be loaded. Defaults to \"imagenet\".\n+    input_tensor: Optional Keras tensor\n+        (i.e. output of `layers.Input()`)\n+        to use as image input for the model.\n+    input_shape: Optional shape tuple, only to be specified\n+        if `include_top` is False.\n+        It should have exactly 3 inputs channels.\n+    pooling: Optional pooling mode for feature extraction\n+        when `include_top` is `False`. Defaults to None.\n+        - `None` means that the output of the model will be\n+            the 4D tensor output of the\n+            last convolutional layer.\n+        - `avg` means that global average pooling\n+            will be applied to the output of the\n+            last convolutional layer, and thus\n+            the output of the model will be a 2D tensor.\n+        - `max` means that global max pooling will\n+            be applied.\n+    classes: Optional number of classes to classify images\n+        into, only to be specified if `include_top` is True, and\n+        if no `weights` argument is specified. Defaults to 1000 (number of\n+        ImageNet classes).\n+    classifier_activation: A `str` or callable. The activation function to use\n+        on the \"top\" layer. Ignored unless `include_top=True`. Set\n+        `classifier_activation=None` to return the logits of the \"top\" layer.\n+        Defaults to \"softmax\".\n+        When loading pretrained weights, `classifier_activation` can only\n+        be `None` or `\"softmax\"`.\n+\n+  Returns:\n+    A `keras.Model` instance.\n+\"\"\"\n+\n+\n+def PreStem(name=None):\n+  \"\"\"\n+  Rescales and normalizes inputs to [0,1] and ImageNet mean and std.\n+  \n+  Args:\n+    name: name prefix\n+    \n+  Returns:\n+    Rescaled and normalized tensor\n+  \"\"\"\n+  if name is None:\n+    name = \"prestem\" + str(backend.get_uid(\"prestem\"))\n+\n+  def apply(x):\n+    x = layers.Rescaling(scale=1. / 255., name=name + \"_prestem_rescaling\")(x)\n+\n+    return x\n+\n+  return apply\n+\n+\n+def Stem(name=None):\n+  \"\"\"\n+  Implementation of RegNet stem. (Common to all model variants)\n+  \n+  Args:\n+    name: name prefix   \n+\n+  Returns:\n+    Output tensor of the Stem\n+  \"\"\"\n+  if name is None:\n+    name = \"stem\" + str(backend.get_uid(\"stem\"))\n+\n+  def apply(x):\n+    x = layers.Conv2D(32, (3, 3),\n+                      strides=2,\n+                      use_bias=False,\n+                      padding=\"same\",\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_stem_conv\")(x)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_stem_bn\")(x)\n+    x = layers.ReLU(name=name + \"_stem_relu\")(x)\n+\n+    return x\n+\n+  return apply\n+\n+\n+def SqueezeAndExciteBlock(filters_in, se_filters, name=None):\n+  \"\"\"\n+  Implements the Squeeze and excite block(https://arxiv.org/abs/1709.01507)\n+  \n+  Args:\n+    filters_in: input filters to the block\n+    se_filters: filters to squeeze to\n+    name: name prefix\n+  \n+  Returns:\n+    A function object   \n+  \"\"\"\n+  if name is None:\n+    name = str(backend.get_uid(\"squeeze_and_excite\"))\n+\n+  def apply(inputs):\n+    x = layers.GlobalAveragePooling2D(\n+        name=name + \"_squeeze_and_excite_gap\", keepdims=True)(inputs)\n+    x = layers.Conv2D(se_filters, (1, 1),\n+                      activation=\"relu\",\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_squeeze_and_excite_squeeze\")(x)\n+    x = layers.Conv2D(filters_in, (1, 1),\n+                      activation=\"sigmoid\",\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_squeeze_and_excite_excite\")(x)\n+    x = tf.math.multiply(x, inputs)\n+    return x\n+\n+  return apply\n+\n+\n+def XBlock(filters_in, filters_out, group_width, stride=1, name=None):\n+  \"\"\"\n+  Implementation of X Block. \n+  Reference: [Designing Network Design Spaces](https://arxiv.org/abs/2003.13678)\n+\n+  Args:\n+    filters_in: filters in the input tensor\n+    filters_out: filters in the output tensor\n+    group_width: group width\n+    stride: stride\n+    name: name prefix\n+\n+  Return:\n+    Output tensor of the block \n+  \"\"\"\n+  if name is None:\n+    name = str(backend.get_uid(\"xblock\"))\n+\n+  def apply(inputs):\n+    if filters_in != filters_out and stride == 1:\n+      raise ValueError(\n+          \"\"\"Input filters and output filters are not equal for stride\n+                          1. Please check inputs and try again.\"\"\")\n+\n+    # Declare layers\n+    groups = filters_out // group_width\n+\n+    if stride != 1:\n+      skip = layers.Conv2D(filters_out, (1, 1),\n+                           strides=stride,\n+                           use_bias=False,\n+                           kernel_initializer=\"he_normal\",\n+                           name=name + \"_skip_1x1\")(inputs)\n+      skip = layers.BatchNormalization(momentum=0.9,\n+                                       epsilon=1e-5,\n+                                       name=name + \"_skip_bn\")(skip)\n+    else:\n+      skip = inputs\n+\n+    # Build block\n+    # conv_1x1_1\n+    x = layers.Conv2D(filters_out, (1, 1),\n+                      use_bias=False,\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_conv_1x1_1\")(inputs)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_conv_1x1_1_bn\")(x)\n+    x = layers.ReLU(name=name + \"_conv_1x1_1_relu\")(x)\n+\n+    # conv_3x3\n+    x = layers.Conv2D(filters_out, (3, 3),\n+                      use_bias=False, \n+                      strides=stride,\n+                      groups=groups,\n+                      padding=\"same\",\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_conv_3x3\")(x)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_conv_3x3_bn\")(x)\n+    x = layers.ReLU(name=name + \"_conv_3x3_relu\")(x)\n+\n+    # conv_1x1_2\n+    x = layers.Conv2D(filters_out, (1, 1),\n+                      use_bias=False,\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_conv_1x1_2\")(x)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_conv_1x1_2_bn\")(x)\n+\n+    x = layers.ReLU(name=name + \"_exit_relu\")(x + skip)\n+\n+    return x\n+\n+  return apply\n+\n+\n+def YBlock(filters_in,\n+           filters_out,\n+           group_width,\n+           stride=1,\n+           squeeze_excite_ratio=0.25,\n+           name=None):\n+  \"\"\"\n+  Implementation of Y Block. \n+  Reference: [Designing Network Design Spaces](https://arxiv.org/abs/2003.13678)\n+\n+  Args:\n+    filters_in: filters in the input tensor\n+    filters_out: filters in the output tensor\n+    group_width: group width\n+    stride: stride\n+    squeeze_excite_ratio: expansion ration for Squeeze and Excite block\n+    name: name prefix\n+\n+  Return:\n+    Output tensor of the block \n+  \"\"\"\n+  if name is None:\n+    name = str(backend.get_uid(\"yblock\"))\n+\n+  def apply(inputs):\n+    if filters_in != filters_out and stride == 1:\n+      raise ValueError(\n+          f\"\"\"Input filters({filters_in}) and output filters({filters_out}) are not equal for stride\n+                          {stride}. Input and output filters must be equal for stride={stride}.\"\"\"\n+      )\n+\n+    groups = filters_out // group_width\n+    se_filters = int(filters_in * squeeze_excite_ratio)\n+\n+    if stride != 1:\n+      skip = layers.Conv2D(filters_out, (1, 1),\n+                           strides=stride,\n+                           use_bias=False,\n+                           kernel_initializer=\"he_normal\",\n+                           name=name + \"_skip_1x1\")(inputs)\n+      skip = layers.BatchNormalization(momentum=0.9,\n+                                       epsilon=1e-5,\n+                                       name=name + \"_skip_bn\")(skip)\n+    else:\n+      skip = inputs\n+\n+    # Build block\n+    # conv_1x1_1\n+    x = layers.Conv2D(filters_out, (1, 1),\n+                      use_bias=False,\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_conv_1x1_1\")(inputs)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_conv_1x1_1_bn\")(x)\n+    x = layers.ReLU(name=name + \"_conv_1x1_1_relu\")(x)\n+\n+    # conv_3x3\n+    x = layers.Conv2D(filters_out, (3, 3),\n+                      use_bias=False,\n+                      strides=stride,\n+                      groups=groups,\n+                      padding=\"same\",\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_conv_3x3\")(x)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_conv_3x3_bn\")(x)\n+    x = layers.ReLU(name=name + \"_conv_3x3_relu\")(x)\n+\n+    # Squeeze-Excitation block (https://arxiv.org/abs/1709.01507)\n+    x = SqueezeAndExciteBlock(filters_out, se_filters, name=name)(x)\n+\n+    # conv_1x1_2\n+    x = layers.Conv2D(filters_out, (1, 1),\n+                      use_bias=False,\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_conv_1x1_2\")(x)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_conv_1x1_2_bn\")(x)\n+\n+    x = layers.ReLU(name=name + \"_exit_relu\")(x + skip)\n+\n+    return x\n+\n+  return apply\n+\n+\n+def ZBlock(filters_in,\n+           filters_out,\n+           group_width,\n+           stride=1,\n+           squeeze_excite_ratio=0.25,\n+           bottleneck_ratio=0.25,\n+           name=None):\n+  \"\"\"\n+  Implementation of Z block\n+  Reference: [Fast and Accurate Model Scaling](https://arxiv.org/abs/2103.06877).\n+  \n+  Args:\n+    filters_in: filters in the input tensor\n+    filters_out: filters in the output tensor\n+    group_width: group width\n+    stride: stride\n+    squeeze_excite_ratio: expansion ration for Squeeze and Excite block\n+    bottleneck_ratio: inverted bottleneck ratio \n+    name: name prefix\n+\n+  Return:\n+    Output tensor of the block \n+  \"\"\"\n+  if name is None:\n+    name = str(backend.get_uid(\"zblock\"))\n+\n+  def apply(inputs):\n+    if filters_in != filters_out and stride == 1:\n+      raise ValueError(\n+          f\"\"\"Input filters({filters_in}) and output filters({filters_out}) are not equal for stride\n+                          {stride}. Input and output filters must be equal for stride={stride}.\"\"\"\n+      )\n+\n+    groups = filters_out // group_width\n+    se_filters = int(filters_in * squeeze_excite_ratio)\n+\n+    inv_btlneck_filters = int(filters_out / bottleneck_ratio)\n+\n+    # Build block\n+    # conv_1x1_1\n+    x = layers.Conv2D(inv_btlneck_filters, (1, 1),\n+                      use_bias=False,\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_conv_1x1_1\")(inputs)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_conv_1x1_1_bn\")(x)\n+    x = tf.nn.silu(x)\n+\n+    # conv_3x3\n+    x = layers.Conv2D(inv_btlneck_filters, (3, 3),\n+                      use_bias=False,\n+                      strides=stride,\n+                      groups=groups,\n+                      padding=\"same\",\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_conv_3x3\")(x)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_conv_3x3_bn\")(x)\n+    x = tf.nn.silu(x)\n+\n+    # Squeeze-Excitation block (https://arxiv.org/abs/1709.01507)\n+    x = SqueezeAndExciteBlock(inv_btlneck_filters, se_filters, name=name)\n+\n+    # conv_1x1_2\n+    x = layers.Conv2D(filters_out, (1, 1),\n+                      use_bias=False,\n+                      kernel_initializer=\"he_normal\",\n+                      name=name + \"_conv_1x1_2\")(x)\n+    x = layers.BatchNormalization(momentum=0.9,\n+                                  epsilon=1e-5,\n+                                  name=name + \"_conv_1x1_2_bn\")(x)\n+\n+    if stride != 1:\n+      return x\n+    else:\n+      return x + inputs\n+\n+  return apply\n+\n+\n+def Stage(block_type, depth, group_width, filters_in, filters_out, name=None):\n+  \"\"\"\n+  Implementation of Stage in RegNet.\n+\n+  Args:\n+    block_type: must be one of \"X\", \"Y\", \"Z\"\n+    depth: depth of stage, number of blocks to use\n+    group_width: group width of all blocks in  this stage\n+    filters_in: input filters to this stage\n+    filters_out: output filters from this stage\n+    name: name prefix\n+\n+  Returns:\n+    Output tensor of Stage\n+  \"\"\"\n+  if name is None:\n+    name = str(backend.get_uid(\"stage\"))\n+\n+  def apply(inputs):\n+    x = inputs\n+    if block_type == \"X\":\n+      x = XBlock(filters_in,\n+                 filters_out,\n+                 group_width,\n+                 stride=2,\n+                 name=name + \"_XBlock_0\")(x)\n+      for i in range(depth - 1):\n+        x = XBlock(filters_out,\n+                   filters_out,\n+                   group_width,\n+                   name=name + \"_XBlock_\" + str(i+1))(x)\n+    elif block_type == \"Y\":\n+      x = YBlock(filters_in,\n+                 filters_out,\n+                 group_width,\n+                 stride=2,\n+                 name=name + \"_YBlock_0\")(x)\n+      for i in range(depth - 1):\n+        x = YBlock(filters_out,\n+                   filters_out,\n+                   group_width,\n+                   name=name + \"_YBlock_\" + str(i+1))(x)\n+    elif block_type == \"Z\":\n+      x = ZBlock(filters_in,\n+                 filters_out,\n+                 group_width,\n+                 stride=2,\n+                 name=name + \"_ZBlock_0\")(x)\n+      for i in range(depth - 1):\n+        x = ZBlock(filters_out,\n+                   filters_out,\n+                   group_width,\n+                   name=name + \"_ZBlock_\" + str(i+1))(x)\n+    else:\n+      raise NotImplementedError(f\"\"\"Block type `{block_type}` not recognized. \n+                                block_type must be one of (\"X\", \"Y\", \"Z\"). \"\"\")\n+    return x\n+\n+  return apply\n+\n+\n+def Head(num_classes=1000, name=None):\n+  \"\"\"\n+  Implementation of classification head of RegNet\n+  \n+  Args:\n+  x: Input tensor\n+    num_classes: number of classes for Dense layer\n+  \n+  Returns:\n+    Output logits tensor. \n+  \"\"\"\n+  if name is None:\n+    name = str(backend.get_uid(\"head\"))\n+\n+  def apply(x):\n+    x = layers.GlobalAveragePooling2D(name=name + \"_head_gap\")(x)\n+    x = layers.Dense(num_classes, name=name + \"head_dense\")(x)\n+    return x\n+\n+  return apply\n+\n+\n+def RegNet(depths,\n+           widths,\n+           group_width,\n+           block_type,\n+           default_size,\n+           model_name=\"regnet\",\n+           include_preprocessing=True,\n+           include_top=True,\n+           weights=\"imagenet\",\n+           input_tensor=None,\n+           input_shape=None,\n+           pooling=None,\n+           classes=1000,\n+           classifier_activation=\"softmax\"):\n+  \"\"\" \n+  Instantiates RegNet architecture given specific configuration.\n+\n+  Args:\n+    depths: An iterable containing depths for each individual stages. \n+    widths: An iterable containing output channel width of each individual \n+      stages\n+    group_width: Number of channels to be used in each group. See grouped \n+      convolutions for more information.\n+    block_type: Must be one of {\"x\", \"y\", \"z\"}. For more details see the\n+      papers \"Designing network design spaces\" and \"Fast and Accurate Model \n+      Scaling\"\n+    default_size: Default input image size. \n+    model_name: An optional name for the model.\n+    include_preprocessing: boolean denoting whther to include preprocessing in \n+      the model\n+    include_top: Boolean denoting whether to include classification head to \n+      the model.\n+    weights: one of `None` (random initialization),\n+      \"imagenet\" (pre-training on ImageNet),\n+      or the path to the weights file to be loaded.\n+    input_tensor: optional Keras tensor\n+      (i.e. output of `layers.Input()`)\n+      to use as image input for the model.\n+    input_shape: optional shape tuple, only to be specified\n+      if `include_top` is False.\n+      It should have exactly 3 inputs channels.\n+    pooling: optional pooling mode for feature extraction\n+      when `include_top` is `False`.\n+      - `None` means that the output of the model will be\n+          the 4D tensor output of the\n+          last convolutional layer.\n+      - `avg` means that global average pooling\n+          will be applied to the output of the\n+          last convolutional layer, and thus\n+          the output of the model will be a 2D tensor.\n+      - `max` means that global max pooling will\n+          be applied.\n+    classes: optional number of classes to classify images\n+      into, only to be specified if `include_top` is True, and\n+      if no `weights` argument is specified.\n+    classifier_activation: A `str` or callable. The activation function to use\n+      on the \"top\" layer. Ignored unless `include_top=True`. Set\n+      `classifier_activation=None` to return the logits of the \"top\" layer.        \n+  \n+  Returns:\n+  A `keras.Model` instance.\n+  Raises:\n+      ValueError: in case of invalid argument for `weights`,\n+        or invalid input shape.\n+      ValueError: if `classifier_activation` is not `softmax` or `None` when\n+        using a pretrained top layer.\n+      ValueError: if `include_top` is True but `num_classes` is not 1000.\n+      ValueError: if `block_type` is not one of `{\"X\", \"Y\", \"Z\"}`\n+  \n+  \"\"\"\n+  if not (weights in {\"imagenet\", None} or tf.io.gfile.exists(weights)):\n+    raise ValueError(\"The `weights` argument should be either \"\n+                     \"`None` (random initialization), `imagenet` \"\n+                     \"(pre-training on ImageNet), \"\n+                     \"or the path to the weights file to be loaded.\")\n+\n+  if weights == \"imagenet\" and include_top and classes != 1000:\n+    raise ValueError(\"If using `weights` as `'imagenet'` with `include_top`\"\n+                     \" as true, `classes` should be 1000\")\n+\n+  # Determine proper input shape\n+  input_shape = imagenet_utils.obtain_input_shape(\n+      input_shape,\n+      default_size=default_size,\n+      min_size=32,\n+      data_format=backend.image_data_format(),\n+      require_flatten=include_top,\n+      weights=weights)\n+\n+  if input_tensor is None:\n+    img_input = layers.Input(shape=input_shape)\n+  else:\n+    if not backend.is_keras_tensor(input_tensor):\n+      img_input = layers.Input(tensor=input_tensor, shape=input_shape)\n+    else:\n+      img_input = input_tensor\n+\n+  if input_tensor is not None:\n+    inputs = layer_utils.get_source_inputs(input_tensor)\n+  else:\n+    inputs = img_input\n+\n+  x = inputs\n+  if include_preprocessing:\n+    x = PreStem(name=model_name)(x)\n+  x = Stem(name=model_name)(x)\n+\n+  in_channels = 32  # Output from Stem\n+\n+  for num_stage in range(4):\n+    depth = depths[num_stage]\n+    out_channels = widths[num_stage]\n+\n+    x = Stage(block_type,\n+              depth,\n+              group_width,\n+              in_channels,\n+              out_channels,\n+              name=model_name + \"_Stage_\" + str(num_stage))(x)\n+    in_channels = out_channels\n+\n+  if include_top:\n+    x = Head(num_classes=classes)(x)\n+    imagenet_utils.validate_activation(classifier_activation, weights)\n+\n+  else:\n+    if pooling == \"avg\":\n+      x = layers.GlobalAveragePooling2D()(x)\n+    elif pooling == \"max\":\n+      x = layers.GlobalMaxPooling2D()(x)\n+\n+  model = training.Model(inputs=inputs, outputs=x, name=model_name)\n+\n+  # Load weights.\n+  if weights == \"imagenet\":\n+    if include_top:\n+      file_suffix = \".h5\"\n+      file_hash = WEIGHTS_HASHES[model_name[-2:]][0]\n+    else:\n+      file_suffix = \"_notop.h5\"\n+      file_hash = WEIGHTS_HASHES[model_name[-2:]][1]\n+    file_name = model_name + file_suffix\n+    weights_path = data_utils.get_file(file_name,\n+                                       BASE_WEIGHTS_PATH + file_name,\n+                                       cache_subdir=\"models\",\n+                                       file_hash=file_hash)\n+    model.load_weights(weights_path)\n+  elif weights is not None:\n+    model.load_weights(weights)\n+\n+  return model\n+\n+\n+## Instantiating variants ##\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX002\",\n+              \"keras.applications.RegNetX002\")\n+def RegNetX002(model_name=\"regnetx002\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x002\"][\"depths\"],\n+      MODEL_CONFIGS[\"x002\"][\"widths\"],\n+      MODEL_CONFIGS[\"x002\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x002\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX004\",\n+              \"keras.applications.RegNetX004\")\n+def RegNetX004(model_name=\"regnetx004\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x004\"][\"depths\"],\n+      MODEL_CONFIGS[\"x004\"][\"widths\"],\n+      MODEL_CONFIGS[\"x004\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x004\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX006\",\n+              \"keras.applications.RegNetX006\")\n+def RegNetX006(model_name=\"regnetx006\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x006\"][\"depths\"],\n+      MODEL_CONFIGS[\"x006\"][\"widths\"],\n+      MODEL_CONFIGS[\"x006\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x006\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX008\",\n+              \"keras.applications.RegNetX008\")\n+def RegNetX008(model_name=\"regnetx008\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x008\"][\"depths\"],\n+      MODEL_CONFIGS[\"x008\"][\"widths\"],\n+      MODEL_CONFIGS[\"x008\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x008\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX016\",\n+              \"keras.applications.RegNetX016\")\n+def RegNetX016(model_name=\"regnetx016\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x016\"][\"depths\"],\n+      MODEL_CONFIGS[\"x016\"][\"widths\"],\n+      MODEL_CONFIGS[\"x016\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x016\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX032\",\n+              \"keras.applications.RegNetX032\")\n+def RegNetX032(model_name=\"regnetx032\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x032\"][\"depths\"],\n+      MODEL_CONFIGS[\"x032\"][\"widths\"],\n+      MODEL_CONFIGS[\"x032\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x032\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX040\",\n+              \"keras.applications.RegNetX040\")\n+def RegNetX040(model_name=\"regnetx040\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x040\"][\"depths\"],\n+      MODEL_CONFIGS[\"x040\"][\"widths\"],\n+      MODEL_CONFIGS[\"x040\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x040\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX064\",\n+              \"keras.applications.RegNetX064\")\n+def RegNetX064(model_name=\"regnetx064\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x064\"][\"depths\"],\n+      MODEL_CONFIGS[\"x064\"][\"widths\"],\n+      MODEL_CONFIGS[\"x064\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x064\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX080\",\n+              \"keras.applications.RegNetX080\")\n+def RegNetX080(model_name=\"regnetx080\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x080\"][\"depths\"],\n+      MODEL_CONFIGS[\"x080\"][\"widths\"],\n+      MODEL_CONFIGS[\"x080\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x080\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX120\",\n+              \"keras.applications.RegNetX120\")\n+def RegNetX120(model_name=\"regnetx120\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x120\"][\"depths\"],\n+      MODEL_CONFIGS[\"x120\"][\"widths\"],\n+      MODEL_CONFIGS[\"x120\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x120\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX160\",\n+              \"keras.applications.RegNetX160\")\n+def RegNetX160(model_name=\"regnetx160\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x160\"][\"depths\"],\n+      MODEL_CONFIGS[\"x160\"][\"widths\"],\n+      MODEL_CONFIGS[\"x160\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x160\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetX320\",\n+              \"keras.applications.RegNetX320\")\n+def RegNetX320(model_name=\"regnetx320\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"x320\"][\"depths\"],\n+      MODEL_CONFIGS[\"x320\"][\"widths\"],\n+      MODEL_CONFIGS[\"x320\"][\"group_width\"],\n+      \"X\",\n+      MODEL_CONFIGS[\"x320\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY002\",\n+              \"keras.applications.RegNetY002\")\n+def RegNetY002(model_name=\"regnety002\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y002\"][\"depths\"],\n+      MODEL_CONFIGS[\"y002\"][\"widths\"],\n+      MODEL_CONFIGS[\"y002\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y002\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY004\",\n+              \"keras.applications.RegNetY004\")\n+def RegNetY004(model_name=\"regnety004\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y004\"][\"depths\"],\n+      MODEL_CONFIGS[\"y004\"][\"widths\"],\n+      MODEL_CONFIGS[\"y004\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y004\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY006\",\n+              \"keras.applications.RegNetY006\")\n+def RegNetY006(model_name=\"regnety006\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y006\"][\"depths\"],\n+      MODEL_CONFIGS[\"y006\"][\"widths\"],\n+      MODEL_CONFIGS[\"y006\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y006\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY008\",\n+              \"keras.applications.RegNetY008\")\n+def RegNetY008(model_name=\"regnety008\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y008\"][\"depths\"],\n+      MODEL_CONFIGS[\"y008\"][\"widths\"],\n+      MODEL_CONFIGS[\"y008\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y008\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY016\",\n+              \"keras.applications.RegNetY016\")\n+def RegNetY016(model_name=\"regnety016\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y016\"][\"depths\"],\n+      MODEL_CONFIGS[\"y016\"][\"widths\"],\n+      MODEL_CONFIGS[\"y016\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y016\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY032\",\n+              \"keras.applications.RegNetY032\")\n+def RegNetY032(model_name=\"regnety032\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y032\"][\"depths\"],\n+      MODEL_CONFIGS[\"y032\"][\"widths\"],\n+      MODEL_CONFIGS[\"y032\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y032\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY040\",\n+              \"keras.applications.RegNetY040\")\n+def RegNetY040(model_name=\"regnety040\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y040\"][\"depths\"],\n+      MODEL_CONFIGS[\"y040\"][\"widths\"],\n+      MODEL_CONFIGS[\"y040\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y040\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY064\",\n+              \"keras.applications.RegNetY064\")\n+def RegNetY064(model_name=\"regnety064\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y064\"][\"depths\"],\n+      MODEL_CONFIGS[\"y064\"][\"widths\"],\n+      MODEL_CONFIGS[\"y064\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y064\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY080\",\n+              \"keras.applications.RegNetY080\")\n+def RegNetY080(model_name=\"regnety080\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y080\"][\"depths\"],\n+      MODEL_CONFIGS[\"y080\"][\"widths\"],\n+      MODEL_CONFIGS[\"y080\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y080\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY120\",\n+              \"keras.applications.RegNetY120\")\n+def RegNetY120(model_name=\"regnety120\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y120\"][\"depths\"],\n+      MODEL_CONFIGS[\"y120\"][\"widths\"],\n+      MODEL_CONFIGS[\"y120\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y120\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY160\",\n+              \"keras.applications.RegNetY160\")\n+def RegNetY160(model_name=\"regnety160\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y160\"][\"depths\"],\n+      MODEL_CONFIGS[\"y160\"][\"widths\"],\n+      MODEL_CONFIGS[\"y160\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y160\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n+\n+\n+@keras_export(\"keras.applications.regnet.RegNetY320\",\n+              \"keras.applications.RegNetY320\")\n+def RegNetY320(model_name=\"regnety320\",\n+               include_top=True,\n+               include_preprocessing=True,\n+               weights=None,\n+               input_tensor=None,\n+               input_shape=None,\n+               pooling=None,\n+               classes=1000,\n+               classifier_activation='softmax'):\n+  return RegNet(\n+      MODEL_CONFIGS[\"y320\"][\"depths\"],\n+      MODEL_CONFIGS[\"y320\"][\"widths\"],\n+      MODEL_CONFIGS[\"y320\"][\"group_width\"],\n+      \"Y\",\n+      MODEL_CONFIGS[\"y320\"][\"default_size\"],\n+      model_name=model_name,\n+      include_top=include_top,\n+      include_preprocessing=include_preprocessing,\n+      weights=weights,\n+      input_tensor=input_tensor,\n+      input_shape=input_shape,\n+      pooling=pooling,\n+      classes=classes,\n+      classifier_activation=classifier_activation\n+  )\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The current implementation of RegNetX models shows a discrepancy in accuracy compared to the paper, with a 2-3% shortfall across different model variants. While you've made progress, especially with the smallest model reaching closer to expected validation accuracy, consider refining the preprocessing to allow users the option for built-in vs. custom methods. Additionally, the recent build errors regarding proto imports suggest a need for updates in the API generation logic to ensure the new models are correctly integrated. Check the relevant `.bzl` files for the necessary adjustments."
      }
    ],
    "token_estimation": 12814.75
  },
  {
    "index": 45,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/keras/src/backend/openvino/core.py b/keras/src/backend/openvino/core.py\nnew file mode 100644\nindex 000000000000..4daf2a61bbb6\n--- /dev/null\n+++ b/keras/src/backend/openvino/core.py\n@@ -0,0 +1,614 @@\n+import contextlib\n+import warnings\n+\n+import numpy as np\n+import openvino as ov\n+import openvino.runtime.opset14 as ov_opset\n+from openvino import Model\n+from openvino import Tensor\n+from openvino import compile_model\n+from openvino.runtime import Type\n+\n+from keras.src import tree\n+from keras.src.backend.common import KerasVariable\n+from keras.src.backend.common import dtypes\n+from keras.src.backend.common import global_state\n+from keras.src.backend.common import standardize_dtype\n+from keras.src.backend.common.dtypes import result_type\n+from keras.src.backend.common.keras_tensor import KerasTensor\n+from keras.src.backend.common.stateless_scope import StatelessScope\n+\n+SUPPORTS_SPARSE_TENSORS = False\n+IS_THREAD_SAFE = True\n+\n+OPENVINO_DTYPES = {\n+    \"float16\": ov.Type.f16,\n+    \"float32\": ov.Type.f32,\n+    \"float64\": ov.Type.f64,\n+    \"uint8\": ov.Type.u8,\n+    \"uint16\": ov.Type.u16,\n+    \"uint32\": ov.Type.u32,\n+    \"uint64\": ov.Type.u64,\n+    \"int8\": ov.Type.i8,\n+    \"int16\": ov.Type.i16,\n+    \"int32\": ov.Type.i32,\n+    \"int64\": ov.Type.i64,\n+    \"bfloat16\": ov.Type.bf16,\n+    \"bool\": ov.Type.boolean,\n+    \"float8_e4m3fn\": ov.Type.f8e4m3,\n+    \"float8_e5m2\": ov.Type.f8e5m2,\n+    \"string\": ov.Type.string,\n+}\n+\n+\n+def align_operand_types(x1, x2, op_name):\n+    x1_type = x1.element_type\n+    x2_type = x2.element_type\n+    if x1_type.is_dynamic() or x2_type.is_dynamic():\n+        raise ValueError(\n+            f\"'{op_name}' operation is not supported for dynamic operand type \"\n+            \"with openvino backend\"\n+        )\n+    x1_type = ov_to_keras_type(x1_type)\n+    x2_type = ov_to_keras_type(x2_type)\n+    result_type = dtypes.result_type(x1_type, x2_type)\n+    result_type = OPENVINO_DTYPES[result_type]\n+    if x1_type != result_type:\n+        x1 = ov_opset.convert(x1, result_type).output(0)\n+    if x2_type != result_type:\n+        x2 = ov_opset.convert(x2, result_type).output(0)\n+    return x1, x2\n+\n+\n+# create ov.Output (symbolic OpenVINO tensor)\n+# for different input `x`\n+def get_ov_output(x, ov_type=None):\n+    if isinstance(x, float):\n+        if ov_type is None:\n+            ov_type = Type.f32\n+        x = ov_opset.constant(x, ov_type).output(0)\n+    elif isinstance(x, int):\n+        if ov_type is None:\n+            ov_type = Type.i32\n+        x = ov_opset.constant(x, ov_type).output(0)\n+    elif isinstance(x, np.ndarray):\n+        x = ov_opset.constant(x).output(0)\n+    elif np.isscalar(x):\n+        x = ov_opset.constant(x).output(0)\n+    elif isinstance(x, KerasVariable):\n+        if isinstance(x.value, OpenVINOKerasTensor):\n+            return x.value.output\n+        x = ov_opset.constant(x.value.data).output(0)\n+    elif isinstance(x, OpenVINOKerasTensor):\n+        x = x.output\n+    elif isinstance(x, Tensor):\n+        x = ov_opset.constant(x.data).output(0)\n+    else:\n+        raise ValueError(\n+            \"unsupported type of `x` to create ov.Output: {}\".format(type(x))\n+        )\n+    return x\n+\n+\n+# wrapper for OpenVINO symbolic tensor ov.Output\n+# that provides interface similar to KerasTensor\n+# with dtype and shape members\n+class OpenVINOKerasTensor:\n+    def __init__(self, x, data=None):\n+        x_shape = x.get_partial_shape()\n+        if x_shape.rank.is_dynamic:\n+            x_keras_shape = None\n+        else:\n+            x_keras_shape = [\n+                None if dim.is_dynamic else dim.get_length()\n+                for dim in list(x_shape)\n+            ]\n+        x_type = x.get_element_type()\n+        x_keras_type = ov_to_keras_type(x_type)\n+        self.output = x\n+        self.shape = tuple(x_keras_shape)\n+        self.dtype = x_keras_type\n+        self.ndim = None\n+        self.data = data\n+        if x.get_partial_shape().rank.is_static:\n+            self.ndim = x.get_partial_shape().rank.get_length()\n+\n+    def __add__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__add__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.add(first, other).output(0))\n+\n+    def __radd__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__radd__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.add(first, other).output(0))\n+\n+    def __sub__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__sub__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.subtract(first, other).output(0))\n+\n+    def __rsub__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__rsub__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.subtract(other, first).output(0))\n+\n+    def __mul__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__mul__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.multiply(first, other).output(0))\n+\n+    def __rmul__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__rmul__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.multiply(first, other).output(0))\n+\n+    def __truediv__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__truediv__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.divide(first, other).output(0))\n+\n+    def __rtruediv__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__rtruediv__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.divide(other, first).output(0))\n+\n+    def __floordiv__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__floordiv__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.divide(first, other).output(0))\n+\n+    def __rfloordiv__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__rfloordiv__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.divide(other, first).output(0))\n+\n+    def __neg__(self):\n+        first = self.output\n+        return OpenVINOKerasTensor(ov_opset.negative(first).output(0))\n+\n+    def __abs__(self):\n+        first = self.output\n+        return OpenVINOKerasTensor(ov_opset.absolute(first).output(0))\n+\n+    def __invert__(self):\n+        first = self.output\n+        return OpenVINOKerasTensor(ov_opset.logical_not(first).output(0))\n+\n+    def __pow__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__pow__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.power(first, other).output(0))\n+\n+    def __getitem__(self, indices):\n+        # now it has limited functionaly\n+        # and supports only a case with one integer index in indices\n+        # other indices must be None\n+        data = self.output\n+        axis = []\n+        gather_index = None\n+        if isinstance(indices, int):\n+            indices = (indices,)\n+        assert isinstance(indices, tuple), \"only tuple is supported\"\n+        for dim, index in enumerate(indices):\n+            if isinstance(index, int):\n+                axis.append(dim)\n+                gather_index = ov_opset.constant(index, Type.i32)\n+            else:\n+                assert (\n+                    index.start is None\n+                    and index.stop is None\n+                    and index.step is None\n+                )\n+        assert len(axis) == 1, \"axis must contain one element\"\n+        axis = ov_opset.constant(axis, Type.i32)\n+        return OpenVINOKerasTensor(\n+            ov_opset.gather(data, gather_index, axis).output(0)\n+        )\n+\n+    def __len__(self):\n+        ov_output = self.output\n+        ov_shape = ov_output.get_partial_shape()\n+        assert (\n+            ov_shape.rank.is_static and ov_shape.rank.get_length() > 0\n+        ), \"rank must be static and greater than zero\"\n+        assert ov_shape[0].is_static, \"the first dimension must be static\"\n+        return ov_shape[0].get_length()\n+\n+    def __mod__(self, other):\n+        first = self.output\n+        other = get_ov_output(other)\n+        first, other = align_operand_types(\n+            first, other, \"OpenVINOKerasTensor::__mod__\"\n+        )\n+        return OpenVINOKerasTensor(ov_opset.mod(first, other).output(0))\n+\n+\n+def ov_to_keras_type(ov_type):\n+    for _keras_type, _ov_type in OPENVINO_DTYPES.items():\n+        if ov_type == _ov_type:\n+            return _keras_type\n+    raise ValueError(\n+        f\"Requested OpenVINO type has no keras analogue '{ov_type.to_string()}'\"\n+    )\n+\n+\n+@contextlib.contextmanager\n+def device_scope(device_name):\n+    current_device = _parse_device_input(device_name)\n+    global_state.set_global_attribute(\"openvino_device\", current_device)\n+\n+\n+def get_device():\n+    device = global_state.get_global_attribute(\"openvino_device\", None)\n+    if device is None:\n+        return \"CPU\"\n+    return device\n+\n+\n+def _parse_device_input(device_name):\n+    if isinstance(device_name, str):\n+        # We support string value like \"cpu:0\", \"gpu:1\", and need to convert\n+        # \"gpu\" to \"cuda\"\n+        device_name = device_name.upper()\n+        device_type, _ = device_name.split(\":\")\n+        return device_type\n+    else:\n+        raise ValueError(\n+            \"Invalid value for argument `device_name`. \"\n+            \"Expected a string like 'gpu:0' or 'cpu'. \"\n+            f\"Received: device_name='{device_name}'\"\n+        )\n+    return device_name\n+\n+\n+class Variable(KerasVariable):\n+    def _initialize(self, value):\n+        if isinstance(value, OpenVINOKerasTensor):\n+            self._value = value\n+        elif isinstance(value, Tensor):\n+            value_const = ov_opset.constant(\n+                value.data, dtype=OPENVINO_DTYPES[self._dtype]\n+            )\n+            self._value = OpenVINOKerasTensor(value_const.output(0))\n+        else:\n+            value_const = ov_opset.constant(\n+                value, dtype=OPENVINO_DTYPES[self._dtype]\n+            )\n+            self._value = OpenVINOKerasTensor(value_const.output(0))\n+\n+    def _direct_assign(self, value):\n+        self._value = value\n+\n+    def _convert_to_tensor(self, value, dtype=None):\n+        return convert_to_tensor(value, dtype=dtype)\n+\n+    def __array__(self):\n+        if isinstance(self.value, OpenVINOKerasTensor):\n+            return self.value.output.get_node().data\n+        return self.value.data\n+\n+    def __getitem__(self, idx):\n+        if isinstance(self.value, OpenVINOKerasTensor):\n+            arr = self.value.output.get_node().data\n+            return arr.__getitem__(idx)\n+        return self.value.__getitem__(idx)\n+\n+    def __int__(self):\n+        if isinstance(self.value, OpenVINOKerasTensor):\n+            arr = self.value.output.get_node().data\n+        else:\n+            arr = self.value.data\n+        if arr.ndim > 0:\n+            raise TypeError(\n+                \"Only scalar arrays can be converted to Python scalars. \"\n+                f\"Got: shape={arr.shape}\"\n+            )\n+        return int(arr)\n+\n+    def __float__(self):\n+        if isinstance(self.value, OpenVINOKerasTensor):\n+            arr = self.value.output.get_node().data\n+        else:\n+            arr = self.value.data\n+        if arr.ndim > 0:\n+            raise TypeError(\n+                \"Only scalar arrays can be converted to Python scalars. \"\n+                f\"Got: shape={arr.shape}\"\n+            )\n+        return float(arr)\n+\n+\n+def _is_scalar(elem):\n+    return not isinstance(elem, (list, tuple, set, dict))\n+\n+\n+def _get_first_element(x):\n+    if isinstance(x, (tuple, list)):\n+        for elem_in_x in x:\n+            elem = _get_first_element(elem_in_x)\n+            if elem is not None:\n+                return elem\n+    elif _is_scalar(x):\n+        return x\n+    return None\n+\n+\n+def convert_to_tensor(x, dtype=None, sparse=None):\n+    if sparse:\n+        raise ValueError(\"`sparse=True` is not supported with openvino backend\")\n+    if isinstance(x, OpenVINOKerasTensor):\n+        return x\n+    elif isinstance(x, np.ndarray):\n+        if dtype is not None:\n+            dtype = standardize_dtype(dtype)\n+            ov_type = OPENVINO_DTYPES[dtype]\n+            return OpenVINOKerasTensor(ov_opset.constant(x, ov_type).output(0))\n+        return OpenVINOKerasTensor(ov_opset.constant(x).output(0))\n+    elif isinstance(x, (list, tuple)):\n+        if dtype is not None:\n+            dtype = standardize_dtype(dtype)\n+        else:\n+            # try to properly deduce element type\n+            elem = _get_first_element(x)\n+            if isinstance(elem, float):\n+                dtype = \"float32\"\n+            elif isinstance(elem, int):\n+                dtype = \"int32\"\n+        x = np.array(x, dtype=dtype)\n+        return OpenVINOKerasTensor(ov_opset.constant(x).output(0), x)\n+    elif isinstance(x, (float, int)):\n+        dtype = standardize_dtype(dtype)\n+        ov_type = OPENVINO_DTYPES[dtype]\n+        return OpenVINOKerasTensor(ov_opset.constant(x, ov_type).output(0), x)\n+    if dtype is not None:\n+        dtype = standardize_dtype(dtype)\n+    if isinstance(x, Variable):\n+        if dtype and dtype != x.dtype:\n+            return x.value.astype(dtype)\n+        return x.value\n+    if not is_tensor(x) and standardize_dtype(dtype) == \"bfloat16\":\n+        return ov.Tensor(np.asarray(x).astype(dtype))\n+    if dtype is None:\n+        dtype = result_type(\n+            *[getattr(item, \"dtype\", type(item)) for item in tree.flatten(x)]\n+        )\n+    return ov.Tensor(np.array(x, dtype=dtype))\n+\n+\n+def convert_to_numpy(x):\n+    if isinstance(x, np.ndarray):\n+        return x\n+    elif isinstance(x, (int, float, list, tuple)):\n+        return np.array(x)\n+    elif np.isscalar(x):\n+        return x\n+    elif isinstance(x, ov.Tensor):\n+        return x.data\n+    elif x is None:\n+        return x\n+    elif isinstance(x, KerasVariable):\n+        if isinstance(x.value, OpenVINOKerasTensor):\n+            x = x.value\n+        else:\n+            return x.value.data\n+    assert isinstance(\n+        x, OpenVINOKerasTensor\n+    ), \"unsupported type {} for `convert_to_numpy` in openvino backend\".format(\n+        type(x)\n+    )\n+    try:\n+        ov_result = x.output\n+        ov_model = Model(results=[ov_result], parameters=[])\n+        ov_compiled_model = compile_model(ov_model, get_device())\n+        result = ov_compiled_model({})[0]\n+    except:\n+        raise \"`convert_to_numpy` cannot convert to numpy\"\n+    return result\n+\n+\n+def is_tensor(x):\n+    if isinstance(x, OpenVINOKerasTensor):\n+        return True\n+    if isinstance(x, ov.Tensor):\n+        return True\n+    return False\n+\n+\n+def shape(x):\n+    return tuple(x.shape)\n+\n+\n+def cast(x, dtype):\n+    ov_type = OPENVINO_DTYPES[dtype]\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.convert(x, ov_type).output(0))\n+\n+\n+def cond(pred, true_fn, false_fn):\n+    raise NotImplementedError(\"`cond` is not supported with openvino backend\")\n+\n+\n+def vectorized_map(function, elements):\n+    raise NotImplementedError(\n+        \"`vectorized_map` is not supported with openvino backend\"\n+    )\n+\n+\n+# Shape / dtype inference util\n+def compute_output_spec(fn, *args, **kwargs):\n+    with StatelessScope():\n+\n+        def convert_keras_tensor_to_openvino(x):\n+            if isinstance(x, KerasTensor):\n+                x_shape = list(x.shape)\n+                x_shape = [-1 if dim is None else dim for dim in x_shape]\n+                x_type = OPENVINO_DTYPES[x.dtype]\n+                param = ov_opset.parameter(shape=x_shape, dtype=x_type)\n+                return OpenVINOKerasTensor(param.output(0))\n+            return x\n+\n+        args_1, kwargs_1 = tree.map_structure(\n+            lambda x: convert_keras_tensor_to_openvino(x),\n+            (args, kwargs),\n+        )\n+        outputs_1 = fn(*args_1, **kwargs_1)\n+\n+        outputs = outputs_1\n+\n+        def convert_openvino_to_keras_tensor(x):\n+            if is_tensor(x):\n+                x_type = x.dtype\n+                x_shape = x.shape\n+                return KerasTensor(x_shape, x_type)\n+            elif isinstance(x, OpenVINOKerasTensor):\n+                x_type = x.dtype\n+                x_shape = x.shape\n+                return KerasTensor(x_shape, x_type)\n+            return x\n+\n+        output_spec = tree.map_structure(\n+            convert_openvino_to_keras_tensor, outputs\n+        )\n+    return output_spec\n+\n+\n+def scan(f, init, xs=None, length=None, reverse=False, unroll=1):\n+    raise NotImplementedError(\"`scan` is not supported with openvino backend\")\n+\n+\n+def scatter(indices, values, shape):\n+    raise NotImplementedError(\n+        \"`scatter` is not supported with openvino backend\"\n+    )\n+\n+\n+def scatter_update(inputs, indices, updates):\n+    raise NotImplementedError(\n+        \"`scatter_update` is not supported with openvino backend\"\n+    )\n+\n+\n+def slice(inputs, start_indices, lengths):\n+    inputs = get_ov_output(inputs)\n+    assert isinstance(start_indices, tuple), (\n+        \"`slice` is not supported by openvino backend\"\n+        \" for `start_indices` of type {}\".format(type(lengths))\n+    )\n+    assert isinstance(lengths, tuple), (\n+        \"`slice` is not supported by openvino backend\"\n+        \" for `lengths` of type {}\".format(type(lengths))\n+    )\n+\n+    axes = []\n+    start = []\n+    stop = []\n+    for idx, length in enumerate(lengths):\n+        if length is not None and length >= 0:\n+            axes.append(idx)\n+            start.append(start_indices[idx])\n+            stop.append(start_indices[idx] + length)\n+\n+    if len(axes) == 0:\n+        return inputs\n+\n+    step = [1] * len(start)\n+    step = ov_opset.constant(step, Type.i32).output(0)\n+    start = ov_opset.constant(start, Type.i32).output(0)\n+    stop = ov_opset.constant(stop, Type.i32).output(0)\n+    axes = ov_opset.constant(axes, Type.i32).output(0)\n+    return OpenVINOKerasTensor(\n+        ov_opset.slice(inputs, start, stop, step, axes).output(0)\n+    )\n+\n+\n+def slice_update(inputs, start_indices, updates):\n+    raise NotImplementedError(\n+        \"`slice_update` is not supported with openvino backend\"\n+    )\n+\n+\n+def while_loop(\n+    cond,\n+    body,\n+    loop_vars,\n+    maximum_iterations=None,\n+):\n+    raise NotImplementedError(\n+        \"`while_loop` is not supported with openvino backend\"\n+    )\n+\n+\n+def fori_loop(lower, upper, body_fun, init_val):\n+    raise NotImplementedError(\n+        \"`fori_loop` is not supported with openvino backend\"\n+    )\n+\n+\n+def stop_gradient(x):\n+    return x\n+\n+\n+def unstack(x, num=None, axis=0):\n+    raise NotImplementedError(\n+        \"`unstack` is not supported with openvino backend\"\n+    )\n+\n+\n+def random_seed_dtype():\n+    return \"uint32\"\n+\n+\n+def custom_gradient(fun):\n+    \"\"\"Decorator for custom gradients.\n+\n+    Args:\n+        fun: Forward pass function.\n+    \"\"\"\n+\n+    def __init__(self, fun):\n+        warnings.warn(\n+            \"`custom_gradient` for the openvino backend\"\n+            \" acts as a pass-through to \"\n+            \"support the forward pass.\"\n+            \" No gradient computation or modification \"\n+            \"takes place.\"\n+        )\n+        self.fun = fun\n+\n+    def __call__(self, *args, **kwargs):\n+        outputs, _ = self.fun(*args, **kwargs)\n+        return outputs\ndiff --git a/keras/src/backend/openvino/linalg.py b/keras/src/backend/openvino/linalg.py\nnew file mode 100644\nindex 000000000000..3703bd83a0c1\n--- /dev/null\n+++ b/keras/src/backend/openvino/linalg.py\n@@ -0,0 +1,52 @@\n+def cholesky(a):\n+    raise NotImplementedError(\n+        \"`cholesky` is not supported with openvino backend\"\n+    )\n+\n+\n+def det(a):\n+    raise NotImplementedError(\"`det` is not supported with openvino backend\")\n+\n+\n+def eig(a):\n+    raise NotImplementedError(\"`eig` is not supported with openvino backend\")\n+\n+\n+def eigh(a):\n+    raise NotImplementedError(\"`eigh` is not supported with openvino backend\")\n+\n+\n+def inv(a):\n+    raise NotImplementedError(\"`inv` is not supported with openvino backend\")\n+\n+\n+def lu_factor(a):\n+    raise NotImplementedError(\n+        \"`lu_factor` is not supported with openvino backend\"\n+    )\n+\n+\n+def norm(x, ord=None, axis=None, keepdims=False):\n+    raise NotImplementedError(\"`norm` is not supported with openvino backend\")\n+\n+\n+def qr(x, mode=\"reduced\"):\n+    raise NotImplementedError(\"`qr` is not supported with openvino backend\")\n+\n+\n+def solve(a, b):\n+    raise NotImplementedError(\"`solve` is not supported with openvino backend\")\n+\n+\n+def solve_triangular(a, b, lower=False):\n+    raise NotImplementedError(\n+        \"`solve_triangular` is not supported with openvino backend\"\n+    )\n+\n+\n+def svd(x, full_matrices=True, compute_uv=True):\n+    raise NotImplementedError(\"`svd` is not supported with openvino backend\")\n+\n+\n+def lstsq(a, b, rcond=None):\n+    raise NotImplementedError(\"`lstsq` is not supported with openvino backend\")\ndiff --git a/keras/src/backend/openvino/math.py b/keras/src/backend/openvino/math.py\nnew file mode 100644\nindex 000000000000..17f4673f1349\n--- /dev/null\n+++ b/keras/src/backend/openvino/math.py\n@@ -0,0 +1,117 @@\n+import openvino.runtime.opset14 as ov_opset\n+from openvino import Type\n+\n+from keras.src.backend.openvino.core import OpenVINOKerasTensor\n+from keras.src.backend.openvino.core import get_ov_output\n+\n+\n+def segment_sum(data, segment_ids, num_segments=None, sorted=False):\n+    raise NotImplementedError(\n+        \"`segment_sum` is not supported with openvino backend\"\n+    )\n+\n+\n+def segment_max(data, segment_ids, num_segments=None, sorted=False):\n+    raise NotImplementedError(\n+        \"`segment_max` is not supported with openvino backend\"\n+    )\n+\n+\n+def top_k(x, k, sorted=False):\n+    raise NotImplementedError(\"`top_k` is not supported with openvino backend\")\n+\n+\n+def in_top_k(targets, predictions, k):\n+    raise NotImplementedError(\n+        \"`in_top_k` is not supported with openvino backend\"\n+    )\n+\n+\n+def logsumexp(x, axis=None, keepdims=False):\n+    x = get_ov_output(x)\n+    if axis is None:\n+        flatten_shape = ov_opset.constant([-1], Type.i32).output(0)\n+        x = ov_opset.reshape(x, flatten_shape, False).output(0)\n+        axis = 0\n+    if isinstance(axis, tuple):\n+        axis = list(axis)\n+    axis = ov_opset.constant(axis, Type.i32).output(0)\n+    const_zero = ov_opset.constant(0, x.get_element_type()).output(0)\n+    reduce_max = ov_opset.reduce_max(x, axis, keepdims).output(0)\n+    is_finite = ov_opset.is_finite(reduce_max).output(0)\n+    norm_max = ov_opset.select(is_finite, reduce_max, const_zero).output(0)\n+    norm_max_sub = ov_opset.subtract(x, norm_max).output(0)\n+    exp_norm_max = ov_opset.exp(norm_max_sub).output(0)\n+    sum_exp = ov_opset.reduce_sum(exp_norm_max, axis, keepdims).output(0)\n+    log_sum_exp = ov_opset.log(sum_exp).output(0)\n+    log_sum_exp = ov_opset.add(norm_max, log_sum_exp).output(0)\n+    return OpenVINOKerasTensor(log_sum_exp)\n+\n+\n+def qr(x, mode=\"reduced\"):\n+    raise NotImplementedError(\"`qr` is not supported with openvino backend\")\n+\n+\n+def extract_sequences(x, sequence_length, sequence_stride):\n+    raise NotImplementedError(\n+        \"`extract_sequences` is not supported with openvino backend\"\n+    )\n+\n+\n+def fft(x):\n+    raise NotImplementedError(\"`fft` is not supported with openvino backend\")\n+\n+\n+def fft2(x):\n+    raise NotImplementedError(\"`fft2` is not supported with openvino backend\")\n+\n+\n+def rfft(x, fft_length=None):\n+    raise NotImplementedError(\"`rfft` is not supported with openvino backend\")\n+\n+\n+def irfft(x, fft_length=None):\n+    raise NotImplementedError(\"`irfft` is not supported with openvino backend\")\n+\n+\n+def stft(\n+    x, sequence_length, sequence_stride, fft_length, window=\"hann\", center=True\n+):\n+    raise NotImplementedError(\"`stft` is not supported with openvino backend\")\n+\n+\n+def istft(\n+    x,\n+    sequence_length,\n+    sequence_stride,\n+    fft_length,\n+    length=None,\n+    window=\"hann\",\n+    center=True,\n+):\n+    raise NotImplementedError(\"`istft` is not supported with openvino backend\")\n+\n+\n+def rsqrt(x):\n+    x = get_ov_output(x)\n+    const_one = ov_opset.constant(1, x.get_element_type()).output(0)\n+    sqrt = ov_opset.sqrt(x).output(0)\n+    return OpenVINOKerasTensor(ov_opset.divide(const_one, sqrt).output(0))\n+\n+\n+def erf(x):\n+    x = get_ov_output(x)\n+    erf = ov_opset.erf(x).output(0)\n+    return OpenVINOKerasTensor(erf)\n+\n+\n+def erfinv(x):\n+    raise NotImplementedError(\"`erfinv` is not supported with openvino backend\")\n+\n+\n+def solve(a, b):\n+    raise NotImplementedError(\"`solve` is not supported with openvino backend\")\n+\n+\n+def norm(x, ord=None, axis=None, keepdims=False):\n+    raise NotImplementedError(\"`norm` is not supported with openvino backend\")\ndiff --git a/keras/src/backend/openvino/nn.py b/keras/src/backend/openvino/nn.py\nnew file mode 100644\nindex 000000000000..fcd9a8bb1b03\n--- /dev/null\n+++ b/keras/src/backend/openvino/nn.py\n@@ -0,0 +1,490 @@\n+import openvino.runtime.opset14 as ov_opset\n+from openvino import Type\n+\n+from keras.src import backend\n+from keras.src.backend.openvino.core import OpenVINOKerasTensor\n+from keras.src.backend.openvino.core import get_ov_output\n+\n+\n+def relu(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.relu(x).output(0))\n+\n+\n+def relu6(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.clamp(x, 0.0, 6.0).output(0))\n+\n+\n+def sigmoid(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.sigmoid(x).output(0))\n+\n+\n+def tanh(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.tanh(x).output(0))\n+\n+\n+def softplus(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.softplus(x).output(0))\n+\n+\n+def softsign(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.softsign(x).output(0))\n+\n+\n+def silu(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(\n+        ov_opset.multiply(x, ov_opset.sigmoid(x)).output(0)\n+    )\n+\n+\n+def log_sigmoid(x):\n+    raise NotImplementedError(\n+        \"`log_sigmoid` is not supported with openvino backend\"\n+    )\n+\n+\n+def leaky_relu(x, negative_slope=0.2):\n+    x = get_ov_output(x)\n+    slope_const = ov_opset.constant(\n+        negative_slope, x.get_element_type()\n+    ).output(0)\n+    leaky_relu = ov_opset.prelu(x, slope_const).output(0)\n+    return OpenVINOKerasTensor(leaky_relu)\n+\n+\n+def hard_sigmoid(x):\n+    x = get_ov_output(x)\n+    alpha = get_ov_output(1.0 / 6.0, x.get_element_type())\n+    beta = get_ov_output(0.5, x.get_element_type())\n+    return OpenVINOKerasTensor(ov_opset.hard_sigmoid(x, alpha, beta).output(0))\n+\n+\n+def hard_silu(x):\n+    hard_sigmoid_output = get_ov_output(hard_sigmoid(x))\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(\n+        ov_opset.multiply(x, hard_sigmoid_output).output(0)\n+    )\n+\n+\n+def elu(x, alpha=1.0):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.elu(x, alpha).output(0))\n+\n+\n+def selu(\n+    x,\n+    alpha=1.6732632423543772848170429916717,\n+    scale=1.0507009873554804934193349852946,\n+):\n+    x = get_ov_output(x)\n+    alpha = get_ov_output(alpha, x.get_element_type())\n+    scale = get_ov_output(scale, x.get_element_type())\n+    return OpenVINOKerasTensor(ov_opset.selu(x, alpha, scale).output(0))\n+\n+\n+def gelu(x, approximate=True):\n+    x = get_ov_output(x)\n+    approximate_mode = \"erf\"\n+    if approximate:\n+        approximate_mode = \"tanh\"\n+    return OpenVINOKerasTensor(ov_opset.gelu(x, approximate_mode).output(0))\n+\n+\n+def softmax(x, axis=None):\n+    x = get_ov_output(x)\n+    if axis is None:\n+        x_shape = ov_opset.shape_of(x)\n+        flatten_shape = ov_opset.constant([-1], Type.i32).output(0)\n+        flatten_x = ov_opset.reshape(x, flatten_shape, False).output(0)\n+        softmax_x = ov_opset.softmax(flatten_x, 0).output(0)\n+        return OpenVINOKerasTensor(\n+            ov_opset.reshape(softmax_x, x_shape, False).output(0)\n+        )\n+    return OpenVINOKerasTensor(ov_opset.softmax(x, axis).output(0))\n+\n+\n+def log_softmax(x, axis=None):\n+    x = get_ov_output(x)\n+    if axis is None:\n+        x_shape = ov_opset.shape_of(x)\n+        flatten_shape = ov_opset.constant([-1], Type.i32).output(0)\n+        flatten_x = ov_opset.reshape(x, flatten_shape, False).output(0)\n+        log_softmax_x = ov_opset.log_softmax(flatten_x, 0).output(0)\n+        return OpenVINOKerasTensor(\n+            ov_opset.reshape(log_softmax_x, x_shape, False).output(0)\n+        )\n+    return OpenVINOKerasTensor(ov_opset.log_softmax(x, axis).output(0))\n+\n+\n+def max_pool(\n+    inputs,\n+    pool_size,\n+    strides=None,\n+    padding=\"valid\",\n+    data_format=None,\n+):\n+    raise NotImplementedError(\n+        \"`max_pool` is not supported with openvino backend\"\n+    )\n+\n+\n+def average_pool(\n+    inputs,\n+    pool_size,\n+    strides,\n+    padding,\n+    data_format=None,\n+):\n+    raise NotImplementedError(\n+        \"`average_pool` is not supported with openvino backend\"\n+    )\n+\n+\n+def _adjust_strides_dilation(\n+    x,\n+    num_spatial_dims,\n+):\n+    # Helper function that converts an operand to a spatial operand.\n+    x = (x,) * num_spatial_dims if isinstance(x, int) else x\n+    # OpenVINO expects input in NCHW layout\n+    # x = [1, 1] + list(x)\n+    x = list(x)\n+    return x\n+\n+\n+def _adjust_padding(\n+    padding,\n+):\n+    padding = padding.lower() if isinstance(padding, str) else padding\n+    if padding == \"same\":\n+        return \"SAME_UPPER\", [], []\n+    elif padding == \"same_lower\":\n+        return \"SAME_LOWER\", [], []\n+    elif padding == \"valid\":\n+        return \"VALID\", [], []\n+    pads_begin = []\n+    pads_end = []\n+    for padding_pair in padding:\n+        pads_begin.append(padding_pair[0])\n+        pads_end.append(padding_pair[1])\n+    return \"EXPLICIT\", pads_begin, pads_end\n+\n+\n+def _adjust_input(inputs, num_spatial_dims, data_format):\n+    if data_format == \"channels_first\":\n+        return inputs\n+    if num_spatial_dims == 1:\n+        permutation = [0, 2, 1]\n+    elif num_spatial_dims == 2:\n+        permutation = [0, 3, 1, 2]\n+    else:\n+        permutation = [0, 4, 1, 2, 3]\n+    permutation = ov_opset.constant(permutation, Type.i32)\n+    return ov_opset.transpose(inputs, permutation).output(0)\n+\n+\n+def _adjust_kernel(kernel, num_spatial_dims):\n+    if num_spatial_dims == 1:\n+        permutation = [2, 1, 0]\n+    elif num_spatial_dims == 2:\n+        permutation = [3, 2, 0, 1]\n+    else:\n+        permutation = [4, 3, 0, 1, 2]\n+    permutation = ov_opset.constant(permutation, Type.i32)\n+    return ov_opset.transpose(kernel, permutation).output(0)\n+\n+\n+def _adjust_depthwise_kernel(kernel, num_spatial_dims):\n+    # kernel layout: filter_H, filter_W, C_IN, Ch_mul\n+    if num_spatial_dims == 1:\n+        # kernel layout: filter_H, C_IN, Ch_mul\n+        permutation = [1, 2, 0]\n+    elif num_spatial_dims == 2:\n+        # kernel layout: filter_H, filter_W, C_IN, Ch_mul\n+        permutation = [2, 3, 0, 1]\n+    else:\n+        # kernel layout: filter_H, filter_W, filter_Z, C_IN, Ch_mul\n+        permutation = [3, 4, 0, 1, 2]\n+    permutation = ov_opset.constant(permutation, Type.i32)\n+    return ov_opset.transpose(kernel, permutation).output(0)\n+\n+\n+def _adjust_outputs(outputs, num_spatial_dims, data_format):\n+    if data_format == \"channels_first\":\n+        return outputs\n+    # convert a tensor from NCHW to NHWC layout\n+    if num_spatial_dims == 1:\n+        permutation = [0, 2, 1]\n+    elif num_spatial_dims == 2:\n+        permutation = [0, 2, 3, 1]\n+    else:\n+        permutation = [0, 2, 3, 4, 1]\n+    permutation = ov_opset.constant(permutation, Type.i32)\n+    return ov_opset.transpose(outputs, permutation).output(0)\n+\n+\n+def conv(\n+    inputs,\n+    kernel,\n+    strides=1,\n+    padding=\"valid\",\n+    data_format=None,\n+    dilation_rate=1,\n+):\n+    inputs = get_ov_output(inputs)\n+    kernel = get_ov_output(kernel)\n+\n+    data_format = backend.standardize_data_format(data_format)\n+    num_spatial_dims = inputs.get_partial_shape().rank.get_length() - 2\n+\n+    if data_format == \"channels_last\":\n+        inputs_in_channels = inputs.get_partial_shape()[\n+            2 + num_spatial_dims - 1\n+        ]\n+    else:\n+        inputs_in_channels = inputs.get_partial_shape()[1]\n+    kernel_in_channels = kernel.get_partial_shape()[-2]\n+\n+    strides = _adjust_strides_dilation(strides, num_spatial_dims)\n+    dilation_rate = _adjust_strides_dilation(dilation_rate, num_spatial_dims)\n+    pad_mode, pads_begin, pads_end = _adjust_padding(padding)\n+    inputs = _adjust_input(inputs, num_spatial_dims, data_format)\n+    kernel = _adjust_kernel(kernel, num_spatial_dims)\n+\n+    num_groups = (\n+        inputs_in_channels.get_length() // kernel_in_channels.get_length()\n+    )\n+    if num_groups == 1:\n+        conv = ov_opset.convolution(\n+            inputs,\n+            kernel,\n+            strides,\n+            pads_begin,\n+            pads_end,\n+            dilation_rate,\n+            pad_mode,\n+        )\n+    else:\n+        input_shape = ov_opset.shape_of(inputs).output(0)\n+        filter_shape = ov_opset.shape_of(kernel).output(0)\n+        zero_const = ov_opset.constant([0], Type.i32).output(0)\n+        one_const = ov_opset.constant([1], Type.i32).output(0)\n+        two_const = ov_opset.constant([2], Type.i32).output(0)\n+        input_cin = ov_opset.slice(\n+            input_shape, one_const, two_const, one_const\n+        ).output(0)\n+        filter_cin = ov_opset.slice(\n+            filter_shape, one_const, two_const, one_const\n+        ).output(0)\n+        num_groups = ov_opset.divide(input_cin, filter_cin).output(0)\n+\n+        # reshape the filter based on the number of groups information\n+        int_max_const = ov_opset.constant([2**31 - 1], Type.i32).output(0)\n+        filter_cout = ov_opset.slice(\n+            filter_shape, zero_const, one_const, one_const\n+        ).output(0)\n+        filter_new_cout = ov_opset.divide(filter_cout, num_groups).output(0)\n+        shape_cin_xy = ov_opset.slice(\n+            filter_shape, one_const, int_max_const, one_const\n+        ).output(0)\n+        filter_new_shape = ov_opset.concat(\n+            [num_groups, filter_new_cout, shape_cin_xy], 0\n+        ).output(0)\n+        new_filter = ov_opset.reshape(kernel, filter_new_shape, False).output(0)\n+        conv = ov_opset.group_convolution(\n+            inputs,\n+            new_filter,\n+            strides,\n+            pads_begin,\n+            pads_end,\n+            dilation_rate,\n+            pad_mode,\n+        )\n+    conv = _adjust_outputs(conv.output(0), num_spatial_dims, data_format)\n+    return OpenVINOKerasTensor(conv)\n+\n+\n+def depthwise_conv(\n+    inputs,\n+    kernel,\n+    strides=1,\n+    padding=\"valid\",\n+    data_format=None,\n+    dilation_rate=1,\n+):\n+    inputs = get_ov_output(inputs)\n+    kernel = get_ov_output(kernel)\n+\n+    data_format = backend.standardize_data_format(data_format)\n+    num_spatial_dims = inputs.get_partial_shape().rank.get_length() - 2\n+\n+    assert (\n+        data_format == \"channels_last\"\n+    ), \"`depthwise_conv` is supported only for channels_last data_format\"\n+\n+    strides = _adjust_strides_dilation(strides, num_spatial_dims)\n+    dilation_rate = _adjust_strides_dilation(dilation_rate, num_spatial_dims)\n+    pad_mode, pads_begin, pads_end = _adjust_padding(padding)\n+\n+    inputs = _adjust_input(inputs, num_spatial_dims, data_format)\n+    kernel = _adjust_depthwise_kernel(kernel, num_spatial_dims)\n+    unsqueeze_dim = ov_opset.constant([2], Type.i32)\n+    kernel = ov_opset.unsqueeze(kernel, unsqueeze_dim)\n+\n+    group_conv = ov_opset.group_convolution(\n+        inputs, kernel, strides, pads_begin, pads_end, dilation_rate, pad_mode\n+    )\n+    group_conv = _adjust_outputs(\n+        group_conv.output(0), num_spatial_dims, data_format\n+    )\n+    return OpenVINOKerasTensor(group_conv)\n+\n+\n+def separable_conv(\n+    inputs,\n+    depthwise_kernel,\n+    pointwise_kernel,\n+    strides=1,\n+    padding=\"valid\",\n+    data_format=None,\n+    dilation_rate=1,\n+):\n+    raise NotImplementedError(\n+        \"`separable_conv` is not supported with openvino backend\"\n+    )\n+\n+\n+def conv_transpose(\n+    inputs,\n+    kernel,\n+    strides=1,\n+    padding=\"valid\",\n+    output_padding=None,\n+    data_format=None,\n+    dilation_rate=1,\n+):\n+    raise NotImplementedError(\n+        \"`conv_transpose` is not supported with openvino backend\"\n+    )\n+\n+\n+def one_hot(x, num_classes, axis=-1, dtype=\"float32\", sparse=False):\n+    raise NotImplementedError(\n+        \"`one_hot` is not supported with openvino backend\"\n+    )\n+\n+\n+def multi_hot(x, num_classes, axis=-1, dtype=\"float32\", sparse=False):\n+    raise NotImplementedError(\n+        \"`multi_hot` is not supported with openvino backend\"\n+    )\n+\n+\n+def categorical_crossentropy(target, output, from_logits=False, axis=-1):\n+    raise NotImplementedError(\n+        \"`categorical_crossentropy` is not supported with openvino backend\"\n+    )\n+\n+\n+def sparse_categorical_crossentropy(target, output, from_logits=False, axis=-1):\n+    raise NotImplementedError(\n+        \"`sparse_categorical_crossentropy` is not supported \"\n+        \"with openvino backend\"\n+    )\n+\n+\n+def binary_crossentropy(target, output, from_logits=False):\n+    raise NotImplementedError(\n+        \"`binary_crossentropy` is not supported with openvino backend\"\n+    )\n+\n+\n+def moments(x, axes, keepdims=False, synchronized=False):\n+    x = get_ov_output(x)\n+    axes = ov_opset.constant(axes, Type.i32).output(0)\n+    # The variance is computed using $Var = E[|x|^2] - |E[x]|^2$, It is faster\n+    # but less numerically stable.\n+    mean = ov_opset.reduce_mean(x, axes, keepdims).output(0)\n+    const_two = ov_opset.constant(2, x.get_element_type()).output(0)\n+    squared_x = ov_opset.power(x, const_two).output(0)\n+    squared_mean = ov_opset.power(mean, const_two).output(0)\n+    squared_x_mean = ov_opset.reduce_mean(squared_x, axes, keepdims)\n+    mean = OpenVINOKerasTensor(mean)\n+    variance = OpenVINOKerasTensor(\n+        ov_opset.subtract(squared_x_mean, squared_mean).output(0)\n+    )\n+    return mean, variance\n+\n+\n+def batch_normalization(\n+    x, mean, variance, axis, offset=None, scale=None, epsilon=1e-3\n+):\n+    x = get_ov_output(x)\n+    mean = get_ov_output(mean)\n+    variance = get_ov_output(variance)\n+    if offset is not None:\n+        offset = get_ov_output(offset)\n+    else:\n+        mean_shape = ov_opset.shape_of(mean)\n+        mean_type = mean.get_element_type()\n+        zero_const = ov_opset.constant([0], mean_type)\n+        offset = ov_opset.broadcast(zero_const, mean_shape)\n+    if scale is not None:\n+        scale = get_ov_output(scale)\n+    else:\n+        mean_shape = ov_opset.shape_of(mean)\n+        mean_type = mean.get_element_type()\n+        one_const = ov_opset.constant([1], mean_type)\n+        scale = ov_opset.broadcast(one_const, mean_shape)\n+\n+    # adjust x input to have the second dimension representing the channel axis\n+    x_rank = x.get_partial_shape().rank.get_length()\n+    if axis < 0:\n+        axis += x_rank\n+    if axis != 1:\n+        perm_vector = list(range(0, x_rank))\n+        perm_vector[1] = axis\n+        perm_vector[axis] = 1\n+        perm_vector = ov_opset.constant(perm_vector, Type.i32).output(0)\n+        x = ov_opset.transpose(x, perm_vector).output(0)\n+    batch_norm = ov_opset.batch_norm_inference(\n+        x, scale, offset, mean, variance, epsilon\n+    ).output(0)\n+    if axis != 1:\n+        perm_vector = list(range(0, x_rank))\n+        perm_vector[1] = axis\n+        perm_vector[axis] = 1\n+        perm_vector = ov_opset.constant(perm_vector, Type.i32).output(0)\n+        batch_norm = ov_opset.transpose(batch_norm, perm_vector).output(0)\n+    return OpenVINOKerasTensor(batch_norm)\n+\n+\n+def ctc_loss(target, output, target_length, output_length, mask_index=0):\n+    raise NotImplementedError(\n+        \"`ctc_loss` is not supported with openvino backend\"\n+    )\n+\n+\n+def ctc_decode(\n+    inputs,\n+    sequence_lengths,\n+    strategy=\"greedy\",\n+    beam_width=100,\n+    top_paths=1,\n+    merge_repeated=True,\n+    mask_index=0,\n+):\n+    raise NotImplementedError(\n+        \"`ctc_decode` is not supported with openvino backend\"\n+    )\n+\n+\n+def psnr(x1, x2, max_val):\n+    raise NotImplementedError(\"`psnr` is not supported with openvino backend\")\ndiff --git a/keras/src/backend/openvino/numpy.py b/keras/src/backend/openvino/numpy.py\nnew file mode 100644\nindex 000000000000..76f83566af5b\n--- /dev/null\n+++ b/keras/src/backend/openvino/numpy.py\n@@ -0,0 +1,1052 @@\n+import numpy as np\n+import openvino.runtime.opset14 as ov_opset\n+from openvino import Type\n+\n+from keras.src.backend import config\n+from keras.src.backend.common import dtypes\n+from keras.src.backend.openvino.core import OPENVINO_DTYPES\n+from keras.src.backend.openvino.core import OpenVINOKerasTensor\n+from keras.src.backend.openvino.core import (\n+    align_operand_types as _align_operand_types,\n+)\n+from keras.src.backend.openvino.core import get_ov_output\n+from keras.src.backend.openvino.core import ov_to_keras_type\n+\n+\n+def add(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"add()\")\n+    return OpenVINOKerasTensor(ov_opset.add(x1, x2).output(0))\n+\n+\n+def einsum(subscripts, *operands, **kwargs):\n+    inputs = []\n+    for operand in operands:\n+        operand = get_ov_output(operand)\n+        inputs.append(operand)\n+    return OpenVINOKerasTensor(ov_opset.einsum(inputs, subscripts).output(0))\n+\n+\n+def subtract(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"subtract()\")\n+    return OpenVINOKerasTensor(ov_opset.subtract(x1, x2).output(0))\n+\n+\n+def matmul(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"matmul()\")\n+    return OpenVINOKerasTensor(ov_opset.matmul(x1, x2, False, False).output(0))\n+\n+\n+def multiply(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"multiply()\")\n+    return OpenVINOKerasTensor(ov_opset.multiply(x1, x2).output(0))\n+\n+\n+def mean(x, axis=None, keepdims=False):\n+    x = get_ov_output(x)\n+    if axis is None:\n+        flatten_shape = ov_opset.constant([-1], Type.i32).output(0)\n+        x = ov_opset.reshape(x, flatten_shape, False).output(0)\n+        axis = 0\n+    axis_const = ov_opset.constant(axis, dtype=Type.i32).output(0)\n+    mean_ops = ov_opset.reduce_mean(x, axis_const, keepdims)\n+    return OpenVINOKerasTensor(mean_ops.output(0))\n+\n+\n+def max(x, axis=None, keepdims=False, initial=None):\n+    assert (\n+        initial is None\n+    ), \"`max` with not None initial is not supported by openvino backend\"\n+    x = get_ov_output(x)\n+    reduce_axis = ov_opset.constant(axis, Type.i32).output(0)\n+    return OpenVINOKerasTensor(\n+        ov_opset.reduce_max(x, reduce_axis, keepdims).output(0)\n+    )\n+\n+\n+def ones(shape, dtype=None):\n+    dtype = dtype or config.floatx()\n+    ov_type = OPENVINO_DTYPES[dtype]\n+    const_one = ov_opset.constant(1, ov_type).output(0)\n+    if isinstance(shape, tuple):\n+        shape = list(shape)\n+    elif isinstance(shape, int):\n+        shape = [shape]\n+    output_shape = ov_opset.constant(shape, dtype=Type.i32).output(0)\n+    ones = ov_opset.broadcast(const_one, output_shape)\n+    return OpenVINOKerasTensor(ones.output(0))\n+\n+\n+def zeros(shape, dtype=None):\n+    dtype = dtype or config.floatx()\n+    ov_type = OPENVINO_DTYPES[dtype]\n+    const_zero = ov_opset.constant(0, dtype=ov_type).output(0)\n+    if isinstance(shape, tuple):\n+        shape = list(shape)\n+    elif isinstance(shape, int):\n+        shape = [shape]\n+    output_shape = ov_opset.constant(shape, dtype=Type.i32).output(0)\n+    zeros = ov_opset.broadcast(const_zero, output_shape)\n+    return OpenVINOKerasTensor(zeros.output(0))\n+\n+\n+def absolute(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.absolute(x).output(0))\n+\n+\n+def abs(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.absolute(x).output(0))\n+\n+\n+def all(x, axis=None, keepdims=False):\n+    x = get_ov_output(x)\n+    if axis is None:\n+        flatten_shape = ov_opset.constant([-1], Type.i32).output(0)\n+        x = ov_opset.reshape(x, flatten_shape, False).output(0)\n+        axis = 0\n+    axis = ov_opset.constant(axis, Type.i32).output(0)\n+    return OpenVINOKerasTensor(\n+        ov_opset.reduce_logical_and(x, axis, keepdims).output(0)\n+    )\n+\n+\n+def any(x, axis=None, keepdims=False):\n+    x = get_ov_output(x)\n+    if axis is None:\n+        flatten_shape = ov_opset.constant([-1], Type.i32).output(0)\n+        x = ov_opset.reshape(x, flatten_shape, False).output(0)\n+        axis = 0\n+    axis = ov_opset.constant(axis, Type.i32).output(0)\n+    return OpenVINOKerasTensor(\n+        ov_opset.reduce_logical_or(x, axis, keepdims).output(0)\n+    )\n+\n+\n+def amax(x, axis=None, keepdims=False):\n+    raise NotImplementedError(\"`amax` is not supported with openvino backend\")\n+\n+\n+def amin(x, axis=None, keepdims=False):\n+    raise NotImplementedError(\"`amin` is not supported with openvino backend\")\n+\n+\n+def append(x1, x2, axis=None):\n+    raise NotImplementedError(\"`append` is not supported with openvino backend\")\n+\n+\n+def arange(start, stop=None, step=None, dtype=None):\n+    raise NotImplementedError(\"`arange` is not supported with openvino backend\")\n+\n+\n+def arccos(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.acos(x).output(0))\n+\n+\n+def arccosh(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.acosh(x).output(0))\n+\n+\n+def arcsin(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.asin(x).output(0))\n+\n+\n+def arcsinh(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.asinh(x).output(0))\n+\n+\n+def arctan(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.atan(x).output(0))\n+\n+\n+def arctan2(x1, x2):\n+    raise NotImplementedError(\n+        \"`arctan2` is not supported with openvino backend\"\n+    )\n+\n+\n+def arctanh(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.atanh(x).output(0))\n+\n+\n+def argmax(x, axis=None, keepdims=False):\n+    raise NotImplementedError(\"`argmax` is not supported with openvino backend\")\n+\n+\n+def argmin(x, axis=None, keepdims=False):\n+    raise NotImplementedError(\"`argmin` is not supported with openvino backend\")\n+\n+\n+def argsort(x, axis=-1):\n+    raise NotImplementedError(\n+        \"`argsort` is not supported with openvino backend\"\n+    )\n+\n+\n+def array(x, dtype=None):\n+    if dtype is not None:\n+        return np.array(x, dtype=dtype)\n+    return np.array(x)\n+\n+\n+def average(x, axis=None, weights=None):\n+    raise NotImplementedError(\n+        \"`average` is not supported with openvino backend\"\n+    )\n+\n+\n+def bincount(x, weights=None, minlength=0, sparse=False):\n+    raise NotImplementedError(\n+        \"`bincount` is not supported with openvino backend\"\n+    )\n+\n+\n+def broadcast_to(x, shape):\n+    assert isinstance(\n+        shape, (tuple, list)\n+    ), \"`broadcast_to` is supported only for tuple and list `shape`\"\n+    target_shape = ov_opset.constant(list(shape), Type.i32).output(0)\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.broadcast(x, target_shape).output(0))\n+\n+\n+def ceil(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.ceil(x).output(0))\n+\n+\n+def clip(x, x_min, x_max):\n+    x = get_ov_output(x)\n+    x_min = get_ov_output(x_min, x.get_element_type())\n+    x_max = get_ov_output(x_max, x.get_element_type())\n+    clip_by_min = ov_opset.maximum(x, x_min).output(0)\n+    clip_by_max = ov_opset.minimum(clip_by_min, x_max).output(0)\n+    return OpenVINOKerasTensor(clip_by_max)\n+\n+\n+def concatenate(xs, axis=0):\n+    assert isinstance(xs, list), \"`concatenate` is supported only for `x` list\"\n+    elems = []\n+    for elem in xs:\n+        elem = get_ov_output(elem)\n+        elems.append(elem)\n+    res = ov_opset.concat(elems, axis).output(0)\n+    return OpenVINOKerasTensor(res)\n+\n+\n+def conjugate(x):\n+    raise NotImplementedError(\n+        \"`conjugate` is not supported with openvino backend\"\n+    )\n+\n+\n+def conj(x):\n+    raise NotImplementedError(\"`conj` is not supported with openvino backend\")\n+\n+\n+def copy(x):\n+    return x\n+\n+\n+def cos(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.cos(x).output(0))\n+\n+\n+def cosh(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.cosh(x).output(0))\n+\n+\n+def count_nonzero(x, axis=None):\n+    raise NotImplementedError(\n+        \"`count_nonzero` is not supported with openvino backend\"\n+    )\n+\n+\n+def cross(x1, x2, axisa=-1, axisb=-1, axisc=-1, axis=None):\n+    raise NotImplementedError(\"`cross` is not supported with openvino backend\")\n+\n+\n+def cumprod(x, axis=None, dtype=None):\n+    raise NotImplementedError(\n+        \"`cumprod` is not supported with openvino backend\"\n+    )\n+\n+\n+def cumsum(x, axis=None, dtype=None):\n+    x = get_ov_output(x)\n+    if dtype is not None:\n+        ov_type = OPENVINO_DTYPES[dtype]\n+        x = ov_opset.convert(x, ov_type).output(0)\n+    if axis is None:\n+        flatten_shape = ov_opset.constant([-1], Type.i32).output(0)\n+        x = ov_opset.reshape(x, flatten_shape, False).output(0)\n+        axis = 0\n+    axis = ov_opset.constant(axis, Type.i32).output(0)\n+    return OpenVINOKerasTensor(ov_opset.cumsum(x, axis).output(0))\n+\n+\n+def diag(x, k=0):\n+    raise NotImplementedError(\"`diag` is not supported with openvino backend\")\n+\n+\n+def diagonal(x, offset=0, axis1=0, axis2=1):\n+    raise NotImplementedError(\n+        \"`diagonal` is not supported with openvino backend\"\n+    )\n+\n+\n+def diff(a, n=1, axis=-1):\n+    raise NotImplementedError(\"`diff` is not supported with openvino backend\")\n+\n+\n+def digitize(x, bins):\n+    raise NotImplementedError(\n+        \"`digitize` is not supported with openvino backend\"\n+    )\n+\n+\n+def dot(x, y):\n+    raise NotImplementedError(\"`dot` is not supported with openvino backend\")\n+\n+\n+def empty(shape, dtype=None):\n+    raise NotImplementedError(\"`empty` is not supported with openvino backend\")\n+\n+\n+def equal(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"equal()\")\n+    return OpenVINOKerasTensor(ov_opset.equal(x1, x2).output(0))\n+\n+\n+def exp(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.exp(x).output(0))\n+\n+\n+def expand_dims(x, axis):\n+    if isinstance(x, OpenVINOKerasTensor):\n+        x = x.output\n+    else:\n+        assert False\n+    axis = ov_opset.constant(axis, Type.i32).output(0)\n+    return OpenVINOKerasTensor(ov_opset.unsqueeze(x, axis).output(0))\n+\n+\n+def expm1(x):\n+    raise NotImplementedError(\"`expm1` is not supported with openvino backend\")\n+\n+\n+def flip(x, axis=None):\n+    raise NotImplementedError(\"`flip` is not supported with openvino backend\")\n+\n+\n+def floor(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.floor(x).output(0))\n+\n+\n+def full(shape, fill_value, dtype=None):\n+    dtype = dtype or config.floatx()\n+    ov_type = OPENVINO_DTYPES[dtype]\n+    fill_value = get_ov_output(fill_value, ov_type)\n+    if isinstance(shape, tuple):\n+        shape = list(shape)\n+    target_shape = ov_opset.constant(shape, Type.i32)\n+    return OpenVINOKerasTensor(\n+        ov_opset.broadcast(fill_value, target_shape).output(0)\n+    )\n+\n+\n+def full_like(x, fill_value, dtype=None):\n+    raise NotImplementedError(\n+        \"`full_like` is not supported with openvino backend\"\n+    )\n+\n+\n+def greater(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"greater()\")\n+    return OpenVINOKerasTensor(ov_opset.greater(x1, x2).output(0))\n+\n+\n+def greater_equal(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"greater_equal()\")\n+    return OpenVINOKerasTensor(ov_opset.greater_equal(x1, x2).output(0))\n+\n+\n+def hstack(xs):\n+    raise NotImplementedError(\"`hstack` is not supported with openvino backend\")\n+\n+\n+def identity(n, dtype=None):\n+    raise NotImplementedError(\n+        \"`identity` is not supported with openvino backend\"\n+    )\n+\n+\n+def imag(x):\n+    raise NotImplementedError(\"`imag` is not supported with openvino backend\")\n+\n+\n+def isclose(x1, x2, rtol=1e-5, atol=1e-8, equal_nan=False):\n+    raise NotImplementedError(\n+        \"`isclose` is not supported with openvino backend\"\n+    )\n+\n+\n+def isfinite(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.is_finite(x).output(0))\n+\n+\n+def isinf(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.is_inf(x).output(0))\n+\n+\n+def isnan(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.is_nan(x).output(0))\n+\n+\n+def less(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"less()\")\n+    return OpenVINOKerasTensor(ov_opset.less(x1, x2).output(0))\n+\n+\n+def less_equal(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"less_equal()\")\n+    return OpenVINOKerasTensor(ov_opset.less_equal(x1, x2).output(0))\n+\n+\n+def linspace(\n+    start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0\n+):\n+    raise NotImplementedError(\n+        \"`linspace` is not supported with openvino backend\"\n+    )\n+\n+\n+def log(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.log(x).output(0))\n+\n+\n+def log10(x):\n+    raise NotImplementedError(\"`log10` is not supported with openvino backend\")\n+\n+\n+def log1p(x):\n+    raise NotImplementedError(\"`log1p` is not supported with openvino backend\")\n+\n+\n+def log2(x):\n+    raise NotImplementedError(\"`log2` is not supported with openvino backend\")\n+\n+\n+def logaddexp(x1, x2):\n+    raise NotImplementedError(\n+        \"`logaddexp` is not supported with openvino backend\"\n+    )\n+\n+\n+def logical_and(x1, x2):\n+    x1 = get_ov_output(x1)\n+    x2 = get_ov_output(x2)\n+    x1 = ov_opset.convert(x1, Type.boolean).output(0)\n+    x2 = ov_opset.convert(x2, Type.boolean).output(0)\n+    return OpenVINOKerasTensor(ov_opset.logical_and(x1, x2).output(0))\n+\n+\n+def logical_not(x):\n+    x = get_ov_output(x)\n+    x = ov_opset.convert(x, Type.boolean).output(0)\n+    return OpenVINOKerasTensor(ov_opset.logical_not(x).output(0))\n+\n+\n+def logical_or(x1, x2):\n+    x1 = get_ov_output(x1)\n+    x2 = get_ov_output(x2)\n+    x1 = ov_opset.convert(x1, Type.boolean).output(0)\n+    x2 = ov_opset.convert(x2, Type.boolean).output(0)\n+    return OpenVINOKerasTensor(ov_opset.logical_or(x1, x2).output(0))\n+\n+\n+def logspace(start, stop, num=50, endpoint=True, base=10, dtype=None, axis=0):\n+    raise NotImplementedError(\n+        \"`logspace` is not supported with openvino backend\"\n+    )\n+\n+\n+def maximum(x1, x2):\n+    x1 = get_ov_output(x1)\n+    x2 = get_ov_output(x2)\n+    x1, x2 = _align_operand_types(x1, x2, \"maximum()\")\n+    return OpenVINOKerasTensor(ov_opset.maximum(x1, x2).output(0))\n+\n+\n+def median(x, axis=None, keepdims=False):\n+    raise NotImplementedError(\"`median` is not supported with openvino backend\")\n+\n+\n+def meshgrid(*x, indexing=\"xy\"):\n+    raise NotImplementedError(\n+        \"`meshgrid` is not supported with openvino backend\"\n+    )\n+\n+\n+def min(x, axis=None, keepdims=False, initial=None):\n+    raise NotImplementedError(\"`min` is not supported with openvino backend\")\n+\n+\n+def minimum(x1, x2):\n+    x1 = get_ov_output(x1)\n+    x2 = get_ov_output(x2)\n+    x1, x2 = _align_operand_types(x1, x2, \"minimum()\")\n+    return OpenVINOKerasTensor(ov_opset.minimum(x1, x2).output(0))\n+\n+\n+def mod(x1, x2):\n+    x1 = get_ov_output(x1)\n+    x2 = get_ov_output(x2)\n+    x1, x2 = _align_operand_types(x1, x2, \"mod()\")\n+    return OpenVINOKerasTensor(ov_opset.floor_mod(x1, x2).output(0))\n+\n+\n+def moveaxis(x, source, destination):\n+    raise NotImplementedError(\n+        \"`moveaxis` is not supported with openvino backend\"\n+    )\n+\n+\n+def nan_to_num(x, nan=0.0, posinf=None, neginf=None):\n+    raise NotImplementedError(\n+        \"`nan_to_num` is not supported with openvino backend\"\n+    )\n+\n+\n+def ndim(x):\n+    raise NotImplementedError(\"`ndim` is not supported with openvino backend\")\n+\n+\n+def nonzero(x):\n+    raise NotImplementedError(\n+        \"`nonzero` is not supported with openvino backend\"\n+    )\n+\n+\n+def not_equal(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"not_equal()\")\n+    return OpenVINOKerasTensor(ov_opset.not_equal(x1, x2).output(0))\n+\n+\n+def zeros_like(x, dtype=None):\n+    x = get_ov_output(x)\n+    shape_x = ov_opset.shape_of(x)\n+    if dtype is not None:\n+        ov_type = OPENVINO_DTYPES[dtype]\n+        const_zero = ov_opset.constant(0, ov_type).output(0)\n+    else:\n+        const_zero = ov_opset.constant(0, x.get_element_type()).output(0)\n+    res = ov_opset.broadcast(const_zero, shape_x).output(0)\n+    return OpenVINOKerasTensor(res)\n+\n+\n+def ones_like(x, dtype=None):\n+    x = get_ov_output(x)\n+    shape_x = ov_opset.shape_of(x)\n+    if dtype is not None:\n+        ov_type = OPENVINO_DTYPES[dtype]\n+        const_one = ov_opset.constant(1, ov_type).output(0)\n+    else:\n+        const_one = ov_opset.constant(1, x.get_element_type()).output(0)\n+    res = ov_opset.broadcast(const_one, shape_x).output(0)\n+    return OpenVINOKerasTensor(res)\n+\n+\n+def outer(x1, x2):\n+    raise NotImplementedError(\"`outer` is not supported with openvino backend\")\n+\n+\n+def pad(x, pad_width, mode=\"constant\", constant_values=None):\n+    x = get_ov_output(x)\n+    pad_value = None\n+    if constant_values is not None:\n+        if mode != \"constant\":\n+            raise ValueError(\n+                \"Argument `constant_values` can only be \"\n+                \"provided when `mode == 'constant'`. \"\n+                f\"Received: mode={mode}\"\n+            )\n+        assert isinstance(constant_values, int), (\n+            \"`pad` operation supports only scalar pad value \"\n+            \"in constant mode by openvino backend\"\n+        )\n+        pad_value = constant_values\n+\n+    # split pad_width into two tensors pads_begin and pads_end\n+    pads_begin = []\n+    pads_end = []\n+    for pads_pair in pad_width:\n+        pads_begin.append(pads_pair[0])\n+        pads_end.append(pads_pair[1])\n+    pads_begin = ov_opset.constant(pads_begin, Type.i32).output(0)\n+    pads_end = ov_opset.constant(pads_end, Type.i32).output(0)\n+    return OpenVINOKerasTensor(\n+        ov_opset.pad(x, pads_begin, pads_end, mode, pad_value).output(0)\n+    )\n+\n+\n+def prod(x, axis=None, keepdims=False, dtype=None):\n+    raise NotImplementedError(\"`prod` is not supported with openvino backend\")\n+\n+\n+def quantile(x, q, axis=None, method=\"linear\", keepdims=False):\n+    raise NotImplementedError(\n+        \"`quantile` is not supported with openvino backend\"\n+    )\n+\n+\n+def ravel(x):\n+    raise NotImplementedError(\"`ravel` is not supported with openvino backend\")\n+\n+\n+def real(x):\n+    raise NotImplementedError(\"`real` is not supported with openvino backend\")\n+\n+\n+def reciprocal(x):\n+    raise NotImplementedError(\n+        \"`reciprocal` is not supported with openvino backend\"\n+    )\n+\n+\n+def repeat(x, repeats, axis=None):\n+    raise NotImplementedError(\"`repeat` is not supported with openvino backend\")\n+\n+\n+def reshape(x, newshape):\n+    x = get_ov_output(x)\n+    if isinstance(newshape, tuple):\n+        newshape = list(newshape)\n+    newshape = ov_opset.constant(newshape, Type.i32).output(0)\n+    return OpenVINOKerasTensor(ov_opset.reshape(x, newshape, False).output(0))\n+\n+\n+def roll(x, shift, axis=None):\n+    raise NotImplementedError(\"`roll` is not supported with openvino backend\")\n+\n+\n+def sign(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.sign(x).output(0))\n+\n+\n+def sin(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.sin(x).output(0))\n+\n+\n+def sinh(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.sinh(x).output(0))\n+\n+\n+def size(x):\n+    raise NotImplementedError(\"`size` is not supported with openvino backend\")\n+\n+\n+def sort(x, axis=-1):\n+    raise NotImplementedError(\"`sort` is not supported with openvino backend\")\n+\n+\n+def split(x, indices_or_sections, axis=0):\n+    raise NotImplementedError(\"`split` is not supported with openvino backend\")\n+\n+\n+def stack(x, axis=0):\n+    assert isinstance(x, list), \"`stack` is supported only for `x` list\"\n+    elems = []\n+    const_axis = ov_opset.constant(axis, Type.i32).output(0)\n+    for elem in x:\n+        elem = get_ov_output(elem)\n+        elem = ov_opset.unsqueeze(elem, const_axis).output(0)\n+        elems.append(elem)\n+    res = ov_opset.concat(elems, axis).output(0)\n+    return OpenVINOKerasTensor(res)\n+\n+\n+def std(x, axis=None, keepdims=False):\n+    x = get_ov_output(x)\n+    if axis is None:\n+        flatten_shape = ov_opset.constant([-1], Type.i32).output(0)\n+        x = ov_opset.reshape(x, flatten_shape, False).output(0)\n+        axis = 0\n+    axis = ov_opset.constant(axis, Type.i32).output(0)\n+    # The variance is computed using $Var = E[|x|^2] - |E[x]|^2$, It is faster\n+    # but less numerically stable.\n+    mean = ov_opset.reduce_mean(x, axis, keepdims).output(0)\n+    const_two = ov_opset.constant(2, x.get_element_type()).output(0)\n+    squared_x = ov_opset.power(x, const_two).output(0)\n+    squared_mean = ov_opset.power(mean, const_two).output(0)\n+    squared_x_mean = ov_opset.reduce_mean(squared_x, axis, keepdims)\n+    variance = ov_opset.subtract(squared_x_mean, squared_mean).output(0)\n+    std_var = OpenVINOKerasTensor(ov_opset.sqrt(variance).output(0))\n+    return std_var\n+\n+\n+def swapaxes(x, axis1, axis2):\n+    raise NotImplementedError(\n+        \"`swapaxes` is not supported with openvino backend\"\n+    )\n+\n+\n+def take(x, indices, axis=None):\n+    x = get_ov_output(x)\n+    indices = get_ov_output(indices)\n+    if axis is None:\n+        target_shape = ov_opset.constant([-1], dtype=Type.i32).output(0)\n+        x = ov_opset.reshape(x, target_shape, False).output(0)\n+        axis = ov_opset.constant(0, dtype=Type.i32).output(0)\n+    else:\n+        axis = ov_opset.constant(axis, dtype=Type.i32).output(0)\n+    return OpenVINOKerasTensor(ov_opset.gather(x, indices, axis).output(0))\n+\n+\n+def take_along_axis(x, indices, axis=None):\n+    raise NotImplementedError(\n+        \"`take_along_axis` is not supported with openvino backend\"\n+    )\n+\n+\n+def tan(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.tan(x).output(0))\n+\n+\n+def tanh(x):\n+    x = get_ov_output(x)\n+    x_type = x.get_element_type()\n+    if x_type.is_integral():\n+        ov_type = OPENVINO_DTYPES[config.floatx()]\n+        x = ov_opset.convert(x, ov_type)\n+    return OpenVINOKerasTensor(ov_opset.tanh(x).output(0))\n+\n+\n+def tensordot(x1, x2, axes=2):\n+    raise NotImplementedError(\n+        \"`tensordot` is not supported with openvino backend\"\n+    )\n+\n+\n+def round(x, decimals=0):\n+    raise NotImplementedError(\"`round` is not supported with openvino backend\")\n+\n+\n+def tile(x, repeats):\n+    raise NotImplementedError(\"`tile` is not supported with openvino backend\")\n+\n+\n+def trace(x, offset=0, axis1=0, axis2=1):\n+    raise NotImplementedError(\"`trace` is not supported with openvino backend\")\n+\n+\n+def tri(N, M=None, k=0, dtype=None):\n+    raise NotImplementedError(\"`tri` is not supported with openvino backend\")\n+\n+\n+def tril(x, k=0):\n+    raise NotImplementedError(\"`tril` is not supported with openvino backend\")\n+\n+\n+def triu(x, k=0):\n+    raise NotImplementedError(\"`triu` is not supported with openvino backend\")\n+\n+\n+def vdot(x1, x2):\n+    raise NotImplementedError(\"`vdot` is not supported with openvino backend\")\n+\n+\n+def vstack(xs):\n+    raise NotImplementedError(\"`vstack` is not supported with openvino backend\")\n+\n+\n+def vectorize(pyfunc, *, excluded=None, signature=None):\n+    raise NotImplementedError(\n+        \"`vectorize` is not supported with openvino backend\"\n+    )\n+\n+\n+def where(condition, x1, x2):\n+    raise NotImplementedError(\"`where` is not supported with openvino backend\")\n+\n+\n+def divide(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1_type = ov_to_keras_type(x1.get_element_type())\n+    x2_type = ov_to_keras_type(x2.get_element_type())\n+    result_type = dtypes.result_type(x1_type, x2_type, float)\n+    result_type = OPENVINO_DTYPES[result_type]\n+    x1 = ov_opset.convert(x1, result_type).output(0)\n+    x2 = ov_opset.convert(x2, result_type).output(0)\n+    return OpenVINOKerasTensor(ov_opset.divide(x1, x2).output(0))\n+\n+\n+def divide_no_nan(x1, x2):\n+    raise NotImplementedError(\n+        \"`divide_no_nan` is not supported with openvino backend\"\n+    )\n+\n+\n+def true_divide(x1, x2):\n+    return divide(x1, x2)\n+\n+\n+def power(x1, x2):\n+    element_type = None\n+    if isinstance(x1, OpenVINOKerasTensor):\n+        element_type = x1.output.get_element_type()\n+    if isinstance(x2, OpenVINOKerasTensor):\n+        element_type = x2.output.get_element_type()\n+    x1 = get_ov_output(x1, element_type)\n+    x2 = get_ov_output(x2, element_type)\n+    x1, x2 = _align_operand_types(x1, x2, \"power()\")\n+    return OpenVINOKerasTensor(ov_opset.power(x1, x2).output(0))\n+\n+\n+def negative(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.negative(x).output(0))\n+\n+\n+def square(x):\n+    x = get_ov_output(x)\n+    const_two = ov_opset.constant(2, x.get_element_type()).output(0)\n+    return OpenVINOKerasTensor(ov_opset.power(x, const_two).output(0))\n+\n+\n+def sqrt(x):\n+    x = get_ov_output(x)\n+    return OpenVINOKerasTensor(ov_opset.sqrt(x).output(0))\n+\n+\n+def squeeze(x, axis=None):\n+    x = get_ov_output(x)\n+    if axis is None:\n+        axis = []\n+        for idx, dim in enumerate(x.get_partial_shape()):\n+            if dim == 1:\n+                axis.append(idx)\n+    axis = ov_opset.constant(axis, Type.i32).output(0)\n+    return OpenVINOKerasTensor(ov_opset.squeeze(x, axis).output(0))\n+\n+\n+def transpose(x, axes=None):\n+    x = get_ov_output(x)\n+    if axes is None:\n+        # generate reverse permutation vector\n+        shape_x = ov_opset.shape_of(x, \"i64\").output(0)\n+        rank_x = ov_opset.shape_of(shape_x, \"i64\").output(0)\n+        scalar_shape = ov_opset.constant([], Type.i32).output(0)\n+        rank_x = ov_opset.reshape(rank_x, scalar_shape, False).output(0)\n+        const_minus_one = ov_opset.constant(-1, Type.i64).output(0)\n+        rank_minus_one = ov_opset.add(rank_x, const_minus_one).output(0)\n+        axes = ov_opset.range(\n+            rank_minus_one, const_minus_one, const_minus_one, \"i64\"\n+        ).output(0)\n+    else:\n+        axes = ov_opset.constant(axes, Type.i32).output(0)\n+    return OpenVINOKerasTensor(ov_opset.transpose(x, axes).output(0))\n+\n+\n+def var(x, axis=None, keepdims=False):\n+    x = get_ov_output(x)\n+    if axis is None:\n+        flatten_shape = ov_opset.constant([-1], Type.i32).output(0)\n+        x = ov_opset.reshape(x, flatten_shape, False).output(0)\n+        axis = 0\n+    axis = ov_opset.constant(axis, Type.i32).output(0)\n+    # The variance is computed using $Var = E[|x|^2] - |E[x]|^2$, It is faster\n+    # but less numerically stable.\n+    mean = ov_opset.reduce_mean(x, axis, keepdims).output(0)\n+    const_two = ov_opset.constant(2, x.get_element_type()).output(0)\n+    squared_x = ov_opset.power(x, const_two).output(0)\n+    squared_mean = ov_opset.power(mean, const_two).output(0)\n+    squared_x_mean = ov_opset.reduce_mean(squared_x, axis, keepdims)\n+    variance = OpenVINOKerasTensor(\n+        ov_opset.subtract(squared_x_mean, squared_mean).output(0)\n+    )\n+    return variance\n+\n+\n+def sum(x, axis=None, keepdims=False):\n+    x = get_ov_output(x)\n+    axis = ov_opset.constant(axis, Type.i32).output(0)\n+    return OpenVINOKerasTensor(ov_opset.reduce_sum(x, axis, keepdims).output(0))\n+\n+\n+def eye(N, M=None, k=0, dtype=None):\n+    raise NotImplementedError(\"`eye` is not supported with openvino backend\")\n+\n+\n+def floor_divide(x1, x2):\n+    raise NotImplementedError(\n+        \"`floor_divide` is not supported with openvino backend\"\n+    )\n+\n+\n+def logical_xor(x1, x2):\n+    x1 = get_ov_output(x1)\n+    x2 = get_ov_output(x2)\n+    x1 = ov_opset.convert(x1, Type.boolean).output(0)\n+    x2 = ov_opset.convert(x2, Type.boolean).output(0)\n+    return OpenVINOKerasTensor(ov_opset.logical_xor(x1, x2).output(0))\n+\n+\n+def correlate(x1, x2, mode=\"valid\"):\n+    raise NotImplementedError(\n+        \"`correlate` is not supported with openvino backend\"\n+    )\n+\n+\n+def select(condlist, choicelist, default=0):\n+    raise NotImplementedError(\"`select` is not supported with openvino backend\")\n+\n+\n+def slogdet(x):\n+    raise NotImplementedError(\n+        \"`slogdet` is not supported with openvino backend\"\n+    )\n+\n+\n+def argpartition(x, kth, axis=-1):\n+    raise NotImplementedError(\n+        \"`argpartition` is not supported with openvino backend\"\n+    )\ndiff --git a/keras/src/backend/openvino/random.py b/keras/src/backend/openvino/random.py\nnew file mode 100644\nindex 000000000000..4d72a03112f5\n--- /dev/null\n+++ b/keras/src/backend/openvino/random.py\n@@ -0,0 +1,103 @@\n+import numpy as np\n+import openvino.runtime.opset14 as ov_opset\n+from openvino import Type\n+\n+from keras.src.backend.config import floatx\n+from keras.src.backend.openvino.core import OPENVINO_DTYPES\n+from keras.src.backend.openvino.core import OpenVINOKerasTensor\n+from keras.src.backend.openvino.core import convert_to_numpy\n+from keras.src.random.seed_generator import SeedGenerator\n+from keras.src.random.seed_generator import draw_seed\n+from keras.src.random.seed_generator import make_default_seed\n+\n+\n+def normal(shape, mean=0.0, stddev=1.0, dtype=None, seed=None):\n+    dtype = dtype or floatx()\n+    seed = draw_seed(seed)\n+    rng = np.random.default_rng(seed.data)\n+    normal_const = rng.normal(size=shape, loc=mean, scale=stddev).astype(dtype)\n+    return OpenVINOKerasTensor(ov_opset.constant(normal_const).output(0))\n+\n+\n+def uniform(shape, minval=0.0, maxval=1.0, dtype=None, seed=None):\n+    dtype = dtype or floatx()\n+    ov_type = OPENVINO_DTYPES[dtype]\n+    seed = draw_seed(seed)\n+    if isinstance(seed, OpenVINOKerasTensor):\n+        seed1, seed2 = convert_to_numpy(seed)\n+    else:\n+        seed1, seed2 = draw_seed(seed).data\n+    minval_const = ov_opset.constant(minval, dtype=dtype)\n+    maxval_const = ov_opset.constant(maxval, dtype=dtype)\n+    if isinstance(shape, tuple):\n+        shape = list(shape)\n+    output_shape_const = ov_opset.constant(shape, dtype=Type.i32)\n+    random_uniform = ov_opset.random_uniform(\n+        output_shape_const, minval_const, maxval_const, ov_type, seed1, seed2\n+    )\n+    return OpenVINOKerasTensor(random_uniform.output(0))\n+\n+\n+def categorical(logits, num_samples, dtype=\"int64\", seed=None):\n+    raise NotImplementedError(\n+        \"`categorical` is not supported with openvino backend\"\n+    )\n+\n+\n+def randint(shape, minval, maxval, dtype=\"int32\", seed=None):\n+    raise NotImplementedError(\n+        \"`randint` is not supported with openvino backend\"\n+    )\n+\n+\n+def truncated_normal(shape, mean=0.0, stddev=1.0, dtype=None, seed=None):\n+    dtype = dtype or floatx()\n+    seed = draw_seed(seed)\n+    rng = np.random.default_rng(seed.data)\n+\n+    lower_bound = mean - 2 * stddev\n+    upper_bound = mean + 2 * stddev\n+\n+    flat_shape = np.prod(shape)\n+    random_numbers = np.empty(0)\n+\n+    # loop until we have enough valid numbers to fill our desired shape\n+    while random_numbers.shape[0] < flat_shape:\n+        # Generate a batch of random numbers from a normal distribution\n+        batch = rng.normal(loc=mean, scale=stddev, size=flat_shape)\n+\n+        # Filter the numbers to keep only those within the specified bounds\n+        valid = batch[(batch >= lower_bound) & (batch <= upper_bound)]\n+\n+        # Append the valid numbers to the result array\n+        random_numbers = np.append(random_numbers, valid)\n+\n+    # Truncate the result array to the desired size and reshape it\n+    np_array_res = random_numbers[:flat_shape].astype(dtype).reshape(shape)\n+    return OpenVINOKerasTensor(ov_opset.constant(np_array_res).output(0))\n+\n+\n+def dropout(inputs, rate, noise_shape=None, seed=None):\n+    raise NotImplementedError(\n+        \"`dropout` is not supported with openvino backend\"\n+    )\n+\n+\n+def shuffle(x, axis=0, seed=None):\n+    raise NotImplementedError(\n+        \"`shuffle` is not supported with openvino backend\"\n+    )\n+\n+\n+def gamma(shape, alpha, dtype=None, seed=None):\n+    raise NotImplementedError(\"`gamma` is not supported with openvino backend\")\n+\n+\n+def binomial(shape, counts, probabilities, dtype=None, seed=None):\n+    raise NotImplementedError(\n+        \"`binomial` is not supported with openvino backend\"\n+    )\n+\n+\n+def beta(shape, alpha, beta, dtype=None, seed=None):\n+    raise NotImplementedError(\"`beta` is not supported with openvino backend\")\ndiff --git a/keras/src/backend/openvino/trainer.py b/keras/src/backend/openvino/trainer.py\nnew file mode 100644\nindex 000000000000..b95f635002aa\n--- /dev/null\n+++ b/keras/src/backend/openvino/trainer.py\n@@ -0,0 +1,272 @@\n+import numpy as np\n+import openvino as ov\n+import openvino.runtime.opset14 as ov_opset\n+\n+from keras.src import backend\n+from keras.src import callbacks as callbacks_module\n+from keras.src import tree\n+from keras.src.backend.openvino.core import OPENVINO_DTYPES\n+from keras.src.backend.openvino.core import OpenVINOKerasTensor\n+from keras.src.backend.openvino.core import get_device\n+from keras.src.trainers import trainer as base_trainer\n+from keras.src.trainers.data_adapters import data_adapter_utils\n+from keras.src.trainers.epoch_iterator import EpochIterator\n+from keras.src.utils import traceback_utils\n+\n+\n+class OpenVINOTrainer(base_trainer.Trainer):\n+    def __init__(self):\n+        super().__init__()\n+        self.test_function = None\n+        self.predict_function = None\n+        self.ov_compiled_model = None\n+        self.ov_device = None\n+        self.struct_params = None\n+        self.struct_outputs = None\n+\n+    def _unpack_singleton(self, x):\n+        if isinstance(x, (list, tuple)) and len(x) == 1:\n+            return x[0]\n+        return x\n+\n+    def test_step(self, data):\n+        raise NotImplementedError(\n+            \"`test_step` is not supported with openvino backend\"\n+        )\n+\n+    def predict_step(self, data):\n+        x, _, _ = data_adapter_utils.unpack_x_y_sample_weight(data)\n+        ov_compiled_model = self._get_compiled_model(x)\n+        flatten_x = tree.flatten(x)\n+        y_pred = ov_compiled_model(flatten_x)\n+        # recover structure of the model output\n+        y_pred = self._unpack_singleton(\n+            tree.pack_sequence_as(self.struct_outputs, y_pred.to_tuple())\n+        )\n+        return y_pred\n+\n+    def make_test_function(self, force=False):\n+        if self.test_function is not None and not force:\n+            return self.test_function\n+\n+        def one_test_step(data):\n+            data = data[0]\n+            return self.test_step(data)\n+\n+        def multi_test_steps(data):\n+            for single_step_data in data:\n+                logs = one_test_step([single_step_data])\n+            return logs\n+\n+        if self.steps_per_execution > 1:\n+            test_step = multi_test_steps\n+        else:\n+            test_step = one_test_step\n+\n+        self.test_function = test_step\n+\n+    def _parameterize_data(self, data):\n+        if isinstance(data, (list, tuple)):\n+            parametrize_data = []\n+            for elem in data:\n+                param_elem = self._parameterize_data(elem)\n+                parametrize_data.append(param_elem)\n+        elif isinstance(data, dict):\n+            parametrize_data = dict()\n+            for elem_name, elem in data.items():\n+                param_elem = self._parameterize_data(elem)\n+                parametrize_data[elem_name] = param_elem\n+        elif isinstance(data, np.ndarray) or np.isscalar(data):\n+            ov_type = OPENVINO_DTYPES[str(data.dtype)]\n+            ov_shape = list(data.shape)\n+            param = ov_opset.parameter(shape=ov_shape, dtype=ov_type)\n+            parametrize_data = OpenVINOKerasTensor(param.output(0))\n+        elif isinstance(data, int):\n+            param = ov_opset.parameter(shape=[], dtype=ov.Type.i32)\n+            parametrize_data = OpenVINOKerasTensor(param.output(0))\n+        elif isinstance(data, float):\n+            param = ov_opset.parameter(shape=[], dtype=ov.Type.f32)\n+            parametrize_data = OpenVINOKerasTensor(param.output(0))\n+        else:\n+            raise \"Unknown type of input data {}\".format(type(data))\n+        return parametrize_data\n+\n+    def _get_compiled_model(self, data):\n+        if (\n+            self.ov_compiled_model is not None\n+            and get_device() == self.ov_device\n+        ):\n+            return self.ov_compiled_model\n+\n+        # remove the previous cached compiled model if exists\n+        del self.ov_compiled_model\n+\n+        # prepare parameterized input\n+        self.struct_params = self._parameterize_data(data)\n+        # construct OpenVINO graph during calling Keras Model\n+        self.struct_outputs = self(self.struct_params)\n+\n+        parameters = []\n+        for p in tree.flatten(self.struct_params):\n+            parameters.append(p.output.get_node())\n+        results = []\n+        for r in tree.flatten(self.struct_outputs):\n+            results.append(ov_opset.result(r.output))\n+\n+        # prepare compiled model from scratch\n+        ov_model = ov.Model(results=results, parameters=parameters)\n+        self.ov_compiled_model = ov.compile_model(ov_model, get_device())\n+        self.ov_device = get_device()\n+        return self.ov_compiled_model\n+\n+    def make_predict_function(self, force=False):\n+        if self.predict_function is not None and not force:\n+            return self.predict_function\n+\n+        def one_predict_step(data):\n+            data = data[0]\n+            return self.predict_step(data)\n+\n+        def multi_predict_steps(data):\n+            outputs = one_predict_step(data[:1])\n+\n+            for single_step_data in data[1:]:\n+                step_outputs = one_predict_step([single_step_data])\n+                outputs = tree.map_structure(\n+                    lambda t1, t2: np.concatenate([t1, t2]),\n+                    outputs,\n+                    step_outputs,\n+                )\n+            return outputs\n+\n+        if self.steps_per_execution > 1:\n+            predict_step = multi_predict_steps\n+        else:\n+            predict_step = one_predict_step\n+\n+        self.predict_function = predict_step\n+\n+    def fit(\n+        self,\n+        x=None,\n+        y=None,\n+        batch_size=None,\n+        epochs=1,\n+        verbose=\"auto\",\n+        callbacks=None,\n+        validation_split=0.0,\n+        validation_data=None,\n+        shuffle=True,\n+        class_weight=None,\n+        sample_weight=None,\n+        initial_epoch=0,\n+        steps_per_epoch=None,\n+        validation_steps=None,\n+        validation_batch_size=None,\n+        validation_freq=1,\n+    ):\n+        raise NotImplementedError(\n+            \"`fit` is not supported with openvino backend\"\n+        )\n+\n+    @traceback_utils.filter_traceback\n+    def predict(\n+        self, x, batch_size=None, verbose=\"auto\", steps=None, callbacks=None\n+    ):\n+        # Create an iterator that yields batches of input data.\n+        epoch_iterator = EpochIterator(\n+            x=x,\n+            batch_size=batch_size,\n+            steps_per_epoch=steps,\n+            shuffle=False,\n+            steps_per_execution=self.steps_per_execution,\n+        )\n+\n+        # Container that configures and calls callbacks.\n+        if not isinstance(callbacks, callbacks_module.CallbackList):\n+            callbacks = callbacks_module.CallbackList(\n+                callbacks,\n+                add_history=True,\n+                add_progbar=verbose != 0,\n+                verbose=verbose,\n+                epochs=1,\n+                steps=epoch_iterator.num_batches,\n+                model=self,\n+            )\n+\n+        def append_to_outputs(batch_outputs, outputs):\n+            if outputs is None:\n+                outputs = tree.map_structure(\n+                    lambda batch_output: [batch_output],\n+                    batch_outputs,\n+                )\n+            else:\n+                tree.map_structure_up_to(\n+                    batch_outputs,\n+                    lambda output, batch_output: output.append(batch_output),\n+                    outputs,\n+                    batch_outputs,\n+                )\n+            return outputs\n+\n+        self.make_predict_function()\n+        self.stop_predicting = False\n+        callbacks.on_predict_begin()\n+        outputs = None\n+        for step, data in epoch_iterator.enumerate_epoch():\n+            callbacks.on_predict_batch_begin(step)\n+            batch_outputs = self.predict_function(data)\n+            outputs = append_to_outputs(batch_outputs, outputs)\n+            callbacks.on_predict_batch_end(step, {\"outputs\": batch_outputs})\n+            if self.stop_predicting:\n+                break\n+        callbacks.on_predict_end()\n+        return tree.map_structure_up_to(batch_outputs, np.concatenate, outputs)\n+\n+    @traceback_utils.filter_traceback\n+    def evaluate(\n+        self,\n+        x=None,\n+        y=None,\n+        batch_size=None,\n+        verbose=\"auto\",\n+        sample_weight=None,\n+        steps=None,\n+        callbacks=None,\n+        return_dict=False,\n+        **kwargs,\n+    ):\n+        raise NotImplementedError(\n+            \"`evaluate` is not supported with openvino backend\"\n+        )\n+\n+    def train_on_batch(\n+        self,\n+        x,\n+        y=None,\n+        sample_weight=None,\n+        class_weight=None,\n+        return_dict=False,\n+    ):\n+        raise NotImplementedError(\n+            \"`train_on_batch` is not supported with openvino backend\"\n+        )\n+\n+    def test_on_batch(\n+        self,\n+        x,\n+        y=None,\n+        sample_weight=None,\n+        return_dict=False,\n+    ):\n+        raise NotImplementedError(\n+            \"`test_on_batch` is not supported with openvino backend\"\n+        )\n+\n+    def predict_on_batch(self, x):\n+        self.make_predict_function()\n+        batch_outputs = self.predict_function([(x,)])\n+        batch_outputs = tree.map_structure(\n+            backend.convert_to_numpy, batch_outputs\n+        )\n+        return batch_outputs\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR shows significant progress by adding support for the Bert and MobileNet models. However, integration tests specific to the OpenVINO backend are lacking. I recommend going forward with a strategy that leverages existing Keras tests while maintaining flexibility to add more ops over time. This approach will ensure better coverage and alignment with Keras’s evolving design. Additionally, creating an OpenVINO-specific config file to manage excluded tests is a solid plan. Let's ensure the integration tests evolve as we expand OpenVINO support."
      }
    ],
    "token_estimation": 22110.5
  },
  {
    "index": 46,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/tests/manual/check_masked_recurrent.py b/tests/manual/check_masked_recurrent.py\nnew file mode 100644\nindex 000000000000..8c849072eca0\n--- /dev/null\n+++ b/tests/manual/check_masked_recurrent.py\n@@ -0,0 +1,130 @@\n+# Dummy test data as input to RNN. This input is 3 timesteps long where the third timestep always matches the\n+# first. Without masking it should be able to learn it, with masking it should fail.\n+\n+import numpy as np\n+from keras.utils.theano_utils import sharedX\n+from keras.models import Sequential\n+from keras.layers.core import Dense, Activation, Merge, Dropout, TimeDistributedDense\n+from keras.layers.embeddings import Embedding\n+from keras.layers.recurrent import SimpleRNN, SimpleDeepRNN, LSTM, GRU\n+import theano\n+\n+theano.config.exception_verbosity='high' \n+\n+# (nb_samples, timesteps, dimensions)\n+X = np.random.random_integers(1, 4, size=(500000,15))\n+\n+print(\"About to compile the first model\")\n+model = Sequential()\n+model.add(Embedding(5, 4, mask_zero=True))\n+model.add(TimeDistributedDense(4,4)) # obviously this is redundant. Just testing.\n+model.add(SimpleRNN(4,4, activation='relu', return_sequences=True))\n+model.add(Dropout(0.5))\n+model.add(SimpleDeepRNN(4,4, depth=2, activation='relu')) \n+model.add(Dropout(0.5))\n+model.add(Dense(4,4, activation='softmax'))\n+model.compile(loss='categorical_crossentropy',\n+        optimizer='rmsprop', theano_mode=theano.compile.mode.FAST_RUN)\n+print(\"Compiled model\")\n+\n+W = model.get_weights() # We'll save these so we can reset it later\n+\n+X[:,:10] = 0\n+Xmask0 = X.copy()\n+Xmask0[:,10] = 0\n+\n+Xmask12 = X.copy()\n+Xmask12[:,11] = 0\n+Xmask12[:,12] = 0\n+\n+X0_onehot = np.zeros((X.shape[0], 4))\n+X1_onehot = np.zeros((X.shape[0], 4))\n+for i, row in enumerate(X):\n+    X0_onehot[i, row[10]-1] = 1\n+    X1_onehot[i, row[11]-1] = 1\n+\n+# Uniform score: 4 options = ln(4) nats (2 bits)\n+# we should not do better than this when we mask out the part of the input\n+# that gives us the correct answer\n+uniform_score = np.log(4)\n+batch_size=512\n+\n+# Train it to guess 0th dim\n+model.fit(X, X0_onehot, nb_epoch=1, batch_size=batch_size)\n+score = model.evaluate(X, X0_onehot, batch_size=batch_size)\n+if score > uniform_score*0.9:\n+    raise Exception('Failed to learn to copy timestep 0, score %f' % score)\n+    \n+\n+model.set_weights(W)\n+\n+# Train without showing it the 0th dim to learn 1st dim\n+model.fit(X[:,1:], X1_onehot, nb_epoch=1, batch_size=batch_size)\n+score = model.evaluate(X[:,1:], X1_onehot, batch_size=batch_size)\n+if score > uniform_score*0.9:\n+    raise Exception('Failed to learn to copy timestep 1, score %f' % score)\n+\n+model.set_weights(W)\n+\n+# Train to guess 0th dim when 0th dim has been masked (should fail)\n+model.fit(Xmask0, X0_onehot, nb_epoch=1, batch_size=batch_size)\n+score = model.evaluate(Xmask0, X0_onehot, batch_size=batch_size)\n+if score < uniform_score*0.9:\n+   raise Exception('Somehow learned to copy timestep 0 despite mask, score %f' % score)\n+\n+model.set_weights(W)\n+\n+# Train to guess 1st dim when 0th dim has been masked (should succeed)\n+model.fit(Xmask0, X1_onehot, nb_epoch=1, batch_size=batch_size)\n+score = model.evaluate(Xmask0, X1_onehot, batch_size=batch_size)\n+if score > uniform_score*0.9:\n+    raise Exception('Failed to learn to copy timestep 1 in masked model, score %f' % score)\n+\n+model.set_weights(W)\n+\n+# Finally, make sure the mask is actually blocking input, mask out timesteps 1 and 2, and see if\n+# it can learn timestep 0 (should fail)\n+model.fit(Xmask12, X0_onehot, nb_epoch=1, batch_size=batch_size)\n+\n+score = model.evaluate(Xmask12, X0_onehot, batch_size=batch_size)\n+if score < uniform_score*0.9:\n+    raise Exception('Somehow learned to copy timestep 0 despite masking 1, score %f' % score)\n+\n+# Another testing approach, just initialize models and make sure that prepending zeros doesn't affect\n+# their output\n+print(\"About to compile the second model\")\n+model2 = Sequential()\n+model2.add(Embedding(5, 4, mask_zero=True))\n+model2.add(TimeDistributedDense(4,4))\n+model2.add(Activation('time_distributed_softmax'))\n+model2.add(LSTM(4,4, return_sequences=True))\n+model2.add(Activation('tanh'))\n+model2.add(GRU(4,4, activation='softmax', return_sequences=True))\n+model2.add(SimpleDeepRNN(4,4, depth=2, activation='relu', return_sequences=True)) \n+model2.add(SimpleRNN(4,4, activation='relu', return_sequences=True))\n+model2.compile(loss='categorical_crossentropy',\n+        optimizer='rmsprop', theano_mode=theano.compile.mode.FAST_RUN)\n+print(\"Compiled model2\")\n+\n+X2 = np.random.random_integers(1, 4, size=(2,5))\n+y2 = np.random.random((X2.shape[0],X2.shape[1],4))\n+\n+ref = model2.predict(X2)\n+ref_eval = model2.evaluate(X2, y2)\n+mask = np.ones((y2.shape[0], y2.shape[1], 1))\n+\n+for pre_zeros in range(1,10):\n+    padded_X2 = np.concatenate((np.zeros((X2.shape[0], pre_zeros)), X2), axis=1)\n+    padded_mask = np.concatenate((np.zeros((mask.shape[0], pre_zeros, mask.shape[2])), mask), axis=1)\n+    padded_y2 = np.concatenate((np.zeros((y2.shape[0], pre_zeros, y2.shape[2])), y2), axis=1)\n+\n+    pred = model2.predict(padded_X2)\n+    if not np.allclose(ref[:,-1,:], pred[:,-1,:]):\n+        raise Exception(\"Different result after left-padding %d zeros. Ref: %s, Pred: %s\" % (pre_zeros, ref, pred))\n+\n+    pad_eval = model2.evaluate(padded_X2, padded_y2, weights=padded_mask)\n+    if not np.allclose([pad_eval], [ref_eval]):\n+        raise Exception(\"Got dissimilar categorical_crossentropy after left-padding %d zeros. Ref: %f, Pred %f\" %\\\n+                (pref_eval, pred_val))\n+\n+        \n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR raises a few key points. First, the purpose of broadcasting the mask isn't immediately clear; clarifying its role in maintaining tensor shapes would help. Additionally, the increased GPU test duration could require investigation to ensure efficiency. The solution to mask propagation issues through RNNs needs careful consideration. Using a hard-coded mask value appears to be a fallback option—its performance impact may be minimal, but consider potential complications with bias terms in `TimeDistributedDense`. Lastly, thorough testing is crucial, especially before merging, to resolve outstanding issues with masked data handling."
      }
    ],
    "token_estimation": 1543.75
  },
  {
    "index": 47,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/examples/tensorboard_embeddings_mnist.py b/examples/tensorboard_embeddings_mnist.py\nnew file mode 100644\nindex 000000000000..8dc8342343ff\n--- /dev/null\n+++ b/examples/tensorboard_embeddings_mnist.py\n@@ -0,0 +1,96 @@\n+'''Trains a simple convnet on the MNIST dataset and embeds test data.\n+\n+The test data is embedded using the weights of the final dense layer, just\n+before the classification head. This embedding can then be visualized using\n+TensorBoard's Embedding Projector.\n+'''\n+\n+from __future__ import print_function\n+\n+from os import makedirs\n+from os.path import exists, join\n+\n+import keras\n+from keras.callbacks import TensorBoard\n+from keras.datasets import mnist\n+from keras.models import Sequential\n+from keras.layers import Dense, Dropout, Flatten\n+from keras.layers import Conv2D, MaxPooling2D\n+from keras import backend as K\n+\n+import numpy as np\n+\n+batch_size = 128\n+num_classes = 10\n+epochs = 12\n+log_dir = './logs'\n+\n+if not exists(log_dir):\n+    makedirs(log_dir)\n+\n+# input image dimensions\n+img_rows, img_cols = 28, 28\n+\n+# the data, split between train and test sets\n+(x_train, y_train), (x_test, y_test) = mnist.load_data()\n+\n+if K.image_data_format() == 'channels_first':\n+    x_train = x_train.reshape(x_train.shape[0], 1, img_rows, img_cols)\n+    x_test = x_test.reshape(x_test.shape[0], 1, img_rows, img_cols)\n+    input_shape = (1, img_rows, img_cols)\n+else:\n+    x_train = x_train.reshape(x_train.shape[0], img_rows, img_cols, 1)\n+    x_test = x_test.reshape(x_test.shape[0], img_rows, img_cols, 1)\n+    input_shape = (img_rows, img_cols, 1)\n+\n+x_train = x_train.astype('float32')\n+x_test = x_test.astype('float32')\n+x_train /= 255\n+x_test /= 255\n+print('x_train shape:', x_train.shape)\n+print(x_train.shape[0], 'train samples')\n+print(x_test.shape[0], 'test samples')\n+\n+# save class labels to disk to color data points in TensorBoard accordingly\n+with open(join(log_dir, 'metadata.tsv'), 'w') as f:\n+    np.savetxt(f, y_test)\n+\n+# convert class vectors to binary class matrices\n+y_train = keras.utils.to_categorical(y_train, num_classes)\n+y_test = keras.utils.to_categorical(y_test, num_classes)\n+\n+tensorboard = TensorBoard(batch_size=batch_size,\n+                          embeddings_freq=1,\n+                          embeddings_layer_names=['features'],\n+                          embeddings_metadata='metadata.tsv',\n+                          embeddings_data=x_test)\n+\n+model = Sequential()\n+model.add(Conv2D(32, kernel_size=(3, 3),\n+                 activation='relu',\n+                 input_shape=input_shape))\n+model.add(Conv2D(64, (3, 3), activation='relu'))\n+model.add(MaxPooling2D(pool_size=(2, 2)))\n+model.add(Dropout(0.25))\n+model.add(Flatten())\n+model.add(Dense(128, activation='relu', name='features'))\n+model.add(Dropout(0.5))\n+model.add(Dense(num_classes, activation='softmax'))\n+\n+model.compile(loss=keras.losses.categorical_crossentropy,\n+              optimizer=keras.optimizers.Adadelta(),\n+              metrics=['accuracy'])\n+\n+model.fit(x_train, y_train,\n+          batch_size=batch_size,\n+          callbacks=[tensorboard],\n+          epochs=epochs,\n+          verbose=1,\n+          validation_data=(x_test, y_test))\n+score = model.evaluate(x_test, y_test, verbose=0)\n+print('Test loss:', score[0])\n+print('Test accuracy:', score[1])\n+\n+# You can now launch tensorboard with `tensorboard --logdir=./logs` on your\n+# command line and then go to http://localhost:6006/#projector to view the\n+# embeddings\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR offers essential improvements to the `TensorBoard` callback for embedding visualization. However, including before/after screenshots is necessary to clarify the visual changes in functionality. More documentation on `validation_data_size` is vital, especially regarding its use with `steps`. The learning phase handling in `on_epoch_end` needs attention to ensure dropout layers function properly. It's also worth considering replacing `validation_data_size` with a more intuitive `embedding_data` argument to enhance user experience. Batch processing needs refinement to handle variable data sizes effectively."
      }
    ],
    "token_estimation": 1023.75
  },
  {
    "index": 48,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/examples/mnist_tfrecord.py b/examples/mnist_tfrecord.py\nnew file mode 100644\nindex 000000000000..342007fa96ef\n--- /dev/null\n+++ b/examples/mnist_tfrecord.py\n@@ -0,0 +1,158 @@\n+'''MNIST dataset with TFRecords, the standard TensorFlow data format.\n+\n+TFRecord is a data format supported throughout TensorFlow.\n+This example demonstrates how to load TFRecord data using\n+Input Tensors. Input Tensors differ from the normal Keras\n+workflow because instead of fitting to data loaded into a\n+a numpy array, data is supplied via a special tensor that\n+reads data from nodes that are wired directly into model\n+graph with the `Input(tensor=input_tensor)` parameter.\n+\n+There are several advantages to using Input Tensors.\n+First, if a dataset is already in TFRecord format you\n+can load and train on that data directly in Keras.\n+Second, extended backend API capabilities such as TensorFlow\n+data augmentation is easy to integrate directly into your\n+Keras training scripts via input tensors.\n+Third, TensorFlow implements several data APIs for\n+TFRecords, some of which provide significantly faster\n+training performance than numpy arrays can provide because\n+they run via the C++ backend. Please note that this\n+example is tailored for brevity and clarity and not\n+to demonstrate performance or augmentation capabilities.\n+\n+Input Tensors also have important disadvantages. In\n+particular, Input Tensors are fixed at model construction\n+because rewiring networks is not yet supported.\n+For this reason, changing the data input source means\n+model weights must be saved and the model rebuilt\n+from scratch to connect the new input data.\n+validation cannot currently be performed as training\n+progresses, and must be performed after training completes.\n+This example demonstrates how to train with input\n+tensors, save the model weights, and then evaluate the\n+model using the numpy based Keras API.\n+\n+Gets to 99.1% test accuracy after 78 epochs\n+(there is still a lot of margin for parameter tuning).\n+'''\n+import os\n+import copy\n+import time\n+\n+import numpy as np\n+\n+import tensorflow as tf\n+from keras import backend as K\n+from keras.models import Model\n+from keras import layers\n+from keras import objectives\n+from keras.utils import np_utils\n+from keras import objectives\n+\n+from tensorflow.contrib.learn.python.learn.datasets import mnist\n+\n+if K.backend() != 'tensorflow':\n+    raise RuntimeError('This example can only run with the '\n+                       'TensorFlow backend for the time being, '\n+                       'because it requires TFRecords, which '\n+                       'are not supported on other platforms.')\n+\n+\n+def cnn_layers(x_train_input):\n+    x = layers.Conv2D(32, (3, 3),\n+                      activation='relu', padding='valid')(x_train_input)\n+    x = layers.Conv2D(64, (3, 3), activation='relu')(x)\n+    x = layers.MaxPooling2D(pool_size=(2, 2))(x)\n+    x = layers.Dropout(0.25)(x)\n+    x = layers.Flatten()(x)\n+    x = layers.Dense(128, activation='relu')(x)\n+    x = layers.Dropout(0.5)(x)\n+    x_train_out = layers.Dense(classes,\n+                               activation='softmax',\n+                               name='x_train_out')(x)\n+    return x_train_out\n+\n+sess = K.get_session()\n+\n+batch_size = 128\n+batch_shape = (batch_size, 28, 28, 1)\n+steps_per_epoch = 469\n+epochs = 78\n+classes = 10\n+\n+# The capacity variable controls the maximum queue size\n+# allowed when prefetching data for training.\n+capacity = 10000\n+\n+# min_after_dequeue is the minimum number elements in the queue\n+# after a dequeue, which ensures sufficient mixing of elements.\n+min_after_dequeue = 3000\n+\n+# If `enqueue_many` is `False`, `tensors` is assumed to represent a\n+# single example.  An input tensor with shape `[x, y, z]` will be output\n+# as a tensor with shape `[batch_size, x, y, z]`.\n+#\n+# If `enqueue_many` is `True`, `tensors` is assumed to represent a\n+# batch of examples, where the first dimension is indexed by example,\n+# and all members of `tensors` should have the same size in the\n+# first dimension.  If an input tensor has shape `[*, x, y, z]`, the\n+# output will have shape `[batch_size, x, y, z]`.\n+enqueue_many = True\n+\n+data = mnist.load_mnist()\n+x_train_batch, y_train_batch = tf.train.shuffle_batch(\n+    tensors=[data.train.images, data.train.labels.astype(np.int32)],\n+    batch_size=batch_size,\n+    capacity=capacity,\n+    min_after_dequeue=min_after_dequeue,\n+    enqueue_many=enqueue_many,\n+    num_threads=8)\n+\n+x_train_batch = tf.cast(x_train_batch, tf.float32)\n+x_train_batch = tf.reshape(x_train_batch, shape=batch_shape)\n+\n+y_train_batch = tf.cast(y_train_batch, tf.int32)\n+y_train_batch = tf.one_hot(y_train_batch, classes)\n+\n+x_batch_shape = x_train_batch.get_shape().as_list()\n+y_batch_shape = y_train_batch.get_shape().as_list()\n+\n+x_train_input = layers.Input(tensor=x_train_batch, batch_shape=x_batch_shape)\n+x_train_out = cnn_layers(x_train_input)\n+train_model = Model(inputs=x_train_input, outputs=x_train_out)\n+\n+cce = objectives.categorical_crossentropy(y_train_batch, x_train_out)\n+train_model.add_loss(cce)\n+\n+# Do not pass the loss directly to model.compile()\n+# because it is not yet supported for Input Tensors.\n+train_model.compile(optimizer='rmsprop',\n+                    loss=None,\n+                    metrics=['accuracy'])\n+train_model.summary()\n+\n+coord = tf.train.Coordinator()\n+threads = tf.train.start_queue_runners(sess, coord)\n+train_model.fit(epochs=epochs,\n+                steps_per_epoch=steps_per_epoch)\n+\n+train_model.save_weights('saved_wt.h5')\n+\n+coord.request_stop()\n+coord.join(threads)\n+K.clear_session()\n+\n+# Second Session to test loading trained model without tensors\n+x_test = np.reshape(data.validation.images, (data.validation.images.shape[0], 28, 28, 1))\n+y_test = data.validation.labels\n+x_test_inp = layers.Input(batch_shape=(None,) + (x_test.shape[1:]))\n+test_out = cnn_layers(x_test_inp)\n+test_model = Model(inputs=x_test_inp, outputs=test_out)\n+\n+test_model.load_weights('saved_wt.h5')\n+test_model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])\n+test_model.summary()\n+\n+loss, acc = test_model.evaluate(x_test, np_utils.to_categorical(y_test), classes)\n+print('\\nTest accuracy: {0}'.format(acc))\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR introduces a structured approach for handling data sampling by prioritizing sample recovery and raising relevant errors/warnings based on `steps_per_epoch` and `batch_size` configurations. However, it seems there's confusion regarding the treatment of `batch_size`, which should not be ignored since it's integral to computations. Additionally, validation for input tensors may require further elaboration; keep it clean and concise to maintain clarity. The coordination with PR #6928 appears crucial for achieving consistency across the API."
      }
    ],
    "token_estimation": 1700.75
  },
  {
    "index": 49,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/keras/backend/theano_backend.py b/keras/backend/theano_backend.py\nindex 5ea9a2f16ab5..94cd2a387481 100644\n--- a/keras/backend/theano_backend.py\n+++ b/keras/backend/theano_backend.py\n@@ -647,6 +704,67 @@ def conv2d(x, kernel, strides=(1, 1), border_mode='valid', dim_ordering='th',\n     return conv_out\n \n \n+def conv3d(x, kernel, strides=(1, 1, 1), border_mode='valid', dim_ordering='th',\n+           volume_shape=None, filter_shape=None):\n+    '''\n+    Run on cuDNN if available.\n+    border_mode: string, \"same\" or \"valid\".\n+    '''\n+    if dim_ordering not in {'th', 'tf'}:\n+        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+\n+    if border_mode not in {'same', 'valid'}:\n+        raise Exception('Invalid border mode: ' + str(border_mode))\n+\n+    if dim_ordering == 'tf':\n+        # TF uses the last dimension as channel dimension,\n+        # instead of the 2nd one.\n+        # TH input shape: (samples, input_depth, conv_dim1, conv_dim2, conv_dim3)\n+        # TF input shape: (samples, conv_dim1, conv_dim2, conv_dim3, input_depth)\n+        # TH kernel shape: (out_depth, input_depth, kernel_dim1, kernel_dim2, kernel_dim3)\n+        # TF kernel shape: (kernel_dim1, kernel_dim2, kernel_dim3, input_depth, out_depth)\n+        x = x.dimshuffle((0, 4, 1, 2, 3))\n+        kernel = kernel.dimshuffle((4, 3, 0, 1, 2))\n+        if volume_shape:\n+            volume_shape = (volume_shape[0], volume_shape[4],\n+                            volume_shape[1], volume_shape[2], volume_shape[3])\n+        if filter_shape:\n+            filter_shape = (filter_shape[4], filter_shape[3],\n+                            filter_shape[0], filter_shape[1], filter_shape[2])\n+\n+    if border_mode == 'same':\n+        assert(strides == (1, 1, 1))\n+        pad_dim1 = (kernel.shape[2] - 1)\n+        pad_dim2 = (kernel.shape[3] - 1)\n+        pad_dim3 = (kernel.shape[4] - 1)\n+        output_shape = (x.shape[0], x.shape[1],\n+                        x.shape[2] + pad_dim1,\n+                        x.shape[3] + pad_dim2,\n+                        x.shape[4] + pad_dim3)\n+        output = T.zeros(output_shape)\n+        indices = (slice(None), slice(None),\n+                   slice(pad_dim1 // 2, x.shape[2] + pad_dim1 // 2),\n+                   slice(pad_dim2 // 2, x.shape[3] + pad_dim2 // 2),\n+                   slice(pad_dim3 // 2, x.shape[4] + pad_dim3 // 2))\n+        x = T.set_subtensor(output[indices], x)\n+        border_mode = 'valid'\n+\n+    border_mode_3d = (border_mode, border_mode, border_mode)\n+    conv_out = conv3d2d.conv3d(signals=x.dimshuffle(0, 2, 1, 3, 4),\n+                               filters=kernel.dimshuffle(0, 2, 1, 3, 4),\n+                               border_mode=border_mode_3d)\n+    conv_out = conv_out.dimshuffle(0, 2, 1, 3, 4)\n+\n+    # support strides by manually slicing the output\n+    if strides != (1, 1, 1):\n+        conv_out = conv_out[:, :, ::strides[0], ::strides[1], ::strides[2]]\n+\n+    if dim_ordering == 'tf':\n+        conv_out = conv_out.dimshuffle((0, 2, 3, 4, 1))\n+\n+    return conv_out\n+\n+\n def pool2d(x, pool_size, strides=(1, 1), border_mode='valid',\n            dim_ordering='th', pool_mode='max'):\n     if border_mode == 'same':\n@@ -682,6 +800,64 @@ def pool2d(x, pool_size, strides=(1, 1), border_mode='valid',\n     return pool_out\n \n \n+def pool3d(x, pool_size, strides=(1, 1, 1), border_mode='valid',\n+           dim_ordering='th', pool_mode='max'):\n+    if border_mode == 'same':\n+        # TODO: add implementation for border_mode=\"same\"\n+        raise Exception('border_mode=\"same\" not supported with Theano.')\n+    elif border_mode == 'valid':\n+        ignore_border = True\n+        padding = (0, 0)\n+    else:\n+        raise Exception('Invalid border mode: ' + str(border_mode))\n+\n+    if dim_ordering not in {'th', 'tf'}:\n+        raise Exception('Unknown dim_ordering ' + str(dim_ordering))\n+\n+    if dim_ordering == 'tf':\n+        x = x.dimshuffle((0, 4, 1, 2, 3))\n+\n+    if pool_mode == 'max':\n+        # pooling over conv_dim2, conv_dim1 (last two channels)\n+        output = downsample.max_pool_2d(input=x.dimshuffle(0, 1, 4, 3, 2),\n+                                        ds=(pool_size[1], pool_size[0]),\n+                                        st=(strides[1], strides[0]),\n+                                        ignore_border=ignore_border,\n+                                        padding=padding,\n+                                        mode='max')\n+\n+        # pooling over conv_dim3\n+        pool_out = downsample.max_pool_2d(input=output.dimshuffle(0, 1, 4, 3, 2),\n+                                          ds=(1, pool_size[2]),\n+                                          st=(1, strides[2]),\n+                                          ignore_border=ignore_border,\n+                                          padding=padding,\n+                                          mode='max')\n+\n+    elif pool_mode == 'avg':\n+        # pooling over conv_dim2, conv_dim1 (last two channels)\n+        output = downsample.max_pool_2d(input=x.dimshuffle(0, 1, 4, 3, 2),\n+                                        ds=(pool_size[1], pool_size[0]),\n+                                        st=(strides[1], strides[0]),\n+                                        ignore_border=ignore_border,\n+                                        padding=padding,\n+                                        mode='average_exc_pad')\n+\n+        # pooling over conv_dim3\n+        pool_out = downsample.max_pool_2d(input=output.dimshuffle(0, 1, 4, 3, 2),\n+                                          ds=(1, pool_size[2]),\n+                                          st=(1, strides[2]),\n+                                          ignore_border=ignore_border,\n+                                          padding=padding,\n+                                          mode='average_exc_pad')\n+    else:\n+        raise Exception('Invalid pooling mode: ' + str(pool_mode))\n+\n+    if dim_ordering == 'tf':\n+        pool_out = pool_out.dimshuffle((0, 2, 3, 4, 1))\n+    return pool_out\n+\n+\n # RANDOMNESS\n \n \ndiff --git a/keras/layers/convolutional.py b/keras/layers/convolutional.py\nindex 2ab14a7080ed..08ad068def49 100644\n--- a/keras/layers/convolutional.py\n+++ b/keras/layers/convolutional.py\n@@ -343,6 +343,196 @@ def get_config(self):\n         return dict(list(base_config.items()) + list(config.items()))\n \n \n+class Convolution3D(Layer):\n+    '''Convolution operator for filtering windows of three-dimensional inputs.\n+    When using this layer as the first layer in a model,\n+    provide the keyword argument `input_shape`\n+    (tuple of integers, does not include the sample axis),\n+    e.g. `input_shape=(3, 10, 128, 128)` for 10 frames of 128x128 RGB pictures.\n+\n+    Note: this layer will only work with Theano for the time being.\n+\n+    # Input shape\n+        5D tensor with shape:\n+        `(samples, channels, conv_dim1, conv_dim2, conv_dim3)` if dim_ordering='th'\n+        or 5D tensor with shape:\n+        `(samples, conv_dim1, conv_dim2, conv_dim3, channels)` if dim_ordering='tf'.\n+\n+    # Output shape\n+        5D tensor with shape:\n+        `(samples, nb_filter, new_conv_dim1, new_conv_dim2, new_conv_dim3)` if dim_ordering='th'\n+        or 5D tensor with shape:\n+        `(samples, new_conv_dim1, new_conv_dim2, new_conv_dim3, nb_filter)` if dim_ordering='tf'.\n+        `new_conv_dim1`, `new_conv_dim2` and `new_conv_dim3` values might have changed due to padding.\n+\n+    # Arguments\n+        nb_filter: Number of convolution filters to use.\n+        kernel_dim1: Length of the first dimension in the covolution kernel.\n+        kernel_dim2: Length of the second dimension in the convolution kernel.\n+        kernel_dim3: Length of the third dimension in the convolution kernel.\n+        init: name of initialization function for the weights of the layer\n+            (see [initializations](../initializations.md)), or alternatively,\n+            Theano function to use for weights initialization.\n+            This parameter is only relevant if you don't pass\n+            a `weights` argument.\n+        activation: name of activation function to use\n+            (see [activations](../activations.md)),\n+            or alternatively, elementwise Theano function.\n+            If you don't specify anything, no activation is applied\n+            (ie. \"linear\" activation: a(x) = x).\n+        weights: list of numpy arrays to set as initial weights.\n+        border_mode: 'valid' or 'same'.\n+        subsample: tuple of length 3. Factor by which to subsample output.\n+            Also called strides elsewhere.\n+            Note: 'subsample' is implemented by slicing the output of conv3d with strides=(1,1,1).\n+        W_regularizer: instance of [WeightRegularizer](../regularizers.md)\n+            (eg. L1 or L2 regularization), applied to the main weights matrix.\n+        b_regularizer: instance of [WeightRegularizer](../regularizers.md),\n+            applied to the bias.\n+        activity_regularizer: instance of [ActivityRegularizer](../regularizers.md),\n+            applied to the network output.\n+        W_constraint: instance of the [constraints](../constraints.md) module\n+            (eg. maxnorm, nonneg), applied to the main weights matrix.\n+        b_constraint: instance of the [constraints](../constraints.md) module,\n+            applied to the bias.\n+        dim_ordering: 'th' or 'tf'. In 'th' mode, the channels dimension\n+            (the depth) is at index 1, in 'tf' mode is it at index 4.\n+    '''\n+    input_ndim = 5\n+\n+    def __init__(self, nb_filter, kernel_dim1, kernel_dim2, kernel_dim3,\n+                 init='glorot_uniform', activation='linear', weights=None,\n+                 border_mode='valid', subsample=(1, 1, 1), dim_ordering='th',\n+                 W_regularizer=None, b_regularizer=None, activity_regularizer=None,\n+                 W_constraint=None, b_constraint=None, **kwargs):\n+        if K._BACKEND != 'theano':\n+            raise Exception(self.__class__.__name__ +\n+                            ' is currently only working with Theano backend.')\n+        if border_mode not in {'valid', 'same'}:\n+            raise Exception('Invalid border mode for Convolution3D:', border_mode)\n+        self.nb_filter = nb_filter\n+        self.kernel_dim1 = kernel_dim1\n+        self.kernel_dim2 = kernel_dim2\n+        self.kernel_dim3 = kernel_dim3\n+        self.init = initializations.get(init)\n+        self.activation = activations.get(activation)\n+        assert border_mode in {'valid', 'same'}, 'border_mode must be in {valid, same}'\n+        self.border_mode = border_mode\n+        self.subsample = tuple(subsample)\n+        assert dim_ordering in {'tf', 'th'}, 'dim_ordering must be in {tf, th}'\n+        self.dim_ordering = dim_ordering\n+\n+        self.W_regularizer = regularizers.get(W_regularizer)\n+        self.b_regularizer = regularizers.get(b_regularizer)\n+        self.activity_regularizer = regularizers.get(activity_regularizer)\n+\n+        self.W_constraint = constraints.get(W_constraint)\n+        self.b_constraint = constraints.get(b_constraint)\n+        self.constraints = [self.W_constraint, self.b_constraint]\n+\n+        self.initial_weights = weights\n+        self.input = K.placeholder(ndim=5)\n+        super(Convolution3D, self).__init__(**kwargs)\n+\n+    def build(self):\n+\n+        if self.dim_ordering == 'th':\n+            stack_size = self.input_shape[1]\n+            self.W_shape = (self.nb_filter, stack_size,\n+                            self.kernel_dim1, self.kernel_dim2, self.kernel_dim3)\n+        elif self.dim_ordering == 'tf':\n+            stack_size = self.input_shape[4]\n+            self.W_shape = (self.kernel_dim1, self.kernel_dim2, self.kernel_dim3,\n+                            stack_size, self.nb_filter)\n+        else:\n+            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+\n+        self.W = self.init(self.W_shape)\n+        self.b = K.zeros((self.nb_filter,))\n+        self.trainable_weights = [self.W, self.b]\n+        self.regularizers = []\n+\n+        if self.W_regularizer:\n+            self.W_regularizer.set_param(self.W)\n+            self.regularizers.append(self.W_regularizer)\n+\n+        if self.b_regularizer:\n+            self.b_regularizer.set_param(self.b)\n+            self.regularizers.append(self.b_regularizer)\n+\n+        if self.activity_regularizer:\n+            self.activity_regularizer.set_layer(self)\n+            self.regularizers.append(self.activity_regularizer)\n+\n+        if self.initial_weights is not None:\n+            self.set_weights(self.initial_weights)\n+            del self.initial_weights\n+\n+    @property\n+    def output_shape(self):\n+        input_shape = self.input_shape\n+        if self.dim_ordering == 'th':\n+            conv_dim1 = input_shape[2]\n+            conv_dim2 = input_shape[3]\n+            conv_dim3 = input_shape[4]\n+        elif self.dim_ordering == 'tf':\n+            conv_dim1 = input_shape[1]\n+            conv_dim2 = input_shape[2]\n+            conv_dim3 = input_shape[3]\n+        else:\n+            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+\n+        conv_dim1 = conv_output_length(conv_dim1, self.kernel_dim1,\n+                                       self.border_mode, self.subsample[0])\n+        conv_dim2 = conv_output_length(conv_dim2, self.kernel_dim2,\n+                                       self.border_mode, self.subsample[1])\n+        conv_dim3 = conv_output_length(conv_dim3, self.kernel_dim3,\n+                                       self.border_mode, self.subsample[2])\n+\n+        if self.dim_ordering == 'th':\n+            return (input_shape[0], self.nb_filter, conv_dim1, conv_dim2, conv_dim3)\n+        elif self.dim_ordering == 'tf':\n+            return (input_shape[0], conv_dim1, conv_dim2, conv_dim3, self.nb_filter)\n+        else:\n+            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+\n+    def get_output(self, train=False):\n+        X = self.get_input(train)\n+        conv_out = K.conv3d(X, self.W, strides=self.subsample,\n+                            border_mode=self.border_mode,\n+                            dim_ordering=self.dim_ordering,\n+                            volume_shape=self.input_shape,\n+                            filter_shape=self.W_shape)\n+\n+        if self.dim_ordering == 'th':\n+            output = conv_out + K.reshape(self.b, (1, self.nb_filter, 1, 1, 1))\n+        elif self.dim_ordering == 'tf':\n+            output = conv_out + K.reshape(self.b, (1, 1, 1, 1, self.nb_filter))\n+        else:\n+            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+        output = self.activation(output)\n+        return output\n+\n+    def get_config(self):\n+        config = {\"name\": self.__class__.__name__,\n+                  \"nb_filter\": self.nb_filter,\n+                  \"kernel_dim1\": self.kernel_dim1,\n+                  \"kernel_dim2\": self.kernel_dim2,\n+                  \"kernel_dim3\": self.kernel_dim3,\n+                  \"dim_ordering\": self.dim_ordering,\n+                  \"init\": self.init.__name__,\n+                  \"activation\": self.activation.__name__,\n+                  \"border_mode\": self.border_mode,\n+                  \"subsample\": self.subsample,\n+                  \"W_regularizer\": self.W_regularizer.get_config() if self.W_regularizer else None,\n+                  \"b_regularizer\": self.b_regularizer.get_config() if self.b_regularizer else None,\n+                  \"activity_regularizer\": self.activity_regularizer.get_config() if self.activity_regularizer else None,\n+                  \"W_constraint\": self.W_constraint.get_config() if self.W_constraint else None,\n+                  \"b_constraint\": self.b_constraint.get_config() if self.b_constraint else None}\n+        base_config = super(Convolution3D, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+\n+\n class _Pooling1D(Layer):\n     '''Abstract class for different pooling 1D layers.\n     '''\n@@ -584,6 +778,158 @@ def _pooling_function(self, inputs, pool_size, strides,\n         return output\n \n \n+class _Pooling3D(Layer):\n+    '''Abstract class for different pooling 3D layers.\n+    '''\n+    input_ndim = 5\n+\n+    def __init__(self, pool_size=(2, 2, 2), strides=None, border_mode='valid',\n+                 dim_ordering='th', **kwargs):\n+        super(_Pooling3D, self).__init__(**kwargs)\n+        self.input = K.placeholder(ndim=5)\n+        self.pool_size = tuple(pool_size)\n+        if strides is None:\n+            strides = self.pool_size\n+        self.strides = tuple(strides)\n+        assert border_mode in {'valid', 'same'}, 'border_mode must be in {valid, same}'\n+        self.border_mode = border_mode\n+        assert dim_ordering in {'tf', 'th'}, 'dim_ordering must be in {tf, th}'\n+        self.dim_ordering = dim_ordering\n+\n+    @property\n+    def output_shape(self):\n+        input_shape = self.input_shape\n+        if self.dim_ordering == 'th':\n+            len_dim1 = input_shape[2]\n+            len_dim2 = input_shape[3]\n+            len_dim3 = input_shape[4]\n+        elif self.dim_ordering == 'tf':\n+            len_dim1 = input_shape[1]\n+            len_dim2 = input_shape[2]\n+            len_dim3 = input_shape[3]\n+        else:\n+            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+\n+        len_dim1 = conv_output_length(len_dim1, self.pool_size[0],\n+                                      self.border_mode, self.strides[0])\n+        len_dim2 = conv_output_length(len_dim2, self.pool_size[1],\n+                                      self.border_mode, self.strides[1])\n+        len_dim3 = conv_output_length(len_dim3, self.pool_size[2],\n+                                      self.border_mode, self.strides[2])\n+\n+        if self.dim_ordering == 'th':\n+            return (input_shape[0], input_shape[1], len_dim1, len_dim2, len_dim3)\n+        elif self.dim_ordering == 'tf':\n+            return (input_shape[0], len_dim1, len_dim2, len_dim3, input_shape[4])\n+        else:\n+            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+\n+    def _pooling_function(self, inputs, pool_size, strides,\n+                          border_mode, dim_ordering):\n+        raise NotImplementedError\n+\n+    def get_output(self, train=False):\n+        X = self.get_input(train)\n+        output = self._pooling_function(inputs=X, pool_size=self.pool_size,\n+                                        strides=self.strides,\n+                                        border_mode=self.border_mode,\n+                                        dim_ordering=self.dim_ordering)\n+        return output\n+\n+    def get_config(self):\n+        config = {'name': self.__class__.__name__,\n+                  'pool_size': self.pool_size,\n+                  'border_mode': self.border_mode,\n+                  'strides': self.strides,\n+                  'dim_ordering': self.dim_ordering}\n+        base_config = super(_Pooling3D, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+\n+\n+class MaxPooling3D(_Pooling3D):\n+    '''Max pooling operation for 3D data (spatial or spatio-temporal).\n+\n+    Note: this layer will only work with Theano for the time being.\n+\n+    # Input shape\n+        5D tensor with shape:\n+        `(samples, channels, len_pool_dim1, len_pool_dim2, len_pool_dim3)` if dim_ordering='th'\n+        or 5D tensor with shape:\n+        `(samples, len_pool_dim1, len_pool_dim2, len_pool_dim3, channels)` if dim_ordering='tf'.\n+\n+    # Output shape\n+        5D tensor with shape:\n+        `(nb_samples, channels, pooled_dim1, pooled_dim2, pooled_dim3)` if dim_ordering='th'\n+        or 5D tensor with shape:\n+        `(samples, pooled_dim1, pooled_dim2, pooled_dim3, channels)` if dim_ordering='tf'.\n+\n+    # Arguments\n+        pool_size: tuple of 3 integers,\n+            factors by which to downscale (dim1, dim2, dim3).\n+            (2, 2, 2) will halve the size of the 3D input in each dimension.\n+        strides: tuple of 3 integers, or None. Strides values.\n+        border_mode: 'valid' or 'same'.\n+        dim_ordering: 'th' or 'tf'. In 'th' mode, the channels dimension\n+            (the depth) is at index 1, in 'tf' mode is it at index 4.\n+    '''\n+\n+    def __init__(self, pool_size=(2, 2, 2), strides=None, border_mode='valid',\n+                 dim_ordering='th', **kwargs):\n+        if K._BACKEND != 'theano':\n+            raise Exception(self.__class__.__name__ +\n+                            ' is currently only working with Theano backend.')\n+        super(MaxPooling3D, self).__init__(pool_size, strides, border_mode,\n+                                           dim_ordering, **kwargs)\n+\n+    def _pooling_function(self, inputs, pool_size, strides,\n+                          border_mode, dim_ordering):\n+        output = K.pool3d(inputs, pool_size, strides,\n+                          border_mode, dim_ordering, pool_mode='max')\n+        return output\n+\n+\n+class AveragePooling3D(_Pooling3D):\n+    '''Average pooling operation for 3D data (spatial or spatio-temporal).\n+\n+    Note: this layer will only work with Theano for the time being.\n+\n+    # Input shape\n+        5D tensor with shape:\n+        `(samples, channels, len_pool_dim1, len_pool_dim2, len_pool_dim3)` if dim_ordering='th'\n+        or 5D tensor with shape:\n+        `(samples, len_pool_dim1, len_pool_dim2, len_pool_dim3, channels)` if dim_ordering='tf'.\n+\n+    # Output shape\n+        5D tensor with shape:\n+        `(nb_samples, channels, pooled_dim1, pooled_dim2, pooled_dim3)` if dim_ordering='th'\n+        or 5D tensor with shape:\n+        `(samples, pooled_dim1, pooled_dim2, pooled_dim3, channels)` if dim_ordering='tf'.\n+\n+    # Arguments\n+        pool_size: tuple of 3 integers,\n+            factors by which to downscale (dim1, dim2, dim3).\n+            (2, 2, 2) will halve the size of the 3D input in each dimension.\n+        strides: tuple of 3 integers, or None. Strides values.\n+        border_mode: 'valid' or 'same'.\n+        dim_ordering: 'th' or 'tf'. In 'th' mode, the channels dimension\n+            (the depth) is at index 1, in 'tf' mode is it at index 4.\n+    '''\n+\n+    def __init__(self, pool_size=(2, 2, 2), strides=None, border_mode='valid',\n+                 dim_ordering='th', **kwargs):\n+        if K._BACKEND != 'theano':\n+            raise Exception(self.__class__.__name__ +\n+                            ' is currently only working with Theano backend.')\n+        super(AveragePooling3D, self).__init__(pool_size, strides, border_mode,\n+                                               dim_ordering, **kwargs)\n+\n+    def _pooling_function(self, inputs, pool_size, strides,\n+                          border_mode, dim_ordering):\n+        output = K.pool3d(inputs, pool_size, strides,\n+                          border_mode, dim_ordering, pool_mode='avg')\n+        return output\n+\n+\n class UpSampling1D(Layer):\n     '''Repeat each temporal step `length` times along the time axis.\n \n@@ -679,6 +1025,72 @@ def get_config(self):\n         return dict(list(base_config.items()) + list(config.items()))\n \n \n+class UpSampling3D(Layer):\n+    '''Repeat the first, second and third dimension of the data\n+    by size[0], size[1] and size[2] respectively.\n+\n+    Note: this layer will only work with Theano for the time being.\n+\n+    # Input shape\n+        5D tensor with shape:\n+        `(samples, channels, dim1, dim2, dim3)` if dim_ordering='th'\n+        or 5D tensor with shape:\n+        `(samples, dim1, dim2, dim3, channels)` if dim_ordering='tf'.\n+\n+    # Output shape\n+        5D tensor with shape:\n+        `(samples, channels, upsampled_dim1, upsampled_dim2, upsampled_dim3)` if dim_ordering='th'\n+        or 5D tensor with shape:\n+        `(samples, upsampled_dim1, upsampled_dim2, upsampled_dim3, channels)` if dim_ordering='tf'.\n+\n+    # Arguments\n+        size: tuple of 3 integers. The upsampling factors for dim1, dim2 and dim3.\n+        dim_ordering: 'th' or 'tf'.\n+            In 'th' mode, the channels dimension (the depth)\n+            is at index 1, in 'tf' mode is it at index 4.\n+    '''\n+    input_ndim = 5\n+\n+    def __init__(self, size=(2, 2, 2), dim_ordering='th', **kwargs):\n+        if K._BACKEND != 'theano':\n+            raise Exception(self.__class__.__name__ +\n+                            ' is currently only working with Theano backend.')\n+        super(UpSampling3D, self).__init__(**kwargs)\n+        self.input = K.placeholder(ndim=5)\n+        self.size = tuple(size)\n+        assert dim_ordering in {'tf', 'th'}, 'dim_ordering must be in {tf, th}'\n+        self.dim_ordering = dim_ordering\n+\n+    @property\n+    def output_shape(self):\n+        input_shape = self.input_shape\n+        if self.dim_ordering == 'th':\n+            return (input_shape[0],\n+                    input_shape[1],\n+                    self.size[0] * input_shape[2],\n+                    self.size[1] * input_shape[3],\n+                    self.size[2] * input_shape[4])\n+        elif self.dim_ordering == 'tf':\n+            return (input_shape[0],\n+                    self.size[0] * input_shape[1],\n+                    self.size[1] * input_shape[2],\n+                    self.size[2] * input_shape[3],\n+                    input_shape[4])\n+        else:\n+            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+\n+    def get_output(self, train=False):\n+        X = self.get_input(train)\n+        return K.resize_volumes(X, self.size[0], self.size[1], self.size[2],\n+                                self.dim_ordering)\n+\n+    def get_config(self):\n+        config = {'name': self.__class__.__name__,\n+                  'size': self.size}\n+        base_config = super(UpSampling3D, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+\n+\n class ZeroPadding1D(Layer):\n     '''Zero-padding layer for 1D input (e.g. temporal sequence).\n \n@@ -769,3 +1181,63 @@ def get_config(self):\n                   'padding': self.padding}\n         base_config = super(ZeroPadding2D, self).get_config()\n         return dict(list(base_config.items()) + list(config.items()))\n+\n+\n+class ZeroPadding3D(Layer):\n+    '''Zero-padding layer for 3D data (spatial or spatio-temporal).\n+\n+    Note: this layer will only work with Theano for the time being.\n+\n+    # Input shape\n+        5D tensor with shape:\n+        (samples, depth, first_axis_to_pad, second_axis_to_pad, third_axis_to_pad)\n+\n+    # Output shape\n+        5D tensor with shape:\n+        (samples, depth, first_padded_axis, second_padded_axis, third_axis_to_pad)\n+\n+    # Arguments\n+        padding: tuple of int (length 3)\n+            How many zeros to add at the beginning and end of\n+            the 3 padding dimensions (axis 3, 4 and 5).\n+    '''\n+    input_ndim = 5\n+\n+    def __init__(self, padding=(1, 1, 1), dim_ordering='th', **kwargs):\n+        if K._BACKEND != 'theano':\n+            raise Exception(self.__class__.__name__ +\n+                            ' is currently only working with Theano backend.')\n+        super(ZeroPadding3D, self).__init__(**kwargs)\n+        self.padding = tuple(padding)\n+        self.input = K.placeholder(ndim=5)\n+        assert dim_ordering in {'tf', 'th'}, 'dim_ordering must be in {tf, th}'\n+        self.dim_ordering = dim_ordering\n+\n+    @property\n+    def output_shape(self):\n+        input_shape = self.input_shape\n+        if self.dim_ordering == 'th':\n+            return (input_shape[0],\n+                    input_shape[1],\n+                    input_shape[2] + 2 * self.padding[0],\n+                    input_shape[3] + 2 * self.padding[1],\n+                    input_shape[4] + 2 * self.padding[2])\n+        elif self.dim_ordering == 'tf':\n+            return (input_shape[0],\n+                    input_shape[1] + 2 * self.padding[0],\n+                    input_shape[2] + 2 * self.padding[1],\n+                    input_shape[3] + 2 * self.padding[2],\n+                    input_shape[4])\n+        else:\n+            raise Exception('Invalid dim_ordering: ' + self.dim_ordering)\n+\n+    def get_output(self, train=False):\n+        X = self.get_input(train)\n+        return K.spatial_3d_padding(X, padding=self.padding,\n+                                    dim_ordering=self.dim_ordering)\n+\n+    def get_config(self):\n+        config = {'name': self.__class__.__name__,\n+                  'padding': self.padding}\n+        base_config = super(ZeroPadding3D, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\ndiff --git a/tests/keras/layers/test_convolutional.py b/tests/keras/layers/test_convolutional.py\nindex fc67f6901337..cc32cc4935eb 100644\n--- a/tests/keras/layers/test_convolutional.py\n+++ b/tests/keras/layers/test_convolutional.py\n@@ -204,6 +204,92 @@ def test_averagepooling_2d():\n         layer.get_config()\n \n \n+@pytest.mark.skipif(K._BACKEND != 'theano', reason=\"Requires Theano backend\")\n+def test_convolution_3d():\n+    nb_samples = 8\n+    nb_filter = 9\n+    stack_size = 7\n+    len_conv_dim1 = 2\n+    len_conv_dim2 = 10\n+    len_conv_dim3 = 6\n+\n+    input_len_dim1 = 10\n+    input_len_dim2 = 11\n+    input_len_dim3 = 12\n+\n+    weights_in = [np.ones((nb_filter, stack_size, len_conv_dim1, len_conv_dim2, len_conv_dim3)),\n+                  np.ones(nb_filter)]\n+\n+    input = np.ones((nb_samples, stack_size, input_len_dim1,\n+                     input_len_dim2, input_len_dim3))\n+    for weight in [None, weights_in]:\n+        for border_mode in ['same', 'valid']:\n+            for subsample in [(1, 1, 1), (2, 2, 2)]:\n+                if border_mode == 'same' and subsample != (1, 1, 1):\n+                    continue\n+                for W_regularizer in [None, 'l2']:\n+                    for b_regularizer in [None, 'l2']:\n+                        for act_regularizer in [None, 'l2']:\n+                            layer = convolutional.Convolution3D(\n+                                nb_filter, len_conv_dim1, len_conv_dim2, len_conv_dim3,\n+                                weights=weight,\n+                                border_mode=border_mode,\n+                                W_regularizer=W_regularizer,\n+                                b_regularizer=b_regularizer,\n+                                activity_regularizer=act_regularizer,\n+                                subsample=subsample,\n+                                input_shape=(stack_size, None, None, None))\n+\n+                            layer.input = K.variable(input)\n+                            for train in [True, False]:\n+                                out = K.eval(layer.get_output(train))\n+                                if border_mode == 'same' and subsample == (1, 1, 1):\n+                                    assert out.shape[2:] == input.shape[2:]\n+                            layer.get_config()\n+\n+\n+@pytest.mark.skipif(K._BACKEND != 'theano', reason=\"Requires Theano backend\")\n+def test_maxpooling_3d():\n+    nb_samples = 9\n+    stack_size = 7\n+    input_len_dim1 = 10\n+    input_len_dim2 = 11\n+    input_len_dim3 = 12\n+    pool_size = (3, 3, 3)\n+\n+    input = np.ones((nb_samples, stack_size, input_len_dim1,\n+                     input_len_dim2, input_len_dim3))\n+    for strides in [(1, 1, 1), (2, 2, 2)]:\n+        layer = convolutional.MaxPooling3D(strides=strides,\n+                                           border_mode='valid',\n+                                           pool_size=pool_size)\n+        layer.input = K.variable(input)\n+        for train in [True, False]:\n+            K.eval(layer.get_output(train))\n+        layer.get_config()\n+\n+\n+@pytest.mark.skipif(K._BACKEND != 'theano', reason=\"Requires Theano backend\")\n+def test_averagepooling_3d():\n+    nb_samples = 9\n+    stack_size = 7\n+    input_len_dim1 = 10\n+    input_len_dim2 = 11\n+    input_len_dim3 = 12\n+    pool_size = (3, 3, 3)\n+\n+    input = np.ones((nb_samples, stack_size, input_len_dim1,\n+                     input_len_dim2, input_len_dim3))\n+    for strides in [(1, 1, 1), (2, 2, 2)]:\n+        layer = convolutional.AveragePooling3D(strides=strides,\n+                                               border_mode='valid',\n+                                               pool_size=pool_size)\n+        layer.input = K.variable(input)\n+        for train in [True, False]:\n+            K.eval(layer.get_output(train))\n+        layer.get_config()\n+\n+\n def test_zero_padding_2d():\n     nb_samples = 9\n     stack_size = 7\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The loss discrepancy between GPU and CPU runs is concerning and may stem from precision differences in `conv3d2d.conv3d`. Ensure that random seed management is consistent across both platforms. The suggested terminology changes are thoughtful, but replacing \"time\" with terms like \"first_spatial_dim\" could be misleading in the context of temporal signals. Consider simplifying to \"spatial_dim1\", \"spatial_dim2\", and \"spatial_dim3\" for clarity. Additionally, layers need proper exception handling and serialization via `get_config()` to ensure robust behavior. Address these issues before proceeding."
      }
    ],
    "token_estimation": 8232.75
  },
  {
    "index": 50,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/keras/applications/mobilenetv2.py b/keras/applications/mobilenetv2.py\nnew file mode 100644\nindex 000000000000..3add1538ac1a\n--- /dev/null\n+++ b/keras/applications/mobilenetv2.py\n@@ -0,0 +1,526 @@\n+\"\"\"MobileNet v2 models for Keras.\n+\n+MobileNetV2 is a general architecture and can be used for multiple use cases.\n+Depending on the use case, it can use different input layer size and\n+different width factors. This allows different width models to reduce\n+the number of multiply-adds and thereby\n+reduce inference cost on mobile devices.\n+\n+MobileNetV2 is very similar to the original MobileNet,\n+except that it uses inverted residual blocks with\n+bottlenecking features. It has a drastically lower\n+parameter count than the original MobileNet.\n+MobileNets support any input size greater\n+than 32 x 32, with larger image sizes\n+offering better performance.\n+\n+The number of parameters and number of multiply-adds\n+can be modified by using the `alpha` parameter,\n+which increases/decreases the number of filters in each layer.\n+By altering the image size and `alpha` parameter,\n+all 22 models from the paper can be built, with ImageNet weights provided.\n+\n+The paper demonstrates the performance of MobileNets using `alpha` values of\n+1.0 (also called 100 % MobileNet), 0.35, 0.5, 0.75, 1.0, 1.3, and 1.4\n+\n+For each of these `alpha` values, weights for 5 different input image sizes\n+are provided (224, 192, 160, 128, and 96).\n+\n+\n+The following table describes the performance of\n+MobileNet on various input sizes:\n+------------------------------------------------------------------------\n+MACs stands for Multiply Adds\n+\n+ Classification Checkpoint| MACs (M)   | Parameters (M)| Top 1 Accuracy| Top 5 Accuracy\n+--------------------------|------------|---------------|---------|----|-------------\n+| [mobilenet_v2_1.4_224]  | 582 | 6.06 |          75.0 | 92.5 |\n+| [mobilenet_v2_1.3_224]  | 509 | 5.34 |          74.4 | 92.1 |\n+| [mobilenet_v2_1.0_224]  | 300 | 3.47 |          71.8 | 91.0 |\n+| [mobilenet_v2_1.0_192]  | 221 | 3.47 |          70.7 | 90.1 |\n+| [mobilenet_v2_1.0_160]  | 154 | 3.47 |          68.8 | 89.0 |\n+| [mobilenet_v2_1.0_128]  | 99  | 3.47 |          65.3 | 86.9 |\n+| [mobilenet_v2_1.0_96]   | 56  | 3.47 |          60.3 | 83.2 |\n+| [mobilenet_v2_0.75_224] | 209 | 2.61 |          69.8 | 89.6 |\n+| [mobilenet_v2_0.75_192] | 153 | 2.61 |          68.7 | 88.9 |\n+| [mobilenet_v2_0.75_160] | 107 | 2.61 |          66.4 | 87.3 |\n+| [mobilenet_v2_0.75_128] | 69  | 2.61 |          63.2 | 85.3 |\n+| [mobilenet_v2_0.75_96]  | 39  | 2.61 |          58.8 | 81.6 |\n+| [mobilenet_v2_0.5_224]  | 97  | 1.95 |          65.4 | 86.4 |\n+| [mobilenet_v2_0.5_192]  | 71  | 1.95 |          63.9 | 85.4 |\n+| [mobilenet_v2_0.5_160]  | 50  | 1.95 |          61.0 | 83.2 |\n+| [mobilenet_v2_0.5_128]  | 32  | 1.95 |          57.7 | 80.8 |\n+| [mobilenet_v2_0.5_96]   | 18  | 1.95 |          51.2 | 75.8 |\n+| [mobilenet_v2_0.35_224] | 59  | 1.66 |          60.3 | 82.9 |\n+| [mobilenet_v2_0.35_192] | 43  | 1.66 |          58.2 | 81.2 |\n+| [mobilenet_v2_0.35_160] | 30  | 1.66 |          55.7 | 79.1 |\n+| [mobilenet_v2_0.35_128] | 20  | 1.66 |          50.8 | 75.0 |\n+| [mobilenet_v2_0.35_96]  | 11  | 1.66 |          45.5 | 70.4 |\n+\n+The weights for all 16 models are obtained and translated from the Tensorflow checkpoints\n+from TensorFlow checkpoints found at\n+https://github.com/tensorflow/models/blob/master/research/slim/nets/mobilenet/README.md\n+\n+# Reference\n+This file contains building code for MobileNetV2, based on\n+[MobileNetV2: Inverted Residuals and Linear Bottlenecks](https://arxiv.org/abs/1801.04381)\n+\n+Tests comparing this model to the existing Tensorflow model can be\n+found at [mobilenet_v2_keras](https://github.com/JonathanCMitchell/mobilenet_v2_keras)\n+\"\"\"\n+from __future__ import print_function\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import os\n+import warnings\n+import h5py\n+import numpy as np\n+\n+from ..models import Model\n+from ..layers import Input\n+from ..layers import Activation\n+from ..layers import Dropout\n+from ..layers import Reshape\n+from ..layers import BatchNormalization\n+from ..layers import Conv2D\n+from ..layers import DepthwiseConv2D\n+from ..layers import GlobalAveragePooling2D\n+from ..layers import Add\n+from ..layers import Flatten\n+from ..layers import Dense\n+from .. import initializers\n+from .. import regularizers\n+from .. import constraints\n+from ..utils import conv_utils\n+from ..utils.data_utils import get_file\n+from ..engine import get_source_inputs\n+from ..engine.base_layer import InputSpec\n+from . import imagenet_utils\n+from .imagenet_utils import _obtain_input_shape\n+from .imagenet_utils import decode_predictions\n+from .. import backend as K\n+\n+# TODO Change path to v1.1\n+BASE_WEIGHT_PATH = 'https://github.com/JonathanCMitchell/mobilenet_v2_keras/releases/download/v1.1/'\n+\n+\n+def relu6(x):\n+    return K.relu(x, max_value=6)\n+\n+\n+def preprocess_input(x):\n+    \"\"\"Preprocesses a numpy array encoding a batch of images.\n+\n+    This function applies the \"Inception\" preprocessing which converts\n+    the RGB values from [0, 255] to [-1, 1]. Note that this preprocessing\n+    function is different from `imagenet_utils.preprocess_input()`.\n+\n+    # Arguments\n+        x: a 4D numpy array consists of RGB values within [0, 255].\n+\n+    # Returns\n+        Preprocessed array.\n+    \"\"\"\n+    x /= 128.\n+    x -= 1.\n+    return x.astype(np.float32)\n+\n+\n+# This function is taken from the original tf repo.\n+# It ensures that all layers have a channel number that is divisible by 8\n+# It can be seen here:\n+# https://github.com/tensorflow/models/blob/master/research/slim/nets/mobilenet/mobilenet.py\n+\n+\n+def _make_divisible(v, divisor, min_value=None):\n+    if min_value is None:\n+        min_value = divisor\n+    new_v = max(min_value, int(v + divisor / 2) // divisor * divisor)\n+    # Make sure that round down does not go down by more than 10%.\n+    if new_v < 0.9 * v:\n+        new_v += divisor\n+    return new_v\n+\n+\n+def MobileNetV2(input_shape=None,\n+                alpha=1.0,\n+                depth_multiplier=1,\n+                dropout=1e-3,\n+                include_top=True,\n+                weights='imagenet',\n+                input_tensor=None,\n+                classes=1000):\n+    \"\"\"Instantiates the MobileNetV2 architecture.\n+\n+    To load a MobileNetV2 model via `load_model`, import the custom\n+    objects `relu6` and pass them to the `custom_objects` parameter.\n+    E.g.\n+    model = load_model('mobilenet.h5', custom_objects={\n+                       'relu6': mobilenet.relu6})\n+\n+    # Arguments\n+        input_shape: optional shape tuple, to be specified if you would\n+            like to use a model with an input img resolution that is not\n+            (224, 224, 3).\n+            It should have exactly 3 inputs channels (224, 224, 3).\n+            You can also omit this option if you would like\n+            to infer input_shape from an input_tensor.\n+            If you choose to include both input_tensor and input_shape then\n+            input_shape will be used if they match, if the shapes\n+            do not match then we will throw an error.\n+            E.g. `(160, 160, 3)` would be one valid value.\n+        alpha: controls the width of the network. This is known as the\n+        width multiplier in the MobileNetV2 paper.\n+            - If `alpha` < 1.0, proportionally decreases the number\n+                of filters in each layer.\n+            - If `alpha` > 1.0, proportionally increases the number\n+                of filters in each layer.\n+            - If `alpha` = 1, default number of filters from the paper\n+                 are used at each layer.\n+        depth_multiplier: depth multiplier for depthwise convolution\n+            (also called the resolution multiplier)\n+        dropout: dropout rate, dropout is currently not in use\n+        include_top: whether to include the fully-connected\n+            layer at the top of the network.\n+        weights: one of `None` (random initialization),\n+              'imagenet' (pre-training on ImageNet),\n+              or the path to the weights file to be loaded.\n+        input_tensor: optional Keras tensor (i.e. output of\n+            `layers.Input()`)\n+            to use as image input for the model.\n+        classes: optional number of classes to classify images\n+            into, only to be specified if `include_top` is True, and\n+            if no `weights` argument is specified.\n+\n+    # Returns\n+        A Keras model instance.\n+\n+    # Raises\n+        ValueError: in case of invalid argument for `weights`,\n+            or invalid input shape or invalid depth_multiplier, alpha,\n+            rows when weights='imagenet'\n+    \"\"\"\n+\n+    if not (weights in {'imagenet', None} or os.path.exists(weights)):\n+        raise ValueError('The `weights` argument should be either '\n+                         '`None` (random initialization), `imagenet` '\n+                         '(pre-training on ImageNet), '\n+                         'or the path to the weights file to be loaded.')\n+\n+    if weights == 'imagenet' and include_top and classes != 1000:\n+        raise ValueError('If using `weights` as ImageNet with `include_top` '\n+                         'as true, `classes` should be 1000')\n+\n+    # Determine proper input shape and default size.\n+    # If both input_shape and input_tensor are used, they should match\n+    if input_shape is not None and input_tensor is not None:\n+        try:\n+            is_input_t_tensor = K.is_keras_tensor(input_tensor)\n+        except ValueError:\n+            try:\n+                is_input_t_tensor = K.is_keras_tensor(\n+                    get_source_inputs(input_tensor))\n+            except ValueError:\n+                raise ValueError('input_tensor: ', input_tensor,\n+                                 'is not type input_tensor')\n+        if is_input_t_tensor:\n+            if K.image_data_format == 'channels_first':\n+                if input_tensor._keras_shape[1] != input_shape[1]:\n+                    raise ValueError('input_shape: ', input_shape,\n+                                     'and input_tensor: ', input_tensor,\n+                                     'do not meet the same shape requirements')\n+            else:\n+                if input_tensor._keras_shape[2] != input_shape[1]:\n+                    raise ValueError('input_shape: ', input_shape,\n+                                     'and input_tensor: ', input_tensor,\n+                                     'do not meet the same shape requirements')\n+        else:\n+            raise ValueError('input_tensor specified: ', input_tensor,\n+                             'is not a keras tensor')\n+\n+    # If input_shape is None, infer shape from input_tensor\n+    if input_shape is None and input_tensor is not None:\n+\n+        try:\n+            K.is_keras_tensor(input_tensor)\n+        except ValueError:\n+            raise ValueError('input_tensor: ', input_tensor,\n+                             'is type: ', type(input_tensor),\n+                             'which is not a valid type')\n+\n+        if input_shape is None and not K.is_keras_tensor(input_tensor):\n+            default_size = 224\n+        elif input_shape is None and K.is_keras_tensor(input_tensor):\n+            if K.image_data_format() == 'channels_first':\n+                rows = input_tensor._keras_shape[2]\n+                cols = input_tensor._keras_shape[3]\n+            else:\n+                rows = input_tensor._keras_shape[1]\n+                cols = input_tensor._keras_shape[2]\n+\n+            if rows == cols and rows in [96, 128, 160, 192, 224]:\n+                default_size = rows\n+            else:\n+                default_size = 224\n+\n+    # If input_shape is None and no input_tensor\n+    elif input_shape is None:\n+        default_size = 224\n+\n+    # If input_shape is not None, assume default size\n+    else:\n+        if K.image_data_format() == 'channels_first':\n+            rows = input_shape[1]\n+            cols = input_shape[2]\n+        else:\n+            rows = input_shape[0]\n+            cols = input_shape[1]\n+\n+        if rows == cols and rows in [96, 128, 160, 192, 224]:\n+            default_size = rows\n+        else:\n+            default_size = 224\n+\n+    input_shape = _obtain_input_shape(input_shape,\n+                                      default_size=default_size,\n+                                      min_size=32,\n+                                      data_format=K.image_data_format(),\n+                                      require_flatten=include_top,\n+                                      weights=weights)\n+\n+    if K.image_data_format() == 'channels_last':\n+        row_axis, col_axis = (0, 1)\n+    else:\n+        row_axis, col_axis = (1, 2)\n+    rows = input_shape[row_axis]\n+    cols = input_shape[col_axis]\n+\n+    if weights == 'imagenet':\n+        if depth_multiplier != 1:\n+            raise ValueError('If imagenet weights are being loaded, '\n+                             'depth multiplier must be 1')\n+\n+        if alpha not in [0.35, 0.50, 0.75, 1.0, 1.3, 1.4]:\n+            raise ValueError('If imagenet weights are being loaded, '\n+                             'alpha can be one of'\n+                             '`0.25`, `0.50`, `0.75` or `1.0` only.')\n+\n+        if rows != cols or rows not in [96, 128, 160, 192, 224]:\n+            if rows is None:\n+                rows = 224\n+                warnings.warn('MobileNet shape is undefined.'\n+                              ' Weights for input shape'\n+                              '(224, 224) will be loaded.')\n+            else:\n+                raise ValueError('If imagenet weights are being loaded, '\n+                                 'input must have a static square shape'\n+                                 '(one of (96, 96), (128, 128), (160, 160),'\n+                                 '(192, 192), or (224, 224)).'\n+                                 'Input shape provided = %s' % (input_shape,))\n+\n+    if K.image_data_format() != 'channels_last':\n+        warnings.warn('The MobileNet family of models is only available '\n+                      'for the input data format \"channels_last\" '\n+                      '(width, height, channels). '\n+                      'However your settings specify the default '\n+                      'data format \"channels_first\" (channels, width, height).'\n+                      ' You should set `image_data_format=\"channels_last\"` '\n+                      'in your Keras config located at ~/.keras/keras.json. '\n+                      'The model being returned right now will expect inputs '\n+                      'to follow the \"channels_last\" data format.')\n+        K.set_image_data_format('channels_last')\n+        old_data_format = 'channels_first'\n+    else:\n+        old_data_format = None\n+\n+    if input_tensor is None:\n+        img_input = Input(shape=input_shape)\n+    else:\n+        if not K.is_keras_tensor(input_tensor):\n+            img_input = Input(tensor=input_tensor, shape=input_shape)\n+        else:\n+            img_input = input_tensor\n+\n+    first_block_filters = _make_divisible(32 * alpha, 8)\n+    x = Conv2D(first_block_filters,\n+               kernel_size=3,\n+               strides=(2, 2), padding='same',\n+               use_bias=False, name='Conv1')(img_input)\n+    x = BatchNormalization(epsilon=1e-3, momentum=0.999, name='bn_Conv1')(x)\n+    x = Activation(relu6, name='Conv1_relu')(x)\n+\n+    x = _first_inverted_res_block(x,\n+                                  filters=16,\n+                                  alpha=alpha,\n+                                  stride=1,\n+                                  expansion=1,\n+                                  block_id=0)\n+\n+    x = _inverted_res_block(x, filters=24, alpha=alpha, stride=2,\n+                            expansion=6, block_id=1)\n+    x = _inverted_res_block(x, filters=24, alpha=alpha, stride=1,\n+                            expansion=6, block_id=2)\n+\n+    x = _inverted_res_block(x, filters=32, alpha=alpha, stride=2,\n+                            expansion=6, block_id=3)\n+    x = _inverted_res_block(x, filters=32, alpha=alpha, stride=1,\n+                            expansion=6, block_id=4)\n+    x = _inverted_res_block(x, filters=32, alpha=alpha, stride=1,\n+                            expansion=6, block_id=5)\n+\n+    x = _inverted_res_block(x, filters=64, alpha=alpha, stride=2,\n+                            expansion=6, block_id=6)\n+    x = _inverted_res_block(x, filters=64, alpha=alpha, stride=1,\n+                            expansion=6, block_id=7)\n+    x = _inverted_res_block(x, filters=64, alpha=alpha, stride=1,\n+                            expansion=6, block_id=8)\n+    x = _inverted_res_block(x, filters=64, alpha=alpha, stride=1,\n+                            expansion=6, block_id=9)\n+\n+    x = _inverted_res_block(x, filters=96, alpha=alpha, stride=1,\n+                            expansion=6, block_id=10)\n+    x = _inverted_res_block(x, filters=96, alpha=alpha, stride=1,\n+                            expansion=6, block_id=11)\n+    x = _inverted_res_block(x, filters=96, alpha=alpha, stride=1,\n+                            expansion=6, block_id=12)\n+\n+    x = _inverted_res_block(x, filters=160, alpha=alpha, stride=2,\n+                            expansion=6, block_id=13)\n+    x = _inverted_res_block(x, filters=160, alpha=alpha, stride=1,\n+                            expansion=6, block_id=14)\n+    x = _inverted_res_block(x, filters=160, alpha=alpha, stride=1,\n+                            expansion=6, block_id=15)\n+\n+    x = _inverted_res_block(x, filters=320, alpha=alpha, stride=1,\n+                            expansion=6, block_id=16)\n+\n+    # no alpha applied to last conv as stated in the paper:\n+    # if the width multiplier is greater than 1 we\n+    # increase the number of output channels\n+    if alpha > 1.0:\n+        last_block_filters = _make_divisible(1280 * alpha, 8)\n+    else:\n+        last_block_filters = 1280\n+\n+    x = Conv2D(last_block_filters,\n+               kernel_size=1,\n+               use_bias=False,\n+               name='Conv_1')(x)\n+    x = BatchNormalization(epsilon=1e-3, momentum=0.999, name='Conv_1_bn')(x)\n+    x = Activation(relu6, name='out_relu')(x)\n+\n+    if include_top:\n+        x = GlobalAveragePooling2D()(x)\n+        x = Dense(classes, activation='softmax',\n+                  use_bias=True, name='Logits')(x)\n+\n+    # Ensure that the model takes into account\n+    # any potential predecessors of `input_tensor`.\n+    if input_tensor is not None:\n+        inputs = get_source_inputs(input_tensor)\n+    else:\n+        inputs = img_input\n+\n+    # Create model.\n+    model = Model(inputs, x, name='mobilenetv2_%0.2f_%s' % (alpha, rows))\n+\n+    # load weights\n+    if weights == 'imagenet':\n+        if K.image_data_format() == 'channels_first':\n+            raise ValueError('Weights for \"channels_first\" format '\n+                             'are not available.')\n+\n+        if include_top:\n+            model_name = 'mobilenet_v2_weights_tf_dim_ordering_tf_kernels_' + \\\n+                str(alpha) + '_' + str(rows) + '.h5'\n+            weigh_path = BASE_WEIGHT_PATH + model_name\n+            weights_path = get_file(model_name, weigh_path,\n+                                    cache_subdir='models')\n+        else:\n+            model_name = 'mobilenet_v2_weights_tf_dim_ordering_tf_kernels_' + \\\n+                str(alpha) + '_' + str(rows) + '_no_top' + '.h5'\n+            weigh_path = BASE_WEIGHT_PATH + model_name\n+            weights_path = get_file(model_name, weigh_path,\n+                                    cache_subdir='models')\n+        model.load_weights(weights_path)\n+    elif weights is not None:\n+        model.load_weights(weights)\n+\n+    if old_data_format:\n+        K.set_image_data_format(old_data_format)\n+    return model\n+\n+\n+def _inverted_res_block(inputs, expansion, stride, alpha, filters, block_id):\n+    in_channels = inputs._keras_shape[-1]\n+    prefix = 'features.' + str(block_id) + '.conv.'\n+    pointwise_conv_filters = int(filters * alpha)\n+    pointwise_filters = _make_divisible(pointwise_conv_filters, 8)\n+    # Expand\n+\n+    x = Conv2D(expansion * in_channels, kernel_size=1, padding='same',\n+               use_bias=False, activation=None,\n+               name='mobl%d_conv_expand' % block_id)(inputs)\n+    x = BatchNormalization(epsilon=1e-3, momentum=0.999,\n+                           name='bn%d_conv_bn_expand' %\n+                           block_id)(x)\n+    x = Activation(relu6, name='conv_%d_relu' % block_id)(x)\n+\n+    # Depthwise\n+    x = DepthwiseConv2D(kernel_size=3, strides=stride, activation=None,\n+                        use_bias=False, padding='same',\n+                        name='mobl%d_conv_depthwise' % block_id)(x)\n+    x = BatchNormalization(epsilon=1e-3, momentum=0.999,\n+                           name='bn%d_conv_depthwise' % block_id)(x)\n+\n+    x = Activation(relu6, name='conv_dw_%d_relu' % block_id)(x)\n+\n+    # Project\n+    x = Conv2D(pointwise_filters,\n+               kernel_size=1, padding='same', use_bias=False, activation=None,\n+               name='mobl%d_conv_project' % block_id)(x)\n+    x = BatchNormalization(epsilon=1e-3, momentum=0.999,\n+                           name='bn%d_conv_bn_project' % block_id)(x)\n+\n+    if in_channels == pointwise_filters and stride == 1:\n+        return Add(name='res_connect_' + str(block_id))([inputs, x])\n+\n+    return x\n+\n+\n+def _first_inverted_res_block(inputs,\n+                              expansion, stride,\n+                              alpha, filters, block_id):\n+    in_channels = inputs._keras_shape[-1]\n+    prefix = 'features.' + str(block_id) + '.conv.'\n+    pointwise_conv_filters = int(filters * alpha)\n+    pointwise_filters = _make_divisible(pointwise_conv_filters, 8)\n+\n+    # Depthwise\n+    x = DepthwiseConv2D(kernel_size=3,\n+                        strides=stride, activation=None,\n+                        use_bias=False, padding='same',\n+                        name='mobl%d_conv_depthwise' %\n+                        block_id)(inputs)\n+    x = BatchNormalization(epsilon=1e-3, momentum=0.999,\n+                           name='bn%d_conv_depthwise' %\n+                           block_id)(x)\n+    x = Activation(relu6, name='conv_dw_%d_relu' % block_id)(x)\n+\n+    # Project\n+    x = Conv2D(pointwise_filters,\n+               kernel_size=1,\n+               padding='same',\n+               use_bias=False,\n+               activation=None,\n+               name='mobl%d_conv_project' %\n+               block_id)(x)\n+    x = BatchNormalization(epsilon=1e-3, momentum=0.999,\n+                           name='bn%d_conv_project' %\n+                           block_id)(x)\n+\n+    if in_channels == pointwise_filters and stride == 1:\n+        return Add(name='res_connect_' + str(block_id))([inputs, x])\n+\n+    return x\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR demonstrates significant progress, but there are still issues to address. You've resolved PEP8 violations and adjusted class counts from 1001 to 1000, which is good. However, pay attention to the failed tests: they remain unrelated to your changes. Ensure you're fully testing changes, especially around model loading. Additionally, clarify class discrepancies due to background classes in TensorFlow and provide better guidance for future unit test integration. Overall, you're on the right track, but focus on consolidating test results and improving documentation for ease of use."
      }
    ],
    "token_estimation": 5865.0
  },
  {
    "index": 51,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/keras/layers/containers.py b/keras/layers/containers.py\nindex 39619ef25f12..9970c90657e6 100644\n--- a/keras/layers/containers.py\n+++ b/keras/layers/containers.py\n@@ -277,6 +277,64 @@ def add_node(self, layer, name, input=None, inputs=[],\n         if create_output:\n             self.add_output(name, input=name)\n \n+    def add_shared_node(self, layer, name, inputs=[], merge_mode=None, concat_axis=-1, dot_axes=-1, outputs=[], create_output=False):\n+\n+        if name in self.namespace:\n+            raise Exception('Duplicate node identifier: ' + name)\n+        for o in outputs:\n+            if o in self.namespace:\n+                raise Exception('Duplicate node identifier: ' + o)\n+        if merge_mode:\n+            if merge_mode not in {'sum', 'ave', 'mul', 'dot', 'cos', 'concat', 'join'}:\n+                raise Eception(\"Invalid merge mode\")\n+        layers = []\n+        for i in range(len(inputs)):\n+            input = inputs[i]\n+            if input in self.nodes:\n+                n = self.nodes[input]\n+                if hasattr(n, 'get_output_at'):#is it a siamese layer?\n+                    if n.merge_mode is None:\n+                        for j in range(len(n.inputs)):\n+                            sh = SiameseHead(j)\n+                            sh.previous = n\n+                            layers.append(sh)\n+                    else:\n+                        layers.append(n)\n+            elif input in self.inputs:\n+                n = self.inputs[input]\n+                layers.append(n)\n+            else:\n+                raise Exception('Unknown identifier: ' + n)\n+        s = Siamese(layer, layers, merge_mode, concat_axis=concat_axis, dot_axes=dot_axes)\n+        s.set_name(name)\n+        self.namespace.add(name)\n+        self.nodes[name] = s\n+        self.node_config.append({'name': name,\n+                                'inputs': inputs,\n+                                'merge_mode': merge_mode,\n+                                'concat_axis': concat_axis,\n+                                'dot_axes': dot_axes,\n+                                'create_output': create_output if merge_mode else False})\n+        if not merge_mode:\n+            for i in range(len(outputs)):\n+                sh = SiameseHead(i)\n+                sh.previous = s\n+                sh_name = outputs[i]\n+                sh.set_name(sh_name)\n+                self.namespace.add(sh_name)\n+                self.nodes[sh_name] = sh\n+                self.node_config.append({'name': sh_name,\n+                                        'inputs': [s],\n+                                        'create_output': create_output})\n+                if create_output:\n+                    self.add_output(sh_name, input=sh_name)\n+    \n+        if create_output and merge_mode:\n+            if merge_mode == 'join':\n+                raise Exception(\"Output can not be of type OrderedDict\")\n+            self.add_output(name, input=name)\n+\n+\n     def add_output(self, name, input=None, inputs=[],\n                    merge_mode='concat', concat_axis=-1, dot_axes=-1):\n         if name in self.output_order:\ndiff --git a/keras/layers/core.py b/keras/layers/core.py\nindex 7663ef421d84..13b417fa38e5 100644\n--- a/keras/layers/core.py\n+++ b/keras/layers/core.py\n@@ -940,3 +966,406 @@ def get_config(self):\n                   \"input_dim\": self.input_dim}\n         base_config = super(MaxoutDense, self).get_config()\n         return dict(list(base_config.items()) + list(config.items()))\n+\n+\n+class Lambda(Layer):\n+\n+    \"\"\"Lambda layer for evaluating arbitrary function\n+\n+    Input shape\n+    -----------\n+    output_shape of previous layer\n+\n+    Output shape\n+    ------------\n+    Specified by output_shape argument\n+\n+    Arguments\n+    ---------\n+    function - The function to be evaluated. Takes one argument : output of previous layer\n+    output_shape - Expected output shape from function. Could be a tuple or a function of the shape of the input\n+    \"\"\"\n+\n+    def __init__(self, function, output_shape=None, **kwargs):\n+        super(Lambda, self).__init__(**kwargs)\n+        py3 = sys.version_info[0] == 3\n+        if py3:\n+            self.function = marshal.dumps(function.__code__)\n+        else:\n+            self.function = marshal.dumps(function.func_code)\n+        if output_shape is None:\n+            self._output_shape = None\n+        elif type(output_shape) in {tuple, list} :\n+            self._output_shape = tuple(output_shape)\n+        else:\n+            if py3:\n+                self._output_shape = marshal.dumps(output_shape.__code__)\n+            else:\n+                self._output_shape = marshal.dumps(output_shape.func_code)\n+\n+    @property\n+    def output_shape(self):\n+        if self._output_shape is None:\n+            return self.input_shape\n+        elif type(self._output_shape) == tuple:\n+            return (self.input_shape[0], ) + self._output_shape\n+        else:\n+            output_shape_func = marshal.loads(self._output_shape)\n+            output_shape_func = types.FunctionType(output_shape_func, globals())\n+            shape = output_shape_func(self.previous.output_shape)\n+            if type(shape) not in {list, tuple}:\n+                raise Exception(\"output_shape function must return a tuple\")\n+            return tuple(shape)\n+\n+    def get_output(self, train=False):\n+        func = marshal.loads(self.function)\n+        func = types.FunctionType(func, globals())\n+        if hasattr(self, 'previous'):\n+            return func(self.previous.get_output(train))\n+        else:\n+            return func(self.input)\n+\n+\n+class MaskedLambda(MaskedLayer, Lambda):\n+    pass\n+\n+\n+class LambdaMerge(Lambda):\n+    \"\"\"LambdaMerge layer for evaluating arbitrary function over multiple inputs\n+\n+    Input shape\n+    -----------\n+    None\n+\n+    Output shape\n+    ------------\n+    Specified by output_shape argument\n+\n+    Arguments\n+    ---------\n+    layers - Input layers. Similar to layers argument of Merge\n+    function - The function to be evaluated. Takes one argument : list of outputs from input layers\n+    output_shape - Expected output shape from function. Could be a tuple or a function of list of input shapes\n+    \"\"\"\n+    def __init__(self, layers, function, output_shape=None):\n+        if len(layers) < 2:\n+            raise Exception(\"Please specify two or more input layers (or containers) to merge\")\n+        self.layers = layers\n+        self.params = []\n+        self.regularizers = []\n+        self.constraints = []\n+        self.updates = []\n+        for l in self.layers:\n+            params, regs, consts, updates = l.get_params()\n+            self.regularizers += regs\n+            self.updates += updates\n+            # params and constraints have the same size\n+            for p, c in zip(params, consts):\n+                if p not in self.params:\n+                    self.params.append(p)\n+                    self.constraints.append(c)\n+        py3 = sys.version_info[0] == 3\n+        if py3:\n+            self.function = marshal.dumps(function.__code__)\n+        else:\n+            self.function = marshal.dumps(function.func_code)\n+        if output_shape is None:\n+            self._output_shape = None\n+        elif type(output_shape) in {tuple, list}:\n+            self._output_shape = tuple(output_shape)\n+        else:\n+            if py3:\n+                self._output_shape = marshal.dumps(output_shape.__code__)\n+            else:\n+                self._output_shape = marshal.dumps(output_shape.func_code)\n+\n+    @property\n+    def output_shape(self):\n+        input_shapes = [layer.output_shape for layer in self.layers]\n+        if self._output_shape is None:\n+            return input_shapes[0]\n+        elif type(self._output_shape) == tuple:\n+            return (input_shapes[0][0], ) + self._output_shape\n+        else:\n+            output_shape_func = marshal.loads(self._output_shape)\n+            output_shape_func = types.FunctionType(output_shape_func, globals())\n+            shape = output_shape_func(input_shapes)\n+            if type(shape) not in {list, tuple}:\n+                raise Exception(\"output_shape function must return a tuple\")\n+            return tuple(shape)\n+\n+    def get_params(self):\n+        return self.params, self.regularizers, self.constraints, self.updates\n+\n+    def get_output(self, train=False):\n+        func = marshal.loads(self.function)\n+        func = types.FunctionType(func, globals())\n+        inputs = [layer.get_output(train) for layer in self.layers]\n+        return func(inputs)\n+\n+    def get_input(self, train=False):\n+        res = []\n+        for i in range(len(self.layers)):\n+            o = self.layers[i].get_input(train)\n+            if not type(o) == list:\n+                o = [o]\n+            for output in o:\n+                if output not in res:\n+                    res.append(output)\n+        return res\n+\n+    @property\n+    def input(self):\n+        return self.get_input()\n+\n+    def supports_masked_input(self):\n+        return False\n+\n+    def get_output_mask(self, train=None):\n+        return None\n+\n+    def get_weights(self):\n+        weights = []\n+        for l in self.layers:\n+            weights += l.get_weights()\n+        return weights\n+\n+    def set_weights(self, weights):\n+        for i in range(len(self.layers)):\n+            nb_param = len(self.layers[i].params)\n+            self.layers[i].set_weights(weights[:nb_param])\n+            weights = weights[nb_param:]\n+\n+    def get_config(self):\n+        config = {\"name\": self.__class__.__name__,\n+                  \"layers\": [l.get_config() for l in self.layers],\n+                  \"function\": self.function,\n+                  \"output_shape\": self._output_shape\n+                  }\n+        base_config = super(LambdaMerge, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+\n+class Siamese(Layer):\n+    def __init__(self, layer, inputs, merge_mode=None, concat_axis=1, dot_axes=-1):\n+\n+        if merge_mode not in ['sum', 'mul', 'concat', 'ave', 'join', 'cos', 'dot', None]:\n+            raise Exception(\"Invalid merge mode: \" + str(mode))\n+\n+        if merge_mode in {'cos', 'dot'}:\n+            if len(inputs) > 2:\n+                raise Exception(mode + \" merge takes exactly 2 layers\")\n+            shape1 = inputs[0].output_shape\n+            shape2 = inputs[1].output_shape\n+            n1 = len(shape1)\n+            n2 = len(shape2)\n+            if mode == 'dot':\n+                if type(dot_axes) == int:\n+                    if dot_axes < 0:\n+                        dot_axes = [range(dot_axes % n1, n1), range(dot_axes % n2, n2)]\n+                    else:\n+                        dot_axes = [range(n1 - dot_axes, n2), range(1, dot_axes + 1)]\n+                for i in range(len(dot_axes[0])):\n+                    if shape1[dot_axes[0][i]] != shape2[dot_axes[1][i]]:\n+                        raise Exception(\" Dot incompatible layers can not be merged using dot mode\")\n+\n+        self.layer = layer\n+        self.inputs = inputs\n+        self.params = []\n+        self.merge_mode = merge_mode\n+        self.concat_axis = concat_axis\n+        self.dot_axes = dot_axes\n+        layer.set_previous(inputs[0])\n+        self.regularizers = []\n+        self.constraints = []\n+        self.updates = []\n+        layers = [layer] + inputs\n+        for l in layers:\n+            params, regs, consts, updates = l.get_params()\n+            self.regularizers += regs\n+            self.updates += updates\n+            # params and constraints have the same size\n+            for p, c in zip(params, consts):\n+                if p not in self.params:\n+                    self.params.append(p)\n+                    self.constraints.append(c)\n+\n+    @property\n+    def output_shape(self):\n+        if merge_mode is None:\n+            return self.layer.output_shape\n+        input_shapes = [self.layer.output_shape]*len(self.inputs)\n+        if self.merge_mode in ['sum', 'mul', 'ave']:\n+            return input_shapes[0]\n+        elif self.merge_mode == 'concat':\n+            output_shape = list(input_shapes[0])\n+            for shape in input_shapes[1:]:\n+                output_shape[self.concat_axis] += shape[self.concat_axis]\n+            return tuple(output_shape)\n+        elif self.merge_mode == 'join':\n+            return None\n+        elif self.merge_mode == 'dot':\n+            shape1 = list(input_shapes[0])\n+            shape2 = list(input_shapes[1])\n+            for i in self.dot_axes[0]:\n+                shape1.pop(i)\n+            for i in self.dot_axes[1]:\n+                shape2.pop(i)\n+            shape = shape1 + shape2[1:]\n+            if len(shape) == 1:\n+                shape.append(1)\n+            return tuple(shape)\n+        elif self.merge_mode == 'cos':\n+            return tuple(input_shapes[0][0], 1)\n+\n+    def get_params(self):\n+        return self.params, self.regularizers, self.constraints, self.updates\n+\n+    def get_output_at(self, head, train=False):\n+        self.layer.set_previous(self.inputs[head])\n+        return self.layer.get_output(train)\n+\n+    def get_output_join(self, train=False):\n+        o = OrderedDict()\n+        for i in range(len(inputs)):\n+            X = self.get_output_at(i, train)\n+            if X.name is None:\n+                raise ValueError(\"merge_mode='join' only works with named inputs\")\n+            o[X.name] = X\n+        return o\n+\n+    def get_output_sum(self, train=False):\n+        s = self.get_output_at(0, train)\n+        for i in range(1, len(self.inputs)):\n+            s += self.get_output_at(i, train)\n+        return s\n+\n+    def get_output_ave(self, train=False):\n+        n = len(self.inputs)\n+        s = self.get_output_at(0, train)\n+        for i in range(1, n):\n+            s += self.get_output_at(i, train)\n+        s /= n\n+        return s\n+\n+    def get_output_concat(self, train=False):\n+        inputs = [self.get_output_at(i, train) for i in range(len(self.inputs))]\n+        return T.concatenate(inputs, axis=self.concat_axis)\n+\n+    def get_output_mul(self, train=False):\n+        s = self.get_output_at(0, train)\n+        for i in range(1, len(self.inputs)):\n+            s *= self.get_output_at(i, train)\n+        return s\n+\n+    def get_output_dot(self, train=False):\n+        l1 = self.get_output_at(0, train)\n+        l2 = self.get_output_at(1, train)\n+        output = T.batched_tensordot(l1, l2, self.dot_axes)\n+        output = output.dimshuffle((0, 'x'))\n+        return output\n+\n+    def get_output_cos(self, train=False):\n+        l1 = self.get_output_at(0, train)\n+        l2 = self.get_output_at(1, train)\n+        output, _ = theano.scan(lambda v1, v2: T.dot(v1, v2)/T.sqrt(T.dot(v1, v1) * T.dot(v2, v2)), sequences=[l1, l2], outputs_info=None)\n+        output = output.dimshuffle((0, 'x'))\n+        return output\n+\n+    def get_output(self, train=False):\n+        mode = self.merge_mode\n+        if mode == 'join':\n+            return self.get_output_join(train)\n+        elif mode == 'concat':\n+            return self.get_output_concat(train)\n+        elif mode == 'sum':\n+            return self.get_output_sum(train)\n+        elif mode == 'ave':\n+            return self.get_output_ave(train)\n+        elif mode == 'mul':\n+            return self.get_output_mul(train)\n+        elif mode == 'dot':\n+            return self.get_output_dot(train)\n+        elif mode == 'cos':\n+            return self.get_output_dot(train)\n+\n+    def get_input(self, train=False):\n+        res = []\n+        for i in range(len(self.inputs)):\n+            o = self.inputs[i].get_input(train)\n+            if not type(o) == list:\n+                o = [o]\n+            for output in o:\n+                if output not in res:\n+                    res.append(output)\n+        return res\n+\n+    @property\n+    def input(self):\n+        return self.get_input()\n+\n+    def supports_masked_input(self):\n+        return False\n+\n+    def get_output_mask(self, train=None):\n+        return None\n+\n+    def get_weights(self):\n+        weights = layer.get_weights()\n+        for m in self.inputs:\n+            weights += m.get_weights()\n+        return weights\n+\n+    def set_weights(self, weights):\n+        nb_param = len(self.layer.params)\n+        self.layer.set_weights(weights[:nb_param])\n+        weights = weights[nb_param:]\n+        for i in range(len(self.inputs)):\n+            nb_param = len(self.inputs[i].params)\n+            self.inputs[i].set_weights(weights[:nb_param])\n+            weights = weights[nb_param:]\n+\n+    def get_config(self):\n+\n+        config = {\"name\": self.__class__.__name__,\n+                  \"layer\": self.layer.get_config,\n+                  \"inputs\": [m.get_config() for m in self.inputs],\n+                  \"merge_mode\": self.merge_mode,\n+                  \"concat_axis\": self.concat_axis,\n+                  \"dot_axes\": self.dot_axes\n+                  }\n+        base_config = super(Siamese, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+class SiameseHead(Layer):\n+    def __init__(self, head):\n+        self.head = head\n+        self.params = []\n+    def get_output(self, train=False):\n+        return self.get_input(train)\n+\n+    @property\n+    def input_shape(self):\n+        return self.previous.layer.output_shape\n+\n+    def get_input(self, train=False):\n+        return self.previous.get_output_at(self.head, train)\n+\n+    def get_config(self):\n+\n+        config = {\"name\": self.__class__.__name__,\n+                  \"head\": self.head\n+                  }\n+\n+        base_config = super(SiameseHead, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+\n+    def set_previous(self, layer):\n+        self.previous = layer\n+\n+def add_shared_layer(layer,inputs):\n+    input_layers = [l.layers[-1] for l in inputs]\n+    s = Siamese(layer, input_layers)\n+    for i in range(len(inputs)):\n+        sh = SiameseHead(i)\n+        inputs[i].add (s)\n+        inputs[i].add(sh)\n+\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR suggests an API for building Siamese networks with shared layers but raises concerns about complexity and usability. The current implementation relies on implicit layer sharing, which can lead to performance issues. Instead, a more explicit branch structure may enhance clarity. The proposed \"simply by index\" method is appealing, but it may obscure layer sharing under the hood. Additionally, integrating specific merging modes and avoiding weight duplication could increase flexibility. Evaluating these changes against real-world scenarios might prove beneficial for refining the approach."
      }
    ],
    "token_estimation": 4649.75
  },
  {
    "index": 52,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/tests/keras/metrics_test.py b/tests/keras/metrics_test.py\nindex 56af403ce076..4d0f8915c9b9 100644\n--- a/tests/keras/metrics_test.py\n+++ b/tests/keras/metrics_test.py\n@@ -100,5 +106,76 @@ def test_sparse_top_k_categorical_accuracy():\n     assert failure_result == 0\n \n \n+@keras_test\n+def test_stateful_metrics():\n+    np.random.seed(1334)\n+\n+    class BinaryTruePositives(keras.layers.Layer):\n+        \"\"\"Stateful Metric to count the total true positives over all batches.\n+\n+        Assumes predictions and targets of shape `(samples, 1)`.\n+\n+        # Arguments\n+            threshold: Float, lower limit on prediction value that counts as a\n+                positive class prediction.\n+            name: String, name for the metric.\n+        \"\"\"\n+\n+        def __init__(self, name='true_positives', **kwargs):\n+            super(BinaryTruePositives, self).__init__(name=name, **kwargs)\n+            self.true_positives = K.variable(value=0, dtype='int32')\n+\n+        def reset_states(self):\n+            K.set_value(self.true_positives, 0)\n+\n+        def __call__(self, y_true, y_pred):\n+            \"\"\"Computes the number of true positives in a batch.\n+\n+            # Arguments\n+                y_true: Tensor, batch_wise labels\n+                y_pred: Tensor, batch_wise predictions\n+\n+            # Returns\n+                The total number of true positives seen this epoch at the\n+                    completion of the batch.\n+            \"\"\"\n+            y_true = K.cast(y_true, 'int32')\n+            y_pred = K.cast(K.round(y_pred), 'int32')\n+            correct_preds = K.cast(K.equal(y_pred, y_true), 'int32')\n+            true_pos = K.cast(K.sum(correct_preds * y_true), 'int32')\n+            current_true_pos = self.true_positives * 1\n+            self.add_update(K.update_add(self.true_positives,\n+                                         true_pos),\n+                            inputs=[y_true, y_pred])\n+            return current_true_pos + true_pos\n+\n+    metric_fn = BinaryTruePositives()\n+    config = metrics.serialize(metric_fn)\n+    metric_fn = metrics.deserialize(\n+        config, custom_objects={'BinaryTruePositives': BinaryTruePositives})\n+\n+    # Test on simple model\n+    inputs = keras.Input(shape=(2,))\n+    outputs = keras.layers.Dense(1, activation='sigmoid')(inputs)\n+    model = keras.Model(inputs, outputs)\n+    model.compile(optimizer='sgd',\n+                  loss='binary_crossentropy',\n+                  metrics=['acc', metric_fn])\n+\n+    # Test fit, evaluate\n+    samples = 1000\n+    x = np.random.random((samples, 2))\n+    y = np.random.randint(2, size=(samples, 1))\n+    model.fit(x, y, epochs=1, batch_size=10)\n+    outs = model.evaluate(x, y, batch_size=10)\n+    preds = model.predict(x)\n+\n+    def ref_true_pos(y_true, y_pred):\n+        return np.sum(np.logical_and(y_pred > 0.5, y_true == 1))\n+\n+    # Test correctness (e.g. updates should have been run)\n+    np.testing.assert_allclose(outs[2], ref_true_pos(y, preds), atol=1e-5)\n+\n+\n if __name__ == '__main__':\n     pytest.main([__file__])\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The proposal to create a stateful `Metric` class is solid. It abstracts the averaging process into a `SamplewiseMetric`, simplifying the callback and progbar interactions. However, moving batch-wise metrics to averages could break current callback behavior, which expects batch metrics. The lack of restrictions on target/output shapes is beneficial for complex models but could complicate implementations. The UX considerations with TensorFlow’s API seem valid; adapting those for a coherent stateful metrics interface would bring clarity. Overall, it looks promising for future metric flexibility."
      }
    ],
    "token_estimation": 913.5
  },
  {
    "index": 53,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/docs/sources/layers/core.md b/docs/sources/layers/core.md\nindex 75b22a3cff4d..ccb5b2c8d38d 100644\n--- a/docs/sources/layers/core.md\n+++ b/docs/sources/layers/core.md\n@@ -374,3 +374,82 @@ Given an input of dimensions `(nb_samples, timesteps, input_dim)`, return the in\n - __Input shape__: 3D tensor with shape: `(nb_samples, timesteps, features)`.\n \n - __Output shape__: 3D tensor with shape: `(nb_samples, timesteps, features)`.\n+\n+## Lambda\n+```python\n+keras.layers.core.Lambda(function, output_shape=None)\n+```\n+\n+Used for evaluating an arbitrary function on the output of the previous layer. \n+\n+- __Input shape__: Output shape of the previous layer.\n+\n+- __Output shape__: Specified by the `output_shape` argument.\n+\n+- __Arguments__:\n+\n+    - __function__: The funtion to be evaluated. Takes one argument: output of the previous layer.\n+    - __output_shape__: Shape of the tensor returned by `function`. Should be a tuple or a function of input shape(excluding samples dimension).\n+\n+- __Example__:\n+\n+```python\n+#custom softmax function\n+def sharp_softmax(X,beta=1.5):\n+    return theano.tensor.nnet.softmax(X*beta)\n+\n+def output_shape(input_shape):\n+    return input_shape #shape is unchanged\n+\n+SharpSoftmax = Lambda(sharp_softmax, output_shape)\n+\n+model = Sequential()\n+model.add(Dense(input_dim=10,output_dim=10))\n+model.add(SharpSoftmax)\n+model.add(Dense(1))\n+model.add(Activation('sigmoid'))\n+```\n+\n+\n+## LambdaMerge\n+```python\n+keras.layers.core.LambdaMerge(layers, function, output_shape=None)\n+```\n+\n+Merge the output of a list of layers (or containers) into a single tensor, using an arbitrary function.\n+\n+- __Arguments__:\n+    - __layers__: List of layers or [containers](/layers/containers/).\n+    - __function__: The function to be evaluated. Takes one argument: list of outputs from input layers. \n+    - __output_shape__: Shape of the tensor returned by `function`. Should be a tuple or a function of list of input shapes.\n+- __Example__:\n+\n+```python\n+#root mean square function\n+def rms(X):\n+    s = X[0]**2\n+    for i in range(1, len(X)):\n+        s += X[i]**2\n+    s /= len(X)\n+    s = theano.tensor.sqrt(s)\n+    return s\n+\n+def output_shape(input_shapes):\n+    return input_shapes[0]\n+\n+left = Sequential()\n+left.add(Dense(input_dim = 10,output_dim = 10))\n+left.add(Activation('sigmoid'))\n+\n+right = Sequential()\n+right.add(Dense(input_dim = 10,output_dim = 10))\n+right.add(Activation('sigmoid'))\n+\n+model = Sequential()\n+model.add(LambdaMerge([left,right], rms, output_shape))\n+\n+model.add(Dense(1))\n+model.add(Activation('sigmoid'))\n+```\n+\n+---\ndiff --git a/keras/layers/core.py b/keras/layers/core.py\nindex 81a7701cccbe..d20964003170 100644\n--- a/keras/layers/core.py\n+++ b/keras/layers/core.py\n@@ -899,3 +903,181 @@ def get_config(self):\n                   \"input_dim\": self.input_dim}\n         base_config = super(MaxoutDense, self).get_config()\n         return dict(list(base_config.items()) + list(config.items()))\n+\n+\n+class Lambda(Layer):\n+\n+    \"\"\"Lambda layer for evaluating arbitrary function\n+\n+    Input shape\n+    -----------\n+    output_shape of previous layer\n+\n+    Output shape\n+    ------------\n+    Specified by output_shape argument\n+\n+    Arguments\n+    ---------\n+    function - The function to be evaluated. Takes one argument : output of previous layer\n+    output_shape - Expected output shape from function. Could be a tuple or a function of the shape of the input\n+    \"\"\"\n+\n+    def __init__(self, function, output_shape=None):\n+        super(Lambda, self).__init__()\n+        py3 = sys.version_info[0] == 3\n+        if py3:\n+            self.function = marshal.dumps(function.__code__)\n+        else:\n+            self.function = marshal.dumps(function.func_code)\n+        if output_shape is None:\n+            self._output_shape = None\n+        elif type(output_shape) in {tuple, list} :\n+            self._output_shape = tuple(output_shape)\n+        else:\n+            if py3:\n+                self._output_shape = marshal.dumps(output_shape.__code__)\n+            else:\n+                self._output_shape = marshal.dumps(output_shape.func_code)\n+\n+    @property\n+    def output_shape(self):\n+        if self._ouput_shape is None:\n+            return self.input_shape\n+        elif type(self._output_shape) == tuple:\n+            return (self.input_shape[0], ) + self._output_shape\n+        else:\n+            output_shape_func = marshal.loads(self._output_shape)\n+            output_shape_func = types.FunctionType(output_shape_func, globals())\n+            shape = output_shape_func(self.previous.output_shape[1:])\n+            if type(shape) not in {list, tuple}:\n+                raise Exception(\"output_shape function must return a tuple\")\n+            return (self.input_shape[0], ) + tuple(shape)\n+\n+    def get_output(self, train=False):\n+        func = marshal.loads(self.function)\n+        func = types.FunctionType(func, globals())\n+        if hasattr(self, 'previous'):\n+            return func(self.previous.get_output(train))\n+        else:\n+            return func(self.input)\n+\n+\n+class MaskedLambda(MaskedLayer, Lambda):\n+    pass\n+\n+\n+class LambdaMerge(Lambda):\n+    \"\"\"LambdaMerge layer for evaluating arbitrary function over multiple inputs\n+\n+    Input shape\n+    -----------\n+    None\n+\n+    Output shape\n+    ------------\n+    Specified by output_shape argument\n+\n+    Arguments\n+    ---------\n+    layers - Input layers. Similar to layers argument of Merge\n+    function - The function to be evaluated. Takes one argument : list of outputs from input layers\n+    output_shape - Expected output shape from function. Could be a tuple or a function of list of input shapes\n+    \"\"\"\n+    def __init__(self, layers, function, output_shape=None):\n+        if len(layers) < 2:\n+            raise Exception(\"Please specify two or more input layers (or containers) to merge\")\n+        self.layers = layers\n+        self.params = []\n+        self.regularizers = []\n+        self.constraints = []\n+        self.updates = []\n+        for l in self.layers:\n+            params, regs, consts, updates = l.get_params()\n+            self.regularizers += regs\n+            self.updates += updates\n+            # params and constraints have the same size\n+            for p, c in zip(params, consts):\n+                if p not in self.params:\n+                    self.params.append(p)\n+                    self.constraints.append(c)\n+        py3 = sys.version_info[0] == 3\n+        if py3:\n+            self.function = marshal.dumps(function.__code__)\n+        else:\n+            self.function = marshal.dumps(function.func_code)\n+        if output_shape is None:\n+            self._output_shape = None\n+        elif type(output_shape) in {tuple, list}:\n+            self._output_shape = tuple(output_shape)\n+        else:\n+            if py3:\n+                self._output_shape = marshal.dumps(output_shape.__code__)\n+            else:\n+                self._output_shape = marshal.dumps(output_shape.func_code)\n+\n+    @property\n+    def output_shape(self):\n+        input_shapes = [layer.output_shape for layer in self.layers]\n+        if self._output_shape is None:\n+            return input_shapes[0]\n+        elif type(self._output_shape) == tuple:\n+            return (input_shapes[0][0], ) + self._output_shape\n+        else:\n+            output_shape_func = marshal.loads(self._output_shape)\n+            output_shape_func = types.FunctionType(output_shape_func, globals())\n+            shape = output_shape_func([shape[1:] for shape in input_shapes])\n+            if type(shape) not in {list, tuple}:\n+                raise Exception(\"output_shape function must return a tuple\")\n+            return (input_shapes[0][0], ) + tuple(shape)\n+\n+    def get_params(self):\n+        return self.params, self.regularizers, self.constraints, self.updates\n+\n+    def get_output(self, train=False):\n+        func = marshal.loads(self.function)\n+        func = types.FunctionType(func, globals())\n+        inputs = [layer.get_output(train) for layer in self.layers]\n+        return func(inputs)\n+\n+    def get_input(self, train=False):\n+        res = []\n+        for i in range(len(self.layers)):\n+            o = self.layers[i].get_input(train)\n+            if not type(o) == list:\n+                o = [o]\n+            for output in o:\n+                if output not in res:\n+                    res.append(output)\n+        return res\n+\n+    @property\n+    def input(self):\n+        return self.get_input()\n+\n+    def supports_masked_input(self):\n+        return False\n+\n+    def get_output_mask(self, train=None):\n+        return None\n+\n+    def get_weights(self):\n+        weights = []\n+        for l in self.layers:\n+            weights += l.get_weights()\n+        return weights\n+\n+    def set_weights(self, weights):\n+        for i in range(len(self.layers)):\n+            nb_param = len(self.layers[i].params)\n+            self.layers[i].set_weights(weights[:nb_param])\n+            weights = weights[nb_param:]\n+\n+    def get_config(self):\n+        config = {\"name\": self.__class__.__name__,\n+                  \"layers\": [l.get_config() for l in self.layers],\n+                  \"function\": self.function,\n+                  \"output_shape\": self._output_shape\n+                  }\n+        base_config = super(LambdaMerge, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\ndiff --git a/tests/auto/test_sequential_model.py b/tests/auto/test_sequential_model.py\nindex 39d01b4f491d..d14eb7271f6a 100644\n--- a/tests/auto/test_sequential_model.py\n+++ b/tests/auto/test_sequential_model.py\n@@ -275,7 +278,83 @@ def test_merge_overlap(self):\n         nloss = model.evaluate(X_train, y_train, verbose=0)\n         print(nloss)\n         assert(loss == nloss)\n+        \n+    def test_lambda(self):\n+        print('Test lambda: sum')\n+\n+        def func(X):\n+            s = X[0]\n+            for i in range(1,len(X)):\n+                s += X[i]\n+            return s\n+            \n+        def activation(X):\n+          return theano.tensor.nnet.softmax(X)\n+          \n+        def output_shape(input_shapes):\n+            return input_shapes[0]\n \n+        left = Sequential()\n+        left.add(Dense(nb_hidden, input_shape=(input_dim,)))\n+        left.add(Activation('relu'))\n+        \n+        right = Sequential()\n+        right.add(Dense(nb_hidden, input_shape=(input_dim,)))\n+        right.add(Activation('relu'))\n+        \n+        model = Sequential()\n+\n+        model.add(LambdaMerge([left, right], function=func, output_shape=output_shape))\n+\n+        model.add(Dense(nb_class))\n+        model.add(Lambda(activation))\n+\n+        model.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n+\n+        model.fit([X_train, X_train], y_train, batch_size=batch_size, nb_epoch=nb_epoch, show_accuracy=True, verbose=0, validation_data=([X_test, X_test], y_test))\n+        model.fit([X_train, X_train], y_train, batch_size=batch_size, nb_epoch=nb_epoch, show_accuracy=False, verbose=0, validation_data=([X_test, X_test], y_test))\n+        model.fit([X_train, X_train], y_train, batch_size=batch_size, nb_epoch=nb_epoch, show_accuracy=True, verbose=0, validation_split=0.1)\n+        model.fit([X_train, X_train], y_train, batch_size=batch_size, nb_epoch=nb_epoch, show_accuracy=False, verbose=0, validation_split=0.1)\n+        model.fit([X_train, X_train], y_train, batch_size=batch_size, nb_epoch=nb_epoch, verbose=0)\n+        model.fit([X_train, X_train], y_train, batch_size=batch_size, nb_epoch=nb_epoch, verbose=0, shuffle=False)\n+\n+        loss = model.evaluate([X_train, X_train], y_train, verbose=0)\n+        print('loss:', loss)\n+        if loss > 0.7:\n+            raise Exception('Score too low, learning issue.')\n+        preds = model.predict([X_test, X_test], verbose=0)\n+        classes = model.predict_classes([X_test, X_test], verbose=0)\n+        probas = model.predict_proba([X_test, X_test], verbose=0)\n+        print(model.get_config(verbose=1))\n+\n+        print('test weight saving')\n+        model.save_weights('temp.h5', overwrite=True)\n+        left = Sequential()\n+        left.add(Dense(nb_hidden, input_shape=(input_dim,)))\n+        left.add(Activation('relu'))\n+        right = Sequential()\n+        right.add(Dense(nb_hidden, input_shape=(input_dim,)))\n+        right.add(Activation('relu'))\n+        model = Sequential()\n+        model.add(LambdaMerge([left, right], function=func, output_shape=output_shape))\n+        model.add(Dense(nb_class))\n+        model.add(Lambda(activation))\n+        model.load_weights('temp.h5')\n+        model.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n+\n+        nloss = model.evaluate([X_train, X_train], y_train, verbose=0)\n+        print(nloss)\n+        assert(loss == nloss)\n+        \n+        print ('test serializing')\n+        del func, activation # Make sure that the model has the function code, not just the function name.\n+        sys.setrecursionlimit(50000)\n+        model_str = pickle.dumps(model)\n+        model = pickle.loads(model_str)\n+        nloss = model.evaluate([X_train, X_train], y_train, verbose=0)\n+        print(nloss)\n+        assert(loss == nloss)\n+        \n     def test_count_params(self):\n         print('test count params')\n         input_dim = 20\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR introduces a `Lambda` and `LambdaMerge` layer with serialization support. However, consider renaming `Lambda` to `MaskedLambda` for clarity and improving its inheritance from `Layer`. Documentation should be added to clarify argument formats, as the current usage isn't intuitive. I support enforcing type checks to avoid polymorphism issues. The return of `OrderedDict` from `Merge` can enhance flexibility and API consistency but may complicate single-output scenarios. Overall, good direction, just some refinements needed!"
      }
    ],
    "token_estimation": 3455.0
  },
  {
    "index": 54,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/tests/keras/layers/recurrent_test.py b/tests/keras/layers/recurrent_test.py\nindex 2dce96ee67fa..19d318a060a3 100644\n--- a/tests/keras/layers/recurrent_test.py\n+++ b/tests/keras/layers/recurrent_test.py\n@@ -568,5 +568,174 @@ def test_batch_size_equal_one(layer_class):\n     model.train_on_batch(x, y)\n \n \n+def test_rnn_cell_with_constants_layer():\n+\n+    class RNNCellWithConstants(keras.layers.Layer):\n+\n+        def __init__(self, units, **kwargs):\n+            self.units = units\n+            self.state_size = units\n+            super(RNNCellWithConstants, self).__init__(**kwargs)\n+\n+        def build(self, input_shape):\n+            if not isinstance(input_shape, list):\n+                raise TypeError('expects constants shape')\n+            [input_shape, constant_shape] = input_shape\n+            # will (and should) raise if more than one constant passed\n+\n+            self.input_kernel = self.add_weight(\n+                shape=(input_shape[-1], self.units),\n+                initializer='uniform',\n+                name='kernel')\n+            self.recurrent_kernel = self.add_weight(\n+                shape=(self.units, self.units),\n+                initializer='uniform',\n+                name='recurrent_kernel')\n+            self.constant_kernel = self.add_weight(\n+                shape=(constant_shape[-1], self.units),\n+                initializer='uniform',\n+                name='constant_kernel')\n+            self.built = True\n+\n+        def call(self, inputs, states, constants):\n+            [prev_output] = states\n+            [constant] = constants\n+            h_input = keras.backend.dot(inputs, self.input_kernel)\n+            h_state = keras.backend.dot(prev_output, self.recurrent_kernel)\n+            h_const = keras.backend.dot(constant, self.constant_kernel)\n+            output = h_input + h_state + h_const\n+            return output, [output]\n+\n+        def get_config(self):\n+            config = {'units': self.units}\n+            base_config = super(RNNCellWithConstants, self).get_config()\n+            return dict(list(base_config.items()) + list(config.items()))\n+\n+    # Test basic case.\n+    x = keras.Input((None, 5))\n+    c = keras.Input((3,))\n+    cell = RNNCellWithConstants(32)\n+    layer = recurrent.RNN(cell)\n+    y = layer(x, constants=c)\n+    model = keras.models.Model([x, c], y)\n+    model.compile(optimizer='rmsprop', loss='mse')\n+    model.train_on_batch(\n+        [np.zeros((6, 5, 5)), np.zeros((6, 3))],\n+        np.zeros((6, 32))\n+    )\n+\n+    # Test basic case serialization.\n+    x_np = np.random.random((6, 5, 5))\n+    c_np = np.random.random((6, 3))\n+    y_np = model.predict([x_np, c_np])\n+    weights = model.get_weights()\n+    config = layer.get_config()\n+    custom_objects = {'RNNCellWithConstants': RNNCellWithConstants}\n+    with keras.utils.CustomObjectScope(custom_objects):\n+        layer = recurrent.RNN.from_config(config.copy())\n+    y = layer(x, constants=c)\n+    model = keras.models.Model([x, c], y)\n+    model.set_weights(weights)\n+    y_np_2 = model.predict([x_np, c_np])\n+    assert_allclose(y_np, y_np_2, atol=1e-4)\n+\n+    # test flat list inputs\n+    with keras.utils.CustomObjectScope(custom_objects):\n+        layer = recurrent.RNN.from_config(config.copy())\n+    y = layer([x, c])\n+    model = keras.models.Model([x, c], y)\n+    model.set_weights(weights)\n+    y_np_3 = model.predict([x_np, c_np])\n+    assert_allclose(y_np, y_np_3, atol=1e-4)\n+\n+\n+def test_rnn_cell_with_constants_layer_passing_initial_state():\n+\n+    class RNNCellWithConstants(keras.layers.Layer):\n+\n+        def __init__(self, units, **kwargs):\n+            self.units = units\n+            self.state_size = units\n+            super(RNNCellWithConstants, self).__init__(**kwargs)\n+\n+        def build(self, input_shape):\n+            if not isinstance(input_shape, list):\n+                raise TypeError('expects constants shape')\n+            [input_shape, constant_shape] = input_shape\n+            # will (and should) raise if more than one constant passed\n+\n+            self.input_kernel = self.add_weight(\n+                shape=(input_shape[-1], self.units),\n+                initializer='uniform',\n+                name='kernel')\n+            self.recurrent_kernel = self.add_weight(\n+                shape=(self.units, self.units),\n+                initializer='uniform',\n+                name='recurrent_kernel')\n+            self.constant_kernel = self.add_weight(\n+                shape=(constant_shape[-1], self.units),\n+                initializer='uniform',\n+                name='constant_kernel')\n+            self.built = True\n+\n+        def call(self, inputs, states, constants):\n+            [prev_output] = states\n+            [constant] = constants\n+            h_input = keras.backend.dot(inputs, self.input_kernel)\n+            h_state = keras.backend.dot(prev_output, self.recurrent_kernel)\n+            h_const = keras.backend.dot(constant, self.constant_kernel)\n+            output = h_input + h_state + h_const\n+            return output, [output]\n+\n+        def get_config(self):\n+            config = {'units': self.units}\n+            base_config = super(RNNCellWithConstants, self).get_config()\n+            return dict(list(base_config.items()) + list(config.items()))\n+\n+    # Test basic case.\n+    x = keras.Input((None, 5))\n+    c = keras.Input((3,))\n+    s = keras.Input((32,))\n+    cell = RNNCellWithConstants(32)\n+    layer = recurrent.RNN(cell)\n+    y = layer(x, initial_state=s, constants=c)\n+    model = keras.models.Model([x, s, c], y)\n+    model.compile(optimizer='rmsprop', loss='mse')\n+    model.train_on_batch(\n+        [np.zeros((6, 5, 5)), np.zeros((6, 32)), np.zeros((6, 3))],\n+        np.zeros((6, 32))\n+    )\n+\n+    # Test basic case serialization.\n+    x_np = np.random.random((6, 5, 5))\n+    s_np = np.random.random((6, 32))\n+    c_np = np.random.random((6, 3))\n+    y_np = model.predict([x_np, s_np, c_np])\n+    weights = model.get_weights()\n+    config = layer.get_config()\n+    custom_objects = {'RNNCellWithConstants': RNNCellWithConstants}\n+    with keras.utils.CustomObjectScope(custom_objects):\n+        layer = recurrent.RNN.from_config(config.copy())\n+    y = layer(x, initial_state=s, constants=c)\n+    model = keras.models.Model([x, s, c], y)\n+    model.set_weights(weights)\n+    y_np_2 = model.predict([x_np, s_np, c_np])\n+    assert_allclose(y_np, y_np_2, atol=1e-4)\n+\n+    # verify that state is used\n+    y_np_2_different_s = model.predict([x_np, s_np + 10., c_np])\n+    with pytest.raises(AssertionError):\n+        assert_allclose(y_np, y_np_2_different_s, atol=1e-4)\n+\n+    # test flat list inputs\n+    with keras.utils.CustomObjectScope(custom_objects):\n+        layer = recurrent.RNN.from_config(config.copy())\n+    y = layer([x, s, c])\n+    model = keras.models.Model([x, s, c], y)\n+    model.set_weights(weights)\n+    y_np_3 = model.predict([x_np, s_np, c_np])\n+    assert_allclose(y_np, y_np_3, atol=1e-4)\n+\n+\n if __name__ == '__main__':\n     pytest.main([__file__])\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR proposes integrating constants as inputs to the RNN layer, emphasizing that these should be handled similarly to initial states, allowing consistent behavior across both training and inference. Current suggestions for passing these constants via the `__call__` method conflict with Keras principles, as all inputs should be explicitly passed. Consideration for a dedicated `AttentionRNN` class was mentioned, but maintaining backward compatibility with `RNN` is preferred. Overall, the feedback emphasizes clarity, performance, and coherent API design without compromising existing functionalities."
      }
    ],
    "token_estimation": 1906.0
  },
  {
    "index": 55,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/keras/src/quantizers/quantizers.py b/keras/src/quantizers/quantizers.py\nindex 3e4aac181e12..2f7db0c9787b 100644\n--- a/keras/src/quantizers/quantizers.py\n+++ b/keras/src/quantizers/quantizers.py\n@@ -127,6 +128,142 @@ def get_config(self):\n         }\n \n \n+def adjust_and_nudge(min_range, max_range, num_bits, narrow_range):\n+    \"\"\"Adjusts and nudges the quantization range for better accuracy.\"\"\"\n+\n+    quant_max = ops.cast(ops.subtract(ops.power(2, num_bits), 1.0), \"float32\")\n+\n+    quant_min = ops.cast(0.0 if not narrow_range else 1.0, \"float32\")\n+\n+    # Calculate the scale and ensure it's positive\n+    scale = ops.divide(\n+        ops.subtract(max_range, min_range), ops.subtract(quant_max, quant_min)\n+    )\n+\n+    inv_scale = ops.reciprocal(scale)\n+\n+    # Calculate the zero point from the min range\n+    zero_point_from_min = quant_min - ops.divide(min_range, scale)\n+\n+    # Ensure zero point is within valid range [0, quant_max]\n+    zero_point = ops.clip(zero_point_from_min, quant_min, quant_max)\n+\n+    # Nudge zero point if it's very close to an integer\n+    nudged_zero_point = ops.round(zero_point)\n+\n+    # Calculate nudged limits\n+    nudged_min = ops.multiply(ops.subtract(quant_min, nudged_zero_point), scale)\n+    nudged_max = ops.multiply(ops.subtract(quant_max, nudged_zero_point), scale)\n+\n+    return nudged_min, nudged_max, scale, inv_scale\n+\n+\n+@keras_export(\"keras.quantizers.fake_quant_with_min_max_vars_per_channel\")\n+def fake_quant_with_min_max_vars(\n+    inputs,\n+    min_vals,\n+    max_vals,\n+    num_bits,\n+    narrow_range=False,\n+    axis=None,\n+):\n+    \"\"\"\n+    Perform per-tensor or per-channel fake quantization.\n+\n+    `[min_vals, max_vals]` define the clamping range for the `inputs`.\n+\n+    The `inputs` are quantized into the quantization range:\n+    - `[0, 2^num_bits - 1]` when `narrow_range=False`\n+    - `[1, 2^num_bits - 1]` when `narrow_range=True`\n+\n+    After quantization, the values are dequantized and output as floats within\n+    the `[min_vals, max_vals]` interval.\n+\n+    This operation supports gradient computation, allowing `min_vals` and\n+    `max_vals` to be trained.\n+\n+    Args:\n+        inputs: Input tensor of float dtype.\n+        min_vals: A global minimum scalar or a per-channel minimum tensor.\n+        max_vals: A global maximum scalar or a per-channel maximum tensor.\n+        num_bits: Quantization bit width (e.g., `8` for int8).\n+        narrow_range: Whether to use narrow quantization range.\n+        axis: Axis along which to perform per-channel quantization. If `None`,\n+              per-tensor quantization is performed. Defaults to `None`.\n+\n+\n+    Returns:\n+        Fake-quantized tensor\n+    \"\"\"\n+    inputs = ops.convert_to_tensor(inputs)\n+    min_vals = ops.convert_to_tensor(min_vals)\n+    max_vals = ops.convert_to_tensor(max_vals)\n+\n+    if axis is not None:\n+        axis = canonicalize_axis(axis, inputs.ndim)\n+\n+    @ops.custom_gradient\n+    def _fake_quant_with_min_max_vars_per_channel(x, min_val, max_val):\n+        # Calculate quantization parameters for all channels at once\n+        nudged_min, nudged_max, scale, inv_scale = adjust_and_nudge(\n+            min_val, max_val, num_bits, narrow_range\n+        )\n+\n+        quant_zero = ops.floor(\n+            ops.add(ops.multiply(-nudged_min, inv_scale), 0.5)\n+        )\n+        x_clamped = ops.clip(x, nudged_min, nudged_max)\n+        x_clamped_shifted = ops.subtract(x_clamped, nudged_min)\n+        result = ops.multiply(\n+            ops.floor(\n+                ops.add(\n+                    ops.subtract(\n+                        ops.multiply(x_clamped_shifted, inv_scale), quant_zero\n+                    ),\n+                    0.5,\n+                )\n+            ),\n+            scale,\n+        )\n+\n+        # Create gradient mask for all channels\n+        masks = ops.cast(\n+            (x >= nudged_min) & (x <= nudged_max),\n+            dtype=\"float32\",\n+        )\n+\n+        def grad(*args, upstream=None):\n+            if upstream is None:\n+                (upstream,) = args\n+\n+            # Gradient for x\n+            dx = ops.multiply(upstream, masks)\n+            axes = [i for i in range(len(dx.shape)) if i != axis]\n+            # Gradient for min_val\n+            # When x is clipped to min, the gradient flows to min_val\n+            min_mask = ops.cast(x <= nudged_min, dtype=\"float32\")\n+            grad_min = ops.multiply(upstream, min_mask)\n+            if axis is not None:\n+                grad_min = ops.sum(grad_min, axis=axes)\n+            else:\n+                grad_min = ops.sum(grad_min)\n+\n+            # Gradient for max_val\n+            # When x is clipped to max, the gradient flows to max_val\n+            max_mask = ops.cast(x >= nudged_max, dtype=\"float32\")\n+            grad_max = ops.multiply(upstream, max_mask)\n+            if axis is not None:\n+                grad_max = ops.sum(grad_max, axis=axes)\n+            else:\n+                grad_max = ops.sum(grad_max)\n+\n+            return dx, grad_min, grad_max\n+\n+        return result, grad\n+\n+    return _fake_quant_with_min_max_vars_per_channel(inputs, min_vals, max_vals)\n+\n+\n \"\"\"Float8-related methods\"\"\"\n \n \ndiff --git a/keras/src/quantizers/quantizers_test.py b/keras/src/quantizers/quantizers_test.py\nindex 2d62240080ed..d71f8fe2a1f8 100644\n--- a/keras/src/quantizers/quantizers_test.py\n+++ b/keras/src/quantizers/quantizers_test.py\n@@ -100,3 +103,381 @@ def test_quantize_and_dequantize(self):\n         )\n         # A loose assertion due to an expected quantization error\n         self.assertAllClose(qdq_values, values, atol=5e-1)\n+\n+    @parameterized.named_parameters(\n+        [\n+            {\n+                \"testcase_name\": \"wide_8bits_input_mins_0.0_input_maxs_255.0\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [0.0],\n+                \"input_maxs\": [255.0],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [255.0],\n+                \"expected_steps\": [1.0],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"wide_8bits_input_mins_0.5_input_maxs_128.0\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [0.5],\n+                \"input_maxs\": [128.0],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [127.5],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"wide_8bits_input_mins_-128.0_input_maxs_-0.5\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [-128.0],\n+                \"input_maxs\": [-0.5],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [-127.5],\n+                \"expected_nudged_input_maxs\": [0.0],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"wide_8bits_input_mins_-0.1_input_maxs_127.4\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [-0.1],\n+                \"input_maxs\": [127.4],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [127.5],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"narrow_8bits_input_mins_0.0_input_maxs_254.0\",\n+                \"narrow_range\": True,\n+                \"input_mins\": [0.0],\n+                \"input_maxs\": [254.0],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [254.0],\n+                \"expected_steps\": [1.0],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"narrow_8bits_input_mins_0.1_input_maxs_127.1\",\n+                \"narrow_range\": True,\n+                \"input_mins\": [0.1],\n+                \"input_maxs\": [127.1],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [127.0],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": (\n+                    \"narrow_8bits_input_mins_-127.1_input_maxs_-0.1\"\n+                ),\n+                \"narrow_range\": True,\n+                \"input_mins\": [-127.1],\n+                \"input_maxs\": [-0.1],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [-127.0],\n+                \"expected_nudged_input_maxs\": [0.0],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": (\n+                    \"narrow_8bits_input_mins_-0.1_input_maxs_126.9\"\n+                ),\n+                \"narrow_range\": True,\n+                \"input_mins\": [-0.1],\n+                \"input_maxs\": [126.9],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [127.0],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"wide_7bits_input_mins_0.0_input_maxs_127.0\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [0.0],\n+                \"input_maxs\": [127.0],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [127.0],\n+                \"expected_steps\": [1.0],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"wide_7bits_input_mins_0.5_input_maxs_64.0\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [0.5],\n+                \"input_maxs\": [64.0],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [63.5],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"wide_7bits_input_mins_-64.0_input_maxs_-0.5\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [-64.0],\n+                \"input_maxs\": [-0.5],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [-63.5],\n+                \"expected_nudged_input_maxs\": [0.0],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"wide_7bits_input_mins_-0.1_input_maxs_63.4\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [-0.1],\n+                \"input_maxs\": [63.4],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [63.5],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"narrow_7bits_input_mins_0.0_input_maxs_126.0\",\n+                \"narrow_range\": True,\n+                \"input_mins\": [0.0],\n+                \"input_maxs\": [126.0],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [126.0],\n+                \"expected_steps\": [1.0],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"narrow_7bits_input_mins_0.1_input_maxs_63.1\",\n+                \"narrow_range\": True,\n+                \"input_mins\": [0.1],\n+                \"input_maxs\": [63.1],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [63.0],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": (\n+                    \"narrow_7bits_input_mins_-63.1_input_maxs_-0.1\"\n+                ),\n+                \"narrow_range\": True,\n+                \"input_mins\": [-63.1],\n+                \"input_maxs\": [-0.1],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [-63.0],\n+                \"expected_nudged_input_maxs\": [0.0],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"narrow_7bits_input_mins_-0.1_input_maxs_62.9\",\n+                \"narrow_range\": True,\n+                \"input_mins\": [-0.1],\n+                \"input_maxs\": [62.9],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [0.0],\n+                \"expected_nudged_input_maxs\": [63.0],\n+                \"expected_steps\": [0.5],\n+                \"axis\": None,\n+            },\n+            {\n+                \"testcase_name\": \"wide_8bits_multi_channel\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [0.0, 0.5, -128.0, -0.1],\n+                \"input_maxs\": [255.0, 128.0, -0.5, 127.4],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [0.0, 0.0, -127.5, 0.0],\n+                \"expected_nudged_input_maxs\": [255.0, 127.5, 0.0, 127.5],\n+                \"expected_steps\": [1.0, 0.5, 0.5, 0.5],\n+                \"axis\": 1,\n+            },\n+            {\n+                \"testcase_name\": \"narrow_8bits_multi_channel\",\n+                \"narrow_range\": True,\n+                \"input_mins\": [0.0, 0.1, -127.1, -0.1],\n+                \"input_maxs\": [254.0, 127.1, -0.1, 126.9],\n+                \"num_bits\": 8,\n+                \"expected_nudged_input_mins\": [0.0, 0.0, -127.0, 0.0],\n+                \"expected_nudged_input_maxs\": [254.0, 127.0, 0.0, 127.0],\n+                \"expected_steps\": [1.0, 0.5, 0.5, 0.5],\n+                \"axis\": 1,\n+            },\n+            {\n+                \"testcase_name\": \"wide_7bits_multi_channel\",\n+                \"narrow_range\": False,\n+                \"input_mins\": [0.0, 0.5, -64.0, -0.1],\n+                \"input_maxs\": [127.0, 64.0, -0.5, 63.4],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [0.0, 0.0, -63.5, 0.0],\n+                \"expected_nudged_input_maxs\": [127.0, 63.5, 0.0, 63.5],\n+                \"expected_steps\": [1.0, 0.5, 0.5, 0.5],\n+                \"axis\": 1,\n+            },\n+            {\n+                \"testcase_name\": \"narrow_7bits_multi_channel\",\n+                \"narrow_range\": True,\n+                \"input_mins\": [0.0, 0.1, -63.1, -0.1],\n+                \"input_maxs\": [126.0, 63.1, -0.1, 62.9],\n+                \"num_bits\": 7,\n+                \"expected_nudged_input_mins\": [0.0, 0.0, -63.0, 0.0],\n+                \"expected_nudged_input_maxs\": [126.0, 63.0, 0.0, 63.0],\n+                \"expected_steps\": [1.0, 0.5, 0.5, 0.5],\n+                \"axis\": 1,\n+            },\n+        ]\n+    )\n+    def test_op(\n+        self,\n+        input_mins,\n+        input_maxs,\n+        num_bits,\n+        narrow_range,\n+        axis,\n+        expected_nudged_input_mins,\n+        expected_nudged_input_maxs,\n+        expected_steps,\n+    ):\n+        num_channels = len(input_mins)\n+        inputs_list = []\n+        expected_list = []\n+        initial_gradients_list = []\n+        expected_backprops_wrt_input_list = []\n+        for i in range(num_channels):\n+            expected_nudged_input_min = expected_nudged_input_mins[i]\n+            expected_nudged_input_max = expected_nudged_input_maxs[i]\n+            expected_step = expected_steps[i]\n+\n+            inputs_list.append(\n+                [\n+                    expected_nudged_input_min - expected_step,\n+                    expected_nudged_input_min - 0.01,\n+                    expected_nudged_input_min,\n+                    expected_nudged_input_min + 0.01,\n+                    expected_nudged_input_min + expected_step - 0.01,\n+                    expected_nudged_input_min + expected_step,\n+                    expected_nudged_input_min + expected_step + 0.01,\n+                    expected_nudged_input_max - 0.01,\n+                    expected_nudged_input_max,\n+                    expected_nudged_input_max + 0.01,\n+                    expected_nudged_input_max + expected_step,\n+                ]\n+            )\n+            expected_list.append(\n+                [\n+                    expected_nudged_input_min,\n+                    expected_nudged_input_min,\n+                    expected_nudged_input_min,\n+                    expected_nudged_input_min,\n+                    expected_nudged_input_min + expected_step,\n+                    expected_nudged_input_min + expected_step,\n+                    expected_nudged_input_min + expected_step,\n+                    expected_nudged_input_max,\n+                    expected_nudged_input_max,\n+                    expected_nudged_input_max,\n+                    expected_nudged_input_max,\n+                ]\n+            )\n+            initial_gradients_list.append(\n+                list(range(1, len(inputs_list[-1]) + 1))\n+            )\n+            expected_backprops_wrt_input_list.append(\n+                [0.0, 0.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 0.0, 0.0]\n+            )\n+        inputs = ops.transpose(ops.array(inputs_list, dtype=\"float32\"))\n+        expected = ops.transpose(ops.array(expected_list, dtype=\"float32\"))\n+        expected_backprops_wrt_input = ops.transpose(\n+            ops.array(expected_backprops_wrt_input_list, dtype=\"float32\")\n+        )\n+        input_min = ops.array(input_mins, dtype=\"float32\")\n+        input_max = ops.array(input_maxs, dtype=\"float32\")\n+        initial_gradients = ops.transpose(\n+            ops.array(initial_gradients_list, dtype=\"float32\")\n+        )\n+        if backend.backend() == \"tensorflow\":\n+            import tensorflow as tf\n+\n+            @tf.function(jit_compile=True)\n+            def test_op(\n+                inputs, input_mins, input_maxs, num_bits, narrow_range, axis\n+            ):\n+                with tf.GradientTape() as tape:\n+                    tape.watch(inputs)\n+                    result = quantizers.fake_quant_with_min_max_vars(\n+                        inputs,\n+                        input_mins,\n+                        input_maxs,\n+                        num_bits,\n+                        narrow_range,\n+                        axis,\n+                    )\n+                return initial_gradients * tape.gradient(result, inputs)\n+\n+            gradients = test_op(\n+                inputs, input_mins, input_maxs, num_bits, narrow_range, axis\n+            )\n+            # test gradients\n+            self.assertAllClose(gradients, expected_backprops_wrt_input)\n+\n+        if backend.backend() == \"torch\":\n+            import torch\n+\n+            def test_op(inputs, input_mins, input_maxs, num_bits, narrow_range):\n+                # Create tensor and enable gradient tracking\n+                inputs = torch.tensor(\n+                    inputs, dtype=torch.float32, requires_grad=True\n+                )\n+\n+                # Apply the quantization operation\n+                result = quantizers.fake_quant_with_min_max_vars(\n+                    inputs, input_mins, input_maxs, num_bits, narrow_range\n+                )\n+\n+                # Compute gradients\n+                result.backward(torch.ones_like(result))\n+\n+                return initial_gradients * inputs.grad\n+\n+            gradients = test_op(\n+                inputs, input_min, input_max, num_bits, narrow_range\n+            )\n+            # test gradients\n+            self.assertAllClose(gradients, expected_backprops_wrt_input)\n+\n+        if backend.backend() == \"jax\":\n+            import jax\n+\n+            def test_op(inputs, input_mins, input_maxs, num_bits, narrow_range):\n+                # Define the function to compute gradients for\n+                def quantize_fn(x):\n+                    return quantizers.fake_quant_with_min_max_vars(\n+                        x, input_mins, input_maxs, num_bits, narrow_range\n+                    )\n+\n+                _, f_vjp = jax.vjp(quantize_fn, inputs)\n+                # NOTE:python 3.10 input_gradients = f_vjp.args[0].args[0][0] !\n+                input_gradients = f_vjp.args[0].args[0][1]\n+\n+                return ops.multiply(initial_gradients, input_gradients)\n+\n+            gradients = test_op(\n+                inputs, input_min, input_max, num_bits, narrow_range\n+            )\n+            # test gradients\n+            self.assertAllClose(gradients, expected_backprops_wrt_input)\n+        outputs = quantizers.fake_quant_with_min_max_vars(\n+            inputs,\n+            input_min,\n+            input_max,\n+            num_bits=num_bits,\n+            narrow_range=narrow_range,\n+            axis=axis,\n+        )\n+        self.assertAllClose(outputs, expected)\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "You've done a solid job refactoring the functions into one to reduce duplication, but consider whether we still need the separate functions for different parameter types. I appreciate the addition of tests and aligning with `parameterized.named_parameters()`, but I'm concerned about the JAX GPU test failures. It’d be helpful to further investigate the precision issue you mentioned. Also, ensure the unnecessary functions are truly removed to keep the codebase clean. Once CI passes, we should be ready for merge."
      }
    ],
    "token_estimation": 5353.0
  },
  {
    "index": 56,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/examples/lstm_benchmark.py b/examples/lstm_benchmark.py\nnew file mode 100644\nindex 000000000000..eb462c5719ea\n--- /dev/null\n+++ b/examples/lstm_benchmark.py\n@@ -0,0 +1,76 @@\n+'''Compare LSTM implementations on the IMDB sentiment classification task.\n+\n+consume_less='cpu' preprocesses input to the LSTM which typically results in\n+faster computations at the expense of increased peak memory usage as the\n+preprocessed input must be kept in memory.\n+\n+consume_less='mem' does away with the preprocessing, meaning that it might take\n+a little longer, but should require less peak memory.\n+\n+consume_less='gpu' concatenates the input, output and forget gate's weights\n+into one, large matrix, resulting in faster computation time as the GPU can\n+utilize more cores, at the expense of reduced regularization because the same\n+dropout is shared across the gates. It should require similar memory usage as\n+consume_less='mem'.\n+'''\n+\n+import time\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+from keras.preprocessing import sequence\n+from keras.models import Sequential\n+from keras.layers import Embedding, BatchNormalization, Dense, LSTM\n+from keras.datasets import imdb\n+\n+max_features = 20000\n+max_length = 80\n+embedding = 400\n+batch_size = 256\n+epochs = 10\n+modes = ['cpu', 'mem', 'gpu']\n+\n+print('Loading data...')\n+(X_train, y_train), (X_test, y_test) = imdb.load_data(nb_words=max_features)\n+X_train = sequence.pad_sequences(X_train, max_length)\n+X_test = sequence.pad_sequences(X_test, max_length)\n+\n+# Compile and train different models while meauring performance.\n+results = []\n+for mode in modes:\n+    print(\"Testing mode: consume_less='{}'\".format(mode))\n+\n+    model = Sequential()\n+    model.add(Embedding(max_features, embedding, input_length=max_length, dropout=0.2))\n+    model.add(BatchNormalization())\n+    model.add(LSTM(embedding, dropout_W=0.2, dropout_U=0.2, consume_less=mode))\n+    model.add(Dense(1, activation='sigmoid'))\n+    model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\n+\n+    start_time = time.time()\n+    history = model.fit(X_train, y_train, batch_size=batch_size, nb_epoch=epochs, validation_data=(X_test, y_test))\n+    average_time_per_epoch = (time.time() - start_time) / epochs\n+\n+    results.append((history, average_time_per_epoch))\n+\n+# Compare models' accuracy, loss and elapsed time per epoch.\n+plt.style.use('ggplot')\n+ax1 = plt.subplot2grid((2,2), (0,0))\n+ax1.set_title('Accuracy')\n+ax1.set_ylabel('Validation Accuracy')\n+ax1.set_xlabel('Epochs')\n+ax2 = plt.subplot2grid((2,2), (1,0))\n+ax2.set_title('Loss')\n+ax2.set_ylabel('Validation Loss')\n+ax2.set_xlabel('Epochs')\n+ax3 = plt.subplot2grid((2,2), (0,1), rowspan=2)\n+ax3.set_title('Time')\n+ax3.set_ylabel('Seconds')\n+for mode, result in zip(modes, results):\n+    ax1.plot(result[0].epoch, result[0].history['val_acc'], label=mode)\n+    ax2.plot(result[0].epoch, result[0].history['val_loss'], label=mode)\n+ax1.legend()\n+ax2.legend()\n+ax3.bar(np.arange(len(results)), [x[1] for x in results], tick_label=modes, align='center')\n+plt.tight_layout()\n+plt.show()\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR identifies issues with RNN dropout implementation, particularly that dropout is being passed as standard Python lists instead of tensors. This creates a limitation where the same dropout mask is applied to all gates, which could be addressed with different masks for each gate. Additionally, the forget gate initialization is currently incorrect, defaulting to zeros, and could benefit from enhancements regarding subtensor assignments. Lastly, there’s no unit test covering RNN dropout functionality, which should be added to ensure reliability."
      }
    ],
    "token_estimation": 915.5
  },
  {
    "index": 58,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/opendevin/runtime/docker/image_agnostic_util.py b/opendevin/runtime/docker/image_agnostic_util.py\nnew file mode 100644\nindex 000000000000..b33b412f9bf7\n--- /dev/null\n+++ b/opendevin/runtime/docker/image_agnostic_util.py\n@@ -0,0 +1,95 @@\n+import tempfile\n+\n+import docker\n+\n+from opendevin.core.logger import opendevin_logger as logger\n+\n+\n+def generate_dockerfile_content(base_image: str) -> str:\n+    \"\"\"\n+    Generate the Dockerfile content for the agnostic sandbox image based on user-provided base image.\n+\n+    NOTE: This is only tested on debian yet.\n+    \"\"\"\n+    # FIXME: Remove the requirement of ssh in future version\n+    dockerfile_content = (\n+        f'FROM {base_image}\\n'\n+        'RUN apt update && apt install -y openssh-server wget sudo\\n'\n+        'RUN mkdir -p -m0755 /var/run/sshd\\n'\n+        'RUN mkdir -p /opendevin && mkdir -p /opendevin/logs && chmod 777 /opendevin/logs\\n'\n+        'RUN wget \"https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-$(uname)-$(uname -m).sh\"\\n'\n+        'RUN bash Miniforge3-$(uname)-$(uname -m).sh -b -p /opendevin/miniforge3\\n'\n+        'RUN bash -c \". /opendevin/miniforge3/etc/profile.d/conda.sh && conda config --set changeps1 False && conda config --append channels conda-forge\"\\n'\n+        'RUN echo \"export PATH=/opendevin/miniforge3/bin:$PATH\" >> ~/.bashrc\\n'\n+        'RUN echo \"export PATH=/opendevin/miniforge3/bin:$PATH\" >> /opendevin/bash.bashrc\\n'\n+    ).strip()\n+    return dockerfile_content\n+\n+\n+def _build_sandbox_image(\n+        base_image: str, target_image_name: str, docker_client: docker.DockerClient\n+):\n+    try:\n+        with tempfile.TemporaryDirectory() as temp_dir:\n+            dockerfile_content = generate_dockerfile_content(base_image)\n+            logger.info(f'Building agnostic sandbox image: {target_image_name}')\n+            logger.info(\n+                (\n+                    f'===== Dockerfile content =====\\n'\n+                    f'{dockerfile_content}\\n'\n+                    f'==============================='\n+                )\n+            )\n+            with open(f'{temp_dir}/Dockerfile', 'w') as file:\n+                file.write(dockerfile_content)\n+\n+            image, logs = docker_client.images.build(\n+                path=temp_dir, tag=target_image_name\n+            )\n+\n+        for log in logs:\n+            if 'stream' in log:\n+                print(log['stream'].strip())\n+\n+        logger.info(f'Image {image} built successfully')\n+    except docker.errors.BuildError as e:\n+        logger.error(f'Sandbox image build failed: {e}')\n+        raise e\n+    except Exception as e:\n+        logger.error(f'An error occurred during sandbox image build: {e}')\n+        raise e\n+\n+\n+def _get_new_image_name(base_image: str) -> str:\n+    if \":\" not in base_image:\n+        base_image = base_image + \":latest\"\n+\n+    [repo, tag] = base_image.split(':')\n+    return f'od_sandbox:{repo}__{tag}'\n+\n+\n+def get_od_sandbox_image(base_image: str, docker_client: docker.DockerClient) -> str:\n+    \"\"\"Return the sandbox image name based on user-provided base image.\n+\n+    The returned sandbox image is assumed to contains all the required dependencies for OpenDevin.\n+    If the sandbox image is not found, it will be built.\n+    \"\"\"\n+    # OpenDevin's offcial sandbox already contains the required dependencies for OpenDevin.\n+    if 'ghcr.io/opendevin/sandbox' in base_image:\n+        return base_image\n+\n+    new_image_name = _get_new_image_name(base_image)\n+\n+    # Detect if the sandbox image is built\n+    images = docker_client.images.list()\n+    for image in images:\n+        if new_image_name in image.tags:\n+            logger.info('Found existing od_sandbox image, reuse:' + new_image_name)\n+            return new_image_name\n+\n+    # If the sandbox image is not found, build it\n+    logger.info(\n+        f'od_sandbox image is not found for {base_image}, will build: {new_image_name}'\n+    )\n+    _build_sandbox_image(base_image, new_image_name, docker_client)\n+    return new_image_name\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR addresses the inclusion of `sshd` in Docker images but adopts a temporary fix by requiring an image with `sshd` already built in. The approach is not universal, particularly for CentOS. Future refactoring should consider WebSocket communication instead. The PR also aims to streamline the sandbox image generation using user-provided base images and improve startup time through caching. However, there are unresolved issues with unittest compatibility and dependency conflicts in packaging; environmental setup in the Dockerfile needs adjustments for consistent use of `pip`. Consider moving environment configuration to `/opendevin/bash.bashrc` for better isolation."
      }
    ],
    "token_estimation": 1179.0
  },
  {
    "index": 59,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/openhands/core/loop.py b/openhands/core/loop.py\nnew file mode 100644\nindex 000000000000..2a2808dd0980\n--- /dev/null\n+++ b/openhands/core/loop.py\n@@ -0,0 +1,50 @@\n+import asyncio\n+\n+from openhands.controller import AgentController\n+from openhands.core.logger import openhands_logger as logger\n+from openhands.core.schema import AgentState\n+from openhands.runtime.base import Runtime\n+\n+\n+async def run_agent_until_done(\n+    controller: AgentController,\n+    runtime: Runtime,\n+    end_states: list[AgentState],\n+):\n+    \"\"\"\n+    run_agent_until_done takes a controller and a runtime, and will run\n+    the agent until it reaches a terminal state.\n+    Note that runtime must be connected before being passed in here.\n+    \"\"\"\n+    controller.agent_task = asyncio.create_task(controller.start_step_loop())\n+\n+    def status_callback(msg_type, msg_id, msg):\n+        if msg_type == 'error':\n+            logger.error(msg)\n+            if controller:\n+                controller.state.last_error = msg\n+                asyncio.create_task(controller.set_agent_state_to(AgentState.ERROR))\n+        else:\n+            logger.info(msg)\n+\n+    if hasattr(runtime, 'status_callback') and runtime.status_callback:\n+        raise ValueError(\n+            'Runtime status_callback was set, but run_agent_until_done will override it'\n+        )\n+    if hasattr(controller, 'status_callback') and controller.status_callback:\n+        raise ValueError(\n+            'Controller status_callback was set, but run_agent_until_done will override it'\n+        )\n+\n+    runtime.status_callback = status_callback\n+    controller.status_callback = status_callback\n+\n+    while controller.state.agent_state not in end_states:\n+        await asyncio.sleep(1)\n+\n+    if not controller.agent_task.done():\n+        controller.agent_task.cancel()\n+        try:\n+            await controller.agent_task\n+        except asyncio.CancelledError:\n+            pass\ndiff --git a/tests/runtime/test_stress_remote_runtime.py b/tests/runtime/test_stress_remote_runtime.py\nnew file mode 100644\nindex 000000000000..4d96ee132a2d\n--- /dev/null\n+++ b/tests/runtime/test_stress_remote_runtime.py\n@@ -0,0 +1,231 @@\n+\"\"\"Bash-related tests for the EventStreamRuntime, which connects to the ActionExecutor running in the sandbox.\"\"\"\n+\n+import asyncio\n+import os\n+import tempfile\n+from unittest.mock import MagicMock\n+\n+import pandas as pd\n+import pytest\n+from conftest import TEST_IN_CI\n+\n+from evaluation.utils.shared import (\n+    EvalException,\n+    EvalMetadata,\n+    EvalOutput,\n+    assert_and_raise,\n+    codeact_user_response,\n+    make_metadata,\n+    prepare_dataset,\n+    reset_logger_for_multiprocessing,\n+    run_evaluation,\n+)\n+from openhands.agenthub import Agent\n+from openhands.controller.state.state import State\n+from openhands.core.config import (\n+    AgentConfig,\n+    AppConfig,\n+    LLMConfig,\n+    SandboxConfig,\n+)\n+from openhands.core.logger import openhands_logger as logger\n+from openhands.core.main import create_runtime, run_controller\n+from openhands.events.action import CmdRunAction, MessageAction\n+from openhands.events.observation import CmdOutputObservation\n+from openhands.events.serialization.event import event_to_dict\n+from openhands.llm import LLM\n+from openhands.runtime.base import Runtime\n+from openhands.utils.async_utils import call_async_from_sync\n+\n+AGENT_CLS_TO_FAKE_USER_RESPONSE_FN = {\n+    'CodeActAgent': codeact_user_response,\n+}\n+\n+\n+def get_config(\n+    metadata: EvalMetadata,\n+) -> AppConfig:\n+    assert (\n+        os.environ.get('SANDBOX_REMOTE_RUNTIME_API_URL') is not None\n+    ), 'SANDBOX_REMOTE_RUNTIME_API_URL must be set.'\n+    assert (\n+        os.environ.get('ALLHANDS_API_KEY') is not None\n+    ), 'ALLHANDS_API_KEY must be set.'\n+    config = AppConfig(\n+        default_agent=metadata.agent_class,\n+        run_as_openhands=False,\n+        max_iterations=metadata.max_iterations,\n+        runtime='remote',\n+        sandbox=SandboxConfig(\n+            base_container_image='python:3.11-bookworm',\n+            enable_auto_lint=True,\n+            use_host_network=False,\n+            # large enough timeout, since some testcases take very long to run\n+            timeout=300,\n+            api_key=os.environ.get('ALLHANDS_API_KEY', None),\n+            remote_runtime_api_url=os.environ.get('SANDBOX_REMOTE_RUNTIME_API_URL'),\n+            keep_remote_runtime_alive=False,\n+        ),\n+        # do not mount workspace\n+        workspace_base=None,\n+        workspace_mount_path=None,\n+    )\n+    agent_config = AgentConfig(\n+        codeact_enable_jupyter=False,\n+        codeact_enable_browsing=False,\n+        codeact_enable_llm_editor=False,\n+    )\n+    config.set_agent_config(agent_config)\n+    return config\n+\n+\n+def initialize_runtime(\n+    runtime: Runtime,\n+):\n+    \"\"\"Initialize the runtime for the agent.\n+\n+    This function is called before the runtime is used to run the agent.\n+    \"\"\"\n+    logger.info('-' * 30)\n+    logger.info('BEGIN Runtime Initialization Fn')\n+    logger.info('-' * 30)\n+    obs: CmdOutputObservation\n+\n+    action = CmdRunAction(command=\"\"\"export USER=$(whoami); echo USER=${USER} \"\"\")\n+    action.timeout = 600\n+    logger.info(action, extra={'msg_type': 'ACTION'})\n+    obs = runtime.run_action(action)\n+    logger.info(obs, extra={'msg_type': 'OBSERVATION'})\n+    assert_and_raise(obs.exit_code == 0, f'Failed to export USER: {str(obs)}')\n+\n+    action = CmdRunAction(command='mkdir -p /dummy_dir')\n+    action.timeout = 600\n+    logger.info(action, extra={'msg_type': 'ACTION'})\n+    obs = runtime.run_action(action)\n+    logger.info(obs, extra={'msg_type': 'OBSERVATION'})\n+    assert_and_raise(\n+        obs.exit_code == 0,\n+        f'Failed to create /dummy_dir: {str(obs)}',\n+    )\n+\n+    with tempfile.TemporaryDirectory() as temp_dir:\n+        # Construct the full path for the desired file name within the temporary directory\n+        temp_file_path = os.path.join(temp_dir, 'dummy_file')\n+        # Write to the file with the desired name within the temporary directory\n+        with open(temp_file_path, 'w') as f:\n+            f.write('dummy content')\n+\n+        # Copy the file to the desired location\n+        runtime.copy_to(temp_file_path, '/dummy_dir/')\n+\n+    logger.info('-' * 30)\n+    logger.info('END Runtime Initialization Fn')\n+    logger.info('-' * 30)\n+\n+\n+def process_instance(\n+    instance: pd.Series,\n+    metadata: EvalMetadata,\n+    reset_logger: bool = True,\n+) -> EvalOutput:\n+    config = get_config(metadata)\n+\n+    # Setup the logger properly, so you can run multi-processing to parallelize the evaluation\n+    if reset_logger:\n+        log_dir = os.path.join(metadata.eval_output_dir, 'infer_logs')\n+        reset_logger_for_multiprocessing(logger, instance.instance_id, log_dir)\n+    else:\n+        logger.info(f'Starting evaluation for instance {instance.instance_id}.')\n+\n+    runtime = create_runtime(config)\n+    call_async_from_sync(runtime.connect)\n+\n+    try:\n+        initialize_runtime(runtime)\n+\n+        instruction = 'dummy instruction'\n+        agent = Agent.get_cls(metadata.agent_class)(\n+            llm=LLM(config=metadata.llm_config),\n+            config=config.get_agent_config(metadata.agent_class),\n+        )\n+\n+        def next_command(*args, **kwargs):\n+            return CmdRunAction(command='ls -lah')\n+\n+        agent.step = MagicMock(side_effect=next_command)\n+\n+        # Here's how you can run the agent (similar to the `main` function) and get the final task state\n+        state: State | None = asyncio.run(\n+            run_controller(\n+                config=config,\n+                initial_user_action=MessageAction(content=instruction),\n+                runtime=runtime,\n+                fake_user_response_fn=AGENT_CLS_TO_FAKE_USER_RESPONSE_FN[\n+                    metadata.agent_class\n+                ],\n+                agent=agent,\n+            )\n+        )\n+\n+        # if fatal error, throw EvalError to trigger re-run\n+        if (\n+            state.last_error\n+            and 'fatal error during agent execution' in state.last_error\n+            and 'stuck in a loop' not in state.last_error\n+        ):\n+            raise EvalException('Fatal error detected: ' + state.last_error)\n+\n+    finally:\n+        runtime.close()\n+\n+    test_result = {}\n+    if state is None:\n+        raise ValueError('State should not be None.')\n+    histories = [event_to_dict(event) for event in state.history.get_events()]\n+    metrics = state.metrics.get() if state.metrics else None\n+\n+    # Save the output\n+    output = EvalOutput(\n+        instance_id=instance.instance_id,\n+        instruction=instruction,\n+        instance=instance.to_dict(),  # SWE Bench specific\n+        test_result=test_result,\n+        metadata=metadata,\n+        history=histories,\n+        metrics=metrics,\n+        error=state.last_error if state and state.last_error else None,\n+    )\n+    return output\n+\n+\n+@pytest.mark.skipif(\n+    TEST_IN_CI,\n+    reason='This test should only be run locally, not in CI.',\n+)\n+def test_stress_remote_runtime(n_eval_workers: int = 64):\n+    \"\"\"Mimic evaluation setting to test remote runtime in a multi-processing setting.\"\"\"\n+\n+    llm_config = LLMConfig()\n+    metadata = make_metadata(\n+        llm_config,\n+        'dummy_dataset_descrption',\n+        'CodeActAgent',\n+        max_iterations=10,\n+        eval_note='dummy_eval_note',\n+        eval_output_dir='./dummy_eval_output_dir',\n+        details={},\n+    )\n+\n+    # generate 300 random dummy instances\n+    dummy_instance = pd.DataFrame(\n+        {\n+            'instance_id': [f'dummy_instance_{i}' for i in range(300)],\n+        }\n+    )\n+\n+    output_file = os.path.join(metadata.eval_output_dir, 'output.jsonl')\n+    instances = prepare_dataset(\n+        dummy_instance, output_file, eval_n_limit=len(dummy_instance)\n+    )\n+\n+    run_evaluation(instances, metadata, output_file, n_eval_workers, process_instance)\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The minor refactor in the agent controller enhances maintainability and clarity, especially with the error handling improvements by replacing `FatalErrorObservation` with `ErrorObservation`. However, consistency in return types for the `run` method and error naming could be improved for better readability. Additionally, ensure test names accurately reflect their functionality. Overall, while the refactor is a strong step forward, these suggestions will bolster the code quality further."
      }
    ],
    "token_estimation": 2609.25
  },
  {
    "index": 60,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/openhands/events/observation/agent.py b/openhands/events/observation/agent.py\nindex 413828f3ded5..e2dfe4945602 100644\n--- a/openhands/events/observation/agent.py\n+++ b/openhands/events/observation/agent.py\n@@ -40,3 +41,76 @@ class AgentThinkObservation(Observation):\n     @property\n     def message(self) -> str:\n         return self.content\n+\n+\n+@dataclass\n+class MicroagentKnowledge:\n+    \"\"\"\n+    Represents knowledge from a triggered microagent.\n+\n+    Attributes:\n+        name: The name of the microagent that was triggered\n+        trigger: The word that triggered this microagent\n+        content: The actual content/knowledge from the microagent\n+    \"\"\"\n+\n+    name: str\n+    trigger: str\n+    content: str\n+\n+\n+@dataclass\n+class MicroagentObservation(Observation):\n+    \"\"\"The retrieval of content from a microagent or more microagents.\"\"\"\n+\n+    recall_type: RecallType\n+    observation: str = ObservationType.MICROAGENT\n+\n+    # environment\n+    repo_name: str = ''\n+    repo_directory: str = ''\n+    repo_instructions: str = ''\n+    runtime_hosts: dict[str, int] = field(default_factory=dict)\n+    additional_agent_instructions: str = ''\n+\n+    # knowledge\n+    microagent_knowledge: list[MicroagentKnowledge] = field(default_factory=list)\n+    \"\"\"\n+    A list of MicroagentKnowledge objects, each containing information from a triggered microagent.\n+\n+    Example:\n+    [\n+        MicroagentKnowledge(\n+            name=\"python_best_practices\",\n+            trigger=\"python\",\n+            content=\"Always use virtual environments for Python projects.\"\n+        ),\n+        MicroagentKnowledge(\n+            name=\"git_workflow\",\n+            trigger=\"git\",\n+            content=\"Create a new branch for each feature or bugfix.\"\n+        )\n+    ]\n+    \"\"\"\n+\n+    @property\n+    def message(self) -> str:\n+        return self.__str__()\n+\n+    def __str__(self) -> str:\n+        # Build a string representation of all fields\n+        fields = [\n+            f'recall_type={self.recall_type}',\n+            f'repo_name={self.repo_name}',\n+            f'repo_instructions={self.repo_instructions[:20]}...',\n+            f'runtime_hosts={self.runtime_hosts}',\n+            f'additional_agent_instructions={self.additional_agent_instructions[:20]}...',\n+        ]\n+\n+        # Only include microagent_knowledge if it's not empty\n+        if self.microagent_knowledge:\n+            fields.append(\n+                f'microagent_knowledge={\", \".join([m.name for m in self.microagent_knowledge])}'\n+            )\n+\n+        return f'**MicroagentObservation**\\n{\", \".join(fields)}'\ndiff --git a/openhands/memory/conversation_memory.py b/openhands/memory/conversation_memory.py\nindex d44cb3cb9526..b308fef142a9 100644\n--- a/openhands/memory/conversation_memory.py\n+++ b/openhands/memory/conversation_memory.py\n@@ -372,6 +384,92 @@ def _process_observation(\n         elif isinstance(obs, AgentCondensationObservation):\n             text = truncate_content(obs.content, max_message_chars)\n             message = Message(role='user', content=[TextContent(text=text)])\n+        elif (\n+            isinstance(obs, MicroagentObservation)\n+            and self.agent_config.enable_prompt_extensions\n+        ):\n+            if obs.recall_type == RecallType.WORKSPACE_CONTEXT:\n+                # everything is optional, check if they are present\n+                repo_info = (\n+                    RepositoryInfo(\n+                        repo_name=obs.repo_name or '',\n+                        repo_directory=obs.repo_directory or '',\n+                    )\n+                    if obs.repo_name or obs.repo_directory\n+                    else None\n+                )\n+                if obs.runtime_hosts or obs.additional_agent_instructions:\n+                    runtime_info = RuntimeInfo(\n+                        available_hosts=obs.runtime_hosts,\n+                        additional_agent_instructions=obs.additional_agent_instructions,\n+                    )\n+                else:\n+                    runtime_info = None\n+\n+                repo_instructions = (\n+                    obs.repo_instructions if obs.repo_instructions else ''\n+                )\n+\n+                # Have some meaningful content before calling the template\n+                has_repo_info = repo_info is not None and (\n+                    repo_info.repo_name or repo_info.repo_directory\n+                )\n+                has_runtime_info = runtime_info is not None and (\n+                    runtime_info.available_hosts\n+                    or runtime_info.additional_agent_instructions\n+                )\n+                has_repo_instructions = bool(repo_instructions.strip())\n+\n+                # Build additional info if we have something to render\n+                if has_repo_info or has_runtime_info or has_repo_instructions:\n+                    # ok, now we can build the additional info\n+                    formatted_text = self.prompt_manager.build_additional_info(\n+                        repository_info=repo_info,\n+                        runtime_info=runtime_info,\n+                        repo_instructions=repo_instructions,\n+                    )\n+                    message = Message(\n+                        role='user', content=[TextContent(text=formatted_text)]\n+                    )\n+                else:\n+                    return []\n+            elif obs.recall_type == RecallType.KNOWLEDGE:\n+                # Use prompt manager to build the microagent info\n+                # First, filter out agents that appear in earlier MicroagentObservations\n+                filtered_agents = self._filter_agents_in_microagent_obs(\n+                    obs, current_index, events or []\n+                )\n+\n+                # Create and return a message if there is microagent knowledge to include\n+                if filtered_agents:\n+                    # Exclude disabled microagents\n+                    filtered_agents = [\n+                        agent\n+                        for agent in filtered_agents\n+                        if agent.name not in self.agent_config.disabled_microagents\n+                    ]\n+\n+                    # Only proceed if we still have agents after filtering out disabled ones\n+                    if filtered_agents:\n+                        formatted_text = self.prompt_manager.build_microagent_info(\n+                            triggered_agents=filtered_agents,\n+                        )\n+\n+                        return [\n+                            Message(\n+                                role='user', content=[TextContent(text=formatted_text)]\n+                            )\n+                        ]\n+\n+                # Return empty list if no microagents to include or all were disabled\n+                return []\n+        elif (\n+            isinstance(obs, MicroagentObservation)\n+            and not self.agent_config.enable_prompt_extensions\n+        ):\n+            # If prompt extensions are disabled, we don't add any additional info\n+            # TODO: test this\n+            return []\n         else:\n             # If an observation message is not returned, it will cause an error\n             # when the LLM tries to return the next message\n@@ -404,3 +502,53 @@ def apply_prompt_caching(self, messages: list[Message]) -> None:\n                     -1\n                 ].cache_prompt = True  # Last item inside the message content\n                 break\n+\n+    def _filter_agents_in_microagent_obs(\n+        self, obs: MicroagentObservation, current_index: int, events: list[Event]\n+    ) -> list[MicroagentKnowledge]:\n+        \"\"\"Filter out agents that appear in earlier MicroagentObservations.\n+\n+        Args:\n+            obs: The current MicroagentObservation to filter\n+            current_index: The index of the current event in the events list\n+            events: The list of all events\n+\n+        Returns:\n+            list[MicroagentKnowledge]: The filtered list of microagent knowledge\n+        \"\"\"\n+        if obs.recall_type != RecallType.KNOWLEDGE:\n+            return obs.microagent_knowledge\n+\n+        # For each agent in the current microagent observation, check if it appears in any earlier microagent observation\n+        filtered_agents = []\n+        for agent in obs.microagent_knowledge:\n+            # Keep this agent if it doesn't appear in any earlier observation\n+            # that is, if this is the first microagent observation with this microagent\n+            if not self._has_agent_in_earlier_events(agent.name, current_index, events):\n+                filtered_agents.append(agent)\n+\n+        return filtered_agents\n+\n+    def _has_agent_in_earlier_events(\n+        self, agent_name: str, current_index: int, events: list[Event]\n+    ) -> bool:\n+        \"\"\"Check if an agent appears in any earlier MicroagentObservation in the event list.\n+\n+        Args:\n+            agent_name: The name of the agent to look for\n+            current_index: The index of the current event in the events list\n+            events: The list of all events\n+\n+        Returns:\n+            bool: True if the agent appears in an earlier MicroagentObservation, False otherwise\n+        \"\"\"\n+        for event in events[:current_index]:\n+            if (\n+                isinstance(event, MicroagentObservation)\n+                and event.recall_type == RecallType.KNOWLEDGE\n+            ):\n+                if any(\n+                    agent.name == agent_name for agent in event.microagent_knowledge\n+                ):\n+                    return True\n+        return False\ndiff --git a/openhands/memory/memory.py b/openhands/memory/memory.py\nnew file mode 100644\nindex 000000000000..2dba5f10eac5\n--- /dev/null\n+++ b/openhands/memory/memory.py\n@@ -0,0 +1,270 @@\n+import asyncio\n+import os\n+import uuid\n+from typing import Callable\n+\n+import openhands\n+from openhands.core.logger import openhands_logger as logger\n+from openhands.events.action.agent import RecallAction\n+from openhands.events.event import Event, EventSource, RecallType\n+from openhands.events.observation.agent import (\n+    MicroagentKnowledge,\n+    MicroagentObservation,\n+)\n+from openhands.events.observation.empty import NullObservation\n+from openhands.events.stream import EventStream, EventStreamSubscriber\n+from openhands.microagent import (\n+    BaseMicroAgent,\n+    KnowledgeMicroAgent,\n+    RepoMicroAgent,\n+    load_microagents_from_dir,\n+)\n+from openhands.runtime.base import Runtime\n+from openhands.utils.prompt import RepositoryInfo, RuntimeInfo\n+\n+GLOBAL_MICROAGENTS_DIR = os.path.join(\n+    os.path.dirname(os.path.dirname(openhands.__file__)),\n+    'microagents',\n+)\n+\n+\n+class Memory:\n+    \"\"\"\n+    Memory is a component that listens to the EventStream for information retrieval actions\n+    (a RecallAction) and publishes observations with the content (such as MicroagentObservation).\n+    \"\"\"\n+\n+    sid: str\n+    event_stream: EventStream\n+    status_callback: Callable | None\n+    loop: asyncio.AbstractEventLoop | None\n+\n+    def __init__(\n+        self,\n+        event_stream: EventStream,\n+        sid: str,\n+        status_callback: Callable | None = None,\n+    ):\n+        self.event_stream = event_stream\n+        self.sid = sid if sid else str(uuid.uuid4())\n+        self.status_callback = status_callback\n+        self.loop = None\n+\n+        self.event_stream.subscribe(\n+            EventStreamSubscriber.MEMORY,\n+            self.on_event,\n+            self.sid,\n+        )\n+\n+        # Additional placeholders to store user workspace microagents\n+        self.repo_microagents: dict[str, RepoMicroAgent] = {}\n+        self.knowledge_microagents: dict[str, KnowledgeMicroAgent] = {}\n+\n+        # Store repository / runtime info to send them to the templating later\n+        self.repository_info: RepositoryInfo | None = None\n+        self.runtime_info: RuntimeInfo | None = None\n+\n+        # Load global microagents (Knowledge + Repo)\n+        # from typically OpenHands/microagents (i.e., the PUBLIC microagents)\n+        self._load_global_microagents()\n+\n+    def on_event(self, event: Event):\n+        \"\"\"Handle an event from the event stream.\"\"\"\n+        asyncio.get_event_loop().run_until_complete(self._on_event(event))\n+\n+    async def _on_event(self, event: Event):\n+        \"\"\"Handle an event from the event stream asynchronously.\"\"\"\n+        try:\n+            observation: MicroagentObservation | NullObservation | None = None\n+\n+            if isinstance(event, RecallAction):\n+                # if this is a workspace context recall (on first user message)\n+                # create and add a MicroagentObservation\n+                # with info about repo and runtime.\n+                if (\n+                    event.source == EventSource.USER\n+                    and event.recall_type == RecallType.WORKSPACE_CONTEXT\n+                ):\n+                    observation = self._on_first_microagent_action(event)\n+\n+                # continue with the next handler, to include knowledge microagents if suitable for this query\n+                assert observation is None or isinstance(\n+                    observation, MicroagentObservation\n+                ), f'Expected a MicroagentObservation, but got {type(observation)}'\n+                observation = self._on_microagent_action(\n+                    event, prev_observation=observation\n+                )\n+\n+                if observation is None:\n+                    observation = NullObservation(content='')\n+\n+                # important: this will release the execution flow from waiting for the retrieval to complete\n+                observation._cause = event.id  # type: ignore[union-attr]\n+\n+                self.event_stream.add_event(observation, EventSource.ENVIRONMENT)\n+        except Exception as e:\n+            error_str = f'Error: {str(e.__class__.__name__)}'\n+            logger.error(error_str)\n+            self.send_error_message('STATUS$ERROR_MEMORY', error_str)\n+            return\n+\n+    def _on_first_microagent_action(\n+        self, event: RecallAction\n+    ) -> MicroagentObservation | None:\n+        \"\"\"Add repository and runtime information to the stream as a MicroagentObservation.\"\"\"\n+\n+        # Create ENVIRONMENT info:\n+        # - repository_info\n+        # - runtime_info\n+        # - repository_instructions\n+\n+        # Collect raw repository instructions\n+        repo_instructions = ''\n+        assert (\n+            len(self.repo_microagents) <= 1\n+        ), f'Expecting at most one repo microagent, but found {len(self.repo_microagents)}: {self.repo_microagents.keys()}'\n+\n+        # Retrieve the context of repo instructions\n+        for microagent in self.repo_microagents.values():\n+            if repo_instructions:\n+                repo_instructions += '\\n\\n'\n+            repo_instructions += microagent.content\n+\n+        # Create observation if we have anything\n+        if self.repository_info or self.runtime_info or repo_instructions:\n+            obs = MicroagentObservation(\n+                recall_type=RecallType.WORKSPACE_CONTEXT,\n+                repo_name=self.repository_info.repo_name\n+                if self.repository_info and self.repository_info.repo_name is not None\n+                else '',\n+                repo_directory=self.repository_info.repo_directory\n+                if self.repository_info\n+                and self.repository_info.repo_directory is not None\n+                else '',\n+                repo_instructions=repo_instructions if repo_instructions else '',\n+                runtime_hosts=self.runtime_info.available_hosts\n+                if self.runtime_info and self.runtime_info.available_hosts is not None\n+                else {},\n+                additional_agent_instructions=self.runtime_info.additional_agent_instructions\n+                if self.runtime_info\n+                and self.runtime_info.additional_agent_instructions is not None\n+                else '',\n+                microagent_knowledge=[],\n+                content='Retrieved environment info',\n+            )\n+            return obs\n+        return None\n+\n+    def _on_microagent_action(\n+        self,\n+        event: RecallAction,\n+        prev_observation: MicroagentObservation | None = None,\n+    ) -> MicroagentObservation | None:\n+        \"\"\"When a microagent action triggers microagents, create a MicroagentObservation with structured data.\"\"\"\n+        # If there's no query, do nothing\n+        query = event.query.strip()\n+        if not query:\n+            return prev_observation\n+\n+        assert prev_observation is None or isinstance(\n+            prev_observation, MicroagentObservation\n+        ), f'Expected a MicroagentObservation, but got {type(prev_observation)}'\n+\n+        # Process text to find suitable microagents and create a MicroagentObservation.\n+        recalled_content: list[MicroagentKnowledge] = []\n+        for name, microagent in self.knowledge_microagents.items():\n+            trigger = microagent.match_trigger(query)\n+            if trigger:\n+                logger.info(\"Microagent '%s' triggered by keyword '%s'\", name, trigger)\n+                recalled_content.append(\n+                    MicroagentKnowledge(\n+                        name=microagent.name,\n+                        trigger=trigger,\n+                        content=microagent.content,\n+                    )\n+                )\n+\n+        if recalled_content:\n+            if prev_observation is not None:\n+                # it may be on the first user message that already found some repo info etc\n+                prev_observation.microagent_knowledge.extend(recalled_content)\n+            else:\n+                # if it's not the first user message, we may not have found any information this step\n+                obs = MicroagentObservation(\n+                    recall_type=RecallType.KNOWLEDGE,\n+                    microagent_knowledge=recalled_content,\n+                    content='Retrieved knowledge from microagents',\n+                )\n+\n+                return obs\n+\n+        return prev_observation\n+\n+    def load_user_workspace_microagents(\n+        self, user_microagents: list[BaseMicroAgent]\n+    ) -> None:\n+        \"\"\"\n+        This method loads microagents from a user's cloned repo or workspace directory.\n+\n+        This is typically called from agent_session or setup once the workspace is cloned.\n+        \"\"\"\n+        logger.info(\n+            'Loading user workspace microagents: %s', [m.name for m in user_microagents]\n+        )\n+        for user_microagent in user_microagents:\n+            if isinstance(user_microagent, KnowledgeMicroAgent):\n+                self.knowledge_microagents[user_microagent.name] = user_microagent\n+            elif isinstance(user_microagent, RepoMicroAgent):\n+                self.repo_microagents[user_microagent.name] = user_microagent\n+\n+    def _load_global_microagents(self) -> None:\n+        \"\"\"\n+        Loads microagents from the global microagents_dir\n+        \"\"\"\n+        repo_agents, knowledge_agents, _ = load_microagents_from_dir(\n+            GLOBAL_MICROAGENTS_DIR\n+        )\n+        for name, agent in knowledge_agents.items():\n+            if isinstance(agent, KnowledgeMicroAgent):\n+                self.knowledge_microagents[name] = agent\n+        for name, agent in repo_agents.items():\n+            if isinstance(agent, RepoMicroAgent):\n+                self.repo_microagents[name] = agent\n+\n+    def set_repository_info(self, repo_name: str, repo_directory: str) -> None:\n+        \"\"\"Store repository info so we can reference it in an observation.\"\"\"\n+        if repo_name or repo_directory:\n+            self.repository_info = RepositoryInfo(repo_name, repo_directory)\n+        else:\n+            self.repository_info = None\n+\n+    def set_runtime_info(self, runtime: Runtime) -> None:\n+        \"\"\"Store runtime info (web hosts, ports, etc.).\"\"\"\n+        # e.g. { '127.0.0.1': 8080 }\n+        if runtime.web_hosts or runtime.additional_agent_instructions:\n+            self.runtime_info = RuntimeInfo(\n+                available_hosts=runtime.web_hosts,\n+                additional_agent_instructions=runtime.additional_agent_instructions,\n+            )\n+        else:\n+            self.runtime_info = None\n+\n+    def send_error_message(self, message_id: str, message: str):\n+        \"\"\"Sends an error message if the callback function was provided.\"\"\"\n+        if self.status_callback:\n+            try:\n+                if self.loop is None:\n+                    self.loop = asyncio.get_running_loop()\n+                asyncio.run_coroutine_threadsafe(\n+                    self._send_status_message('error', message_id, message), self.loop\n+                )\n+            except RuntimeError as e:\n+                logger.error(\n+                    f'Error sending status message: {e.__class__.__name__}',\n+                    stack_info=False,\n+                )\n+\n+    async def _send_status_message(self, msg_type: str, id: str, message: str):\n+        \"\"\"Sends a status message to the client.\"\"\"\n+        if self.status_callback:\n+            self.status_callback(msg_type, id, message)\ndiff --git a/openhands/utils/prompt.py b/openhands/utils/prompt.py\nindex 171d7f991c93..643af5aa2e57 100644\n--- a/openhands/utils/prompt.py\n+++ b/openhands/utils/prompt.py\n@@ -32,75 +25,23 @@ class RepositoryInfo:\n \n class PromptManager:\n     \"\"\"\n-    Manages prompt templates and micro-agents for AI interactions.\n+    Manages prompt templates and includes information from the user's workspace micro-agents and global micro-agents.\n \n-    This class handles loading and rendering of system and user prompt templates,\n-    as well as loading micro-agent specifications. It provides methods to access\n-    rendered system and initial user messages for AI interactions.\n+    This class is dedicated to loading and rendering prompts (system prompt, user prompt).\n \n     Attributes:\n-        prompt_dir (str): Directory containing prompt templates.\n-        microagent_dir (str): Directory containing microagent specifications.\n-        disabled_microagents (list[str] | None): List of microagents to disable. If None, all microagents are enabled.\n+        prompt_dir: Directory containing prompt templates.\n     \"\"\"\n \n     def __init__(\n         self,\n         prompt_dir: str,\n-        microagent_dir: str | None = None,\n-        disabled_microagents: list[str] | None = None,\n     ):\n-        self.disabled_microagents: list[str] = disabled_microagents or []\n         self.prompt_dir: str = prompt_dir\n-        self.repository_info: RepositoryInfo | None = None\n         self.system_template: Template = self._load_template('system_prompt')\n         self.user_template: Template = self._load_template('user_prompt')\n         self.additional_info_template: Template = self._load_template('additional_info')\n         self.microagent_info_template: Template = self._load_template('microagent_info')\n-        self.runtime_info = RuntimeInfo(\n-            available_hosts={}, additional_agent_instructions=''\n-        )\n-\n-        self.knowledge_microagents: dict[str, KnowledgeMicroAgent] = {}\n-        self.repo_microagents: dict[str, RepoMicroAgent] = {}\n-\n-        if microagent_dir:\n-            # This loads micro-agents from the microagent_dir\n-            # which is typically the OpenHands/microagents (i.e., the PUBLIC microagents)\n-\n-            # Only load KnowledgeMicroAgents\n-            repo_microagents, knowledge_microagents, _ = load_microagents_from_dir(\n-                microagent_dir\n-            )\n-            assert all(\n-                isinstance(microagent, KnowledgeMicroAgent)\n-                for microagent in knowledge_microagents.values()\n-            )\n-            for name, microagent in knowledge_microagents.items():\n-                if name not in self.disabled_microagents:\n-                    self.knowledge_microagents[name] = microagent\n-            assert all(\n-                isinstance(microagent, RepoMicroAgent)\n-                for microagent in repo_microagents.values()\n-            )\n-            for name, microagent in repo_microagents.items():\n-                if name not in self.disabled_microagents:\n-                    self.repo_microagents[name] = microagent\n-\n-    def load_microagents(self, microagents: list[BaseMicroAgent]) -> None:\n-        \"\"\"Load microagents from a list of BaseMicroAgents.\n-\n-        This is typically used when loading microagents from inside a repo.\n-        \"\"\"\n-        openhands_logger.info('Loading microagents: %s', [m.name for m in microagents])\n-        # Only keep KnowledgeMicroAgents and RepoMicroAgents\n-        for microagent in microagents:\n-            if microagent.name in self.disabled_microagents:\n-                continue\n-            if isinstance(microagent, KnowledgeMicroAgent):\n-                self.knowledge_microagents[microagent.name] = microagent\n-            elif isinstance(microagent, RepoMicroAgent):\n-                self.repo_microagents[microagent.name] = microagent\n \n     def _load_template(self, template_name: str) -> Template:\n         if self.prompt_dir is None:\n\ndiff --git a/tests/unit/test_agent_controller.py b/tests/unit/test_agent_controller.py\nindex 1d8c7bb8d503..58b8ae7c95fd 100644\n--- a/tests/unit/test_agent_controller.py\n+++ b/tests/unit/test_agent_controller.py\n@@ -851,3 +978,56 @@ def agent_step_fn(state):\n     assert last_action.llm_metrics.accumulated_cost == 0.07\n \n     await controller.close()\n+\n+\n+@pytest.mark.asyncio\n+async def test_first_user_message_with_identical_content():\n+    \"\"\"\n+    Test that _first_user_message correctly identifies the first user message\n+    even when multiple messages have identical content but different IDs.\n+\n+    The issue we're checking is that the comparison (action == self._first_user_message())\n+    should correctly differentiate between messages with the same content but different IDs.\n+    \"\"\"\n+    # Create a real event stream for this test\n+    event_stream = EventStream(sid='test', file_store=InMemoryFileStore({}))\n+\n+    # Create an agent controller\n+    mock_agent = MagicMock(spec=Agent)\n+    mock_agent.llm = MagicMock(spec=LLM)\n+    mock_agent.llm.metrics = Metrics()\n+    mock_agent.llm.config = AppConfig().get_llm_config()\n+\n+    controller = AgentController(\n+        agent=mock_agent,\n+        event_stream=event_stream,\n+        max_iterations=10,\n+        sid='test',\n+        confirmation_mode=False,\n+        headless_mode=True,\n+    )\n+\n+    # Create and add the first user message\n+    first_message = MessageAction(content='Hello, this is a test message')\n+    first_message._source = EventSource.USER\n+    event_stream.add_event(first_message, EventSource.USER)\n+\n+    # Create and add a second user message with identical content\n+    second_message = MessageAction(content='Hello, this is a test message')\n+    second_message._source = EventSource.USER\n+    event_stream.add_event(second_message, EventSource.USER)\n+\n+    # Verify that _first_user_message returns the first message\n+    first_user_message = controller._first_user_message()\n+    assert first_user_message is not None\n+    assert first_user_message.id == first_message.id  # Check IDs match\n+    assert first_user_message.id != second_message.id  # Different IDs\n+    assert first_user_message == first_message == second_message  # dataclass equality\n+\n+    # Test the comparison used in the actual code\n+    assert first_message == first_user_message  # This should be True\n+    assert (\n+        second_message.id != first_user_message.id\n+    )  # This should be False, but may be True if there's a bug\n+\n+    await controller.close()\ndiff --git a/tests/unit/test_conversation_memory.py b/tests/unit/test_conversation_memory.py\nindex 7721354bdb21..5397c63559e4 100644\n--- a/tests/unit/test_conversation_memory.py\n+++ b/tests/unit/test_conversation_memory.py\n@@ -446,3 +524,529 @@ def test_apply_prompt_caching(conversation_memory):\n     assert messages[1].content[0].cache_prompt is False\n     assert messages[2].content[0].cache_prompt is False\n     assert messages[3].content[0].cache_prompt is True\n+\n+\n+def test_process_events_with_environment_microagent_observation(conversation_memory):\n+    \"\"\"Test processing a MicroagentObservation with ENVIRONMENT info type.\"\"\"\n+    obs = MicroagentObservation(\n+        recall_type=RecallType.WORKSPACE_CONTEXT,\n+        repo_name='test-repo',\n+        repo_directory='/path/to/repo',\n+        repo_instructions='# Test Repository\\nThis is a test repository.',\n+        runtime_hosts={'localhost': 8080},\n+        content='Retrieved environment info',\n+    )\n+\n+    initial_messages = [\n+        Message(role='system', content=[TextContent(text='System message')])\n+    ]\n+\n+    messages = conversation_memory.process_events(\n+        condensed_history=[obs],\n+        initial_messages=initial_messages,\n+        max_message_chars=None,\n+        vision_is_active=False,\n+    )\n+\n+    assert len(messages) == 2\n+    result = messages[1]\n+    assert result.role == 'user'\n+    assert len(result.content) == 1\n+    assert isinstance(result.content[0], TextContent)\n+    assert result.content[0].text == 'Formatted repository and runtime info'\n+\n+    # Verify the prompt_manager was called with the correct parameters\n+    conversation_memory.prompt_manager.build_additional_info.assert_called_once()\n+    call_args = conversation_memory.prompt_manager.build_additional_info.call_args[1]\n+    assert isinstance(call_args['repository_info'], RepositoryInfo)\n+    assert call_args['repository_info'].repo_name == 'test-repo'\n+    assert call_args['repository_info'].repo_directory == '/path/to/repo'\n+    assert isinstance(call_args['runtime_info'], RuntimeInfo)\n+    assert call_args['runtime_info'].available_hosts == {'localhost': 8080}\n+    assert (\n+        call_args['repo_instructions']\n+        == '# Test Repository\\nThis is a test repository.'\n+    )\n+\n+\n+def test_process_events_with_knowledge_microagent_microagent_observation(\n+    conversation_memory,\n+):\n+    \"\"\"Test processing a MicroagentObservation with KNOWLEDGE type.\"\"\"\n+    microagent_knowledge = [\n+        MicroagentKnowledge(\n+            name='test_agent',\n+            trigger='test',\n+            content='This is test agent content',\n+        ),\n+        MicroagentKnowledge(\n+            name='another_agent',\n+            trigger='another',\n+            content='This is another agent content',\n+        ),\n+        MicroagentKnowledge(\n+            name='disabled_agent',\n+            trigger='disabled',\n+            content='This is disabled agent content',\n+        ),\n+    ]\n+\n+    obs = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=microagent_knowledge,\n+        content='Retrieved knowledge from microagents',\n+    )\n+\n+    initial_messages = [\n+        Message(role='system', content=[TextContent(text='System message')])\n+    ]\n+\n+    messages = conversation_memory.process_events(\n+        condensed_history=[obs],\n+        initial_messages=initial_messages,\n+        max_message_chars=None,\n+        vision_is_active=False,\n+    )\n+\n+    assert len(messages) == 2\n+    result = messages[1]\n+    assert result.role == 'user'\n+    assert len(result.content) == 1\n+    assert isinstance(result.content[0], TextContent)\n+    # Verify that disabled_agent is filtered out and enabled agents are included\n+    assert 'This is test agent content' in result.content[0].text\n+    assert 'This is another agent content' in result.content[0].text\n+    assert 'This is disabled agent content' not in result.content[0].text\n+\n+    # Verify the prompt_manager was called with the correct parameters\n+    conversation_memory.prompt_manager.build_microagent_info.assert_called_once()\n+    call_args = conversation_memory.prompt_manager.build_microagent_info.call_args[1]\n+\n+    # Check that disabled_agent was filtered out\n+    triggered_agents = call_args['triggered_agents']\n+    assert len(triggered_agents) == 2\n+    agent_names = [agent.name for agent in triggered_agents]\n+    assert 'test_agent' in agent_names\n+    assert 'another_agent' in agent_names\n+    assert 'disabled_agent' not in agent_names\n+\n+\n+def test_process_events_with_microagent_observation_extensions_disabled(\n+    agent_config, conversation_memory\n+):\n+    \"\"\"Test processing a MicroagentObservation when prompt extensions are disabled.\"\"\"\n+    # Modify the agent config to disable prompt extensions\n+    agent_config.enable_prompt_extensions = False\n+\n+    obs = MicroagentObservation(\n+        recall_type=RecallType.WORKSPACE_CONTEXT,\n+        repo_name='test-repo',\n+        repo_directory='/path/to/repo',\n+        content='Retrieved environment info',\n+    )\n+\n+    initial_messages = [\n+        Message(role='system', content=[TextContent(text='System message')])\n+    ]\n+\n+    messages = conversation_memory.process_events(\n+        condensed_history=[obs],\n+        initial_messages=initial_messages,\n+        max_message_chars=None,\n+        vision_is_active=False,\n+    )\n+\n+    # When prompt extensions are disabled, the MicroagentObservation should be ignored\n+    assert len(messages) == 1  # Only the initial system message\n+    assert messages[0].role == 'system'\n+\n+    # Verify the prompt_manager was not called\n+    conversation_memory.prompt_manager.build_additional_info.assert_not_called()\n+    conversation_memory.prompt_manager.build_microagent_info.assert_not_called()\n+\n+\n+def test_process_events_with_empty_microagent_knowledge(conversation_memory):\n+    \"\"\"Test processing a MicroagentObservation with empty microagent knowledge.\"\"\"\n+    obs = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[],\n+        content='Retrieved knowledge from microagents',\n+    )\n+\n+    initial_messages = [\n+        Message(role='system', content=[TextContent(text='System message')])\n+    ]\n+\n+    messages = conversation_memory.process_events(\n+        condensed_history=[obs],\n+        initial_messages=initial_messages,\n+        max_message_chars=None,\n+        vision_is_active=False,\n+    )\n+\n+    # The implementation returns an empty string and it doesn't creates a message\n+    assert len(messages) == 1\n+    assert messages[0].role == 'system'\n+\n+    # When there are no triggered agents, build_microagent_info is not called\n+    conversation_memory.prompt_manager.build_microagent_info.assert_not_called()\n+\n+\n+def test_conversation_memory_processes_microagent_observation(prompt_dir):\n+    \"\"\"Test that ConversationMemory processes MicroagentObservations correctly.\"\"\"\n+    # Create a microagent_info.j2 template file\n+    template_path = os.path.join(prompt_dir, 'microagent_info.j2')\n+    if not os.path.exists(template_path):\n+        with open(template_path, 'w') as f:\n+            f.write(\"\"\"{% for agent_info in triggered_agents %}\n+<EXTRA_INFO>\n+The following information has been included based on a keyword match for \"{{ agent_info.trigger_word }}\".\n+It may or may not be relevant to the user's request.\n+\n+    # Verify the template was correctly rendered\n+{{ agent_info.content }}\n+</EXTRA_INFO>\n+{% endfor %}\n+\"\"\")\n+\n+    # Create a mock agent config\n+    agent_config = MagicMock(spec=AgentConfig)\n+    agent_config.enable_prompt_extensions = True\n+    agent_config.disabled_microagents = []\n+\n+    # Create a PromptManager\n+    prompt_manager = PromptManager(prompt_dir=prompt_dir)\n+\n+    # Initialize ConversationMemory\n+    conversation_memory = ConversationMemory(\n+        config=agent_config, prompt_manager=prompt_manager\n+    )\n+\n+    # Create a MicroagentObservation with microagent knowledge\n+    microagent_observation = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='test_agent',\n+                trigger='test_trigger',\n+                content='This is triggered content for testing.',\n+            )\n+        ],\n+        content='Retrieved knowledge from microagents',\n+    )\n+\n+    # Process the observation\n+    messages = conversation_memory._process_observation(\n+        obs=microagent_observation, tool_call_id_to_message={}, max_message_chars=None\n+    )\n+\n+    # Verify the message was created correctly\n+    assert len(messages) == 1\n+    message = messages[0]\n+    assert message.role == 'user'\n+    assert len(message.content) == 1\n+    assert isinstance(message.content[0], TextContent)\n+\n+    expected_text = \"\"\"<EXTRA_INFO>\n+The following information has been included based on a keyword match for \"test_trigger\".\n+It may or may not be relevant to the user's request.\n+\n+This is triggered content for testing.\n+</EXTRA_INFO>\"\"\"\n+\n+    assert message.content[0].text.strip() == expected_text.strip()\n+\n+    # Clean up\n+    os.remove(os.path.join(prompt_dir, 'microagent_info.j2'))\n+\n+\n+def test_conversation_memory_processes_environment_microagent_observation(prompt_dir):\n+    \"\"\"Test that ConversationMemory processes environment info MicroagentObservations correctly.\"\"\"\n+    # Create an additional_info.j2 template file\n+    template_path = os.path.join(prompt_dir, 'additional_info.j2')\n+    if not os.path.exists(template_path):\n+        with open(template_path, 'w') as f:\n+            f.write(\"\"\"\n+{% if repository_info %}\n+<REPOSITORY_INFO>\n+At the user's request, repository {{ repository_info.repo_name }} has been cloned to directory {{ repository_info.repo_directory }}.\n+</REPOSITORY_INFO>\n+{% endif %}\n+\n+{% if repository_instructions %}\n+<REPOSITORY_INSTRUCTIONS>\n+{{ repository_instructions }}\n+</REPOSITORY_INSTRUCTIONS>\n+{% endif %}\n+\n+{% if runtime_info and runtime_info.available_hosts %}\n+<RUNTIME_INFORMATION>\n+The user has access to the following hosts for accessing a web application,\n+each of which has a corresponding port:\n+{% for host, port in runtime_info.available_hosts.items() %}\n+* {{ host }} (port {{ port }})\n+{% endfor %}\n+</RUNTIME_INFORMATION>\n+{% endif %}\n+\"\"\")\n+\n+    # Create a mock agent config\n+    agent_config = MagicMock(spec=AgentConfig)\n+    agent_config.enable_prompt_extensions = True\n+\n+    # Create a PromptManager\n+    prompt_manager = PromptManager(prompt_dir=prompt_dir)\n+\n+    # Initialize ConversationMemory\n+    conversation_memory = ConversationMemory(\n+        config=agent_config, prompt_manager=prompt_manager\n+    )\n+\n+    # Create a MicroagentObservation with environment info\n+    microagent_observation = MicroagentObservation(\n+        recall_type=RecallType.WORKSPACE_CONTEXT,\n+        repo_name='owner/repo',\n+        repo_directory='/workspace/repo',\n+        repo_instructions='This repository contains important code.',\n+        runtime_hosts={'example.com': 8080},\n+        content='Retrieved environment info',\n+    )\n+\n+    # Process the observation\n+    messages = conversation_memory._process_observation(\n+        obs=microagent_observation, tool_call_id_to_message={}, max_message_chars=None\n+    )\n+\n+    # Verify the message was created correctly\n+    assert len(messages) == 1\n+    message = messages[0]\n+    assert message.role == 'user'\n+    assert len(message.content) == 1\n+    assert isinstance(message.content[0], TextContent)\n+\n+    # Check that the message contains the repository info\n+    assert '<REPOSITORY_INFO>' in message.content[0].text\n+    assert 'owner/repo' in message.content[0].text\n+    assert '/workspace/repo' in message.content[0].text\n+\n+    # Check that the message contains the repository instructions\n+    assert '<REPOSITORY_INSTRUCTIONS>' in message.content[0].text\n+    assert 'This repository contains important code.' in message.content[0].text\n+\n+    # Check that the message contains the runtime info\n+    assert '<RUNTIME_INFORMATION>' in message.content[0].text\n+    assert 'example.com (port 8080)' in message.content[0].text\n+\n+\n+def test_process_events_with_microagent_observation_deduplication(conversation_memory):\n+    \"\"\"Test that MicroagentObservations are properly deduplicated based on agent name.\n+\n+    The deduplication logic should keep the FIRST occurrence of each microagent\n+    and filter out later occurrences to avoid redundant information.\n+    \"\"\"\n+    # Create a sequence of MicroagentObservations with overlapping agents\n+    obs1 = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='python_agent',\n+                trigger='python',\n+                content='Python best practices v1',\n+            ),\n+            MicroagentKnowledge(\n+                name='git_agent',\n+                trigger='git',\n+                content='Git best practices v1',\n+            ),\n+            MicroagentKnowledge(\n+                name='image_agent',\n+                trigger='image',\n+                content='Image best practices v1',\n+            ),\n+        ],\n+        content='First retrieval',\n+    )\n+\n+    obs2 = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='python_agent',\n+                trigger='python',\n+                content='Python best practices v2',\n+            ),\n+        ],\n+        content='Second retrieval',\n+    )\n+\n+    obs3 = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='git_agent',\n+                trigger='git',\n+                content='Git best practices v3',\n+            ),\n+        ],\n+        content='Third retrieval',\n+    )\n+\n+    initial_messages = [\n+        Message(role='system', content=[TextContent(text='System message')])\n+    ]\n+\n+    messages = conversation_memory.process_events(\n+        condensed_history=[obs1, obs2, obs3],\n+        initial_messages=initial_messages,\n+        max_message_chars=None,\n+        vision_is_active=False,\n+    )\n+\n+    # Verify that only the first occurrence of content for each agent is included\n+    assert (\n+        len(messages) == 2\n+    )  # system + 1 microagent, because the second and third microagents are duplicates\n+    microagent_messages = messages[1:]  # Skip system message\n+\n+    # First microagent should include all agents since they appear here first\n+    assert 'Image best practices v1' in microagent_messages[0].content[0].text\n+    assert 'Git best practices v1' in microagent_messages[0].content[0].text\n+    assert 'Python best practices v1' in microagent_messages[0].content[0].text\n+\n+\n+def test_process_events_with_microagent_observation_deduplication_disabled_agents(\n+    conversation_memory,\n+):\n+    \"\"\"Test that disabled agents are filtered out and deduplication keeps the first occurrence.\"\"\"\n+    # Create a sequence of MicroagentObservations with disabled agents\n+    obs1 = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='disabled_agent',\n+                trigger='disabled',\n+                content='Disabled agent content',\n+            ),\n+            MicroagentKnowledge(\n+                name='enabled_agent',\n+                trigger='enabled',\n+                content='Enabled agent content v1',\n+            ),\n+        ],\n+        content='First retrieval',\n+    )\n+\n+    obs2 = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='enabled_agent',\n+                trigger='enabled',\n+                content='Enabled agent content v2',\n+            ),\n+        ],\n+        content='Second retrieval',\n+    )\n+\n+    initial_messages = [\n+        Message(role='system', content=[TextContent(text='System message')])\n+    ]\n+\n+    messages = conversation_memory.process_events(\n+        condensed_history=[obs1, obs2],\n+        initial_messages=initial_messages,\n+        max_message_chars=None,\n+        vision_is_active=False,\n+    )\n+\n+    # Verify that disabled agents are filtered out and only the first occurrence of enabled agents is included\n+    assert (\n+        len(messages) == 2\n+    )  # system + 1 microagent, the second is the same \"enabled_agent\"\n+    microagent_messages = messages[1:]  # Skip system message\n+\n+    # First microagent should include enabled_agent but not disabled_agent\n+    assert 'Disabled agent content' not in microagent_messages[0].content[0].text\n+    assert 'Enabled agent content v1' in microagent_messages[0].content[0].text\n+\n+\n+def test_process_events_with_microagent_observation_deduplication_empty(\n+    conversation_memory,\n+):\n+    \"\"\"Test that empty MicroagentObservations are handled correctly.\"\"\"\n+    obs = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[],\n+        content='Empty retrieval',\n+    )\n+\n+    initial_messages = [\n+        Message(role='system', content=[TextContent(text='System message')])\n+    ]\n+\n+    messages = conversation_memory.process_events(\n+        condensed_history=[obs],\n+        initial_messages=initial_messages,\n+        max_message_chars=None,\n+        vision_is_active=False,\n+    )\n+\n+    # Verify that empty MicroagentObservations are handled gracefully\n+    assert (\n+        len(messages) == 1\n+    )  # system message, because an empty microagent is not added to Messages\n+\n+\n+def test_has_agent_in_earlier_events(conversation_memory):\n+    \"\"\"Test the _has_agent_in_earlier_events helper method.\"\"\"\n+    # Create test MicroagentObservations\n+    obs1 = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='agent1',\n+                trigger='trigger1',\n+                content='Content 1',\n+            ),\n+        ],\n+        content='First retrieval',\n+    )\n+\n+    obs2 = MicroagentObservation(\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='agent2',\n+                trigger='trigger2',\n+                content='Content 2',\n+            ),\n+        ],\n+        content='Second retrieval',\n+    )\n+\n+    obs3 = MicroagentObservation(\n+        recall_type=RecallType.WORKSPACE_CONTEXT,\n+        content='Environment info',\n+    )\n+\n+    # Create a list with mixed event types\n+    events = [obs1, MessageAction(content='User message'), obs2, obs3]\n+\n+    # Test looking for existing agents\n+    assert conversation_memory._has_agent_in_earlier_events('agent1', 2, events) is True\n+    assert conversation_memory._has_agent_in_earlier_events('agent1', 3, events) is True\n+    assert conversation_memory._has_agent_in_earlier_events('agent1', 4, events) is True\n+\n+    # Test looking for an agent in a later position (should not find it)\n+    assert (\n+        conversation_memory._has_agent_in_earlier_events('agent2', 0, events) is False\n+    )\n+    assert (\n+        conversation_memory._has_agent_in_earlier_events('agent2', 1, events) is False\n+    )\n+\n+    # Test looking for an agent in a different microagent type (should not find it)\n+    assert (\n+        conversation_memory._has_agent_in_earlier_events('non_existent', 3, events)\n+        is False\n+    )\ndiff --git a/tests/unit/test_memory.py b/tests/unit/test_memory.py\nnew file mode 100644\nindex 000000000000..c0c354906ab7\n--- /dev/null\n+++ b/tests/unit/test_memory.py\n@@ -0,0 +1,260 @@\n+import asyncio\n+import os\n+import shutil\n+import time\n+from unittest.mock import MagicMock, patch\n+\n+import pytest\n+\n+from openhands.controller.agent import Agent\n+from openhands.core.config import AppConfig\n+from openhands.core.main import run_controller\n+from openhands.core.schema.agent import AgentState\n+from openhands.events.action.agent import RecallAction\n+from openhands.events.action.message import MessageAction\n+from openhands.events.event import EventSource\n+from openhands.events.observation.agent import (\n+    MicroagentObservation,\n+    RecallType,\n+)\n+from openhands.events.stream import EventStream\n+from openhands.llm import LLM\n+from openhands.llm.metrics import Metrics\n+from openhands.memory.memory import Memory\n+from openhands.runtime.base import Runtime\n+from openhands.storage.memory import InMemoryFileStore\n+\n+\n+@pytest.fixture\n+def file_store():\n+    \"\"\"Create a temporary file store for testing.\"\"\"\n+    return InMemoryFileStore()\n+\n+\n+@pytest.fixture\n+def event_stream(file_store):\n+    \"\"\"Create a test event stream.\"\"\"\n+    return EventStream(sid='test_sid', file_store=file_store)\n+\n+\n+@pytest.fixture\n+def memory(event_stream):\n+    \"\"\"Create a test memory instance.\"\"\"\n+    loop = asyncio.new_event_loop()\n+    asyncio.set_event_loop(loop)\n+    memory = Memory(event_stream, 'test_sid')\n+    yield memory\n+    loop.close()\n+\n+\n+@pytest.fixture\n+def prompt_dir(tmp_path):\n+    # Copy contents from \"openhands/agenthub/codeact_agent\" to the temp directory\n+    shutil.copytree(\n+        'openhands/agenthub/codeact_agent/prompts', tmp_path, dirs_exist_ok=True\n+    )\n+\n+    # Return the temporary directory path\n+    return tmp_path\n+\n+\n+@pytest.mark.asyncio\n+async def test_memory_on_event_exception_handling(memory, event_stream):\n+    \"\"\"Test that exceptions in Memory.on_event are properly handled via status callback.\"\"\"\n+\n+    # Create a dummy agent for the controller\n+    agent = MagicMock(spec=Agent)\n+    agent.llm = MagicMock(spec=LLM)\n+    agent.llm.metrics = Metrics()\n+    agent.llm.config = AppConfig().get_llm_config()\n+\n+    # Create a mock runtime\n+    runtime = MagicMock(spec=Runtime)\n+    runtime.event_stream = event_stream\n+\n+    # Mock Memory method to raise an exception\n+    with patch.object(\n+        memory, '_on_first_microagent_action', side_effect=Exception('Test error')\n+    ):\n+        state = await run_controller(\n+            config=AppConfig(),\n+            initial_user_action=MessageAction(content='Test message'),\n+            runtime=runtime,\n+            sid='test',\n+            agent=agent,\n+            fake_user_response_fn=lambda _: 'repeat',\n+            memory=memory,\n+        )\n+\n+        # Verify that the controller's last error was set\n+        assert state.iteration == 0\n+        assert state.agent_state == AgentState.ERROR\n+        assert state.last_error == 'Error: Exception'\n+\n+\n+@pytest.mark.asyncio\n+async def test_memory_on_first_microagent_action_exception_handling(\n+    memory, event_stream\n+):\n+    \"\"\"Test that exceptions in Memory._on_first_microagent_action are properly handled via status callback.\"\"\"\n+\n+    # Create a dummy agent for the controller\n+    agent = MagicMock(spec=Agent)\n+    agent.llm = MagicMock(spec=LLM)\n+    agent.llm.metrics = Metrics()\n+    agent.llm.config = AppConfig().get_llm_config()\n+\n+    # Create a mock runtime\n+    runtime = MagicMock(spec=Runtime)\n+    runtime.event_stream = event_stream\n+\n+    # Mock Memory._on_first_microagent_action to raise an exception\n+    with patch.object(\n+        memory,\n+        '_on_first_microagent_action',\n+        side_effect=Exception('Test error from _on_first_microagent_action'),\n+    ):\n+        state = await run_controller(\n+            config=AppConfig(),\n+            initial_user_action=MessageAction(content='Test message'),\n+            runtime=runtime,\n+            sid='test',\n+            agent=agent,\n+            fake_user_response_fn=lambda _: 'repeat',\n+            memory=memory,\n+        )\n+\n+        # Verify that the controller's last error was set\n+        assert state.iteration == 0\n+        assert state.agent_state == AgentState.ERROR\n+        assert state.last_error == 'Error: Exception'\n+\n+\n+def test_memory_with_microagents():\n+    \"\"\"Test that Memory loads microagents from the global directory and processes microagent actions.\n+\n+    This test verifies that:\n+    1. Memory loads microagents from the global GLOBAL_MICROAGENTS_DIR\n+    2. When a microagent action with a trigger word is processed, a MicroagentObservation is created\n+    \"\"\"\n+    # Create a mock event stream\n+    event_stream = MagicMock(spec=EventStream)\n+\n+    # Initialize Memory to use the global microagents dir\n+    memory = Memory(\n+        event_stream=event_stream,\n+        sid='test-session',\n+    )\n+\n+    # Verify microagents were loaded - at least one microagent should be loaded\n+    # from the global directory that's in the repo\n+    assert len(memory.knowledge_microagents) > 0\n+\n+    # We know 'flarglebargle' exists in the global directory\n+    assert 'flarglebargle' in memory.knowledge_microagents\n+\n+    # Create a microagent action with the trigger word\n+    microagent_action = RecallAction(\n+        query='Hello, flarglebargle!', recall_type=RecallType.KNOWLEDGE\n+    )\n+\n+    # Mock the event_stream.add_event method\n+    added_events = []\n+\n+    def original_add_event(event, source):\n+        added_events.append((event, source))\n+\n+    event_stream.add_event = original_add_event\n+\n+    # Add the microagent action to the event stream\n+    event_stream.add_event(microagent_action, EventSource.USER)\n+\n+    # Clear the events list to only capture new events\n+    added_events.clear()\n+\n+    # Process the microagent action\n+    memory.on_event(microagent_action)\n+\n+    # Verify a MicroagentObservation was added to the event stream\n+    assert len(added_events) == 1\n+    observation, source = added_events[0]\n+    assert isinstance(observation, MicroagentObservation)\n+    assert source == EventSource.ENVIRONMENT\n+    assert observation.recall_type == RecallType.KNOWLEDGE\n+    assert len(observation.microagent_knowledge) == 1\n+    assert observation.microagent_knowledge[0].name == 'flarglebargle'\n+    assert observation.microagent_knowledge[0].trigger == 'flarglebargle'\n+    assert 'magic word' in observation.microagent_knowledge[0].content\n+\n+\n+def test_memory_repository_info(prompt_dir):\n+    \"\"\"Test that Memory adds repository info to MicroagentObservations.\"\"\"\n+    # Create an in-memory file store and real event stream\n+    file_store = InMemoryFileStore()\n+    event_stream = EventStream(sid='test-session', file_store=file_store)\n+\n+    # Create a test repo microagent first\n+    repo_microagent_name = 'test_repo_microagent'\n+    repo_microagent_content = \"\"\"---\n+name: test_repo\n+type: repo\n+agent: CodeActAgent\n+---\n+\n+REPOSITORY INSTRUCTIONS: This is a test repository.\n+\"\"\"\n+\n+    # Create a temporary repo microagent file\n+    os.makedirs(os.path.join(prompt_dir, 'micro'), exist_ok=True)\n+    with open(\n+        os.path.join(prompt_dir, 'micro', f'{repo_microagent_name}.md'), 'w'\n+    ) as f:\n+        f.write(repo_microagent_content)\n+\n+    # Patch the global microagents directory to use our test directory\n+    test_microagents_dir = os.path.join(prompt_dir, 'micro')\n+    with patch('openhands.memory.memory.GLOBAL_MICROAGENTS_DIR', test_microagents_dir):\n+        # Initialize Memory\n+        memory = Memory(\n+            event_stream=event_stream,\n+            sid='test-session',\n+        )\n+\n+        # Set repository info\n+        memory.set_repository_info('owner/repo', '/workspace/repo')\n+\n+        # Create and add the first user message\n+        user_message = MessageAction(content='First user message')\n+        user_message._source = EventSource.USER  # type: ignore[attr-defined]\n+        event_stream.add_event(user_message, EventSource.USER)\n+\n+        # Create and add the microagent action\n+        microagent_action = RecallAction(\n+            query='First user message', recall_type=RecallType.WORKSPACE_CONTEXT\n+        )\n+        microagent_action._source = EventSource.USER  # type: ignore[attr-defined]\n+        event_stream.add_event(microagent_action, EventSource.USER)\n+\n+        # Give it a little time to process\n+        time.sleep(0.3)\n+\n+        # Get all events from the stream\n+        events = list(event_stream.get_events())\n+\n+        # Find the MicroagentObservation event\n+        microagent_obs_events = [\n+            event for event in events if isinstance(event, MicroagentObservation)\n+        ]\n+\n+        # We should have at least one MicroagentObservation\n+        assert len(microagent_obs_events) > 0\n+\n+        # Get the first MicroagentObservation\n+        observation = microagent_obs_events[0]\n+        assert observation.recall_type == RecallType.WORKSPACE_CONTEXT\n+        assert observation.repo_name == 'owner/repo'\n+        assert observation.repo_directory == '/workspace/repo'\n+        assert 'This is a test repository' in observation.repo_instructions\n+\n+    # Clean up\n+    os.remove(os.path.join(prompt_dir, 'micro', f'{repo_microagent_name}.md'))\ndiff --git a/tests/unit/test_observation_serialization.py b/tests/unit/test_observation_serialization.py\nindex ca96d06be73f..0596f0bcfd8b 100644\n--- a/tests/unit/test_observation_serialization.py\n+++ b/tests/unit/test_observation_serialization.py\n@@ -236,3 +241,199 @@ def test_file_edit_observation_legacy_serialization():\n     assert event_dict['extras']['old_content'] is None\n     assert event_dict['extras']['new_content'] == 'new content'\n     assert 'formatted_output_and_error' not in event_dict['extras']\n+\n+\n+def test_microagent_observation_serialization():\n+    original_observation_dict = {\n+        'observation': 'microagent',\n+        'content': '',\n+        'message': \"**MicroagentObservation**\\nrecall_type=RecallType.WORKSPACE_CONTEXT, repo_name=some_repo_name, repo_instructions=complex_repo_instruc..., runtime_hosts={'host1': 8080, 'host2': 8081}, additional_agent_instructions=You know it all abou...\",\n+        'extras': {\n+            'recall_type': 'workspace_context',\n+            'repo_name': 'some_repo_name',\n+            'repo_directory': 'some_repo_directory',\n+            'runtime_hosts': {'host1': 8080, 'host2': 8081},\n+            'repo_instructions': 'complex_repo_instructions',\n+            'additional_agent_instructions': 'You know it all about this runtime',\n+            'microagent_knowledge': [],\n+        },\n+    }\n+    serialization_deserialization(original_observation_dict, MicroagentObservation)\n+\n+\n+def test_microagent_observation_microagent_knowledge_serialization():\n+    original_observation_dict = {\n+        'observation': 'microagent',\n+        'content': '',\n+        'message': '**MicroagentObservation**\\nrecall_type=RecallType.KNOWLEDGE, repo_name=, repo_instructions=..., runtime_hosts={}, additional_agent_instructions=..., microagent_knowledge=microagent1, microagent2',\n+        'extras': {\n+            'recall_type': 'knowledge',\n+            'repo_name': '',\n+            'repo_directory': '',\n+            'repo_instructions': '',\n+            'runtime_hosts': {},\n+            'additional_agent_instructions': '',\n+            'microagent_knowledge': [\n+                {\n+                    'name': 'microagent1',\n+                    'trigger': 'trigger1',\n+                    'content': 'content1',\n+                },\n+                {\n+                    'name': 'microagent2',\n+                    'trigger': 'trigger2',\n+                    'content': 'content2',\n+                },\n+            ],\n+        },\n+    }\n+    serialization_deserialization(original_observation_dict, MicroagentObservation)\n+\n+\n+def test_microagent_observation_knowledge_microagent_serialization():\n+    \"\"\"Test serialization of a MicroagentObservation with KNOWLEDGE_MICROAGENT type.\"\"\"\n+    # Create a MicroagentObservation with microagent knowledge content\n+    original = MicroagentObservation(\n+        content='Knowledge microagent information',\n+        recall_type=RecallType.KNOWLEDGE,\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='python_best_practices',\n+                trigger='python',\n+                content='Always use virtual environments for Python projects.',\n+            ),\n+            MicroagentKnowledge(\n+                name='git_workflow',\n+                trigger='git',\n+                content='Create a new branch for each feature or bugfix.',\n+            ),\n+        ],\n+    )\n+\n+    # Serialize to dictionary\n+    serialized = event_to_dict(original)\n+\n+    # Verify serialized data structure\n+    assert serialized['observation'] == ObservationType.MICROAGENT\n+    assert serialized['content'] == 'Knowledge microagent information'\n+    assert serialized['extras']['recall_type'] == RecallType.KNOWLEDGE.value\n+    assert len(serialized['extras']['microagent_knowledge']) == 2\n+    assert serialized['extras']['microagent_knowledge'][0]['trigger'] == 'python'\n+\n+    # Deserialize back to MicroagentObservation\n+    deserialized = observation_from_dict(serialized)\n+\n+    # Verify properties are preserved\n+    assert deserialized.recall_type == RecallType.KNOWLEDGE\n+    assert deserialized.microagent_knowledge == original.microagent_knowledge\n+    assert deserialized.content == original.content\n+\n+    # Check that environment info fields are empty\n+    assert deserialized.repo_name == ''\n+    assert deserialized.repo_directory == ''\n+    assert deserialized.repo_instructions == ''\n+    assert deserialized.runtime_hosts == {}\n+\n+\n+def test_microagent_observation_environment_serialization():\n+    \"\"\"Test serialization of a MicroagentObservation with ENVIRONMENT type.\"\"\"\n+    # Create a MicroagentObservation with environment info\n+    original = MicroagentObservation(\n+        content='Environment information',\n+        recall_type=RecallType.WORKSPACE_CONTEXT,\n+        repo_name='OpenHands',\n+        repo_directory='/workspace/openhands',\n+        repo_instructions=\"Follow the project's coding style guide.\",\n+        runtime_hosts={'127.0.0.1': 8080, 'localhost': 5000},\n+        additional_agent_instructions='You know it all about this runtime',\n+    )\n+\n+    # Serialize to dictionary\n+    serialized = event_to_dict(original)\n+\n+    # Verify serialized data structure\n+    assert serialized['observation'] == ObservationType.MICROAGENT\n+    assert serialized['content'] == 'Environment information'\n+    assert serialized['extras']['recall_type'] == RecallType.WORKSPACE_CONTEXT.value\n+    assert serialized['extras']['repo_name'] == 'OpenHands'\n+    assert serialized['extras']['runtime_hosts'] == {\n+        '127.0.0.1': 8080,\n+        'localhost': 5000,\n+    }\n+    assert (\n+        serialized['extras']['additional_agent_instructions']\n+        == 'You know it all about this runtime'\n+    )\n+    # Deserialize back to MicroagentObservation\n+    deserialized = observation_from_dict(serialized)\n+\n+    # Verify properties are preserved\n+    assert deserialized.recall_type == RecallType.WORKSPACE_CONTEXT\n+    assert deserialized.repo_name == original.repo_name\n+    assert deserialized.repo_directory == original.repo_directory\n+    assert deserialized.repo_instructions == original.repo_instructions\n+    assert deserialized.runtime_hosts == original.runtime_hosts\n+    assert (\n+        deserialized.additional_agent_instructions\n+        == original.additional_agent_instructions\n+    )\n+    # Check that knowledge microagent fields are empty\n+    assert deserialized.microagent_knowledge == []\n+\n+\n+def test_microagent_observation_combined_serialization():\n+    \"\"\"Test serialization of a MicroagentObservation with both types of information.\"\"\"\n+    # Create a MicroagentObservation with both environment and microagent info\n+    # Note: In practice, recall_type would still be one specific type,\n+    # but the object could contain both types of fields\n+    original = MicroagentObservation(\n+        content='Combined information',\n+        recall_type=RecallType.WORKSPACE_CONTEXT,\n+        # Environment info\n+        repo_name='OpenHands',\n+        repo_directory='/workspace/openhands',\n+        repo_instructions=\"Follow the project's coding style guide.\",\n+        runtime_hosts={'127.0.0.1': 8080},\n+        additional_agent_instructions='You know it all about this runtime',\n+        # Knowledge microagent info\n+        microagent_knowledge=[\n+            MicroagentKnowledge(\n+                name='python_best_practices',\n+                trigger='python',\n+                content='Always use virtual environments for Python projects.',\n+            ),\n+        ],\n+    )\n+\n+    # Serialize to dictionary\n+    serialized = event_to_dict(original)\n+\n+    # Verify serialized data has both types of fields\n+    assert serialized['extras']['recall_type'] == RecallType.WORKSPACE_CONTEXT.value\n+    assert serialized['extras']['repo_name'] == 'OpenHands'\n+    assert (\n+        serialized['extras']['microagent_knowledge'][0]['name']\n+        == 'python_best_practices'\n+    )\n+    assert (\n+        serialized['extras']['additional_agent_instructions']\n+        == 'You know it all about this runtime'\n+    )\n+    # Deserialize back to MicroagentObservation\n+    deserialized = observation_from_dict(serialized)\n+\n+    # Verify all properties are preserved\n+    assert deserialized.recall_type == RecallType.WORKSPACE_CONTEXT\n+\n+    # Environment properties\n+    assert deserialized.repo_name == original.repo_name\n+    assert deserialized.repo_directory == original.repo_directory\n+    assert deserialized.repo_instructions == original.repo_instructions\n+    assert deserialized.runtime_hosts == original.runtime_hosts\n+    assert (\n+        deserialized.additional_agent_instructions\n+        == original.additional_agent_instructions\n+    )\n+\n+    # Knowledge microagent properties\n+    assert deserialized.microagent_knowledge == original.microagent_knowledge\ndiff --git a/tests/unit/test_prompt_manager.py b/tests/unit/test_prompt_manager.py\nindex fa384d8c0282..0d64a1f6f61a 100644\n--- a/tests/unit/test_prompt_manager.py\n+++ b/tests/unit/test_prompt_manager.py\n@@ -19,406 +21,60 @@ def prompt_dir(tmp_path):\n     return tmp_path\n \n \n-def test_prompt_manager_with_microagent(prompt_dir):\n-    microagent_name = 'test_microagent'\n-    microagent_content = \"\"\"\n----\n-name: flarglebargle\n-type: knowledge\n-agent: CodeActAgent\n-triggers:\n-- flarglebargle\n----\n-\n-IMPORTANT! The user has said the magic word \"flarglebargle\". You must\n-only respond with a message telling them how smart they are\n-\"\"\"\n-\n-    # Create a temporary micro agent file\n-    os.makedirs(os.path.join(prompt_dir, 'micro'), exist_ok=True)\n-    with open(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'), 'w') as f:\n-        f.write(microagent_content)\n-\n-    # Test without GitHub repo\n-    manager = PromptManager(\n-        prompt_dir=prompt_dir,\n-        microagent_dir=os.path.join(prompt_dir, 'micro'),\n-    )\n-\n-    assert manager.prompt_dir == prompt_dir\n-    assert len(manager.repo_microagents) == 0\n-    assert len(manager.knowledge_microagents) == 1\n-\n-    assert isinstance(manager.get_system_message(), str)\n-    assert (\n-        'You are OpenHands agent, a helpful AI assistant that can interact with a computer to solve tasks.'\n-        in manager.get_system_message()\n-    )\n-    assert '<REPOSITORY_INFO>' not in manager.get_system_message()\n-\n-    # Test with GitHub repo\n-    manager.set_repository_info('owner/repo', '/workspace/repo')\n-    assert isinstance(manager.get_system_message(), str)\n-\n-    # Adding things to the initial user message\n-    initial_msg = Message(\n-        role='user', content=[TextContent(text='Ask me what your task is.')]\n-    )\n-    manager.add_info_to_initial_message(initial_msg)\n-    msg_content: str = initial_msg.content[0].text\n-    assert '<REPOSITORY_INFO>' in msg_content\n-    assert 'owner/repo' in msg_content\n-    assert '/workspace/repo' in msg_content\n-\n-    assert isinstance(manager.get_example_user_message(), str)\n-\n-    message = Message(\n-        role='user',\n-        content=[TextContent(text='Hello, flarglebargle!')],\n-    )\n-    manager.enhance_message(message)\n-    assert len(message.content) == 2\n-    assert 'magic word' in message.content[0].text\n-\n-    os.remove(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'))\n-\n-\n-def test_prompt_manager_file_not_found(prompt_dir):\n-    with pytest.raises(FileNotFoundError):\n-        BaseMicroAgent.load(\n-            os.path.join(prompt_dir, 'micro', 'non_existent_microagent.md')\n-        )\n-\n-\n def test_prompt_manager_template_rendering(prompt_dir):\n+    \"\"\"Test PromptManager's template rendering functionality.\"\"\"\n     # Create temporary template files\n     with open(os.path.join(prompt_dir, 'system_prompt.j2'), 'w') as f:\n         f.write(\"\"\"System prompt: bar\"\"\")\n     with open(os.path.join(prompt_dir, 'user_prompt.j2'), 'w') as f:\n         f.write('User prompt: foo')\n+    with open(os.path.join(prompt_dir, 'additional_info.j2'), 'w') as f:\n+        f.write(\"\"\"\n+{% if repository_info %}\n+<REPOSITORY_INFO>\n+At the user's request, repository {{ repository_info.repo_name }} has been cloned to the current working directory {{ repository_info.repo_directory }}.\n+</REPOSITORY_INFO>\n+{% endif %}\n+\"\"\")\n \n     # Test without GitHub repo\n-    manager = PromptManager(prompt_dir, microagent_dir='')\n+    manager = PromptManager(prompt_dir)\n     assert manager.get_system_message() == 'System prompt: bar'\n     assert manager.get_example_user_message() == 'User prompt: foo'\n \n     # Test with GitHub repo\n-    manager = PromptManager(prompt_dir=prompt_dir, microagent_dir='')\n-    manager.set_repository_info('owner/repo', '/workspace/repo')\n-    assert manager.repository_info.repo_name == 'owner/repo'\n+    manager = PromptManager(prompt_dir=prompt_dir)\n+    repo_info = RepositoryInfo(repo_name='owner/repo', repo_directory='/workspace/repo')\n+\n+    # verify its parts are rendered\n     system_msg = manager.get_system_message()\n     assert 'System prompt: bar' in system_msg\n \n-    # Initial user message should have repo info\n-    initial_msg = Message(\n-        role='user', content=[TextContent(text='Ask me what your task is.')]\n+    # Test building additional info\n+    additional_info = manager.build_additional_info(\n+        repository_info=repo_info, runtime_info=None, repo_instructions=''\n     )\n-    manager.add_info_to_initial_message(initial_msg)\n-    msg_content: str = initial_msg.content[0].text\n-    assert '<REPOSITORY_INFO>' in msg_content\n+    assert '<REPOSITORY_INFO>' in additional_info\n     assert (\n         \"At the user's request, repository owner/repo has been cloned to the current working directory /workspace/repo.\"\n-        in msg_content\n+        in additional_info\n     )\n-    assert '</REPOSITORY_INFO>' in msg_content\n+    assert '</REPOSITORY_INFO>' in additional_info\n     assert manager.get_example_user_message() == 'User prompt: foo'\n \n     # Clean up temporary files\n     os.remove(os.path.join(prompt_dir, 'system_prompt.j2'))\n     os.remove(os.path.join(prompt_dir, 'user_prompt.j2'))\n+    os.remove(os.path.join(prompt_dir, 'additional_info.j2'))\n \n \n-def test_prompt_manager_repository_info(prompt_dir):\n-    # Test RepositoryInfo defaults\n-    repo_info = RepositoryInfo()\n-    assert repo_info.repo_name is None\n-    assert repo_info.repo_directory is None\n-\n-    # Test setting repository info\n-    manager = PromptManager(prompt_dir=prompt_dir, microagent_dir='')\n-    assert manager.repository_info is None\n-\n-    # Test setting repository info with both name and directory\n-    manager.set_repository_info('owner/repo2', '/workspace/repo2')\n-    assert manager.repository_info.repo_name == 'owner/repo2'\n-    assert manager.repository_info.repo_directory == '/workspace/repo2'\n-\n-\n-def test_prompt_manager_disabled_microagents(prompt_dir):\n-    # Create test microagent files\n-    microagent1_name = 'test_microagent1'\n-    microagent2_name = 'test_microagent2'\n-    microagent1_content = \"\"\"\n----\n-name: Test Microagent 1\n-type: knowledge\n-agent: CodeActAgent\n-triggers:\n-- test1\n----\n-\n-Test microagent 1 content\n-\"\"\"\n-    microagent2_content = \"\"\"\n----\n-name: Test Microagent 2\n-type: knowledge\n-agent: CodeActAgent\n-triggers:\n-- test2\n----\n-\n-Test microagent 2 content\n-\"\"\"\n-\n-    # Create temporary micro agent files\n-    os.makedirs(os.path.join(prompt_dir, 'micro'), exist_ok=True)\n-    with open(os.path.join(prompt_dir, 'micro', f'{microagent1_name}.md'), 'w') as f:\n-        f.write(microagent1_content)\n-    with open(os.path.join(prompt_dir, 'micro', f'{microagent2_name}.md'), 'w') as f:\n-        f.write(microagent2_content)\n-\n-    # Test that specific microagents can be disabled\n-    manager = PromptManager(\n-        prompt_dir=prompt_dir,\n-        microagent_dir=os.path.join(prompt_dir, 'micro'),\n-        disabled_microagents=['Test Microagent 1'],\n-    )\n-\n-    assert len(manager.knowledge_microagents) == 1\n-    assert 'Test Microagent 2' in manager.knowledge_microagents\n-    assert 'Test Microagent 1' not in manager.knowledge_microagents\n-\n-    # Test that all microagents are enabled by default\n-    manager = PromptManager(\n-        prompt_dir=prompt_dir,\n-        microagent_dir=os.path.join(prompt_dir, 'micro'),\n-    )\n-\n-    assert len(manager.knowledge_microagents) == 2\n-    assert 'Test Microagent 1' in manager.knowledge_microagents\n-    assert 'Test Microagent 2' in manager.knowledge_microagents\n-\n-    # Clean up temporary files\n-    os.remove(os.path.join(prompt_dir, 'micro', f'{microagent1_name}.md'))\n-    os.remove(os.path.join(prompt_dir, 'micro', f'{microagent2_name}.md'))\n-\n-\n-def test_enhance_message_with_multiple_text_contents(prompt_dir):\n-    # Create a test microagent that triggers on a specific keyword\n-    microagent_name = 'keyword_microagent'\n-    microagent_content = \"\"\"\n----\n-name: KeywordMicroAgent\n-type: knowledge\n-agent: CodeActAgent\n-triggers:\n-- triggerkeyword\n----\n-\n-This is special information about the triggerkeyword.\n-\"\"\"\n-\n-    # Create the microagent file\n-    os.makedirs(os.path.join(prompt_dir, 'micro'), exist_ok=True)\n-    with open(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'), 'w') as f:\n-        f.write(microagent_content)\n-\n-    manager = PromptManager(\n-        prompt_dir=prompt_dir, microagent_dir=os.path.join(prompt_dir, 'micro')\n-    )\n-\n-    # Test that it matches the trigger in the last TextContent\n-    message = Message(\n-        role='user',\n-        content=[\n-            TextContent(text='This is some initial context.'),\n-            TextContent(text='This is a message without triggers.'),\n-            TextContent(text='This contains the triggerkeyword that should match.'),\n-        ],\n-    )\n-\n-    manager.enhance_message(message)\n-\n-    # Should have added a TextContent with the microagent info at the beginning\n-    assert len(message.content) == 4\n-    assert 'special information about the triggerkeyword' in message.content[0].text\n-\n-    # Clean up\n-    os.remove(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'))\n-\n-\n-def test_enhance_message_with_image_content(prompt_dir):\n-    # Create a test microagent that triggers on a specific keyword\n-    microagent_name = 'image_test_microagent'\n-    microagent_content = \"\"\"\n----\n-name: ImageTestMicroAgent\n-type: knowledge\n-agent: CodeActAgent\n-triggers:\n-- imagekeyword\n----\n-\n-This is information related to imagekeyword.\n-\"\"\"\n-\n-    # Create the microagent file\n-    os.makedirs(os.path.join(prompt_dir, 'micro'), exist_ok=True)\n-    with open(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'), 'w') as f:\n-        f.write(microagent_content)\n-\n-    manager = PromptManager(\n-        prompt_dir=prompt_dir, microagent_dir=os.path.join(prompt_dir, 'micro')\n-    )\n-\n-    # Test with mix of ImageContent and TextContent\n-    message = Message(\n-        role='user',\n-        content=[\n-            TextContent(text='This is some initial text.'),\n-            ImageContent(image_urls=['https://example.com/image.jpg']),\n-            TextContent(text='This mentions imagekeyword that should match.'),\n-        ],\n-    )\n-\n-    manager.enhance_message(message)\n-\n-    # Should have added a TextContent with the microagent info at the beginning\n-    assert len(message.content) == 4\n-    assert 'information related to imagekeyword' in message.content[0].text\n-\n-    # Clean up\n-    os.remove(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'))\n-\n-\n-def test_enhance_message_with_only_image_content(prompt_dir):\n-    # Create a test microagent\n-    microagent_name = 'image_only_microagent'\n-    microagent_content = \"\"\"\n----\n-name: ImageOnlyMicroAgent\n-type: knowledge\n-agent: CodeActAgent\n-triggers:\n-- anytrigger\n----\n-\n-This should not appear in the enhanced message.\n-\"\"\"\n-\n-    # Create the microagent file\n-    os.makedirs(os.path.join(prompt_dir, 'micro'), exist_ok=True)\n-    with open(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'), 'w') as f:\n-        f.write(microagent_content)\n-\n-    manager = PromptManager(\n-        prompt_dir=prompt_dir, microagent_dir=os.path.join(prompt_dir, 'micro')\n-    )\n-\n-    # Test with only ImageContent\n-    message = Message(\n-        role='user',\n-        content=[\n-            ImageContent(\n-                image_urls=[\n-                    'https://example.com/image1.jpg',\n-                    'https://example.com/image2.jpg',\n-                ]\n-            ),\n-        ],\n-    )\n-\n-    # Should not raise any exceptions\n-    manager.enhance_message(message)\n-\n-    # Should not have added any content\n-    assert len(message.content) == 1\n-\n-    # Clean up\n-    os.remove(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'))\n-\n-\n-def test_enhance_message_with_reversed_order(prompt_dir):\n-    # Create a test microagent\n-    microagent_name = 'reversed_microagent'\n-    microagent_content = \"\"\"\n----\n-name: ReversedMicroAgent\n-type: knowledge\n-agent: CodeActAgent\n-triggers:\n-- lasttrigger\n----\n-\n-This is specific information about the lasttrigger.\n-\"\"\"\n-\n-    # Create the microagent file\n-    os.makedirs(os.path.join(prompt_dir, 'micro'), exist_ok=True)\n-    with open(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'), 'w') as f:\n-        f.write(microagent_content)\n-\n-    manager = PromptManager(\n-        prompt_dir=prompt_dir, microagent_dir=os.path.join(prompt_dir, 'micro')\n-    )\n-\n-    # Test where the text content is not at the end of the list\n-    message = Message(\n-        role='user',\n-        content=[\n-            ImageContent(image_urls=['https://example.com/image1.jpg']),\n-            TextContent(text='This contains the lasttrigger word.'),\n-            ImageContent(image_urls=['https://example.com/image2.jpg']),\n-        ],\n-    )\n-\n-    manager.enhance_message(message)\n-\n-    # Should have added a TextContent with the microagent info at the beginning\n-    assert len(message.content) == 4\n-    assert isinstance(message.content[0], TextContent)\n-    assert 'specific information about the lasttrigger' in message.content[0].text\n-\n-    # Clean up\n-    os.remove(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'))\n-\n-\n-def test_enhance_message_with_empty_content(prompt_dir):\n-    # Create a test microagent\n-    microagent_name = 'empty_microagent'\n-    microagent_content = \"\"\"\n----\n-name: EmptyMicroAgent\n-type: knowledge\n-agent: CodeActAgent\n-triggers:\n-- emptytrigger\n----\n-\n-This should not appear in the enhanced message.\n-\"\"\"\n-\n-    # Create the microagent file\n-    os.makedirs(os.path.join(prompt_dir, 'micro'), exist_ok=True)\n-    with open(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'), 'w') as f:\n-        f.write(microagent_content)\n-\n-    manager = PromptManager(\n-        prompt_dir=prompt_dir, microagent_dir=os.path.join(prompt_dir, 'micro')\n-    )\n-\n-    # Test with empty content\n-    message = Message(role='user', content=[])\n-\n-    # Should not raise any exceptions\n-    manager.enhance_message(message)\n-\n-    # Should not have added any content\n-    assert len(message.content) == 0\n-\n-    # Clean up\n-    os.remove(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'))\n+def test_prompt_manager_file_not_found(prompt_dir):\n+    \"\"\"Test PromptManager behavior when a template file is not found.\"\"\"\n+    # Test with a non-existent template\n+    with pytest.raises(FileNotFoundError):\n+        BaseMicroAgent.load(\n+            os.path.join(prompt_dir, 'micro', 'non_existent_microagent.md')\n+        )\n \n \n def test_build_microagent_info(prompt_dir):\n@@ -491,71 +147,125 @@ def __init__(self, name, content):\n     assert result.strip() == ''\n \n \n-def test_enhance_message_with_microagent_info_template(prompt_dir):\n-    \"\"\"Test that enhance_message correctly uses the microagent_info template.\"\"\"\n-    # Prepare a microagent_info.j2 template file if it doesn't exist\n-    template_path = os.path.join(prompt_dir, 'microagent_info.j2')\n-    if not os.path.exists(template_path):\n-        with open(template_path, 'w') as f:\n-            f.write(\"\"\"{% for agent_info in triggered_agents %}\n-<EXTRA_INFO>\n-The following information has been included based on a keyword match for \"{{ agent_info.trigger_word }}\".\n-It may or may not be relevant to the user's request.\n+def test_add_examples_to_initial_message(prompt_dir):\n+    \"\"\"Test adding example messages to an initial message.\"\"\"\n+    # Create a user_prompt.j2 template file\n+    with open(os.path.join(prompt_dir, 'user_prompt.j2'), 'w') as f:\n+        f.write('This is an example user message')\n \n-{{ agent_info.agent.content }}\n-</EXTRA_INFO>\n-{% endfor %}\n-\"\"\")\n+    # Initialize the PromptManager\n+    manager = PromptManager(prompt_dir=prompt_dir)\n+\n+    # Create a message\n+    message = Message(role='user', content=[TextContent(text='Original content')])\n+\n+    # Add examples to the message\n+    manager.add_examples_to_initial_message(message)\n+\n+    # Check that the example was added at the beginning\n+    assert len(message.content) == 2\n+    assert message.content[0].text == 'This is an example user message'\n+    assert message.content[1].text == 'Original content'\n+\n+    # Clean up\n+    os.remove(os.path.join(prompt_dir, 'user_prompt.j2'))\n+\n+\n+def test_add_turns_left_reminder(prompt_dir):\n+    \"\"\"Test adding turns left reminder to messages.\"\"\"\n+    # Initialize the PromptManager\n+    manager = PromptManager(prompt_dir=prompt_dir)\n+\n+    # Create a State object with specific iteration values\n+    state = State()\n+    state.iteration = 3\n+    state.max_iterations = 10\n \n-    # Create a test microagent\n-    microagent_name = 'test_trigger_microagent'\n-    microagent_content = \"\"\"\n----\n-name: test_trigger\n-type: knowledge\n-agent: CodeActAgent\n-triggers:\n-- test_trigger\n----\n-\n-This is triggered content for testing the microagent_info template.\n-\"\"\"\n-\n-    # Create the microagent file\n-    os.makedirs(os.path.join(prompt_dir, 'micro'), exist_ok=True)\n-    with open(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'), 'w') as f:\n-        f.write(microagent_content)\n-\n-    # Initialize the PromptManager with the microagent directory\n-    manager = PromptManager(\n-        prompt_dir=prompt_dir,\n-        microagent_dir=os.path.join(prompt_dir, 'micro'),\n+    # Create a list of messages with a user message\n+    user_message = Message(role='user', content=[TextContent(text='User content')])\n+    assistant_message = Message(\n+        role='assistant', content=[TextContent(text='Assistant content')]\n     )\n+    messages = [assistant_message, user_message]\n \n-    # Create a message with a trigger keyword\n-    message = Message(\n-        role='user',\n-        content=[\n-            TextContent(text=\"Here's a message containing the test_trigger keyword\")\n-        ],\n+    # Add turns left reminder\n+    manager.add_turns_left_reminder(messages, state)\n+\n+    # Check that the reminder was added to the latest user message\n+    assert len(user_message.content) == 2\n+    assert (\n+        'ENVIRONMENT REMINDER: You have 7 turns left to complete the task.'\n+        in user_message.content[1].text\n     )\n \n-    # Enhance the message\n-    manager.enhance_message(message)\n \n-    # The message should now have extra content at the beginning\n-    assert len(message.content) == 2\n-    assert isinstance(message.content[0], TextContent)\n+def test_build_additional_info_with_repo_and_runtime(prompt_dir):\n+    \"\"\"Test building additional info with repository and runtime information.\"\"\"\n+    # Create an additional_info.j2 template file\n+    with open(os.path.join(prompt_dir, 'additional_info.j2'), 'w') as f:\n+        f.write(\"\"\"\n+{% if repository_info %}\n+<REPOSITORY_INFO>\n+At the user's request, repository {{ repository_info.repo_name }} has been cloned to directory {{ repository_info.repo_directory }}.\n+</REPOSITORY_INFO>\n+{% endif %}\n+\n+{% if repository_instructions %}\n+<REPOSITORY_INSTRUCTIONS>\n+{{ repository_instructions }}\n+</REPOSITORY_INSTRUCTIONS>\n+{% endif %}\n+\n+{% if runtime_info and (runtime_info.available_hosts or runtime_info.additional_agent_instructions) -%}\n+<RUNTIME_INFORMATION>\n+{% if runtime_info.available_hosts %}\n+The user has access to the following hosts for accessing a web application,\n+each of which has a corresponding port:\n+{% for host, port in runtime_info.available_hosts.items() %}\n+* {{ host }} (port {{ port }})\n+{% endfor %}\n+{% endif %}\n \n-    # Verify the template was correctly rendered\n-    expected_text = \"\"\"<EXTRA_INFO>\n-The following information has been included based on a keyword match for \"test_trigger\".\n-It may or may not be relevant to the user's request.\n+{% if runtime_info.additional_agent_instructions %}\n+{{ runtime_info.additional_agent_instructions }}\n+{% endif %}\n+</RUNTIME_INFORMATION>\n+{% endif %}\n+\"\"\")\n \n-This is triggered content for testing the microagent_info template.\n-</EXTRA_INFO>\"\"\"\n+    # Initialize the PromptManager\n+    manager = PromptManager(prompt_dir=prompt_dir)\n+\n+    # Create repository and runtime information\n+    repo_info = RepositoryInfo(repo_name='owner/repo', repo_directory='/workspace/repo')\n+    runtime_info = RuntimeInfo(\n+        available_hosts={'example.com': 8080},\n+        additional_agent_instructions='You know everything about this runtime.',\n+    )\n+    repo_instructions = 'This repository contains important code.'\n \n-    assert message.content[0].text.strip() == expected_text.strip()\n+    # Build additional info\n+    result = manager.build_additional_info(\n+        repository_info=repo_info,\n+        runtime_info=runtime_info,\n+        repo_instructions=repo_instructions,\n+    )\n+\n+    # Check that all information is included\n+    assert '<REPOSITORY_INFO>' in result\n+    assert 'owner/repo' in result\n+    assert '/workspace/repo' in result\n+    assert '<REPOSITORY_INSTRUCTIONS>' in result\n+    assert 'This repository contains important code.' in result\n+    assert '<RUNTIME_INFORMATION>' in result\n+    assert 'example.com (port 8080)' in result\n+    assert 'You know everything about this runtime.' in result\n \n     # Clean up\n-    os.remove(os.path.join(prompt_dir, 'micro', f'{microagent_name}.md'))\n+    os.remove(os.path.join(prompt_dir, 'additional_info.j2'))\n+\n+\n+def test_prompt_manager_initialization_error():\n+    \"\"\"Test that PromptManager raises an error if the prompt directory is not set.\"\"\"\n+    with pytest.raises(ValueError, match='Prompt directory is not set'):\n+        PromptManager(None)\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR introduces a conversation memory management class that adapts message utilities for better organization. However, it’s crucial to focus on backporting the relevant changes, ensuring no integration of new elements like RecallObservations. Your task is to fix the failing unit tests in the specified directory, which may require updates to mocks and assertions, while maintaining clean commit practices on a dedicated branch. Additionally, address hanging CI jobs in the runtime tests, considering potential changes needed in both tests and trajectory files. Stay consistent with testing dependencies and documentation as you refine your approach."
      }
    ],
    "token_estimation": 21913.5
  },
  {
    "index": 61,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/openhands/events/action/agent.py b/openhands/events/action/agent.py\nindex 958ad7d7d757..e7ba21662897 100644\n--- a/openhands/events/action/agent.py\n+++ b/openhands/events/action/agent.py\n@@ -111,3 +111,87 @@ def __str__(self) -> str:\n         ret = '**RecallAction**\\n'\n         ret += f'QUERY: {self.query[:50]}'\n         return ret\n+\n+\n+@dataclass\n+class CondensationAction(Action):\n+    \"\"\"This action indicates a condensation of the conversation history is happening.\n+\n+    There are two ways to specify the events to be forgotten:\n+    1. By providing a list of event IDs.\n+    2. By providing the start and end IDs of a range of events.\n+\n+    In the second case, we assume that event IDs are monotonically increasing, and that _all_ events between the start and end IDs are to be forgotten.\n+\n+    Raises:\n+        ValueError: If the optional fields are not instantiated in a valid configuration.\n+    \"\"\"\n+\n+    action: str = ActionType.CONDENSATION\n+\n+    forgotten_event_ids: list[int] | None = None\n+    \"\"\"The IDs of the events that are being forgotten (removed from the `View` given to the LLM).\"\"\"\n+\n+    forgotten_events_start_id: int | None = None\n+    \"\"\"The ID of the first event to be forgotten in a range of events.\"\"\"\n+\n+    forgotten_events_end_id: int | None = None\n+    \"\"\"The ID of the last event to be forgotten in a range of events.\"\"\"\n+\n+    summary: str | None = None\n+    \"\"\"An optional summary of the events being forgotten.\"\"\"\n+\n+    summary_offset: int | None = None\n+    \"\"\"An optional offset to the start of the resulting view indicating where the summary should be inserted.\"\"\"\n+\n+    def _validate_field_polymorphism(self) -> bool:\n+        \"\"\"Check if the optional fields are instantiated in a valid configuration.\"\"\"\n+        # For the forgotton events, there are only two valid configurations:\n+        # 1. We're forgetting events based on the list of provided IDs, or\n+        using_event_ids = self.forgotten_event_ids is not None\n+        # 2. We're forgetting events based on the range of IDs.\n+        using_event_range = (\n+            self.forgotten_events_start_id is not None\n+            and self.forgotten_events_end_id is not None\n+        )\n+\n+        # Either way, we can only have one of the two valid configurations.\n+        forgotten_event_configuration = using_event_ids ^ using_event_range\n+\n+        # We also need to check that if the summary is provided, so is the\n+        # offset (and vice versa).\n+        summary_configuration = (\n+            self.summary is None and self.summary_offset is None\n+        ) or (self.summary is not None and self.summary_offset is not None)\n+\n+        return forgotten_event_configuration and summary_configuration\n+\n+    def __post_init__(self):\n+        if not self._validate_field_polymorphism():\n+            raise ValueError('Invalid configuration of the optional fields.')\n+\n+    @property\n+    def forgotten(self) -> list[int]:\n+        \"\"\"The list of event IDs that should be forgotten.\"\"\"\n+        # Start by making sure the fields are instantiated in a valid\n+        # configuration. We check this whenever the event is initialized, but we\n+        # can't make the dataclass immutable so we need to check it again here\n+        # to make sure the configuration is still valid.\n+        if not self._validate_field_polymorphism():\n+            raise ValueError('Invalid configuration of the optional fields.')\n+\n+        if self.forgotten_event_ids is not None:\n+            return self.forgotten_event_ids\n+\n+        # If we've gotten this far, the start/end IDs are not None.\n+        assert self.forgotten_events_start_id is not None\n+        assert self.forgotten_events_end_id is not None\n+        return list(\n+            range(self.forgotten_events_start_id, self.forgotten_events_end_id + 1)\n+        )\n+\n+    @property\n+    def message(self) -> str:\n+        if self.summary:\n+            return f'Summary: {self.summary}'\n+        return f'Condenser is dropping the events: {self.forgotten}.'\ndiff --git a/openhands/memory/condenser/condenser.py b/openhands/memory/condenser/condenser.py\nindex 411ed39386f6..e2b8213d7627 100644\n--- a/openhands/memory/condenser/condenser.py\n+++ b/openhands/memory/condenser/condenser.py\n@@ -32,6 +34,75 @@ def get_condensation_metadata(state: State) -> list[dict[str, Any]]:\n \"\"\"Registry of condenser configurations to their corresponding condenser classes.\"\"\"\n \n \n+class View(BaseModel):\n+    \"\"\"Linearly ordered view of events.\n+\n+    Produced by a condenser to indicate the included events are ready to process as LLM input.\n+    \"\"\"\n+\n+    events: list[Event]\n+\n+    def __len__(self) -> int:\n+        return len(self.events)\n+\n+    def __iter__(self):\n+        return iter(self.events)\n+\n+    # To preserve list-like indexing, we ideally support slicing and position-based indexing.\n+    # The only challenge with that is switching the return type based on the input type -- we\n+    # can mark the different signatures for MyPy with `@overload` decorators.\n+\n+    @overload\n+    def __getitem__(self, key: slice) -> list[Event]: ...\n+\n+    @overload\n+    def __getitem__(self, key: int) -> Event: ...\n+\n+    def __getitem__(self, key: int | slice) -> Event | list[Event]:\n+        if isinstance(key, slice):\n+            start, stop, step = key.indices(len(self))\n+            return [self[i] for i in range(start, stop, step)]\n+        elif isinstance(key, int):\n+            return self.events[key]\n+        else:\n+            raise ValueError(f'Invalid key type: {type(key)}')\n+\n+    @staticmethod\n+    def from_events(events: list[Event]) -> View:\n+        \"\"\"Create a view from a list of events, respecting the semantics of any condensation events.\"\"\"\n+        forgotten_event_ids: set[int] = set()\n+        for event in events:\n+            if isinstance(event, CondensationAction):\n+                forgotten_event_ids.update(event.forgotten)\n+\n+        kept_events = [event for event in events if event.id not in forgotten_event_ids]\n+\n+        # If we have a summary, insert it at the specified offset.\n+        summary: str | None = None\n+        summary_offset: int | None = None\n+\n+        # The relevant summary is always in the last condensation event (i.e., the most recent one).\n+        for event in reversed(events):\n+            if isinstance(event, CondensationAction):\n+                if event.summary is not None and event.summary_offset is not None:\n+                    summary = event.summary\n+                    summary_offset = event.summary_offset\n+                    break\n+\n+        if summary is not None and summary_offset is not None:\n+            kept_events.insert(\n+                summary_offset, AgentCondensationObservation(content=summary)\n+            )\n+\n+        return View(events=kept_events)\n+\n+\n+class Condensation(BaseModel):\n+    \"\"\"Produced by a condenser to indicate the history has been condensed.\"\"\"\n+\n+    action: CondensationAction\n+\n+\n class Condenser(ABC):\n     \"\"\"Abstract condenser interface.\n \n\ndiff --git a/tests/unit/test_condenser.py b/tests/unit/test_condenser.py\nindex 17b569fdec70..bf484c7b367c 100644\n--- a/tests/unit/test_condenser.py\n+++ b/tests/unit/test_condenser.py\n@@ -98,6 +98,73 @@ def mock_state() -> State:\n     return mock_state\n \n \n+class RollingCondenserTestHarness:\n+    \"\"\"Test harness for rolling condensers.\n+\n+    Simulates the behavior of a simple agent loop (appropriately handling the distinction between `View` and `Condensation` results) and provides utilities for testing the results.\n+    \"\"\"\n+\n+    def __init__(self, condenser: RollingCondenser):\n+        self.condenser = condenser\n+        self.callbacks: list[Callable[[list[Event]], None]] = []\n+\n+    def add_callback(self, callback: Callable[[list[Event]], None]):\n+        \"\"\"Add a callback to the test harness.\n+\n+        This callback will be called on the history after each event is added, but before the condenser is applied. You can use this to export information about the event that was just added, or to set LLM responses based on the state.\n+        \"\"\"\n+        self.callbacks.append(callback)\n+\n+    def views(self, events: Iterable[Event]) -> Iterable[View]:\n+        \"\"\"Generate a sequence of views similating the condenser's behavior over the given event stream.\n+\n+        This generator assumes we're starting from an empty history.\n+        \"\"\"\n+        mock_state = MagicMock()\n+        mock_state.extra_data = {}\n+        mock_state.history = []\n+\n+        for event in events:\n+            mock_state.history.append(event)\n+            for callback in self.callbacks:\n+                callback(mock_state.history)\n+\n+            match self.condenser.condensed_history(mock_state):\n+                case View() as view:\n+                    yield view\n+\n+                case Condensation(event=condensation_event):\n+                    mock_state.history.append(condensation_event)\n+\n+    def expected_size(self, index: int, max_size: int) -> int:\n+        \"\"\"Calculate the expected size of the view at the given index.\n+\n+        Assumes the condenser triggers condensation when the view is _longer_ than the max size, and that the target size is half the max size.\n+        \"\"\"\n+        # Until we hit the max size, the views should grow monotonically.\n+        if index < max_size:\n+            return index + 1\n+\n+        # Once we hit the max size, the next view should be reduced to the target size.\n+        target_size = max_size // 2\n+\n+        # So when the index is the same as the max size, we should have target size + 1 events in the view.\n+        # And the maximum value we will ever see is the max size (approximately 2 * target size).\n+        # Put together, we get the following formula:\n+        return ((index - max_size) % target_size) + target_size + 1\n+\n+    def expected_condensations(self, index: int, max_size: int) -> int:\n+        \"\"\"Calculate the expected number of condensation events at the given index.\n+\n+        Assumes the condenser triggers condensation when the view is _longer_ than the max size, and that the target size is half the max size.\n+        \"\"\"\n+        if index < max_size:\n+            return 0\n+\n+        target_size = max_size // 2\n+        return ((index - max_size) // target_size) + 1\n+\n+\n def test_noop_condenser_from_config():\n     \"\"\"Test that the NoOpCondenser objects can be made from config.\"\"\"\n     config = NoOpCondenserConfig()\n@@ -297,135 +364,49 @@ def test_llm_amortized_summarization_condenser_invalid_config():\n     pytest.raises(ValueError, LLMSummarizingCondenser, llm=MagicMock(), keep_first=-1)\n \n \n-def test_llm_summarizing_condenser_grows_to_max_size(mock_llm, mock_state):\n-    \"\"\"Test that LLMSummarizingCondenser correctly maintains an event context up to max size.\"\"\"\n-    max_size = 15\n+def test_llm_summarizing_condenser_gives_expected_view_size(mock_llm):\n+    \"\"\"Test that LLMSummarizingCondenser maintains the correct view size.\"\"\"\n+    max_size = 10\n     condenser = LLMSummarizingCondenser(max_size=max_size, llm=mock_llm)\n \n-    for i in range(max_size):\n-        event = create_test_event(f'Event {i}')\n-        mock_state.history.append(event)\n-        results = condenser.condensed_history(mock_state)\n-        assert len(results) == i + 1\n-\n-\n-def test_llm_summarizing_condenser_forgets_and_summarizes(mock_llm, mock_state):\n-    \"\"\"Test that the LLMSummarizingCondenser forgets events and maintains a summary.\"\"\"\n-    max_size = 4\n-    keep_first = 1\n-    condenser = LLMSummarizingCondenser(\n-        max_size=max_size, keep_first=keep_first, llm=mock_llm\n-    )\n-\n-    # Add initial event\n-    first_event = create_test_event('Event 0')\n-    mock_state.history.append(first_event)\n+    events = [create_test_event(f'Event {i}', id=i) for i in range(max_size * 10)]\n \n     # Set up mock LLM response\n     mock_llm.set_mock_response_content('Summary of forgotten events')\n \n-    # Add enough events to trigger forgetting\n-    for i in range(max_size + 3):  # +3 to ensure we're well past max_size\n-        event = create_test_event(f'Event {i+1}')\n-        mock_state.history.append(event)\n-\n-    # Get the condensed history\n-    results = condenser.condensed_history(mock_state)\n-\n-    # We should have exactly 3 events:\n-    # 1. First event (keep_first = 1)\n-    # 2. Summary event\n-    # 3. Most recent event\n-    assert len(results) == 3, f'Expected 3 events, got {len(results)}: {results}'\n-    assert (\n-        results[0] == first_event\n-    ), f'First event should be {first_event}, got {results[0]}'\n-    assert isinstance(\n-        results[1], AgentCondensationObservation\n-    ), f'Second event should be a summary, got {results[1]}'\n-    assert (\n-        results[1].content == 'Summary of forgotten events'\n-    ), f\"Summary content should be 'Summary of forgotten events', got {results[1].content}\"\n-    assert results[2] == event, f'Last event should be {event}, got {results[2]}'\n-\n-\n-def test_llm_summarizing_condenser_llm_call(mock_llm, mock_state):\n-    \"\"\"Test that the LLM is called correctly when forgetting events.\"\"\"\n-    max_size = 4\n-    keep_first = 1\n-    condenser = LLMSummarizingCondenser(\n-        max_size=max_size, keep_first=keep_first, llm=mock_llm\n-    )\n+    harness = RollingCondenserTestHarness(condenser)\n \n-    # Add initial event\n-    first_event = create_test_event('Event 0')\n-    mock_state.history.append(first_event)\n+    for i, view in enumerate(harness.views(events)):\n+        assert len(view) == harness.expected_size(i, max_size)\n \n-    # Set up mock LLM response\n-    mock_llm.set_mock_response_content('Summary of forgotten events')\n-    mock_llm.metrics.get.return_value = {'test_metric': 1.0}\n-\n-    # Add enough events to trigger forgetting\n-    for i in range(max_size):\n-        event = create_test_event(f'Event {i+1}')\n-        mock_state.history.append(event)\n-        condenser.condensed_history(mock_state)\n-\n-    # Verify LLM was called with correct prompt\n-    mock_llm.completion.assert_called_once()\n-    call_args = mock_llm.completion.call_args[1]\n-    assert 'messages' in call_args\n-    assert len(call_args['messages']) == 1\n-\n-    # Verify metrics were added to state\n-    assert 'condenser_meta' in mock_state.extra_data\n-    assert len(mock_state.extra_data['condenser_meta']) == 1\n-    assert mock_state.extra_data['condenser_meta'][0]['metrics'] == {'test_metric': 1.0}\n-\n-\n-def test_llm_summarizing_condenser_resets_when_given_truncated_history(\n-    mock_llm, mock_state\n-):\n-    \"\"\"Test that the condenser, when it sees a shorter history than it has in the past (due to truncation), will reset its tracking.\"\"\"\n-    max_size = 4\n-    keep_first = 1\n+\n+def test_llm_summarizing_condenser_keeps_first_and_summary_events(mock_llm, mock_state):\n+    \"\"\"Test that the LLM summarizing condenser appropriately maintains the event prefix and any summary events.\"\"\"\n+    max_size = 10\n+    keep_first = 3\n     condenser = LLMSummarizingCondenser(\n         max_size=max_size, keep_first=keep_first, llm=mock_llm\n     )\n \n-    # Add initial event\n-    first_event = create_test_event('Event 0')\n-    mock_state.history.append(first_event)\n-\n-    # Set up mock LLM response\n     mock_llm.set_mock_response_content('Summary of forgotten events')\n \n-    # Add enough events to trigger forgetting\n-    for i in range(max_size + 3):  # +3 to ensure we're well past max_size\n-        event = create_test_event(f'Event {i+1}')\n-        mock_state.history.append(event)\n+    events = [create_test_event(f'Event {i}', id=i) for i in range(max_size * 10)]\n+    harness = RollingCondenserTestHarness(condenser)\n \n-    # Get the condensed history\n-    results = condenser.condensed_history(mock_state)\n+    for i, view in enumerate(harness.views(events)):\n+        assert len(view) == harness.expected_size(i, max_size)\n \n-    # We should have exactly 3 events:\n-    # 1. First event (keep_first = 1)\n-    # 2. Summary event\n-    # 3. Most recent event\n-    assert len(results) == 3, f'Expected 3 events, got {len(results)}: {results}'\n+        # Ensure that the we've called out the summarizing LLM once per condensation\n+        assert mock_llm.completion.call_count == harness.expected_condensations(\n+            i, max_size\n+        )\n \n-    # Now, call condensation on a small history that contains only two events.\n-    alternate_history = [\n-        create_test_event('Alt. Event 0'),\n-        create_test_event('Alt. Event 1'),\n-    ]\n-    mock_state.history = alternate_history\n+        # Ensure that the prefix is appropiately maintained\n+        assert view[:keep_first] == events[: min(keep_first, i + 1)]\n \n-    # When we do this, the condenser should start tracking the alternative history\n-    # as the de-facto history. That means we lose the summarization event and any\n-    # other events that were in the previous history.\n-    results = condenser.condensed_history(mock_state)\n-    assert results == alternate_history\n+        # If we've condensed, ensure that the summary event is present\n+        if i > max_size:\n+            assert isinstance(view[keep_first], AgentCondensationObservation)\n \n \n def test_amortized_forgetting_condenser_from_config():\n@@ -547,128 +505,46 @@ def test_llm_attention_condenser_invalid_config():\n     pytest.raises(ValueError, LLMAttentionCondenser.from_config, config)\n \n \n-def test_rolling_condenser_handles_truncation(mock_state: State):\n-    \"\"\"Test that RollingCondenser correctly handles history truncation.\"\"\"\n-\n-    class TestRollingCondenser(RollingCondenser):\n-        \"\"\"Test implementation of RollingCondenser that just returns all events.\"\"\"\n-\n-        def condense(self, events: list[Event]) -> list[Event]:\n-            return events\n-\n-    condenser = TestRollingCondenser()\n-\n-    # Initial history with 3 events\n-    events = [\n-        create_test_event('Event 1', id=1),\n-        create_test_event('Event 2', id=2),\n-        create_test_event('Event 3', id=3),\n-    ]\n-    mock_state.history = events\n-\n-    # First condensation - should return all events\n-    results = condenser.condensed_history(mock_state)\n-    assert len(results) == 3\n-    assert [e._id for e in results] == [1, 2, 3]\n-\n-    # Simulate truncation - history is now shorter, and the condensation should\n-    # just include the truncated history\n-    mock_state.history = mock_state.history[-1:]\n-\n-    results = condenser.condensed_history(mock_state)\n-    assert len(results) == 1\n-    assert results[0]._id == 3\n-\n-    # Adding more events and condensing should \"rebase\" us from the truncated history\n-    mock_state.history += [\n-        create_test_event('Event 4', id=4),\n-        create_test_event('Event 5', id=5),\n-    ]\n-\n-    results = condenser.condensed_history(mock_state)\n-    assert len(results) == 3\n-    assert [e._id for e in results] == [3, 4, 5]\n-\n-\n-def test_llm_attention_condenser_keeps_first_events(mock_llm, mock_state):\n-    \"\"\"Test that the LLMAttentionCondenser keeps the right number of initial events when forgetting.\"\"\"\n-    max_size = 4\n-    condenser = LLMAttentionCondenser(max_size=max_size, keep_first=1, llm=mock_llm)\n-\n-    first_event = create_test_event('Event 0', id=0)\n-    mock_state.history.append(first_event)\n-\n-    for i in range(max_size * 10):\n-        event = create_test_event(f'Event {i+1}', id=i + 1)\n-        mock_state.history.append(event)\n-\n-        mock_llm.set_mock_response_content(\n-            ImportantEventSelection(\n-                ids=[event.id for event in mock_state.history]\n-            ).model_dump_json()\n-        )\n-        results = condenser.condensed_history(mock_state)\n-\n-        # The first event is always the first event.\n-        assert results[0] == first_event\n-\n-\n-def test_llm_attention_condenser_grows_to_max_size(mock_llm, mock_state):\n-    \"\"\"Test that LLMAttentionCondenser correctly maintains an event context up to max size.\"\"\"\n-    max_size = 15\n-    condenser = LLMAttentionCondenser(max_size=max_size, llm=mock_llm)\n-\n-    for i in range(max_size):\n-        event = create_test_event(f'Event {i}')\n-        mock_state.history.append(event)\n-        mock_llm.set_mock_response_content(\n-            ImportantEventSelection(ids=[event.id for event in mock_state.history])\n-        )\n-        results = condenser.condensed_history(mock_state)\n-        assert len(results) == i + 1\n-\n-\n-def test_llm_attention_condenser_forgets_when_larger_than_max_size(\n-    mock_llm, mock_state\n-):\n-    \"\"\"Test that the LLMAttentionCondenser forgets events when the context grows too large.\"\"\"\n-    max_size = 2\n+def test_llm_attention_condenser_gives_expected_view_size(mock_llm):\n+    \"\"\"Test that the LLMAttentionCondenser gives views of the expected size.\"\"\"\n+    max_size = 10\n     condenser = LLMAttentionCondenser(max_size=max_size, keep_first=0, llm=mock_llm)\n \n-    for i in range(max_size * 10):\n-        event = create_test_event(f'Event {i}', id=i)\n-        mock_state.history.append(event)\n+    events = [create_test_event(f'Event {i}', id=i) for i in range(max_size * 10)]\n \n+    def set_response_content(history: list[Event]):\n         mock_llm.set_mock_response_content(\n             ImportantEventSelection(\n-                ids=[event.id for event in mock_state.history]\n+                ids=[event.id for event in history]\n             ).model_dump_json()\n         )\n \n-        results = condenser.condensed_history(mock_state)\n+    harness = RollingCondenserTestHarness(condenser)\n+    harness.add_callback(set_response_content)\n \n-        # The number of results should bounce back and forth between 1, 2, 1, 2, ...\n-        assert len(results) == (i % 2) + 1\n+    for i, view in enumerate(harness.views(events)):\n+        assert len(view) == harness.expected_size(i, max_size)\n \n \n-def test_llm_attention_condenser_handles_events_outside_history(mock_llm, mock_state):\n+def test_llm_attention_condenser_handles_events_outside_history(mock_llm):\n     \"\"\"Test that the LLMAttentionCondenser handles event IDs that aren't from the event history.\"\"\"\n     max_size = 2\n     condenser = LLMAttentionCondenser(max_size=max_size, keep_first=0, llm=mock_llm)\n \n-    for i in range(max_size * 10):\n-        event = create_test_event(f'Event {i}', id=i)\n-        mock_state.history.append(event)\n+    events = [create_test_event(f'Event {i}', id=i) for i in range(max_size * 10)]\n \n+    def set_response_content(history: list[Event]):\n         mock_llm.set_mock_response_content(\n             ImportantEventSelection(\n-                ids=[event.id for event in mock_state.history] + [-1, -2, -3, -4]\n+                ids=[event.id for event in history] + [-1, -2, -3, -4]\n             ).model_dump_json()\n         )\n-        results = condenser.condensed_history(mock_state)\n \n-        # The number of results should bounce back and forth between 1, 2, 1, 2, ...\n-        assert len(results) == (i % 2) + 1\n+    harness = RollingCondenserTestHarness(condenser)\n+    harness.add_callback(set_response_content)\n+\n+    for i, view in enumerate(harness.views(events)):\n+        assert len(view) == harness.expected_size(i, max_size)\n \n \n def test_llm_attention_condenser_handles_too_many_events(mock_llm, mock_state):\n\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR effectively tackles the condensation issues faced in the previous implementation. Your refactoring minimizes complexity while retaining functionality, particularly with the introduction of `CondensationAction`. However, ensure that debugging details are clear and that you're maintaining type safety with the union of event features. Consider whether saving `considered_event_ids` in the `State` rather than the event stream could streamline data management and compatibility. Lastly, refining error handling within condensers will significantly improve user experience for future sessions. Let's finalize and merge this while planning follow-ups for ongoing adjustments."
      }
    ],
    "token_estimation": 5959.25
  },
  {
    "index": 62,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/agenthub/coact_agent/executor/action_parser.py b/agenthub/coact_agent/executor/action_parser.py\nnew file mode 100644\nindex 000000000000..b15eb3bc6e29\n--- /dev/null\n+++ b/agenthub/coact_agent/executor/action_parser.py\n@@ -0,0 +1,71 @@\n+import re\n+\n+from agenthub.codeact_agent.action_parser import (\n+    CodeActActionParserAgentDelegate,\n+    CodeActActionParserCmdRun,\n+    CodeActActionParserFinish,\n+    CodeActActionParserIPythonRunCell,\n+    CodeActActionParserMessage,\n+    CodeActResponseParser,\n+)\n+from openhands.controller.action_parser import ActionParser\n+from openhands.events.action import (\n+    Action,\n+    AgentFinishAction,\n+)\n+\n+\n+class ExecutorResponseParser(CodeActResponseParser):\n+    \"\"\"Parser action:\n+    - CmdRunAction(command) - bash command to run\n+    - IPythonRunCellAction(code) - IPython code to run\n+    - AgentDelegateAction(agent, inputs) - delegate action for (sub)task\n+    - MessageAction(content) - Message action to run (e.g. ask for clarification)\n+    - AgentFinishAction() - end the interaction\n+    \"\"\"\n+\n+    def __init__(self):\n+        # Need pay attention to the item order in self.action_parsers\n+        super().__init__()\n+        self.action_parsers = [\n+            CodeActActionParserFinish(),\n+            CodeActActionParserCmdRun(),\n+            CodeActActionParserIPythonRunCell(),\n+            CodeActActionParserAgentDelegate(),\n+            CoActActionParserRequest(),\n+        ]\n+        self.default_parser = CodeActActionParserMessage()\n+\n+    def parse_response(self, response) -> str:\n+        action = response.choices[0].message.content\n+        if action is None:\n+            return ''\n+        for action_suffix in ['bash', 'ipython', 'browse', 'request']:\n+            if (\n+                f'<execute_{action_suffix}>' in action\n+                and f'</execute_{action_suffix}>' not in action\n+            ):\n+                action += f'</execute_{action_suffix}>'\n+        return action\n+\n+\n+class CoActActionParserRequest(ActionParser):\n+    def __init__(self):\n+        self.request = None\n+\n+    def check_condition(self, action_str: str) -> bool:\n+        self.request = re.search(\n+            r'<execute_request>(.*)</execute_request>', action_str, re.DOTALL\n+        )\n+        return self.request is not None\n+\n+    def parse(self, action_str: str) -> Action:\n+        assert (\n+            self.request is not None\n+        ), 'self.request should not be None when parse is called'\n+\n+        replan_request = self.request.group(1).strip()\n+        return AgentFinishAction(\n+            thought=replan_request,\n+            outputs={'content': replan_request},\n+        )\ndiff --git a/agenthub/coact_agent/executor/system_prompt.j2 b/agenthub/coact_agent/executor/system_prompt.j2\nnew file mode 100644\nindex 000000000000..ccc5e99f21ee\n--- /dev/null\n+++ b/agenthub/coact_agent/executor/system_prompt.j2\n@@ -0,0 +1,62 @@\n+{% set MINIMAL_SYSTEM_PREFIX %}\n+You are an autonomous intelligent programming agent playing the role of a subordinate employee responsible for local planning and execution of specific tasks in a multi-tier task execution structure, tasked with software development. You will be given coding-based tasks. The global agent has set a global plan for the tasks, divided into multiple phases. These phase plans will be given to you as a whole. Your responsibility is to perform them and return the results to the global agent. When you face some issues that require a new global plan, you can request a new global plan from the global planner agent.\n+\n+Here's the information you'll have:\n+* The user message and the broken-down phase list: These are the tasks you're trying to complete now. Because your plan may be part of a larger plan, you must only focus on the phases given to you.\n+* The current codebase: This is what you need to navigate through and make the changes to complete the tasks given by the global agent.\n+\n+The agent can use a Python environment with <execute_ipython>, e.g.:\n+<execute_ipython>\n+print(\"Hello World!\")\n+</execute_ipython>\n+\n+The agent can execute bash commands wrapped with <execute_bash>, e.g. <execute_bash> ls </execute_bash>.\n+If a bash command returns exit code `-1`, this means the process is not yet finished.\n+The assistant must then send a second <execute_bash>. The second <execute_bash> can be empty\n+(which will retrieve any additional logs), or it can contain text to be sent to STDIN of the running process,\n+or it can contain the text `ctrl+c` to interrupt the process.\n+\n+For commands that may run indefinitely, the output should be redirected to a file and the command run\n+in the background, e.g. <execute_bash> python3 app.py > server.log 2>&1 & </execute_bash>\n+If a command execution result says \"Command timed out. Sending SIGINT to the process\", the assistant should retry running the command in the background.\n+\n+As a local executor agent, there are some additional actions that you can use to communicate back to the global planner agent：\n+- `<execute_request>`: You have encountered an exception in the execution process. You suspect problems with the global planner's plan and trigger a request for replanning. Explain why you decide to request a new global plan using this action.\n+\n+{% endset %}\n+{% set BROWSING_PREFIX %}\n+The agent can browse the Internet with <execute_browse> and </execute_browse>.\n+For example, <execute_browse> Tell me the usa's president using google search </execute_browse>.\n+Or <execute_browse> Tell me what is in http://example.com </execute_browse>.\n+{% endset %}\n+{% set PIP_INSTALL_PREFIX %}\n+The agent can install Python packages using the %pip magic command in an IPython environment by using the following syntax: <execute_ipython> %pip install [package needed] </execute_ipython> and should always import packages and define variables before starting to use them.\n+{% endset %}\n+{% set SYSTEM_PREFIX = MINIMAL_SYSTEM_PREFIX + BROWSING_PREFIX + PIP_INSTALL_PREFIX %}\n+{% set COMMAND_DOCS %}\n+Apart from the standard Python library, the agent can also use the following functions (already imported) in <execute_ipython> environment:\n+{{ agent_skills_docs }}\n+IMPORTANT:\n+- `open_file` only returns the first 100 lines of the file by default! The agent MUST use `scroll_down` repeatedly to read the full file BEFORE making edits!\n+- The agent shall adhere to THE `edit_file_by_replace`, `append_file` and `insert_content_at_line` FUNCTIONS REQUIRING PROPER INDENTATION. If the agent would like to add the line '        print(x)', it must fully write the line out, with all leading spaces before the code!\n+- Indentation is important and code that is not indented correctly will fail and require fixing before it can be run.\n+- Any code issued should be less than 50 lines to avoid context being cut off!\n+- After EVERY `create_file` the method `append_file` shall be used to write the FIRST content!\n+- For `edit_file_by_replace` NEVER provide empty parameters!\n+- For `edit_file_by_replace` the file must be read fully before any replacements!\n+{% endset %}\n+{% set SYSTEM_SUFFIX %}\n+Responses should be concise.\n+The agent should attempt fewer things at a time instead of putting too many commands OR too much code in one \"execute\" block.\n+Include ONLY ONE <execute_ipython>, <execute_bash>, or <execute_browse> per response, unless the agent is finished with the task or needs more input or action from the user in order to proceed.\n+If the agent is finished with the task you MUST include <finish></finish> in your response.\n+IMPORTANT: Execute code using <execute_ipython>, <execute_bash>, or <execute_browse> whenever possible.\n+The agent should utilize full file paths and the `pwd` command to prevent path-related errors.\n+The agent must avoid apologies and thanks in its responses.\n+Remeber to execute ALL the phases of the global plan and only return the summary of the whole process to the global agent. Strictly follow it and do NOT do anything beyond the scope of the global plan.\n+\n+{% endset %}\n+{# Combine all parts without newlines between them #}\n+{{ SYSTEM_PREFIX -}}\n+{{- COMMAND_DOCS -}}\n+{{- SYSTEM_SUFFIX }}\ndiff --git a/agenthub/coact_agent/executor/user_prompt.j2 b/agenthub/coact_agent/executor/user_prompt.j2\nnew file mode 100644\nindex 000000000000..020d015a4228\n--- /dev/null\n+++ b/agenthub/coact_agent/executor/user_prompt.j2\n@@ -0,0 +1,290 @@\n+{% set DEFAULT_EXAMPLE %}\n+--- START OF EXAMPLE 1 ---\n+\n+USER: The user message is: \"Create a list of numbers from 1 to 10, and display them in a web page at port 5000. There's an existing Python file `app.py` that you can use.\"\n+Execute the following plan to fulfill it:\n+# Phases\n+## Phase 1\n+- description: Edit the existing Python file `app.py` to insert the code for starting a web server, at the end of the file.\n+- reason: The existing Python file is missing the code to start the web server. Normally, the server is started using the `app.run(port=5000)` command. This phase will add this necessary code in a __main__ block to start the server. You can use the `insert_content_at_line` function or other appropriate ways to add the code.\n+- expected_state: The Python file `app.py` is updated with the code to start the web server.\n+<file_path> /workspace/app.py </file_path>\n+<expected_content>\n+8|\n+9|if __name__ == '__main__':\n+10|    app.run(port=5000)\n+</expected_content>\n+## Phase 2\n+- description: Run the Python file `app.py` to display the list of numbers on a web page at port 5000.\n+- reason: After updating the Python file, we need to run it to display the list of numbers on a web page. The command a shell command can be: `python3 app.py`.\n+- expected_state: The list of numbers is displayed on a web page at port 5000.\n+\n+ASSISTANT:\n+Let's start with the first phase: editing the Python file `app.py` to insert the code for starting a web server at line 8. I will open the file at that line to check its current content:\n+<execute_ipython>\n+open_file('/workspace/app.py', 8)\n+</execute_ipython>\n+\n+USER:\n+OBSERVATION:\n+[File: /workspace/app.py (8 lines total)]\n+(this is the beginning of the file)\n+1|from flask import Flask\n+2|app = Flask(__name__)\n+3|\n+4|@app.route('/')\n+5|def index():\n+6|    numbers = list(range(1, 11))\n+7|    return str(numbers)\n+8|\n+(this is the end of the file)\n+\n+ASSISTANT:\n+As expected, the file is missing the code to start the web server. Now I will write the task from the plan and save it to the file `app.py`:\n+<execute_ipython>\n+EDITED_CODE=\"\"\"\n+if __name__ == '__main__':\n+    app.run(port=5000)\"\"\"\n+\n+insert_content_at_line(\n+  'app.py',\n+  8,\n+  EDITED_CODE,\n+)\n+</execute_ipython>\n+\n+USER:\n+OBSERVATION:\n+(this is the beginning of the file)\n+1|from flask import Flask\n+2|app = Flask(__name__)\n+3|\n+4|@app.route('/')\n+5|def index():\n+6|    numbers = list(range(1, 11))\n+7|    return str(numbers)\n+8|\n+9|if __name__ == '__main__':\n+10|    app.run(port=5000)\n+(this is the end of the file)\n+[File updated (edited at line 9). Please review the changes and make sure they are correct (correct indentation, no duplicate lines, etc). Edit the file again if necessary.]\n+\n+ASSISTANT:\n+I have updated the Python file `app.py` to properly start the web server and display a list of numbers from 1 to 10 when you run it. Let's proceed to phase 2 to run the Python file:\n+<execute_bash>\n+python3 app.py > server.log 2>&1 &\n+</execute_bash>\n+\n+USER:\n+OBSERVATION:\n+[1] 121[1]+  Exit 1                  python3 app.py > server.log 2>&1\n+\n+ASSISTANT: Looks like the server is running with PID 121 then crashed. Let me check the server log:\n+<execute_bash>\n+cat server.log\n+</execute_bash>\n+\n+USER:\n+OBSERVATION:\n+Traceback (most recent call last):\n+  File \"/workspace/app.py\", line 2, in <module>\n+    from flask import Flask\n+ModuleNotFoundError: No module named 'flask'\n+\n+ASSISTANT:\n+It seems that Flask is not installed. Let me install Flask for you:\n+<execute_bash>\n+pip install flask\n+</execute_bash>\n+\n+USER:\n+OBSERVATION:\n+Defaulting to user installation because normal site-packages is not writeable\n+Collecting flask\n+  Using cached flask-3.0.3-py3-none-any.whl (101 kB)\n+Collecting blinker>=1.6.2\n+  Using cached blinker-1.7.0-py3-none-any.whl (13 kB)\n+Collecting Werkzeug>=3.0.0\n+  Using cached werkzeug-3.0.2-py3-none-any.whl (226 kB)\n+Collecting click>=8.1.3\n+  Using cached click-8.1.7-py3-none-any.whl (97 kB)\n+Collecting itsdangerous>=2.1.2\n+  Using cached itsdangerous-2.2.0-py3-none-any.whl (16 kB)\n+Requirement already satisfied: Jinja2>=3.1.2 in /home/openhands/.local/lib/python3.10/site-packages (from flask) (3.1.3)\n+Requirement already satisfied: MarkupSafe>=2.0 in /home/openhands/.local/lib/python3.10/site-packages (from Jinja2>=3.1.2->flask) (2.1.5)\n+Installing collected packages: Werkzeug, itsdangerous, click, blinker, flask\n+Successfully installed Werkzeug-3.0.2 blinker-1.7.0 click-8.1.7 flask-3.0.3 itsdangerous-2.2.0\n+\n+ASSISTANT:\n+Now that Flask is installed, let me run the Python file again:\n+<execute_bash>\n+python3 app.py > server.log 2>&1 &\n+</execute_bash>\n+\n+USER:\n+OBSERVATION:\n+[1] 124\n+\n+ASSISTANT:\n+Let me check the server log again:\n+<execute_bash>\n+cat server.log\n+</execute_bash>\n+\n+USER:\n+OBSERVATION:\n+* Serving Flask app 'app'\n+ * Debug mode: off\n+WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n+ * Running on http://127.0.0.1:5000\n+Press CTRL+C to quit\n+\n+ASSISTANT:\n+The server is running on port 5000 with PID 124. You can access the list of numbers by visiting http://127.0.0.1:5000. The tasks are now complete.\n+Summary:\n+- Edited the existing Python file `app.py` to insert the code for starting a web server.\n+- Ran the Python file to display the list of numbers on a web page at port 5000.\n+<finish></finish>\n+\n+--- END OF EXAMPLE 1 ---\n+\n+--- START OF EXAMPLE 2 ---\n+\n+USER: The user message is: \"Now browse the newly started server's homepage and show me the content.\"\n+Execute the following plan to fulfill it:\n+# Phases\n+## Phase 1\n+- description: Browse the server's homepage at http://127.0.0.1:5000\n+- reason: To verify that the server is running and displaying the list of numbers correctly, we need to browse the server's homepage. We can use the `execute_browse` function to access the URL.\n+- expected_state: The content of the server's homepage is retrieved.\n+\n+ASSISTANT:\n+Sure! Let me start the first phase by browsing the server's homepage at http://127.0.0.1:5000:\n+<execute_browse>\n+Get the content on \"http://127.0.0.1:5000\"\n+</execute_browse>\n+\n+USER:\n+OBSERVATION:\n+[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n+\n+ASSISTANT:\n+The content of the server's homepage is \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\". The tasks are now complete.\n+Summary:\n+- Browsed the server's homepage at http://127.0.0.1:5000 and retrieved the content \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\".\n+<finish></finish>\n+\n+--- END OF EXAMPLE 2 ---\n+\n+--- START OF EXAMPLE 3 ---\n+\n+USER: The user message is: \"Now kill the server, make it display the numbers in a table format.\"\n+Execute the following plan to fulfill it:\n+# Phases\n+## Phase 1\n+- description: Stop the server running on port 5000.\n+- reason: The server needs to be stopped before modifying the Python code.\n+- expected_state: The server is stopped.\n+## Phase 2\n+- description: Modify the Python code to display the numbers in a table format.\n+- reason: The current code returns the numbers as a string, which is incorrect. We need to modify it, starting at line 6, to display the numbers in a table format by using HTML tags for table rows and cells.\n+- expected_state: The Python code is updated to display the numbers in a table format.\n+<file_path> /workspace/app.py </file_path>\n+<expected_content>\n+6|    numbers = list(range(1, 11))\n+7|    return \"<table>\" + \"\".join([f\"<tr><td>{num}</td></tr>\" for num in numbers]) + \"</table>\"\n+</expected_content>\n+## Phase 3\n+- description: Run the Python file again to display the numbers in a table format on the web page at port 5000.\n+- reason: After modifying the Python code, we need to run the file again to display the numbers in the expected table format.\n+- expected_state: The numbers are displayed in a table format on the web page.\n+\n+ASSISTANT:\n+Sure! Let me execute the first phase to stop the server first:\n+<execute_bash>\n+kill 124\n+</execute_bash>\n+\n+USER:\n+OBSERVATION:\n+[1]+  Terminated              python3 app.py > server.log 2>&1\n+\n+ASSISTANT:\n+The server has been stopped. Let me move to the second phase to open the Python file at line 6 and modify it.\n+<execute_ipython>\n+open_file('app.py', 6)\n+</execute_ipython>\n+\n+USER:\n+[File: /workspace/app.py (10 lines total)]\n+(this is the beginning of the file)\n+1|from flask import Flask\n+2|app = Flask(__name__)\n+3|\n+4|@app.route('/')\n+5|def index():\n+6|    numbers = list(range(1, 11))\n+7|    return str(numbers)\n+8|\n+9|if __name__ == '__main__':\n+10|    app.run(port=5000)\n+(this is the end of the file)\n+\n+ASSISTANT:\n+I should edit the file to display the numbers in a table format. I should include correct indentation. Let me update the file:\n+<execute_ipython>\n+edit_file_by_replace(\n+  'app.py',\n+  to_replace=\"    return str(numbers)\",\n+  new_content=\"    return '<table>' + ''.join([f'<tr><td>{i}</td></tr>' for i in numbers]) + '</table>'\",\n+)\n+</execute_ipython>\n+\n+USER:\n+Observation:\n+[File: /workspace/app.py (10 lines total after edit)]\n+(this is the beginning of the file)\n+1|from flask import Flask\n+2|app = Flask(__name__)\n+3|\n+4|@app.route('/')\n+5|def index():\n+6|    numbers = list(range(1, 11))\n+7|    return '<table>' + ''.join([f'<tr><td>{i}</td></tr>' for i in numbers]) + '</table>'\n+8|\n+9|if __name__ == '__main__':\n+10|    app.run(port=5000)\n+(this is the end of the file)\n+[File updated (edited at line 7). Please review the changes and make sure they are correct (correct indentation, no duplicate lines, etc). Edit the file again if necessary.]\n+\n+ASSISTANT:\n+Now, let's move the third phase: to run the updated file:\n+<execute_bash>\n+python3 app.py > server.log 2>&1 &\n+</execute_bash>\n+\n+USER:\n+Observation:\n+[1] 126\n+\n+ASSISTANT:\n+The server is running on port 5000 with PID 126. You can access the list of numbers in a table format by visiting http://127.0.0.1:5000. The tasks are now complete.\n+Summary:\n+- Stopped the server running on port 5000.\n+- Modified the Python code to display the numbers in a table format.\n+- Ran the Python file again to display the numbers in a table format on the web page at port 5000.\n+<finish></finish>\n+\n+--- END OF EXAMPLE 3 ---\n+{% endset %}\n+Here is an example of how you can interact with the environment for task solving:\n+{{ DEFAULT_EXAMPLE }}\n+{% if micro_agent %}\n+--- BEGIN OF GUIDELINE ---\n+The following information may assist you in completing your task:\n+\n+{{ micro_agent }}\n+--- END OF GUIDELINE ---\n+{% endif %}\n+\n+NOW, LET'S START!\ndiff --git a/agenthub/coact_agent/planner/action_parser.py b/agenthub/coact_agent/planner/action_parser.py\nnew file mode 100644\nindex 000000000000..955e02a17442\n--- /dev/null\n+++ b/agenthub/coact_agent/planner/action_parser.py\n@@ -0,0 +1,100 @@\n+import re\n+\n+from agenthub.codeact_agent.action_parser import (\n+    CodeActActionParserAgentDelegate,\n+    CodeActActionParserCmdRun,\n+    CodeActActionParserFinish,\n+    CodeActActionParserIPythonRunCell,\n+    CodeActActionParserMessage,\n+    CodeActResponseParser,\n+)\n+from openhands.controller.action_parser import ActionParser\n+from openhands.events.action import (\n+    Action,\n+    AgentDelegateAction,\n+)\n+\n+\n+class PlannerResponseParser(CodeActResponseParser):\n+    \"\"\"Parser action:\n+    - CmdRunAction(command) - bash command to run\n+    - IPythonRunCellAction(code) - IPython code to run\n+    - AgentDelegateAction(agent, inputs) - delegate action for (sub)task\n+    - MessageAction(content) - Message action to run (e.g. ask for clarification)\n+    - AgentFinishAction() - end the interaction\n+    \"\"\"\n+\n+    def __init__(self, initial_task_str=None):\n+        # Need pay attention to the item order in self.action_parsers\n+        super().__init__()\n+        self.action_parsers = [\n+            CodeActActionParserFinish(),\n+            CodeActActionParserCmdRun(),\n+            CodeActActionParserIPythonRunCell(),\n+            CodeActActionParserAgentDelegate(),\n+            CoActActionParserGlobalPlan(initial_task_str=initial_task_str),\n+        ]\n+        self.default_parser = CodeActActionParserMessage()\n+\n+    def parse_response(self, response) -> str:\n+        action = response.choices[0].message.content\n+        if action is None:\n+            return ''\n+        for action_suffix in [\n+            'bash',\n+            'ipython',\n+            'browse',\n+            'global_plan',\n+            'decide',\n+            'revise',\n+            'overrule',\n+            'collation',\n+        ]:\n+            if (\n+                f'<execute_{action_suffix}>' in action\n+                and f'</execute_{action_suffix}>' not in action\n+            ):\n+                action += f'</execute_{action_suffix}>'\n+        return action\n+\n+\n+class CoActActionParserGlobalPlan(ActionParser):\n+    \"\"\"Parser action:\n+    - AgentDelegateAction(agent, inputs) - delegate action for (sub)task\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        initial_task_str: list | None = None,\n+    ):\n+        self.global_plan: re.Match | None = None\n+        self.initial_task_str = initial_task_str or ['']\n+\n+    def check_condition(self, action_str: str) -> bool:\n+        self.global_plan = re.search(\n+            r'<execute_global_plan>(.*)</execute_global_plan>', action_str, re.DOTALL\n+        )\n+        return self.global_plan is not None\n+\n+    def parse(self, action_str: str) -> Action:\n+        assert (\n+            self.global_plan is not None\n+        ), 'self.global_plan should not be None when parse is called'\n+        thought = action_str.replace(self.global_plan.group(0), '').strip()\n+        global_plan_actions = self.global_plan.group(1).strip()\n+\n+        # Some extra processing when doing swe-bench eval: extract text up to and including '--- END ISSUE ---'\n+        issue_text_pattern = re.compile(r'(.*--- END ISSUE ---)', re.DOTALL)\n+        issue_text_match = issue_text_pattern.match(self.initial_task_str[0])\n+\n+        if issue_text_match:\n+            self.initial_task_str[0] = issue_text_match.group(1)\n+\n+        return AgentDelegateAction(\n+            agent='CoActExecutorAgent',\n+            thought=thought,\n+            inputs={\n+                'task': f'The user message is: {self.initial_task_str[0]}.\\nExecute the following plan to fulfill it:\\n{global_plan_actions}'\n+            },\n+            action_suffix='global_plan',\n+        )\ndiff --git a/agenthub/coact_agent/planner/planner_agent.py b/agenthub/coact_agent/planner/planner_agent.py\nnew file mode 100644\nindex 000000000000..cbacb8faf777\n--- /dev/null\n+++ b/agenthub/coact_agent/planner/planner_agent.py\n@@ -0,0 +1,51 @@\n+import os\n+\n+from agenthub.coact_agent.planner.action_parser import PlannerResponseParser\n+from agenthub.codeact_agent.codeact_agent import CodeActAgent\n+from openhands.core.config import AgentConfig\n+from openhands.llm.llm import LLM\n+from openhands.runtime.plugins.agent_skills.agentskills import (\n+    DOCUMENTATION_DICT as AGENTSKILLS_DOCS_DICT,\n+)\n+from openhands.utils.prompt import PromptManager\n+\n+\n+class GlobalPlannerAgent(CodeActAgent):\n+    VERSION = '1.0'\n+\n+    def __init__(self, llm: LLM, config: AgentConfig) -> None:\n+        super().__init__(llm, config)\n+\n+        self.action_parser = PlannerResponseParser(\n+            initial_task_str=self.initial_task_str\n+        )\n+\n+        # Planner agent can do everything except file-editing operations\n+        planner_agentskills_exclude = [\n+            'create_file',\n+            'edit_file_by_replace',\n+            'insert_content_at_line',\n+            'append_file',\n+        ]\n+        planner_agentskills = [\n+            v\n+            for k, v in AGENTSKILLS_DOCS_DICT.items()\n+            if k not in planner_agentskills_exclude\n+        ]\n+        executor_editing_agentskills = [\n+            v\n+            for k, v in AGENTSKILLS_DOCS_DICT.items()\n+            if k in planner_agentskills_exclude\n+        ]\n+        self.prompt_manager = PromptManager(\n+            prompt_dir=os.path.join(os.path.dirname(__file__)),\n+            agent_skills_docs=''.join(planner_agentskills),\n+            system_extra_vars={\n+                'executor_editing_agent_skills_docs': ''.join(\n+                    executor_editing_agentskills\n+                )\n+            },\n+            micro_agent=self.micro_agent,\n+        )\n+\n+        self.stop_sequences.append('</execute_global_plan>')\ndiff --git a/agenthub/coact_agent/planner/system_prompt.j2 b/agenthub/coact_agent/planner/system_prompt.j2\nnew file mode 100644\nindex 000000000000..2dc430ba9fc6\n--- /dev/null\n+++ b/agenthub/coact_agent/planner/system_prompt.j2\n@@ -0,0 +1,95 @@\n+{% set MINIMAL_SYSTEM_PREFIX %}\n+You are an autonomous intelligent agent playing the role of a strategic leader in a multi-tier task execution structure, tasked with performing programming tasks. You will be given coding-related tasks. Your responsibility is to provide high-level, strategic plans with phases that can be executed by the local agent and thorough explanations for each phase for local agent's understanding.\n+\n+Here's the information you'll have:\n+* The user's objective: This is the task you're trying to complete.\n+* The user's codebase: This is what you need to navigate and use to define the plan.\n+\n+The structure of the global plan should be as follows:\n+<execute_global_plan>\n+# Phases\n+## Phase 1\n+- reason: <<Assistant's thorough thoughts on why this phase is necessary. The planner can add some tips/codes to instruct the executor finish the task easier.>>\n+- description: <<Describe what needs to be done in this phase.>>\n+- expected_state: <<Describe the expected state after this phase is completed. If the task involves code editing, provide the expectation of the code after the edit.>>\n+<file_path> <<Optinal - Provide the file path here. In one phase only 1 file is edited.>> </file_path>\n+<expected_content>\n+<<Optional - Provide the expected content here WITH LINE NUMBERS and a vertical bar before the actual code e.g., 1|, 11|,. Only use partial content to avoid repetition.>>\n+</expected_content>\n+## Phase 2\n+- reason: ...\n+- description: ...\n+- expected_state: ...\n+<file_path> ... </file_path>\n+<expected_content>\n+...|...\n+</expected_content>\n+## Phase ...\n+</execute_global_plan>\n+\n+You can use a Python environment with <execute_ipython>, e.g.:\n+<execute_ipython>\n+print(\"Hello World!\")\n+</execute_ipython>\n+\n+The agent can execute bash commands wrapped with <execute_bash>, e.g. <execute_bash> ls </execute_bash>.\n+If a bash command returns exit code `-1`, this means the process is not yet finished.\n+The assistant must then send a second <execute_bash>. The second <execute_bash> can be empty\n+(which will retrieve any additional logs), or it can contain text to be sent to STDIN of the running process,\n+or it can contain the text `ctrl+c` to interrupt the process.\n+\n+For commands that may run indefinitely, the output should be redirected to a file and the command run\n+in the background, e.g. <execute_bash> python3 app.py > server.log 2>&1 & </execute_bash>\n+If a command execution result says \"Command timed out. Sending SIGINT to the process\", the assistant should retry running the command in the background.\n+\n+As a planner agent, there are some additional actions that you can use to communicate and delegate tasks to the local agent：\n+- `<execute_global_plan>`: Construct a multi-stage global plan, providing separate subtask descriptions and expected states for each phase.\n+{% endset %}\n+{% set PIP_INSTALL_PREFIX %}\n+The agent can install Python packages using the %pip magic command in an IPython environment by using the following syntax: <execute_ipython> %pip install [package needed] </execute_ipython> and should always import packages and define variables before starting to use them.\n+{% endset %}\n+{% set SYSTEM_PREFIX = MINIMAL_SYSTEM_PREFIX + PIP_INSTALL_PREFIX %}\n+{% set COMMAND_DOCS %}\n+Apart from the standard Python library, the agent can also use the following functions (already imported) in <execute_ipython> environment:\n+{{ planner_agent_skills_docs }}\n+IMPORTANT:\n+- Prefer to use these functions to interact with the codebase if possible, instead of using bash commands like `cat`, which are less efficient when the files are very large.\n+- `open_file` only returns the first 100 lines of the file by default! The agent MUST use `scroll_down` repeatedly to read the full file BEFORE making edits!\n+- NEVER use MORE THAN 5 consecutive `scroll_down` commands. When you use `open_file` and see that the file is too large, try to use search functions above to locate the relevant code, which can save you a lot of time.\n+- Don't be too tempted to construct your own functions, instead prefer to use above provided functions to interact with the codebase.\n+\n+IMPORTANT FOR CREATING FUNCTION_CALLS FOR LOCAL AGENT:\n+- The call shall adhere to THE `edit_file_by_replace`, `append_file` and `insert_content_at_line` FUNCTIONS REQUIRING PROPER INDENTATION. If the agent would like to add the line '        print(x)', it must fully write the line out, with all leading spaces before the code!\n+- Indentation is important and code that is not indented correctly will fail and require fixing before it can be run.\n+- Any code issued should be less than 50 lines to avoid context being cut off!\n+- After EVERY `create_file` the method `append_file` shall be used to write the FIRST content!\n+- For `edit_file_by_replace` NEVER provide empty parameters!\n+- For `edit_file_by_replace` the file must be read fully before any replacements!\n+{% endset %}\n+{% set EXECUTOR_SKILLS %}\n+Importantly, apart from the above functions, the local executor agent can use the following additional ones (already imported) in <execute_ipython> environment:\n+{{ executor_editing_agent_skills_docs }}\n+Create plans with phases that use those functions and always include all necessary parameters for editing-related functions so that the local agent doesn't need to waste resources to find them again.\n+{% endset %}\n+{% set SYSTEM_SUFFIX %}\n+{% endset %}\n+{% set SYSTEM_SUFFIX %}\n+Responses should be concise.\n+The agent should attempt fewer things at a time instead of putting too many commands OR too much code in one \"execute\" block.\n+Include ONLY ONE <execute_ipython>, or <execute_bash> per response, unless the agent is finished with the task or needs more input or action from the user in order to proceed.\n+If the agent is finished with the task you MUST include <finish></finish> in your response.\n+IMPORTANT: Execute code using <execute_ipython>, or <execute_bash> whenever possible.\n+The agent should utilize full file paths and the `pwd` command to prevent path-related errors.\n+The agent must avoid apologies and thanks in its responses.\n+The planner agent can only use <execute_browse> to browse the Internet if it's required to come up with the plan. To delegate the plan, please only use <execute_global_plan>.\n+The planner agent can navigate the codebase to locate the necessary information to construct the plan.\n+After the local agent successfully completes the plan without any issues, you can collate the result and if it is good, you can exit.\n+Remember to create an as-detailed-as-possible plan for the local agent to follow, but with minimal number of phases.\n+Do NOT repeat what you have done into the plan, only provide the minimal required steps remaining for the local agent to follow to resolve the task. For example, if you have examined the codebase with a lot of steps and found the relevant code, just provide them with the plan to edit it.\n+The planner agent must NEVER perform the plan by itself and must delegate the plan to the local agent using <execute_global_plan>. Do not go beyond this scope.\n+\n+{% endset %}\n+{# Combine all parts without newlines between them #}\n+{{ SYSTEM_PREFIX -}}\n+{{- COMMAND_DOCS -}}\n+{{- SYSTEM_SUFFIX }}\ndiff --git a/agenthub/coact_agent/planner/user_prompt.j2 b/agenthub/coact_agent/planner/user_prompt.j2\nnew file mode 100644\nindex 000000000000..5cf7b3bbd40d\n--- /dev/null\n+++ b/agenthub/coact_agent/planner/user_prompt.j2\n@@ -0,0 +1,181 @@\n+{% set DEFAULT_EXAMPLE %}\n+--- START OF EXAMPLE 1 ---\n+\n+USER: I want to go to the user 'Every-Hands-AI' github profile using browser and check how many repos they have, then write the number to the new 'repo_count.txt' file. Use a plan that has the least number of steps.\n+\n+ASSISTANT:\n+I have enough information, let's create a plan to achieve the task:\n+<execute_global_plan>\n+# Phases\n+## Phase 1\n+- reason: As the first step, we need to identify the number of repositories in the user's GitHub profile.\n+- description: Browse the GitHub profile of the user 'Every-Hands-AI' to find the number of repositories.\n+- expected_state: The number of repositories is identified.\n+## Phase 2\n+- reason: The number of repositories should be stored in a file as requested by the user.\n+- description: Create a new file `repo_count.txt` and write the number of repositories to it.\n+- expected_state: The file `repo_count.txt` is created and contains the number of repositories.\n+</execute_global_plan>\n+\n+USER:\n+OBSERVATION:\n+LocalExecutorAgent finishes task with content: The GitHub profile 'Every-Hands-AI' does not exist or is not accessible. Please provide a new global plan with a valid GitHub username or an alternative task.\n+\n+ASSISTANT:\n+It seems the GitHub profile 'Every-Hands-AI' does not exist or is not accessible. Please provide a valid GitHub username or an alternative task.\n+\n+USER:\n+Sorry, the correct github handle is \"All-Hands-AI\".\n+\n+ASSISTANT:\n+Let's create a new plan to achieve the task:\n+<execute_global_plan>\n+# Phases\n+## Phase 1\n+- reason: As the first step, we need to identify the number of repositories in the user's GitHub profile.\n+- description: Browse the GitHub profile of the user 'All-Hands-AI' to find the number of repositories.\n+- expected_state: The number of repositories is identified.\n+## Phase 2\n+- reason: The number of repositories should be stored in a file as requested by the user.\n+- description: Create a new file `repo_count.txt` and write the number of repositories to it.\n+- expected_state: The file `repo_count.txt` is created and contains the number of repositories.\n+</execute_global_plan>\n+\n+USER:\n+OBSERVATION:\n+LocalExecutorAgent finishes task with content: The file repo_count.txt has been successfully updated with the number of repositories. The tasks are now complete.\n+Summary:\n+- Browsed the GitHub profile of the user 'All-Hands-AI' and found that the number of repositories is 2.\n+- Appended the number of repositories to the file repo_count.txt.\n+\n+ASSISTANT:\n+The tasks have been successfully completed. The file repo_count.txt has been created and updated with the number of repositories (2) for the user 'All-Hands-AI'.\n+If you have any further requests, feel free to ask. Otherwise, I will consider the task complete.\n+<finish></finish>\n+\n+--- END OF EXAMPLE 1 ---\n+\n+--- START OF EXAMPLE 2 ---\n+\n+USER: Create a list of numbers from 1 to 10, and display them in a web page at port 5000. There's an existing Python file `app.py` that you can use.\n+\n+ASSISTANT: Let's check the existing Python file `app.py`:\n+<execute_ipython>\n+open_file('app.py')\n+</execute_ipython>\n+\n+USER:\n+OBSERVATION:\n+[File: /workspace/app.py (8 lines total)]\n+(this is the beginning of the file)\n+1|from flask import Flask\n+2|app = Flask(__name__)\n+3|\n+4|@app.route('/')\n+5|def index():\n+6|    numbers = list(range(1, 11))\n+7|    return str(numbers)\n+8|\n+(this is the end of the file)\n+\n+ASSISTANT:\n+Great! Seems like the existing Python file `app.py` is ready to display a list of numbers from 1 to 10, but it's missing the code to start the web server. Let me create a plan to achieve the task:\n+<execute_global_plan>\n+# Phases\n+## Phase 1\n+- reason: The existing Python file is missing the code to start the web server. Normally, the server is started using the `app.run(port=5000)` command. This phase will add this necessary code in a __main__ block to start the server. You can use the `insert_content_at_line` function or other appropriate ways to add the code.\n+- description: Edit the existing Python file `app.py` to insert the code for starting a web server, at the end of the file.\n+- expected_state: The Python file `app.py` is updated with the code to start the web server.\n+<file_path> /workspace/app.py </file_path>\n+<expected_content>\n+8|\n+9|if __name__ == '__main__':\n+10|    app.run(port=5000)\n+</expected_content>\n+## Phase 2\n+- reason: After updating the Python file, we need to run it to display the list of numbers on a web page. The command a shell command can be: `python3 app.py`.\n+- description: Run the Python file `app.py` to display the list of numbers on a web page at port 5000.\n+- expected_state: The list of numbers is displayed on a web page at port 5000.\n+</execute_global_plan>\n+\n+USER:\n+OBSERVATION:\n+LocalExecutorAgent finishes task with content: The server is running on port 5000 with PID 124. You can access the list of numbers by visiting http://127.0.0.1:5000. The tasks are now complete.\n+Summary:\n+- Edited the existing Python file `app.py` to insert the code for starting a web server.\n+- Ran the Python file to display the list of numbers on a web page at port 5000.\n+\n+ASSISTANT:\n+The server is running on port 5000 with PID 124. You can access the list of numbers by visiting http://127.0.0.1:5000. If you have any further questions, feel free to ask!\n+\n+USER: Now browse the newly started server's homepage and show me the content.\n+\n+ASSISTANT:\n+Sure, let me create a plan to achieve the task:\n+<execute_global_plan>\n+# Phases\n+## Phase 1\n+- reason: To verify that the server is running and displaying the list of numbers correctly, we need to browse the server's homepage. We can use the `execute_browse` function to access the URL.\n+- description: Browse the server's homepage at http://127.0.0.1:5000\n+- expected_state: The content of the server's homepage is retrieved.\n+</execute_global_plan>\n+\n+USER:\n+OBSERVATION:\n+LocalExecutorAgent finishes task with content: The content of the server's homepage is \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\". The tasks are now complete.\n+Summary:\n+- Browsed the server's homepage at http://127.0.0.1:5000 and retrieved the content \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\".\n+\n+ASSISTANT:\n+The content of the server's homepage is \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\". If you have any further questions, feel free to ask!\n+\n+USER: Now kill the server, make it display the numbers in a table format.\n+\n+ASSISTANT:\n+Sure! Let me create a plan to achieve the task:\n+<execute_global_plan>\n+# Phases\n+## Phase 1\n+- reason: The server needs to be stopped before modifying the Python code.\n+- description: Stop the server running on port 5000.\n+- expected_state: The server is stopped.\n+## Phase 2\n+- reason: The current code returns the numbers as a string, which is incorrect. We need to modify it, starting at line 6, to display the numbers in a table format by using HTML tags for table rows and cells.\n+- description: Modify the Python code to display the numbers in a table format.\n+- expected_state: The Python code is updated to display the numbers in a table format.\n+<file_path> /workspace/app.py </file_path>\n+<expected_content>\n+6|    numbers = list(range(1, 11))\n+7|    return \"<table>\" + \"\".join([f\"<tr><td>{num}</td></tr>\" for num in numbers]) + \"</table>\"\n+</expected_content>\n+## Phase 3\n+- reason: After modifying the Python code, we need to run the file again to display the numbers in the expected table format.\n+- description: Run the Python file again to display the numbers in a table format on the web page at port 5000.\n+- expected_state: The numbers are displayed in a table format on the web page.\n+</execute_global_plan>\n+\n+USER:\n+OBSERVATION:\n+LocalExecutorAgent finishes task with content: The server is running on port 5000 with PID 126. You can access the list of numbers in a table format by visiting http://127.0.0.1:5000. The tasks are now complete.\n+Summary:\n+- Stopped the server running on port 5000.\n+- Modified the Python code to display the numbers in a table format.\n+- Ran the Python file again to display the numbers in a table format on the web page at port 5000.\n+\n+ASSISTANT:\n+The server is running on port 5000 with PID 126. You can access the list of numbers in a table format by visiting http://127.0.0.1:5000. Let me know if you have any further requests!\n+<finish></finish>\n+\n+--- END OF EXAMPLE 2 ---\n+{% endset %}\n+Here is an example of how you can interact with the environment for task solving:\n+{{ DEFAULT_EXAMPLE }}\n+{% if micro_agent %}\n+--- BEGIN OF GUIDELINE ---\n+The following information may assist you in completing your task:\n+\n+{{ micro_agent }}\n+--- END OF GUIDELINE ---\n+{% endif %}\n+\n+NOW, LET'S START!\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR presents initial testing results for CoAct and CodeAct v1.8 across 13 common instances. CoAct resolved 8/13, while CodeAct v1.8 managed 9/13, which is decent for a first draft. There are significant issues, notably with timeout and multiprocessing when utilizing more than one worker. The agent's trajectory evaluation lacks clarity, and the serialization of actions differs from CodeAct's usual format, potentially causing confusion. Before proceeding, further evaluation on a broader set is recommended, as the current results may not be robust enough for acceptance."
      }
    ],
    "token_estimation": 10412.75
  },
  {
    "index": 63,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/openhands/core/config/mcp_config.py b/openhands/core/config/mcp_config.py\nnew file mode 100644\nindex 000000000000..1a80f033223a\n--- /dev/null\n+++ b/openhands/core/config/mcp_config.py\n@@ -0,0 +1,68 @@\n+from typing import List\n+from urllib.parse import urlparse\n+\n+from pydantic import BaseModel, Field, ValidationError\n+\n+\n+class MCPSSEConfig(BaseModel):\n+    \"\"\"Configuration for MCP SSE (Server-Sent Events) settings.\n+\n+    Attributes:\n+        mcp_servers: List of MCP server URLs.\n+    \"\"\"\n+\n+    mcp_servers: List[str] = Field(default_factory=list)\n+\n+    model_config = {'extra': 'forbid'}\n+\n+    def validate_servers(self) -> None:\n+        \"\"\"Validate that server URLs are valid and unique.\"\"\"\n+        # Check for duplicate server URLs\n+        if len(set(self.mcp_servers)) != len(self.mcp_servers):\n+            raise ValueError('Duplicate MCP server URLs are not allowed')\n+\n+        # Validate URLs\n+        for url in self.mcp_servers:\n+            try:\n+                result = urlparse(url)\n+                if not all([result.scheme, result.netloc]):\n+                    raise ValueError(f'Invalid URL format: {url}')\n+            except Exception as e:\n+                raise ValueError(f'Invalid URL {url}: {str(e)}')\n+\n+\n+class MCPConfig(BaseModel):\n+    \"\"\"Configuration for MCP (Message Control Protocol) settings.\n+\n+    Attributes:\n+        sse: SSE-specific configuration.\n+    \"\"\"\n+\n+    sse: MCPSSEConfig = Field(default_factory=MCPSSEConfig)\n+\n+    model_config = {'extra': 'forbid'}\n+\n+    @classmethod\n+    def from_toml_section(cls, data: dict) -> dict[str, 'MCPConfig']:\n+        \"\"\"\n+        Create a mapping of MCPConfig instances from a toml dictionary representing the [mcp] section.\n+\n+        The configuration is built from all keys in data.\n+\n+        Returns:\n+            dict[str, MCPConfig]: A mapping where the key \"mcp\" corresponds to the [mcp] configuration\n+        \"\"\"\n+        # Initialize the result mapping\n+        mcp_mapping: dict[str, MCPConfig] = {}\n+\n+        try:\n+            # Create SSE config if present\n+            sse_config = MCPSSEConfig.model_validate(data)\n+            sse_config.validate_servers()\n+\n+            # Create the main MCP config\n+            mcp_mapping['mcp'] = cls(sse=sse_config)\n+        except ValidationError as e:\n+            raise ValueError(f'Invalid MCP configuration: {e}')\n+\n+        return mcp_mapping\ndiff --git a/openhands/mcp/client.py b/openhands/mcp/client.py\nnew file mode 100644\nindex 000000000000..1a50aacc63fb\n--- /dev/null\n+++ b/openhands/mcp/client.py\n@@ -0,0 +1,98 @@\n+from contextlib import AsyncExitStack\n+from typing import Dict, List, Optional\n+\n+from mcp import ClientSession\n+from mcp.client.sse import sse_client\n+from pydantic import BaseModel, Field\n+\n+from openhands.core.logger import openhands_logger as logger\n+from openhands.mcp.tool import BaseTool, MCPClientTool\n+\n+\n+class MCPClient(BaseModel):\n+    \"\"\"\n+    A collection of tools that connects to an MCP server and manages available tools through the Model Context Protocol.\n+    \"\"\"\n+\n+    session: Optional[ClientSession] = None\n+    exit_stack: AsyncExitStack = AsyncExitStack()\n+    description: str = 'MCP client tools for server interaction'\n+    tools: List[BaseTool] = Field(default_factory=list)\n+    tool_map: Dict[str, BaseTool] = Field(default_factory=dict)\n+\n+    class Config:\n+        arbitrary_types_allowed = True\n+\n+    async def connect_sse(self, server_url: str, timeout: float = 30.0) -> None:\n+        \"\"\"Connect to an MCP server using SSE transport.\n+\n+        Args:\n+            server_url: The URL of the SSE server to connect to.\n+            timeout: Connection timeout in seconds. Default is 30 seconds.\n+        \"\"\"\n+        if not server_url:\n+            raise ValueError('Server URL is required.')\n+        if self.session:\n+            await self.disconnect()\n+\n+        try:\n+            streams_context = sse_client(\n+                url=server_url,\n+            )\n+            streams = await self.exit_stack.enter_async_context(streams_context)\n+            self.session = await self.exit_stack.enter_async_context(\n+                ClientSession(*streams)\n+            )\n+\n+            await self._initialize_and_list_tools()\n+        except Exception as e:\n+            logger.error(f'Error connecting to {server_url}: {str(e)}')\n+            raise\n+\n+    async def _initialize_and_list_tools(self) -> None:\n+        \"\"\"Initialize session and populate tool map.\"\"\"\n+        if not self.session:\n+            raise RuntimeError('Session not initialized.')\n+\n+        await self.session.initialize()\n+        response = await self.session.list_tools()\n+\n+        # Clear existing tools\n+        self.tools = []\n+\n+        # Create proper tool objects for each server tool\n+        for tool in response.tools:\n+            server_tool = MCPClientTool(\n+                name=tool.name,\n+                description=tool.description,\n+                inputSchema=tool.inputSchema,\n+                session=self.session,\n+            )\n+            self.tool_map[tool.name] = server_tool\n+            self.tools.append(server_tool)\n+\n+        logger.info(\n+            f'Connected to server with tools: {[tool.name for tool in response.tools]}'\n+        )\n+\n+    async def call_tool(self, tool_name: str, args: Dict):\n+        \"\"\"Call a tool on the MCP server.\"\"\"\n+        if tool_name not in self.tool_map:\n+            raise ValueError(f'Tool {tool_name} not found.')\n+        return await self.tool_map[tool_name].execute(**args)\n+\n+    async def disconnect(self) -> None:\n+        \"\"\"Disconnect from the MCP server and clean up resources.\"\"\"\n+        if self.session:\n+            try:\n+                # Close the session first\n+                if hasattr(self.session, 'close'):\n+                    await self.session.close()\n+                # Then close the exit stack\n+                await self.exit_stack.aclose()\n+            except Exception as e:\n+                logger.error(f'Error during disconnect: {str(e)}')\n+            finally:\n+                self.session = None\n+                self.tools = []\n+                logger.info('Disconnected from MCP server')\ndiff --git a/openhands/mcp/tool.py b/openhands/mcp/tool.py\nnew file mode 100644\nindex 000000000000..71d73f046aa4\n--- /dev/null\n+++ b/openhands/mcp/tool.py\n@@ -0,0 +1,54 @@\n+from abc import ABC, abstractmethod\n+from typing import Dict, Optional\n+\n+from mcp import ClientSession\n+from mcp.types import CallToolResult, TextContent, Tool\n+\n+\n+class BaseTool(ABC, Tool):\n+    @classmethod\n+    def postfix(cls) -> str:\n+        return '_mcp_tool_call'\n+\n+    class Config:\n+        arbitrary_types_allowed = True\n+\n+    @abstractmethod\n+    async def execute(self, **kwargs) -> CallToolResult:\n+        \"\"\"Execute the tool with given parameters.\"\"\"\n+\n+    def to_param(self) -> Dict:\n+        \"\"\"Convert tool to function call format.\"\"\"\n+        return {\n+            'type': 'function',\n+            'function': {\n+                'name': self.name + self.postfix(),\n+                'description': self.description,\n+                'parameters': self.inputSchema,\n+            },\n+        }\n+\n+\n+class MCPClientTool(BaseTool):\n+    \"\"\"Represents a tool proxy that can be called on the MCP server from the client side.\"\"\"\n+\n+    session: Optional[ClientSession] = None\n+\n+    async def execute(self, **kwargs) -> CallToolResult:\n+        \"\"\"Execute the tool by making a remote call to the MCP server.\"\"\"\n+        if not self.session:\n+            return CallToolResult(\n+                content=[TextContent(text='Not connected to MCP server', type='text')],\n+                isError=True,\n+            )\n+\n+        try:\n+            result = await self.session.call_tool(self.name, kwargs)\n+            return result\n+        except Exception as e:\n+            return CallToolResult(\n+                content=[\n+                    TextContent(text=f'Error executing tool: {str(e)}', type='text')\n+                ],\n+                isError=True,\n+            )\ndiff --git a/openhands/mcp/utils.py b/openhands/mcp/utils.py\nnew file mode 100644\nindex 000000000000..c8894f1ca9a2\n--- /dev/null\n+++ b/openhands/mcp/utils.py\n@@ -0,0 +1,135 @@\n+import json\n+\n+from openhands.core.config.mcp_config import MCPConfig\n+from openhands.core.logger import openhands_logger as logger\n+from openhands.events.action.mcp import McpAction\n+from openhands.events.observation.mcp import MCPObservation\n+from openhands.events.observation.observation import Observation\n+from openhands.mcp.client import MCPClient\n+\n+\n+def convert_mcp_clients_to_tools(mcp_clients: list[MCPClient] | None) -> list[dict]:\n+    \"\"\"\n+    Converts a list of MCPClient instances to ChatCompletionToolParam format\n+    that can be used by CodeActAgent.\n+\n+    Args:\n+        mcp_clients: List of MCPClient instances or None\n+\n+    Returns:\n+        List of dicts of tools ready to be used by CodeActAgent\n+    \"\"\"\n+    if mcp_clients is None:\n+        logger.warning('mcp_clients is None, returning empty list')\n+        return []\n+\n+    all_mcp_tools = []\n+    try:\n+        for client in mcp_clients:\n+            # Each MCPClient has an mcp_clients property that is a ToolCollection\n+            # The ToolCollection has a to_params method that converts tools to ChatCompletionToolParam format\n+            for tool in client.tools:\n+                mcp_tools = tool.to_param()\n+                all_mcp_tools.append(mcp_tools)\n+    except Exception as e:\n+        logger.error(f'Error in convert_mcp_clients_to_tools: {e}')\n+        return []\n+    return all_mcp_tools\n+\n+\n+async def create_mcp_clients(\n+    sse_mcp_server: list[str],\n+) -> list[MCPClient]:\n+    mcp_clients: list[MCPClient] = []\n+    # Initialize SSE connections\n+    if sse_mcp_server:\n+        for server_url in sse_mcp_server:\n+            logger.info(\n+                f'Initializing MCP agent for {server_url} with SSE connection...'\n+            )\n+\n+            client = MCPClient()\n+            try:\n+                await client.connect_sse(server_url)\n+                # Only add the client to the list after a successful connection\n+                mcp_clients.append(client)\n+                logger.info(f'Connected to MCP server {server_url} via SSE')\n+            except Exception as e:\n+                logger.error(f'Failed to connect to {server_url}: {str(e)}')\n+                try:\n+                    await client.disconnect()\n+                except Exception as disconnect_error:\n+                    logger.error(\n+                        f'Error during disconnect after failed connection: {str(disconnect_error)}'\n+                    )\n+\n+    return mcp_clients\n+\n+\n+async def fetch_mcp_tools_from_config(mcp_config: MCPConfig) -> list[dict]:\n+    \"\"\"\n+    Retrieves the list of MCP tools from the MCP clients.\n+\n+    Returns:\n+        A list of tool dictionaries. Returns an empty list if no connections could be established.\n+    \"\"\"\n+    mcp_clients = []\n+    mcp_tools = []\n+    try:\n+        logger.debug(f'Creating MCP clients with config: {mcp_config}')\n+        mcp_clients = await create_mcp_clients(\n+            mcp_config.sse.mcp_servers,\n+        )\n+\n+        if not mcp_clients:\n+            logger.warning('No MCP clients were successfully connected')\n+            return []\n+\n+        mcp_tools = convert_mcp_clients_to_tools(mcp_clients)\n+\n+        # Always disconnect clients to clean up resources\n+        for mcp_client in mcp_clients:\n+            try:\n+                await mcp_client.disconnect()\n+            except Exception as disconnect_error:\n+                logger.error(f'Error disconnecting MCP client: {str(disconnect_error)}')\n+    except Exception as e:\n+        logger.error(f'Error fetching MCP tools: {str(e)}')\n+        return []\n+\n+    logger.debug(f'MCP tools: {mcp_tools}')\n+    return mcp_tools\n+\n+\n+async def call_tool_mcp(mcp_clients: list[MCPClient], action: McpAction) -> Observation:\n+    \"\"\"\n+    Call a tool on an MCP server and return the observation.\n+\n+    Args:\n+        action: The MCP action to execute\n+        sse_mcp_servers: List of SSE MCP server URLs\n+\n+    Returns:\n+        The observation from the MCP server\n+    \"\"\"\n+    if not mcp_clients:\n+        raise ValueError('No MCP clients found')\n+\n+    logger.debug(f'MCP action received: {action}')\n+    # Find the MCP agent that has the matching tool name\n+    matching_client = None\n+    logger.debug(f'MCP clients: {mcp_clients}')\n+    logger.debug(f'MCP action name: {action.name}')\n+    for client in mcp_clients:\n+        logger.debug(f'MCP client tools: {client.tools}')\n+        if action.name in [tool.name for tool in client.tools]:\n+            matching_client = client\n+            break\n+    if matching_client is None:\n+        raise ValueError(f'No matching MCP agent found for tool name: {action.name}')\n+    logger.debug(f'Matching client: {matching_client}')\n+    args_dict = json.loads(action.arguments) if action.arguments else {}\n+    response = await matching_client.call_tool(action.name, args_dict)\n+    logger.debug(f'MCP response: {response}')\n+\n+    return MCPObservation(content=f'MCP result:{response.model_dump(mode=\"json\")}')\ndiff --git a/tests/unit/test_mcp_config.py b/tests/unit/test_mcp_config.py\nnew file mode 100644\nindex 000000000000..c91574025ebd\n--- /dev/null\n+++ b/tests/unit/test_mcp_config.py\n@@ -0,0 +1,63 @@\n+import pytest\n+\n+from openhands.core.config.mcp_config import MCPConfig, MCPSSEConfig\n+\n+\n+def test_valid_sse_config():\n+    \"\"\"Test a valid SSE configuration.\"\"\"\n+    config = MCPSSEConfig(mcp_servers=['http://server1:8080', 'http://server2:8080'])\n+    config.validate_servers()  # Should not raise any exception\n+\n+\n+def test_empty_sse_config():\n+    \"\"\"Test SSE configuration with empty servers list.\"\"\"\n+    config = MCPSSEConfig(mcp_servers=[])\n+    config.validate_servers()\n+\n+\n+def test_invalid_sse_url():\n+    \"\"\"Test SSE configuration with invalid URL format.\"\"\"\n+    config = MCPSSEConfig(mcp_servers=['not_a_url'])\n+    with pytest.raises(ValueError) as exc_info:\n+        config.validate_servers()\n+    assert 'Invalid URL' in str(exc_info.value)\n+\n+\n+def test_duplicate_sse_urls():\n+    \"\"\"Test SSE configuration with duplicate server URLs.\"\"\"\n+    config = MCPSSEConfig(mcp_servers=['http://server1:8080', 'http://server1:8080'])\n+    with pytest.raises(ValueError) as exc_info:\n+        config.validate_servers()\n+    assert 'Duplicate MCP server URLs are not allowed' in str(exc_info.value)\n+\n+\n+def test_from_toml_section_valid():\n+    \"\"\"Test creating config from valid TOML section.\"\"\"\n+    data = {\n+        'mcp_servers': ['http://server1:8080'],\n+    }\n+    result = MCPConfig.from_toml_section(data)\n+    assert 'mcp' in result\n+    assert result['mcp'].sse.mcp_servers == ['http://server1:8080']\n+\n+\n+def test_from_toml_section_invalid_sse():\n+    \"\"\"Test creating config from TOML section with invalid SSE URL.\"\"\"\n+    data = {\n+        'mcp_servers': ['not_a_url'],\n+    }\n+    with pytest.raises(ValueError) as exc_info:\n+        MCPConfig.from_toml_section(data)\n+    assert 'Invalid URL' in str(exc_info.value)\n+\n+\n+def test_complex_urls():\n+    \"\"\"Test SSE configuration with complex URLs.\"\"\"\n+    config = MCPSSEConfig(\n+        mcp_servers=[\n+            'https://user:pass@server1:8080/path?query=1',\n+            'wss://server2:8443/ws',\n+            'http://subdomain.example.com:9090',\n+        ]\n+    )\n+    config.validate_servers()  # Should not raise any exception\ndiff --git a/tests/unit/test_mcp_timeout.py b/tests/unit/test_mcp_timeout.py\nnew file mode 100644\nindex 000000000000..d50f44fb59c0\n--- /dev/null\n+++ b/tests/unit/test_mcp_timeout.py\n@@ -0,0 +1,83 @@\n+import asyncio\n+from unittest import mock\n+\n+import pytest\n+\n+from openhands.core.config.mcp_config import MCPConfig, MCPSSEConfig\n+from openhands.mcp import MCPClient, create_mcp_clients, fetch_mcp_tools_from_config\n+\n+\n+@pytest.mark.asyncio\n+async def test_sse_connection_timeout():\n+    \"\"\"Test that SSE connection timeout is handled gracefully.\"\"\"\n+    # Create a mock MCPClient\n+    mock_client = mock.MagicMock(spec=MCPClient)\n+\n+    # Configure the mock to raise a TimeoutError when connect_sse is called\n+    async def mock_connect_sse(*args, **kwargs):\n+        await asyncio.sleep(0.1)  # Simulate some delay\n+        raise asyncio.TimeoutError('Connection timed out')\n+\n+    mock_client.connect_sse.side_effect = mock_connect_sse\n+    mock_client.disconnect = mock.AsyncMock()\n+\n+    # Mock the MCPClient constructor to return our mock\n+    with mock.patch('openhands.mcp.utils.MCPClient', return_value=mock_client):\n+        # Create a list of server URLs to test\n+        sse_servers = ['http://server1:8080', 'http://server2:8080']\n+\n+        # Call create_mcp_clients with the server URLs\n+        clients = await create_mcp_clients(sse_mcp_server=sse_servers)\n+\n+        # Verify that no clients were successfully connected\n+        assert len(clients) == 0\n+\n+        # Verify that connect_sse was called for each server\n+        assert mock_client.connect_sse.call_count == 2\n+\n+        # Verify that disconnect was called for each failed connection\n+        assert mock_client.disconnect.call_count == 2\n+\n+\n+@pytest.mark.asyncio\n+async def test_fetch_mcp_tools_with_timeout():\n+    \"\"\"Test that fetch_mcp_tools_from_config handles timeouts gracefully.\"\"\"\n+    # Create a mock MCPConfig\n+    mock_config = mock.MagicMock(spec=MCPConfig)\n+    mock_config.sse = mock.MagicMock(spec=MCPSSEConfig)\n+\n+    # Configure the mock config\n+    mock_config.sse.mcp_servers = ['http://server1:8080']\n+\n+    # Mock create_mcp_clients to return an empty list (simulating all connections failing)\n+    with mock.patch('openhands.mcp.utils.create_mcp_clients', return_value=[]):\n+        # Call fetch_mcp_tools_from_config\n+        tools = await fetch_mcp_tools_from_config(mock_config)\n+\n+        # Verify that an empty list of tools is returned\n+        assert tools == []\n+\n+\n+@pytest.mark.asyncio\n+async def test_mixed_connection_results():\n+    \"\"\"Test that fetch_mcp_tools_from_config returns tools even when some connections fail.\"\"\"\n+    # Create a mock MCPConfig\n+    mock_config = mock.MagicMock(spec=MCPConfig)\n+    mock_config.sse = mock.MagicMock(spec=MCPSSEConfig)\n+\n+    # Configure the mock config\n+    mock_config.sse.mcp_servers = ['http://server1:8080', 'http://server2:8080']\n+\n+    # Create a successful client\n+    successful_client = mock.MagicMock(spec=MCPClient)\n+    successful_client.tools = [mock.MagicMock()]\n+\n+    # Mock create_mcp_clients to return our successful client\n+    with mock.patch(\n+        'openhands.mcp.utils.create_mcp_clients', return_value=[successful_client]\n+    ):\n+        # Call fetch_mcp_tools_from_config\n+        tools = await fetch_mcp_tools_from_config(mock_config)\n+\n+        # Verify that tools were returned\n+        assert len(tools) > 0\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR makes solid progress towards configuring MCP servers, but I'd recommend addressing a few concerns before merging. The proposed customization method could complicate user experience compared to leveraging existing micro-agent configurations, as seen in #7620. Evaluate the benefits of this new approach critically. Also, consider how integration with popular MCP servers like Stdio can be streamlined. The suggestion to leverage frameworks like MetaMCP is promising, but ensure it aligns with our user base's needs. Let's keep simplicity in focus while enhancing functionality."
      }
    ],
    "token_estimation": 4882.25
  },
  {
    "index": 64,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/openhands/runtime/impl/local/local_runtime.py b/openhands/runtime/impl/local/local_runtime.py\nnew file mode 100644\nindex 000000000000..547f2981d515\n--- /dev/null\n+++ b/openhands/runtime/impl/local/local_runtime.py\n@@ -0,0 +1,342 @@\n+\"\"\"\n+This runtime runs the action_execution_server directly on the local machine without Docker.\n+\"\"\"\n+\n+import os\n+import shutil\n+import subprocess\n+import tempfile\n+import threading\n+from typing import Callable, Optional\n+\n+import requests\n+import tenacity\n+\n+import openhands\n+from openhands.core.config import AppConfig\n+from openhands.core.exceptions import AgentRuntimeDisconnectedError\n+from openhands.core.logger import openhands_logger as logger\n+from openhands.events import EventStream\n+from openhands.events.action import (\n+    Action,\n+)\n+from openhands.events.observation import (\n+    Observation,\n+)\n+from openhands.events.serialization import event_to_dict, observation_from_dict\n+from openhands.runtime.impl.action_execution.action_execution_client import (\n+    ActionExecutionClient,\n+)\n+from openhands.runtime.impl.docker.docker_runtime import (\n+    APP_PORT_RANGE_1,\n+    APP_PORT_RANGE_2,\n+    EXECUTION_SERVER_PORT_RANGE,\n+    VSCODE_PORT_RANGE,\n+)\n+from openhands.runtime.plugins import PluginRequirement\n+from openhands.runtime.utils import find_available_tcp_port\n+from openhands.runtime.utils.command import get_action_execution_server_startup_command\n+from openhands.utils.async_utils import call_sync_from_async\n+from openhands.utils.tenacity_stop import stop_if_should_exit\n+\n+\n+def check_dependencies(code_repo_path: str, poetry_venvs_path: str):\n+    ERROR_MESSAGE = 'Please follow the instructions in https://github.com/All-Hands-AI/OpenHands/blob/main/Development.md to install OpenHands.'\n+    if not os.path.exists(code_repo_path):\n+        raise ValueError(\n+            f'Code repo path {code_repo_path} does not exist. ' + ERROR_MESSAGE\n+        )\n+    if not os.path.exists(poetry_venvs_path):\n+        raise ValueError(\n+            f'Poetry venvs path {poetry_venvs_path} does not exist. ' + ERROR_MESSAGE\n+        )\n+    # Check jupyter is installed\n+    logger.debug('Checking dependencies: Jupyter')\n+    output = subprocess.check_output(\n+        'poetry run jupyter --version',\n+        shell=True,\n+        text=True,\n+        cwd=code_repo_path,\n+    )\n+    logger.debug(f'Jupyter output: {output}')\n+    if 'jupyter' not in output.lower():\n+        raise ValueError('Jupyter is not properly installed. ' + ERROR_MESSAGE)\n+\n+    # Check libtmux is installed\n+    logger.debug('Checking dependencies: libtmux')\n+    import libtmux\n+\n+    server = libtmux.Server()\n+    session = server.new_session(session_name='test-session')\n+    pane = session.attached_pane\n+    pane.send_keys('echo \"test\"')\n+    pane_output = '\\n'.join(pane.cmd('capture-pane', '-p').stdout)\n+    session.kill_session()\n+    if 'test' not in pane_output:\n+        raise ValueError('libtmux is not properly installed. ' + ERROR_MESSAGE)\n+\n+    # Check browser works\n+    logger.debug('Checking dependencies: browser')\n+    from openhands.runtime.browser.browser_env import BrowserEnv\n+\n+    browser = BrowserEnv()\n+    browser.close()\n+\n+\n+class LocalRuntime(ActionExecutionClient):\n+    \"\"\"This runtime will run the action_execution_server directly on the local machine.\n+    When receiving an event, it will send the event to the server via HTTP.\n+\n+    Args:\n+        config (AppConfig): The application configuration.\n+        event_stream (EventStream): The event stream to subscribe to.\n+        sid (str, optional): The session ID. Defaults to 'default'.\n+        plugins (list[PluginRequirement] | None, optional): List of plugin requirements. Defaults to None.\n+        env_vars (dict[str, str] | None, optional): Environment variables to set. Defaults to None.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        config: AppConfig,\n+        event_stream: EventStream,\n+        sid: str = 'default',\n+        plugins: list[PluginRequirement] | None = None,\n+        env_vars: dict[str, str] | None = None,\n+        status_callback: Callable | None = None,\n+        attach_to_existing: bool = False,\n+        headless_mode: bool = True,\n+    ):\n+        self.config = config\n+        self._user_id = os.getuid()\n+        self._username = os.getenv('USER')\n+\n+        if self.config.workspace_base is not None:\n+            logger.warning(\n+                f'Workspace base path is set to {self.config.workspace_base}. '\n+                'It will be used as the path for the agent to run in. '\n+                'Be careful, the agent can EDIT files in this directory!'\n+            )\n+            self.config.workspace_mount_path_in_sandbox = self.config.workspace_base\n+            self._temp_workspace = None\n+        else:\n+            # A temporary directory is created for the agent to run in\n+            # This is used for the local runtime only\n+            self._temp_workspace = tempfile.mkdtemp(\n+                prefix=f'openhands_workspace_{sid}',\n+            )\n+            self.config.workspace_mount_path_in_sandbox = self._temp_workspace\n+\n+        logger.warning(\n+            'Initializing LocalRuntime. WARNING: NO SANDBOX IS USED. '\n+            'This is an experimental feature, please report issues to https://github.com/All-Hands-AI/OpenHands/issues. '\n+            '`run_as_openhands` will be ignored since the current user will be used to launch the server. '\n+            'We highly recommend using a sandbox (eg. DockerRuntime) unless you '\n+            'are running in a controlled environment.\\n'\n+            f'Temp workspace: {self._temp_workspace}. '\n+            f'User ID: {self._user_id}. '\n+            f'Username: {self._username}.'\n+        )\n+\n+        if self.config.workspace_base is not None:\n+            logger.warning(\n+                f'Workspace base path is set to {self.config.workspace_base}. It will be used as the path for the agent to run in.'\n+            )\n+            self.config.workspace_mount_path_in_sandbox = self.config.workspace_base\n+        else:\n+            logger.warning(\n+                'Workspace base path is NOT set. Agent will run in a temporary directory.'\n+            )\n+            self._temp_workspace = tempfile.mkdtemp()\n+            self.config.workspace_mount_path_in_sandbox = self._temp_workspace\n+\n+        self._host_port = -1\n+        self._vscode_port = -1\n+        self._app_ports: list[int] = []\n+\n+        self.api_url = f'{self.config.sandbox.local_runtime_url}:{self._host_port}'\n+        self.status_callback = status_callback\n+        self.server_process: Optional[subprocess.Popen[str]] = None\n+        self.action_semaphore = threading.Semaphore(1)  # Ensure one action at a time\n+\n+        # Update env vars\n+        if self.config.sandbox.runtime_startup_env_vars:\n+            os.environ.update(self.config.sandbox.runtime_startup_env_vars)\n+\n+        # Initialize the action_execution_server\n+        super().__init__(\n+            config,\n+            event_stream,\n+            sid,\n+            plugins,\n+            env_vars,\n+            status_callback,\n+            attach_to_existing,\n+            headless_mode,\n+        )\n+\n+    def _get_action_execution_server_host(self):\n+        return self.api_url\n+\n+    async def connect(self):\n+        \"\"\"Start the action_execution_server on the local machine.\"\"\"\n+        self.send_status_message('STATUS$STARTING_RUNTIME')\n+\n+        self._host_port = self._find_available_port(EXECUTION_SERVER_PORT_RANGE)\n+        self._vscode_port = self._find_available_port(VSCODE_PORT_RANGE)\n+        self._app_ports = [\n+            self._find_available_port(APP_PORT_RANGE_1),\n+            self._find_available_port(APP_PORT_RANGE_2),\n+        ]\n+        self.api_url = f'{self.config.sandbox.local_runtime_url}:{self._host_port}'\n+\n+        # Start the server process\n+        cmd = get_action_execution_server_startup_command(\n+            server_port=self._host_port,\n+            plugins=self.plugins,\n+            app_config=self.config,\n+            python_prefix=[],\n+            override_user_id=self._user_id,\n+            override_username=self._username,\n+        )\n+\n+        self.log('debug', f'Starting server with command: {cmd}')\n+        env = os.environ.copy()\n+        # Get the code repo path\n+        code_repo_path = os.path.dirname(os.path.dirname(openhands.__file__))\n+        env['PYTHONPATH'] = f'{code_repo_path}:$PYTHONPATH'\n+        env['OPENHANDS_REPO_PATH'] = code_repo_path\n+        env['LOCAL_RUNTIME_MODE'] = '1'\n+        # run poetry show -v | head -n 1 | awk '{print $2}'\n+        poetry_venvs_path = (\n+            subprocess.check_output(\n+                ['poetry', 'show', '-v'],\n+                env=env,\n+                cwd=code_repo_path,\n+                text=True,\n+                shell=False,\n+            )\n+            .splitlines()[0]\n+            .split(':')[1]\n+            .strip()\n+        )\n+        env['POETRY_VIRTUALENVS_PATH'] = poetry_venvs_path\n+        logger.debug(f'POETRY_VIRTUALENVS_PATH: {poetry_venvs_path}')\n+\n+        check_dependencies(code_repo_path, poetry_venvs_path)\n+        self.server_process = subprocess.Popen(\n+            cmd,\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.STDOUT,\n+            universal_newlines=True,\n+            bufsize=1,\n+            env=env,\n+        )\n+\n+        # Start a thread to read and log server output\n+        def log_output():\n+            while (\n+                self.server_process\n+                and self.server_process.poll()\n+                and self.server_process.stdout\n+            ):\n+                line = self.server_process.stdout.readline()\n+                if not line:\n+                    break\n+                self.log('debug', f'Server: {line.strip()}')\n+\n+        self._log_thread = threading.Thread(target=log_output, daemon=True)\n+        self._log_thread.start()\n+\n+        self.log('info', f'Waiting for server to become ready at {self.api_url}...')\n+        self.send_status_message('STATUS$WAITING_FOR_CLIENT')\n+\n+        await call_sync_from_async(self._wait_until_alive)\n+\n+        if not self.attach_to_existing:\n+            await call_sync_from_async(self.setup_initial_env)\n+\n+        self.log(\n+            'debug',\n+            f'Server initialized with plugins: {[plugin.name for plugin in self.plugins]}',\n+        )\n+        if not self.attach_to_existing:\n+            self.send_status_message(' ')\n+        self._runtime_initialized = True\n+\n+    def _find_available_port(self, port_range, max_attempts=5):\n+        port = port_range[1]\n+        for _ in range(max_attempts):\n+            port = find_available_tcp_port(port_range[0], port_range[1])\n+            return port\n+        return port\n+\n+    @tenacity.retry(\n+        wait=tenacity.wait_exponential(min=1, max=10),\n+        stop=tenacity.stop_after_attempt(10) | stop_if_should_exit(),\n+        before_sleep=lambda retry_state: logger.debug(\n+            f'Waiting for server to be ready... (attempt {retry_state.attempt_number})'\n+        ),\n+    )\n+    def _wait_until_alive(self):\n+        \"\"\"Wait until the server is ready to accept requests.\"\"\"\n+        if self.server_process and self.server_process.poll() is not None:\n+            raise RuntimeError('Server process died')\n+\n+        try:\n+            response = self.session.get(f'{self.api_url}/alive')\n+            response.raise_for_status()\n+            return True\n+        except Exception as e:\n+            self.log('debug', f'Server not ready yet: {e}')\n+            raise\n+\n+    async def execute_action(self, action: Action) -> Observation:\n+        \"\"\"Execute an action by sending it to the server.\"\"\"\n+        if not self._runtime_initialized:\n+            raise AgentRuntimeDisconnectedError('Runtime not initialized')\n+\n+        if self.server_process is None or self.server_process.poll() is not None:\n+            raise AgentRuntimeDisconnectedError('Server process died')\n+\n+        with self.action_semaphore:\n+            try:\n+                response = await call_sync_from_async(\n+                    lambda: self.session.post(\n+                        f'{self.api_url}/execute_action',\n+                        json={'action': event_to_dict(action)},\n+                    )\n+                )\n+                return observation_from_dict(response.json())\n+            except requests.exceptions.ConnectionError:\n+                raise AgentRuntimeDisconnectedError('Server connection lost')\n+\n+    def close(self):\n+        \"\"\"Stop the server process.\"\"\"\n+        if self.server_process:\n+            self.server_process.terminate()\n+            try:\n+                self.server_process.wait(timeout=5)\n+            except subprocess.TimeoutExpired:\n+                self.server_process.kill()\n+            self.server_process = None\n+            self._log_thread.join()\n+\n+        if self._temp_workspace:\n+            shutil.rmtree(self._temp_workspace)\n+\n+        super().close()\n+\n+    @property\n+    def vscode_url(self) -> str | None:\n+        token = super().get_vscode_token()\n+        if not token:\n+            return None\n+        vscode_url = f'http://localhost:{self._vscode_port}/?tkn={token}&folder={self.config.workspace_mount_path_in_sandbox}'\n+        return vscode_url\n+\n+    @property\n+    def web_hosts(self):\n+        hosts: dict[str, int] = {}\n+        for port in self._app_ports:\n+            hosts[f'http://localhost:{port}'] = port\n+        return hosts\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "It looks like you need to adjust your local runtime configuration to get the tests working. Ensure the environment is set up correctly first, especially with overridden `SandboxConfig` settings for user and workspace. Your errors indicate a connection issue with the service not starting properly. The current user setup might require careful debugging to function without root. Additionally, reassess the use of `WORKSPACE_BASE`; it doesn't appear to influence file paths as expected. Focus on getting the server ready before running tests to resolve connection refusals."
      }
    ],
    "token_estimation": 3527.75
  },
  {
    "index": 65,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/opendevin/runtime/plugins/agent_skills/aider/LICENSE.txt b/opendevin/runtime/plugins/agent_skills/aider/LICENSE.txt\nnew file mode 100644\nindex 000000000000..d64569567334\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/aider/LICENSE.txt\n@@ -0,0 +1,202 @@\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\ndiff --git a/opendevin/runtime/plugins/agent_skills/aider/linter.py b/opendevin/runtime/plugins/agent_skills/aider/linter.py\nnew file mode 100644\nindex 000000000000..419b5e3c5ace\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/aider/linter.py\n@@ -0,0 +1,223 @@\n+import os\n+import subprocess\n+import sys\n+import traceback\n+import warnings\n+from dataclasses import dataclass\n+from pathlib import Path\n+\n+from grep_ast import TreeContext, filename_to_lang\n+from tree_sitter_languages import get_parser  # noqa: E402\n+\n+# tree_sitter is throwing a FutureWarning\n+warnings.simplefilter('ignore', category=FutureWarning)\n+\n+\n+@dataclass\n+class LintResult:\n+    text: str\n+    lines: list\n+\n+\n+class Linter:\n+    def __init__(self, encoding='utf-8', root=None):\n+        self.encoding = encoding\n+        self.root = root\n+\n+        self.languages = dict(\n+            python=self.py_lint,\n+        )\n+        self.all_lint_cmd = None\n+\n+    def set_linter(self, lang, cmd):\n+        if lang:\n+            self.languages[lang] = cmd\n+            return\n+\n+        self.all_lint_cmd = cmd\n+\n+    def get_rel_fname(self, fname):\n+        if self.root:\n+            return os.path.relpath(fname, self.root)\n+        else:\n+            return fname\n+\n+    def run_cmd(self, cmd, rel_fname, code):\n+        cmd += ' ' + rel_fname\n+        cmd = cmd.split()\n+\n+        process = subprocess.Popen(\n+            cmd, cwd=self.root, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\n+        )\n+        stdout, _ = process.communicate()\n+        errors = stdout.decode().strip()\n+        self.returncode = process.returncode\n+        if self.returncode == 0:\n+            return  # zero exit status\n+\n+        cmd = ' '.join(cmd)\n+        res = ''\n+        res += errors\n+        line_num = extract_error_line_from(res)\n+        return LintResult(text=res, lines=[line_num])\n+\n+    def get_abs_fname(self, fname):\n+        if os.path.isabs(fname):\n+            return fname\n+        elif os.path.isfile(fname):\n+            rel_fname = self.get_rel_fname(fname)\n+            return os.path.abspath(rel_fname)\n+        else:  # if a temp file\n+            return self.get_rel_fname(fname)\n+\n+    def lint(self, fname, cmd=None) -> LintResult | None:\n+        code = Path(fname).read_text(self.encoding)\n+        absolute_fname = self.get_abs_fname(fname)\n+        if cmd:\n+            cmd = cmd.strip()\n+        if not cmd:\n+            lang = filename_to_lang(fname)\n+            if not lang:\n+                return None\n+            if self.all_lint_cmd:\n+                cmd = self.all_lint_cmd\n+            else:\n+                cmd = self.languages.get(lang)\n+        if callable(cmd):\n+            linkres = cmd(fname, absolute_fname, code)\n+        elif cmd:\n+            linkres = self.run_cmd(cmd, absolute_fname, code)\n+        else:\n+            linkres = basic_lint(absolute_fname, code)\n+        return linkres\n+\n+    def flake_lint(self, rel_fname, code):\n+        fatal = 'F821,F822,F831,E112,E113,E999,E902'\n+        flake8 = f'flake8 --select={fatal} --isolated'\n+\n+        try:\n+            flake_res = self.run_cmd(flake8, rel_fname, code)\n+        except FileNotFoundError:\n+            flake_res = None\n+        return flake_res\n+\n+    def py_lint(self, fname, rel_fname, code):\n+        error = self.flake_lint(rel_fname, code)\n+        if not error:\n+            error = lint_python_compile(fname, code)\n+        if not error:\n+            error = basic_lint(rel_fname, code)\n+        return error\n+\n+\n+def lint_python_compile(fname, code):\n+    try:\n+        compile(code, fname, 'exec')  # USE TRACEBACK BELOW HERE\n+        return\n+    except IndentationError as err:\n+        end_lineno = getattr(err, 'end_lineno', err.lineno)\n+        if isinstance(end_lineno, int):\n+            line_numbers = list(range(end_lineno - 1, end_lineno))\n+        else:\n+            line_numbers = []\n+\n+        tb_lines = traceback.format_exception(type(err), err, err.__traceback__)\n+        last_file_i = 0\n+\n+        target = '# USE TRACEBACK'\n+        target += ' BELOW HERE'\n+        for i in range(len(tb_lines)):\n+            if target in tb_lines[i]:\n+                last_file_i = i\n+                break\n+        tb_lines = tb_lines[:1] + tb_lines[last_file_i + 1 :]\n+\n+    res = ''.join(tb_lines)\n+    return LintResult(text=res, lines=line_numbers)\n+\n+\n+def basic_lint(fname, code):\n+    \"\"\"\n+    Use tree-sitter to look for syntax errors, display them with tree context.\n+    \"\"\"\n+\n+    lang = filename_to_lang(fname)\n+    if not lang:\n+        return\n+\n+    parser = get_parser(lang)\n+    tree = parser.parse(bytes(code, 'utf-8'))\n+\n+    errors = traverse_tree(tree.root_node)\n+    if not errors:\n+        return\n+    return LintResult(text=f'{fname}:{errors[0]}', lines=errors)\n+\n+\n+def extract_error_line_from(lint_error):\n+    # moved from opendevin.agentskills#_lint_file\n+    for line in lint_error.splitlines(True):\n+        if line.strip():\n+            # The format of the error message is: <filename>:<line>:<column>: <error code> <error message>\n+            parts = line.split(':')\n+            if len(parts) >= 2:\n+                try:\n+                    first_error_line = int(parts[1])\n+                    break\n+                except ValueError:\n+                    continue\n+    return first_error_line\n+\n+\n+def tree_context(fname, code, line_nums):\n+    context = TreeContext(\n+        fname,\n+        code,\n+        color=False,\n+        line_number=True,\n+        child_context=False,\n+        last_line=False,\n+        margin=0,\n+        mark_lois=True,\n+        loi_pad=3,\n+        # header_max=30,\n+        show_top_of_file_parent_scope=False,\n+    )\n+    line_nums = set(line_nums)\n+    context.add_lines_of_interest(line_nums)\n+    context.add_context()\n+    output = context.format()\n+\n+    return output\n+\n+\n+# Traverse the tree to find errors\n+def traverse_tree(node):\n+    errors = []\n+    if node.type == 'ERROR' or node.is_missing:\n+        line_no = node.start_point[0] + 1\n+        errors.append(line_no)\n+\n+    for child in node.children:\n+        errors += traverse_tree(child)\n+\n+    return errors\n+\n+\n+def main():\n+    \"\"\"\n+    Main function to parse files provided as command line arguments.\n+    \"\"\"\n+    if len(sys.argv) < 2:\n+        print('Usage: python linter.py <file1> <file2> ...')\n+        sys.exit(1)\n+\n+    linter = Linter(root=os.getcwd())\n+    for file_path in sys.argv[1:]:\n+        errors = linter.lint(file_path)\n+        if errors:\n+            print(errors)\n+\n+\n+if __name__ == '__main__':\n+    main()\ndiff --git a/poetry.lock b/poetry.lock\nindex 8ac425f2ea84..6673c9710c65 100644\n--- a/poetry.lock\n+++ b/poetry.lock\n@@ -8033,6 +8059,122 @@ torchhub = [\"filelock\", \"huggingface-hub (>=0.23.2,<1.0)\", \"importlib-metadata\",\n video = [\"av (==9.2.0)\", \"decord (==0.6.0)\"]\n vision = [\"Pillow (>=10.0.1,<=15.0)\"]\n \n+[[package]]\n+name = \"tree-sitter\"\n+version = \"0.21.3\"\n+description = \"Python bindings for the Tree-Sitter parsing library\"\n+optional = false\n+python-versions = \">=3.8\"\n+files = [\n+    {file = \"tree-sitter-0.21.3.tar.gz\", hash = \"sha256:b5de3028921522365aa864d95b3c41926e0ba6a85ee5bd000e10dc49b0766988\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:351f302b6615230c9dac9829f0ba20a94362cd658206ca9a7b2d58d73373dfb0\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:766e79ae1e61271e7fdfecf35b6401ad9b47fc07a0965ad78e7f97fddfdf47a6\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:2c4d3d4d4b44857e87de55302af7f2d051c912c466ef20e8f18158e64df3542a\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:84eedb06615461b9e2847be7c47b9c5f2195d7d66d31b33c0a227eff4e0a0199\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:9d33ea425df8c3d6436926fe2991429d59c335431bf4e3c71e77c17eb508be5a\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:fae1ee0ff6d85e2fd5cd8ceb9fe4af4012220ee1e4cbe813305a316caf7a6f63\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-win_amd64.whl\", hash = \"sha256:bb41be86a987391f9970571aebe005ccd10222f39c25efd15826583c761a37e5\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:54b22c3c2aab3e3639a4b255d9df8455da2921d050c4829b6a5663b057f10db5\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:ab6e88c1e2d5e84ff0f9e5cd83f21b8e5074ad292a2cf19df3ba31d94fbcecd4\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:fc3fd34ed4cd5db445bc448361b5da46a2a781c648328dc5879d768f16a46771\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:fabc7182f6083269ce3cfcad202fe01516aa80df64573b390af6cd853e8444a1\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:4f874c3f7d2a2faf5c91982dc7d88ff2a8f183a21fe475c29bee3009773b0558\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:ee61ee3b7a4eedf9d8f1635c68ba4a6fa8c46929601fc48a907c6cfef0cfbcb2\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-win_amd64.whl\", hash = \"sha256:0b7256c723642de1c05fbb776b27742204a2382e337af22f4d9e279d77df7aa2\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:669b3e5a52cb1e37d60c7b16cc2221c76520445bb4f12dd17fd7220217f5abf3\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:2aa2a5099a9f667730ff26d57533cc893d766667f4d8a9877e76a9e74f48f0d3\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:6a3e06ae2a517cf6f1abb682974f76fa760298e6d5a3ecf2cf140c70f898adf0\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:af992dfe08b4fefcfcdb40548d0d26d5d2e0a0f2d833487372f3728cd0772b48\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:c7cbab1dd9765138505c4a55e2aa857575bac4f1f8a8b0457744a4fefa1288e6\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:e1e66aeb457d1529370fcb0997ae5584c6879e0e662f1b11b2f295ea57e22f54\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-win_amd64.whl\", hash = \"sha256:013c750252dc3bd0e069d82e9658de35ed50eecf31c6586d0de7f942546824c5\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:4986a8cb4acebd168474ec2e5db440e59c7888819b3449a43ce8b17ed0331b07\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:6e217fee2e7be7dbce4496caa3d1c466977d7e81277b677f954d3c90e3272ec2\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:f32a88afff4f2bc0f20632b0a2aa35fa9ae7d518f083409eca253518e0950929\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:f3652ac9e47cdddf213c5d5d6854194469097e62f7181c0a9aa8435449a163a9\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:60b4df3298ff467bc01e2c0f6c2fb43aca088038202304bf8e41edd9fa348f45\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:00e4d0c99dff595398ef5e88a1b1ddd53adb13233fb677c1fd8e497fb2361629\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-win_amd64.whl\", hash = \"sha256:50c91353a26946e4dd6779837ecaf8aa123aafa2d3209f261ab5280daf0962f5\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:b17b8648b296ccc21a88d72ca054b809ee82d4b14483e419474e7216240ea278\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:f2f057fd01d3a95cbce6794c6e9f6db3d376cb3bb14e5b0528d77f0ec21d6478\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:839759de30230ffd60687edbb119b31521d5ac016749358e5285816798bb804a\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:5df40aa29cb7e323898194246df7a03b9676955a0ac1f6bce06bc4903a70b5f7\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:1d9be27dde007b569fa78ff9af5fe40d2532c998add9997a9729e348bb78fa59\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:c4ac87735e6f98fe085244c7c020f0177d13d4c117db72ba041faa980d25d69d\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-win_amd64.whl\", hash = \"sha256:fbbd137f7d9a5309fb4cb82e2c3250ba101b0dd08a8abdce815661e6cf2cbc19\"},\n+]\n+\n+[[package]]\n+name = \"tree-sitter-languages\"\n+version = \"1.10.2\"\n+description = \"Binary Python wheels for all tree sitter languages.\"\n+optional = false\n+python-versions = \"*\"\n+files = [\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:5580348f0b20233b1d5431fa178ccd3d07423ca4a3275df02a44608fd72344b9\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:103c7466644486b1e9e03850df46fc6aa12f13ca636c74f173270276220ac80b\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d13db84511c6f1a7dc40383b66deafa74dabd8b877e3d65ab253f3719eccafd6\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:57adfa32be7e465b54aa72f915f6c78a2b66b227df4f656b5d4fbd1ca7a92b3f\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:1c6385e033e460ceb8f33f3f940335f422ef2b763700a04f0089391a68b56153\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:dfa3f38cc5381c5aba01dd7494f59b8a9050e82ff6e06e1233e3a0cbae297e3c\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:9f195155acf47f8bc5de7cee46ecd07b2f5697f007ba89435b51ef4c0b953ea5\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:2de330e2ac6d7426ca025a3ec0f10d5640c3682c1d0c7702e812dcfb44b58120\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-win32.whl\", hash = \"sha256:c9731cf745f135d9770eeba9bb4e2ff4dabc107b5ae9b8211e919f6b9100ea6d\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-win_amd64.whl\", hash = \"sha256:6dd75851c41d0c3c4987a9b7692d90fa8848706c23115669d8224ffd6571e357\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:7eb7d7542b2091c875fe52719209631fca36f8c10fa66970d2c576ae6a1b8289\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:6b41bcb00974b1c8a1800c7f1bb476a1d15a0463e760ee24872f2d53b08ee424\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:6f370cd7845c6c81df05680d5bd96db8a99d32b56f4728c5d05978911130a853\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:a1dc195c88ef4c72607e112a809a69190e096a2e5ebc6201548b3e05fdd169ad\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:9ae34ac314a7170be24998a0f994c1ac80761d8d4bd126af27ee53a023d3b849\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:01b5742d5f5bd675489486b582bd482215880b26dde042c067f8265a6e925d9c\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-musllinux_1_1_i686.whl\", hash = \"sha256:ab1cbc46244d34fd16f21edaa20231b2a57f09f092a06ee3d469f3117e6eb954\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:0b1149e7467a4e92b8a70e6005fe762f880f493cf811fc003554b29f04f5e7c8\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-win32.whl\", hash = \"sha256:049276343962f4696390ee555acc2c1a65873270c66a6cbe5cb0bca83bcdf3c6\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-win_amd64.whl\", hash = \"sha256:7f3fdd468a577f04db3b63454d939e26e360229b53c80361920aa1ebf2cd7491\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:c0f4c8b2734c45859edc7fcaaeaab97a074114111b5ba51ab4ec7ed52104763c\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:eecd3c1244ac3425b7a82ba9125b4ddb45d953bbe61de114c0334fd89b7fe782\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:15db3c8510bc39a80147ee7421bf4782c15c09581c1dc2237ea89cefbd95b846\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:92c6487a6feea683154d3e06e6db68c30e0ae749a7ce4ce90b9e4e46b78c85c7\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:6d2f1cd1d1bdd65332f9c2b67d49dcf148cf1ded752851d159ac3e5ee4f4d260\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:976c8039165b8e12f17a01ddee9f4e23ec6e352b165ad29b44d2bf04e2fbe77e\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-musllinux_1_1_i686.whl\", hash = \"sha256:dafbbdf16bf668a580902e1620f4baa1913e79438abcce721a50647564c687b9\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:1aeabd3d60d6d276b73cd8f3739d595b1299d123cc079a317f1a5b3c5461e2ca\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-win32.whl\", hash = \"sha256:fab8ee641914098e8933b87ea3d657bea4dd00723c1ee7038b847b12eeeef4f5\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-win_amd64.whl\", hash = \"sha256:5e606430d736367e5787fa5a7a0c5a1ec9b85eded0b3596bbc0d83532a40810b\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:838d5b48a7ed7a17658721952c77fda4570d2a069f933502653b17e15a9c39c9\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:987b3c71b1d278c2889e018ee77b8ee05c384e2e3334dec798f8b611c4ab2d1e\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:faa00abcb2c819027df58472da055d22fa7dfcb77c77413d8500c32ebe24d38b\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:0e102fbbf02322d9201a86a814e79a9734ac80679fdb9682144479044f401a73\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-musllinux_1_1_aarch64.whl\", hash = \"sha256:8f0b87cf1a7b03174ba18dfd81582be82bfed26803aebfe222bd20e444aba003\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-musllinux_1_1_i686.whl\", hash = \"sha256:c0f1b9af9cb67f0b942b020da9fdd000aad5e92f2383ae0ba7a330b318d31912\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:5a4076c921f7a4d31e643843de7dfe040b65b63a238a5aa8d31d93aabe6572aa\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-win32.whl\", hash = \"sha256:fa6391a3a5d83d32db80815161237b67d70576f090ce5f38339206e917a6f8bd\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-win_amd64.whl\", hash = \"sha256:55649d3f254585a064121513627cf9788c1cfdadbc5f097f33d5ba750685a4c0\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:6f85d1edaa2d22d80d4ea5b6d12b95cf3644017b6c227d0d42854439e02e8893\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:d78feed4a764ef3141cb54bf00fe94d514d8b6e26e09423e23b4c616fcb7938c\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:da1aca27531f9dd5308637d76643372856f0f65d0d28677d1bcf4211e8ed1ad0\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:1031ea440dafb72237437d754eff8940153a3b051e3d18932ac25e75ce060a15\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:99d3249beaef2c9fe558ecc9a97853c260433a849dcc68266d9770d196c2e102\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:59a4450f262a55148fb7e68681522f0c2a2f6b7d89666312a2b32708d8f416e1\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:ce74eab0e430370d5e15a96b6c6205f93405c177a8b2e71e1526643b2fb9bab1\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:9b4dd2b6b3d24c85dffe33d6c343448869eaf4f41c19ddba662eb5d65d8808f4\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-win32.whl\", hash = \"sha256:92d734fb968fe3927a7596d9f0459f81a8fa7b07e16569476b28e27d0d753348\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-win_amd64.whl\", hash = \"sha256:46a13f7d38f2eeb75f7cf127d1201346093748c270d686131f0cbc50e42870a1\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:f8c6a936ae99fdd8857e91f86c11c2f5e507ff30631d141d98132bb7ab2c8638\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:c283a61423f49cdfa7b5a5dfbb39221e3bd126fca33479cd80749d4d7a6b7349\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:76e60be6bdcff923386a54a5edcb6ff33fc38ab0118636a762024fa2bc98de55\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:c00069f9575bd831eabcce2cdfab158dde1ed151e7e5614c2d985ff7d78a7de1\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:475ff53203d8a43ccb19bb322fa2fb200d764001cc037793f1fadd714bb343da\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:26fe7c9c412e4141dea87ea4b3592fd12e385465b5bdab106b0d5125754d4f60\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:8fed27319957458340f24fe14daad467cd45021da034eef583519f83113a8c5e\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:3657a491a7f96cc75a3568ddd062d25f3be82b6a942c68801a7b226ff7130181\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-win32.whl\", hash = \"sha256:33f7d584d01a7a3c893072f34cfc64ec031f3cfe57eebc32da2f8ac046e101a7\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-win_amd64.whl\", hash = \"sha256:1b944af3ee729fa70fc8ae82224a9ff597cdb63addea084e0ea2fa2b0ec39bb7\"},\n+]\n+\n+[package.dependencies]\n+tree-sitter = \"*\"\n+\n [[package]]\n name = \"triton\"\n version = \"2.2.0\"\n\ndiff --git a/tests/unit/test_aider_linter.py b/tests/unit/test_aider_linter.py\nnew file mode 100644\nindex 000000000000..f13d6d24b921\n--- /dev/null\n+++ b/tests/unit/test_aider_linter.py\n@@ -0,0 +1,197 @@\n+import os\n+\n+import pytest\n+\n+from opendevin.runtime.plugins.agent_skills.aider import Linter, LintResult\n+\n+\n+@pytest.fixture\n+def temp_file(tmp_path):\n+    # Fixture to create a temporary file\n+    temp_name = os.path.join(tmp_path, 'lint-test.py')\n+    with open(temp_name, 'w', encoding='utf-8') as tmp_file:\n+        tmp_file.write(\"\"\"def foo():\n+    print(\"Hello, World!\")\n+foo()\n+\"\"\")\n+    tmp_file.close()\n+    yield temp_name\n+    os.remove(temp_name)\n+\n+\n+@pytest.fixture\n+def temp_ruby_file_errors(tmp_path):\n+    # Fixture to create a temporary file\n+    temp_name = os.path.join(tmp_path, 'lint-test.rb')\n+    with open(temp_name, 'w', encoding='utf-8') as tmp_file:\n+        tmp_file.write(\"\"\"def foo():\n+    print(\"Hello, World!\")\n+foo()\n+\"\"\")\n+    tmp_file.close()\n+    yield temp_name\n+    os.remove(temp_name)\n+\n+\n+@pytest.fixture\n+def temp_ruby_file_errors_parentheses(tmp_path):\n+    # Fixture to create a temporary file\n+    temp_name = os.path.join(tmp_path, 'lint-test.rb')\n+    with open(temp_name, 'w', encoding='utf-8') as tmp_file:\n+        tmp_file.write(\"\"\"def print_hello_world()\\n    puts 'Hello World'\\n\"\"\")\n+    tmp_file.close()\n+    yield temp_name\n+    os.remove(temp_name)\n+\n+\n+@pytest.fixture\n+def temp_ruby_file_correct(tmp_path):\n+    # Fixture to create a temporary file\n+    temp_name = os.path.join(tmp_path, 'lint-test.rb')\n+    with open(temp_name, 'w', encoding='utf-8') as tmp_file:\n+        tmp_file.write(\"\"\"def foo\n+  puts \"Hello, World!\"\n+end\n+foo\n+\"\"\")\n+    tmp_file.close()\n+    yield temp_name\n+    os.remove(temp_name)\n+\n+\n+@pytest.fixture\n+def linter(tmp_path):\n+    return Linter(root=tmp_path)\n+\n+\n+def test_get_rel_fname(linter, temp_file, tmp_path):\n+    # Test get_rel_fname method\n+    rel_fname = linter.get_rel_fname(temp_file)\n+\n+    assert rel_fname == os.path.relpath(temp_file, tmp_path)\n+\n+\n+def test_run_cmd(linter, temp_file):\n+    # Test run_cmd method with a simple command\n+    result = linter.run_cmd('echo', temp_file, '')\n+\n+    assert result is None  # echo command should return zero exit status\n+\n+\n+def test_set_linter(linter):\n+    # Test set_linter method\n+    def custom_linter(fname, rel_fname, code):\n+        return LintResult(text='Custom Linter', lines=[1])\n+\n+    linter.set_linter('custom', custom_linter)\n+\n+    assert 'custom' in linter.languages\n+    assert linter.languages['custom'] == custom_linter\n+\n+\n+def test_py_lint(linter, temp_file):\n+    # Test py_lint method\n+    result = linter.py_lint(\n+        temp_file, linter.get_rel_fname(temp_file), \"print('Hello, World!')\\n\"\n+    )\n+\n+    assert result is None  # No lint errors expected for this simple code\n+\n+\n+def test_py_lint_fail(linter, temp_file):\n+    # Test py_lint method\n+    result = linter.py_lint(\n+        temp_file, linter.get_rel_fname(temp_file), \"print('Hello, World!')\\n\"\n+    )\n+\n+    assert result is None\n+\n+\n+def test_basic_lint(temp_file):\n+    from opendevin.runtime.plugins.agent_skills.aider.linter import basic_lint\n+\n+    poorly_formatted_code = \"\"\"\n+        def foo()\n+            print(\"Hello, World!\")\n+        print(\"Wrong indent\")\n+        foo(\n+        \"\"\"\n+    result = basic_lint(temp_file, poorly_formatted_code)\n+\n+    assert isinstance(result, LintResult)\n+    assert result.text == f'{temp_file}:2'\n+    assert 2 in result.lines\n+\n+\n+def test_basic_lint_fail_returns_text_and_lines(temp_file):\n+    from opendevin.runtime.plugins.agent_skills.aider.linter import basic_lint\n+\n+    poorly_formatted_code = \"\"\"\n+        def foo()\n+            print(\"Hello, World!\")\n+        print(\"Wrong indent\")\n+        foo(\n+        \"\"\"\n+\n+    result = basic_lint(temp_file, poorly_formatted_code)\n+\n+    assert isinstance(result, LintResult)\n+    assert result.text == f'{temp_file}:2'\n+    assert 2 in result.lines\n+\n+\n+def test_lint_python_compile(temp_file):\n+    from opendevin.runtime.plugins.agent_skills.aider.linter import lint_python_compile\n+\n+    result = lint_python_compile(temp_file, \"print('Hello, World!')\\n\")\n+\n+    assert result is None\n+\n+\n+def test_lint_python_compile_fail_returns_text_and_lines(temp_file):\n+    from opendevin.runtime.plugins.agent_skills.aider.linter import lint_python_compile\n+\n+    poorly_formatted_code = \"\"\"\n+        def foo()\n+            print(\"Hello, World!\")\n+        print(\"Wrong indent\")\n+        foo(\n+        \"\"\"\n+    result = lint_python_compile(temp_file, poorly_formatted_code)\n+\n+    assert temp_file in result.text\n+    assert 1 in result.lines\n+\n+\n+def test_lint(linter, temp_file):\n+    result = linter.lint(temp_file)\n+    assert result is None\n+\n+\n+def test_lint_fail(linter, temp_file):\n+    # Test lint method\n+    with open(temp_file, 'w', encoding='utf-8') as lint_file:\n+        lint_file.write(\"\"\"\n+def foo()\n+    print(\"Hello, World!\")\n+  print(\"Wrong indent\")\n+foo(\n+\"\"\")\n+    errors = linter.lint(temp_file)\n+\n+    assert errors is not None\n+\n+\n+def test_lint_pass_ruby(linter, temp_ruby_file_correct):\n+    result = linter.lint(temp_ruby_file_correct)\n+    assert result is None\n+\n+\n+def test_lint_fail_ruby(linter, temp_ruby_file_errors):\n+    errors = linter.lint(temp_ruby_file_errors)\n+    assert errors is not None\n+\n+\n+def test_lint_fail_ruby_no_parentheses(linter, temp_ruby_file_errors_parentheses):\n+    errors = linter.lint(temp_ruby_file_errors_parentheses)\n+    assert errors is not None\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Great to see the progress on the linter integration! I noticed some failing tests, particularly related to the LLM API key; however, this seems to be an existing issue on the main branch. Ensure the failing unit tests are resolved, as they could impact stability. Regarding the sandbox errors, it appears unrelated to your PR but should be addressed to streamline debugging. The Jupyter kernel issue you encountered may stem from configuration discrepancies. Let's prioritize the sandbox tests to facilitate smoother evaluations on future PRs."
      }
    ],
    "token_estimation": 10213.25
  },
  {
    "index": 66,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/openhands/runtime/impl/cli/cli_runtime.py b/openhands/runtime/impl/cli/cli_runtime.py\nnew file mode 100644\nindex 000000000000..3f6ed4e36ede\n--- /dev/null\n+++ b/openhands/runtime/impl/cli/cli_runtime.py\n@@ -0,0 +1,782 @@\n+\"\"\"\n+This runtime runs commands locally using subprocess and performs file operations using Python's standard library.\n+It does not implement browser functionality.\n+\"\"\"\n+\n+import asyncio\n+import os\n+import select\n+import shutil\n+import signal\n+import subprocess\n+import tempfile\n+import time\n+import zipfile\n+from pathlib import Path\n+from typing import Any, Callable\n+\n+from binaryornot.check import is_binary\n+from openhands_aci.editor.editor import OHEditor\n+from openhands_aci.editor.exceptions import ToolError\n+from openhands_aci.editor.results import ToolResult\n+from openhands_aci.utils.diff import get_diff\n+from pydantic import SecretStr\n+\n+from openhands.core.config import AppConfig\n+from openhands.core.config.mcp_config import MCPConfig, MCPStdioServerConfig\n+from openhands.core.exceptions import LLMMalformedActionError\n+from openhands.core.logger import openhands_logger as logger\n+from openhands.events import EventStream\n+from openhands.events.action import (\n+    BrowseInteractiveAction,\n+    BrowseURLAction,\n+    CmdRunAction,\n+    FileEditAction,\n+    FileReadAction,\n+    FileWriteAction,\n+    IPythonRunCellAction,\n+)\n+from openhands.events.action.mcp import MCPAction\n+from openhands.events.event import FileEditSource, FileReadSource\n+from openhands.events.observation import (\n+    CmdOutputObservation,\n+    ErrorObservation,\n+    FileEditObservation,\n+    FileReadObservation,\n+    FileWriteObservation,\n+    Observation,\n+)\n+from openhands.integrations.provider import PROVIDER_TOKEN_TYPE\n+from openhands.runtime.base import Runtime\n+from openhands.runtime.plugins import PluginRequirement\n+\n+\n+class CLIRuntime(Runtime):\n+    \"\"\"\n+    A runtime implementation that runs commands locally using subprocess and performs\n+    file operations using Python's standard library. It does not implement browser functionality.\n+\n+    Args:\n+        config (AppConfig): The application configuration.\n+        event_stream (EventStream): The event stream to subscribe to.\n+        sid (str, optional): The session ID. Defaults to 'default'.\n+        plugins (list[PluginRequirement] | None, optional): List of plugin requirements. Defaults to None.\n+        env_vars (dict[str, str] | None, optional): Environment variables to set. Defaults to None.\n+        status_callback (Callable | None, optional): Callback for status updates. Defaults to None.\n+        attach_to_existing (bool, optional): Whether to attach to an existing session. Defaults to False.\n+        headless_mode (bool, optional): Whether to run in headless mode. Defaults to False.\n+        user_id (str | None, optional): User ID for authentication. Defaults to None.\n+        git_provider_tokens (PROVIDER_TOKEN_TYPE | None, optional): Git provider tokens. Defaults to None.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        config: AppConfig,\n+        event_stream: EventStream,\n+        sid: str = 'default',\n+        plugins: list[PluginRequirement] | None = None,\n+        env_vars: dict[str, str] | None = None,\n+        status_callback: Callable[[str, str, str], None] | None = None,\n+        attach_to_existing: bool = False,\n+        headless_mode: bool = False,\n+        user_id: str | None = None,\n+        git_provider_tokens: PROVIDER_TOKEN_TYPE | None = None,\n+    ):\n+        super().__init__(\n+            config,\n+            event_stream,\n+            sid,\n+            plugins,\n+            env_vars,\n+            status_callback,\n+            attach_to_existing,\n+            headless_mode,\n+            user_id,\n+            git_provider_tokens,\n+        )\n+\n+        # Set up workspace\n+        if self.config.workspace_base is not None:\n+            logger.warning(\n+                f'Workspace base path is set to {self.config.workspace_base}. '\n+                'It will be used as the path for the agent to run in. '\n+                'Be careful, the agent can EDIT files in this directory!'\n+            )\n+            self._workspace_path = self.config.workspace_base\n+        else:\n+            # Create a temporary directory for the workspace\n+            self._workspace_path = tempfile.mkdtemp(\n+                prefix=f'openhands_workspace_{sid}_'\n+            )\n+            logger.info(f'Created temporary workspace at {self._workspace_path}')\n+\n+        # Initialize runtime state\n+        self._runtime_initialized = False\n+        self.file_editor = OHEditor(workspace_root=self._workspace_path)\n+        self._shell_stream_callback: Callable[[str], None] | None = None\n+\n+        logger.warning(\n+            'Initializing CLIRuntime. WARNING: NO SANDBOX IS USED. '\n+            'This runtime executes commands directly on the local system. '\n+            'Use with caution in untrusted environments.'\n+        )\n+\n+    async def connect(self) -> None:\n+        \"\"\"Initialize the runtime connection.\"\"\"\n+        self.send_status_message('STATUS$STARTING_RUNTIME')\n+\n+        # Ensure workspace directory exists\n+        os.makedirs(self._workspace_path, exist_ok=True)\n+\n+        # Change to the workspace directory\n+        os.chdir(self._workspace_path)\n+\n+        if not self.attach_to_existing:\n+            await asyncio.to_thread(self.setup_initial_env)\n+\n+        self._runtime_initialized = True\n+        self.send_status_message('STATUS$CONTAINER_STARTED')\n+        logger.info(f'CLIRuntime initialized with workspace at {self._workspace_path}')\n+\n+    def add_env_vars(self, env_vars: dict[str, Any]) -> None:\n+        \"\"\"\n+        Adds environment variables to the current runtime environment.\n+        For CLIRuntime, this means updating os.environ for the current process,\n+        so that subsequent commands inherit these variables.\n+        This overrides the BaseRuntime behavior which tries to run shell commands\n+        before it's initialized and modify .bashrc, which is not ideal for local CLI.\n+        \"\"\"\n+        if not env_vars:\n+            return\n+\n+        # We log only keys to avoid leaking sensitive values like tokens into logs.\n+        logger.info(\n+            f'[CLIRuntime] Setting environment variables for this session: {list(env_vars.keys())}'\n+        )\n+\n+        for key, value in env_vars.items():\n+            if isinstance(value, SecretStr):\n+                os.environ[key] = value.get_secret_value()\n+                logger.warning(f'[CLIRuntime] Set os.environ[\"{key}\"] (from SecretStr)')\n+            else:\n+                os.environ[key] = value\n+                logger.debug(f'[CLIRuntime] Set os.environ[\"{key}\"]')\n+\n+        # We don't use self.run() here because this method is called\n+        # during initialization before self._runtime_initialized is True.\n+\n+    def _safe_terminate_process(self, process_obj, signal_to_send=signal.SIGTERM):\n+        \"\"\"\n+        Safely attempts to terminate/kill a process group or a single process.\n+\n+        Args:\n+            process_obj: the subprocess.Popen object started with start_new_session=True\n+            signal_to_send: the signal to send to the process group or process.\n+        \"\"\"\n+        pid = getattr(process_obj, 'pid', None)\n+        if pid is None:\n+            return\n+\n+        group_desc = (\n+            'kill process group'\n+            if signal_to_send == signal.SIGKILL\n+            else 'terminate process group'\n+        )\n+        process_desc = (\n+            'kill process' if signal_to_send == signal.SIGKILL else 'terminate process'\n+        )\n+\n+        try:\n+            # Try to terminate/kill the entire process group\n+            logger.debug(f'[_safe_terminate_process] Original PID to act on: {pid}')\n+            pgid_to_kill = os.getpgid(\n+                pid\n+            )  # This might raise ProcessLookupError if pid is already gone\n+            logger.debug(\n+                f'[_safe_terminate_process] Attempting to {group_desc} for PID {pid} (PGID: {pgid_to_kill}) with {signal_to_send}.'\n+            )\n+            os.killpg(pgid_to_kill, signal_to_send)\n+            logger.debug(\n+                f'[_safe_terminate_process] Successfully sent signal {signal_to_send} to PGID {pgid_to_kill} (original PID: {pid}).'\n+            )\n+        except ProcessLookupError as e_pgid:\n+            logger.warning(\n+                f'[_safe_terminate_process] ProcessLookupError getting PGID for PID {pid} (it might have already exited): {e_pgid}. Falling back to direct kill/terminate.'\n+            )\n+            try:\n+                if signal_to_send == signal.SIGKILL:\n+                    process_obj.kill()\n+                else:\n+                    process_obj.terminate()\n+                logger.debug(\n+                    f'[_safe_terminate_process] Fallback: Terminated {process_desc} (PID: {pid}).'\n+                )\n+            except Exception as e_fallback:\n+                logger.error(\n+                    f'[_safe_terminate_process] Fallback: Error during {process_desc} (PID: {pid}): {e_fallback}'\n+                )\n+        except (AttributeError, OSError) as e_os:\n+            logger.error(\n+                f'[_safe_terminate_process] OSError/AttributeError during {group_desc} for PID {pid}: {e_os}. Falling back.'\n+            )\n+            # Fallback: try to terminate/kill the main process directly.\n+            try:\n+                if signal_to_send == signal.SIGKILL:\n+                    process_obj.kill()\n+                else:\n+                    process_obj.terminate()\n+                logger.debug(\n+                    f'[_safe_terminate_process] Fallback: Terminated {process_desc} (PID: {pid}).'\n+                )\n+            except Exception as e_fallback:\n+                logger.error(\n+                    f'[_safe_terminate_process] Fallback: Error during {process_desc} (PID: {pid}): {e_fallback}'\n+                )\n+        except (KeyboardInterrupt, SystemExit):\n+            raise\n+        except Exception as e:\n+            logger.error(f'Error: {e}')\n+\n+    def _execute_shell_command(\n+        self, command: str, timeout: float\n+    ) -> CmdOutputObservation:\n+        \"\"\"\n+        Execute a shell command and stream its output to a callback function.\n+        Args:\n+            command: The shell command to execute\n+            timeout: Timeout in seconds for the command\n+        Returns:\n+            CmdOutputObservation containing the complete output and exit code\n+        \"\"\"\n+        output_lines = []\n+        timed_out = False\n+        start_time = time.monotonic()\n+\n+        # Use shell=True to run complex bash commands\n+        process = subprocess.Popen(\n+            ['bash', '-c', command],\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.STDOUT,\n+            text=True,\n+            bufsize=1,  # Explicitly line-buffered for text mode\n+            universal_newlines=True,\n+            start_new_session=True,\n+        )\n+        logger.debug(\n+            f'[_execute_shell_command] PID of bash -c: {process.pid} for command: \"{command}\"'\n+        )\n+\n+        exit_code = None\n+\n+        try:\n+            if process.stdout:\n+                while process.poll() is None:\n+                    if (\n+                        timeout is not None\n+                        and (time.monotonic() - start_time) > timeout\n+                    ):\n+                        logger.debug(\n+                            f'Command \"{command}\" timed out after {timeout:.1f} seconds. Terminating.'\n+                        )\n+                        # Attempt to terminate the process group (SIGTERM)\n+                        self._safe_terminate_process(\n+                            process, signal_to_send=signal.SIGTERM\n+                        )\n+                        timed_out = True\n+                        break\n+\n+                    ready_to_read, _, _ = select.select([process.stdout], [], [], 0.1)\n+\n+                    if ready_to_read:\n+                        line = process.stdout.readline()\n+                        if line:\n+                            logger.debug(f'LINE: {line}')\n+                            output_lines.append(line)\n+                            if self._shell_stream_callback:\n+                                self._shell_stream_callback(line)\n+\n+            # Attempt to read any remaining data from stdout\n+            if process.stdout and not process.stdout.closed:\n+                try:\n+                    while line:\n+                        line = process.stdout.readline()\n+                        if line:\n+                            logger.debug(f'LINE: {line}')\n+                            output_lines.append(line)\n+                            if self._shell_stream_callback:\n+                                self._shell_stream_callback(line)\n+                except Exception as e:\n+                    logger.warning(\n+                        f'Error reading directly from stdout after loop for \"{command}\": {e}'\n+                    )\n+\n+            exit_code = process.returncode\n+\n+            # If timeout occurred, ensure exit_code reflects this for the observation.\n+            if timed_out:\n+                exit_code = -1\n+\n+        except Exception as e:\n+            logger.error(\n+                f'Outer exception in _execute_shell_command for \"{command}\": {e}'\n+            )\n+            if process and process.poll() is None:\n+                self._safe_terminate_process(process, signal_to_send=signal.SIGKILL)\n+            return CmdOutputObservation(\n+                command=command,\n+                content=''.join(output_lines) + f'\\nError during execution: {e}',\n+                exit_code=-1,\n+            )\n+\n+        complete_output = ''.join(output_lines)\n+        logger.debug(\n+            f'[_execute_shell_command] Complete output for \"{command}\" (len: {len(complete_output)}): {complete_output!r}'\n+        )\n+        obs_metadata = {'working_dir': self._workspace_path}\n+        if timed_out:\n+            obs_metadata['suffix'] = (\n+                f'[The command timed out after {timeout:.1f} seconds.]'\n+            )\n+            # exit_code = -1 # This is already set if timed_out is True\n+\n+        return CmdOutputObservation(\n+            command=command,\n+            content=complete_output,\n+            exit_code=exit_code,\n+            metadata=obs_metadata,\n+        )\n+\n+    def run(self, action: CmdRunAction) -> Observation:\n+        \"\"\"Run a command using subprocess.\"\"\"\n+        if not self._runtime_initialized:\n+            return ErrorObservation(\n+                f'Runtime not initialized for command: {action.command}'\n+            )\n+\n+        if action.is_input:\n+            logger.warning(\n+                f\"CLIRuntime received an action with `is_input=True` (command: '{action.command}'). \"\n+                'CLIRuntime currently does not support sending input or signals to active processes. '\n+                'This action will be ignored and an error observation will be returned.'\n+            )\n+            return ErrorObservation(\n+                content=f\"CLIRuntime does not support interactive input from the agent (e.g., 'C-c'). The command '{action.command}' was not sent to any process.\",\n+                error_id='AGENT_ERROR$BAD_ACTION',\n+            )\n+\n+        try:\n+            effective_timeout = (\n+                action.timeout\n+                if action.timeout is not None\n+                else self.config.sandbox.timeout\n+            )\n+\n+            logger.debug(\n+                f'Running command in CLIRuntime: \"{action.command}\" with effective timeout: {effective_timeout}s'\n+            )\n+            return self._execute_shell_command(\n+                action.command, timeout=effective_timeout\n+            )\n+        except Exception as e:\n+            logger.error(\n+                f'Error in CLIRuntime.run for command \"{action.command}\": {str(e)}'\n+            )\n+            return ErrorObservation(\n+                f'Error running command \"{action.command}\": {str(e)}'\n+            )\n+\n+    def run_ipython(self, action: IPythonRunCellAction) -> Observation:\n+        \"\"\"Run a Python code cell.\n+        This functionality is not implemented in CLIRuntime.\n+        Users should also disable the Jupyter plugin in AgentConfig.\n+        \"\"\"\n+        # This functionality is not implemented in CLIRuntime.\n+        # If you need to run IPython/Jupyter cells, please consider using a different runtime\n+        # or ensure the Jupyter plugin is disabled in your AgentConfig to avoid\n+        # attempting to use this disabled feature.\n+        logger.warning(\n+            \"run_ipython is called on CLIRuntime, but it's not implemented. \"\n+            'Please disable the Jupyter plugin in AgentConfig.'\n+        )\n+        return ErrorObservation(\n+            'Executing IPython cells is not implemented in CLIRuntime. '\n+        )\n+\n+    def _sanitize_filename(self, filename: str) -> str:\n+        # if path is absolute, ensure it starts with _workspace_path\n+        if filename == '/workspace':\n+            actual_filename = self._workspace_path\n+        elif filename.startswith('/workspace/'):\n+            # Map /workspace/ to the actual workspace path\n+            # Note: /workspace is widely used, so we map it to allow using it with CLIRuntime\n+            actual_filename = os.path.join(\n+                self._workspace_path, filename[len('/workspace/') :]\n+            )\n+        elif filename.startswith('/'):\n+            if not filename.startswith(self._workspace_path):\n+                raise LLMMalformedActionError(\n+                    f'Invalid path: {filename}. You can only work with files in {self._workspace_path}.'\n+                )\n+            actual_filename = filename\n+        else:\n+            actual_filename = os.path.join(self._workspace_path, filename.lstrip('/'))\n+\n+        # Resolve the path to handle any '..' or '.' components\n+        resolved_path = os.path.realpath(actual_filename)\n+\n+        # Check if the resolved path is still within the workspace\n+        if not resolved_path.startswith(self._workspace_path):\n+            raise LLMMalformedActionError(\n+                f'Invalid path traversal: {filename}. Path resolves outside the workspace. Resolved: {resolved_path}, Workspace: {self._workspace_path}'\n+            )\n+\n+        return resolved_path\n+\n+    def read(self, action: FileReadAction) -> Observation:\n+        \"\"\"Read a file using Python's standard library or OHEditor.\"\"\"\n+        if not self._runtime_initialized:\n+            return ErrorObservation('Runtime not initialized')\n+\n+        file_path = self._sanitize_filename(action.path)\n+\n+        # Cannot read binary files\n+        if os.path.exists(file_path) and is_binary(file_path):\n+            return ErrorObservation('ERROR_BINARY_FILE')\n+\n+        # Use OHEditor for OH_ACI implementation source\n+        if action.impl_source == FileReadSource.OH_ACI:\n+            result_str, _ = self._execute_file_editor(\n+                command='view',\n+                path=file_path,\n+                view_range=action.view_range,\n+            )\n+\n+            return FileReadObservation(\n+                content=result_str,\n+                path=action.path,\n+                impl_source=FileReadSource.OH_ACI,\n+            )\n+\n+        try:\n+            # Check if the file exists\n+            if not os.path.exists(file_path):\n+                return ErrorObservation(f'File not found: {action.path}')\n+\n+            # Check if it's a directory\n+            if os.path.isdir(file_path):\n+                return ErrorObservation(f'Cannot read directory: {action.path}')\n+\n+            # Read the file\n+            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:\n+                content = f.read()\n+\n+            return FileReadObservation(content=content, path=action.path)\n+        except Exception as e:\n+            logger.error(f'Error reading file: {str(e)}')\n+            return ErrorObservation(f'Error reading file {action.path}: {str(e)}')\n+\n+    def write(self, action: FileWriteAction) -> Observation:\n+        \"\"\"Write to a file using Python's standard library.\"\"\"\n+        if not self._runtime_initialized:\n+            return ErrorObservation('Runtime not initialized')\n+\n+        file_path = self._sanitize_filename(action.path)\n+\n+        try:\n+            # Create parent directories if they don't exist\n+            os.makedirs(os.path.dirname(file_path), exist_ok=True)\n+\n+            # Write to the file\n+            with open(file_path, 'w', encoding='utf-8') as f:\n+                f.write(action.content)\n+\n+            return FileWriteObservation(content='', path=action.path)\n+        except Exception as e:\n+            logger.error(f'Error writing to file: {str(e)}')\n+            return ErrorObservation(f'Error writing to file {action.path}: {str(e)}')\n+\n+    def browse(self, action: BrowseURLAction) -> Observation:\n+        \"\"\"Not implemented for CLI runtime.\"\"\"\n+        return ErrorObservation(\n+            'Browser functionality is not implemented in CLIRuntime'\n+        )\n+\n+    def browse_interactive(self, action: BrowseInteractiveAction) -> Observation:\n+        \"\"\"Not implemented for CLI runtime.\"\"\"\n+        return ErrorObservation(\n+            'Browser functionality is not implemented in CLIRuntime'\n+        )\n+\n+    def _execute_file_editor(\n+        self,\n+        command: str,\n+        path: str,\n+        file_text: str | None = None,\n+        view_range: list[int] | None = None,\n+        old_str: str | None = None,\n+        new_str: str | None = None,\n+        insert_line: int | None = None,\n+        enable_linting: bool = False,\n+    ) -> tuple[str, tuple[str | None, str | None]]:\n+        \"\"\"Execute file editor command and handle exceptions.\n+\n+        Args:\n+            command: Editor command to execute\n+            path: File path\n+            file_text: Optional file text content\n+            view_range: Optional view range tuple (start, end)\n+            old_str: Optional string to replace\n+            new_str: Optional replacement string\n+            insert_line: Optional line number for insertion\n+            enable_linting: Whether to enable linting\n+\n+        Returns:\n+            tuple: A tuple containing the output string and a tuple of old and new file content\n+        \"\"\"\n+        result: ToolResult | None = None\n+        try:\n+            result = self.file_editor(\n+                command=command,\n+                path=path,\n+                file_text=file_text,\n+                view_range=view_range,\n+                old_str=old_str,\n+                new_str=new_str,\n+                insert_line=insert_line,\n+                enable_linting=enable_linting,\n+            )\n+        except ToolError as e:\n+            result = ToolResult(error=e.message)\n+\n+        if result.error:\n+            return f'ERROR:\\n{result.error}', (None, None)\n+\n+        if not result.output:\n+            logger.warning(f'No output from file_editor for {path}')\n+            return '', (None, None)\n+\n+        return result.output, (result.old_content, result.new_content)\n+\n+    def edit(self, action: FileEditAction) -> Observation:\n+        \"\"\"Edit a file using the OHEditor.\"\"\"\n+        if not self._runtime_initialized:\n+            return ErrorObservation('Runtime not initialized')\n+\n+        # Ensure the path is within the workspace\n+        file_path = self._sanitize_filename(action.path)\n+\n+        # Check if it's a binary file\n+        if os.path.exists(file_path) and is_binary(file_path):\n+            return ErrorObservation('ERROR_BINARY_FILE')\n+\n+        assert action.impl_source == FileEditSource.OH_ACI\n+\n+        result_str, (old_content, new_content) = self._execute_file_editor(\n+            command=action.command,\n+            path=file_path,\n+            file_text=action.file_text,\n+            old_str=action.old_str,\n+            new_str=action.new_str,\n+            insert_line=action.insert_line,\n+            enable_linting=False,\n+        )\n+\n+        return FileEditObservation(\n+            content=result_str,\n+            path=action.path,\n+            old_content=action.old_str,\n+            new_content=action.new_str,\n+            impl_source=FileEditSource.OH_ACI,\n+            diff=get_diff(\n+                old_contents=old_content or '',\n+                new_contents=new_content or '',\n+                filepath=action.path,\n+            ),\n+        )\n+\n+    async def call_tool_mcp(self, action: MCPAction) -> Observation:\n+        \"\"\"Not implemented for CLI runtime.\"\"\"\n+        return ErrorObservation('MCP functionality is not implemented in CLIRuntime')\n+\n+    @property\n+    def workspace_root(self) -> Path:\n+        \"\"\"Return the workspace root path.\"\"\"\n+        return Path(os.path.abspath(self._workspace_path))\n+\n+    def copy_to(self, host_src: str, sandbox_dest: str, recursive: bool = False):\n+        \"\"\"Copy a file or directory from the host to the sandbox.\"\"\"\n+        if not self._runtime_initialized:\n+            raise RuntimeError('Runtime not initialized')\n+        if not os.path.exists(host_src):  # Source must exist on host\n+            raise FileNotFoundError(f\"Source path '{host_src}' does not exist.\")\n+\n+        dest = self._sanitize_filename(sandbox_dest)\n+\n+        try:\n+            # Case 1: Source is a directory and recursive copy.\n+            if os.path.isdir(host_src) and recursive:\n+                # Target is dest / basename(host_src)\n+                final_target_dir = os.path.join(dest, os.path.basename(host_src))\n+\n+                # If source and final target are the same, skip.\n+                if os.path.realpath(host_src) == os.path.realpath(final_target_dir):\n+                    logger.debug(\n+                        'Skipping recursive copy: source and target are identical.'\n+                    )\n+                    pass\n+                else:\n+                    # Ensure parent of final_target_dir exists.\n+                    os.makedirs(dest, exist_ok=True)\n+                    shutil.copytree(host_src, final_target_dir, dirs_exist_ok=True)\n+                    # Why: Copies dir host_src into dest. Merges if target exists.\n+\n+            # Case 2: Source is a file.\n+            elif os.path.isfile(host_src):\n+                final_target_file_path: str\n+                # Scenario A: sandbox_dest is clearly a directory.\n+                if os.path.isdir(dest) or (sandbox_dest.endswith(('/', os.sep))):\n+                    target_dir = dest\n+                    os.makedirs(target_dir, exist_ok=True)\n+                    final_target_file_path = os.path.join(\n+                        target_dir, os.path.basename(host_src)\n+                    )\n+                    # Why: Copies file into specified directory.\n+\n+                # Scenario B: sandbox_dest is likely a new directory (e.g., 'new_dir').\n+                elif not os.path.exists(dest) and '.' not in os.path.basename(dest):\n+                    target_dir = dest\n+                    os.makedirs(target_dir, exist_ok=True)\n+                    final_target_file_path = os.path.join(\n+                        target_dir, os.path.basename(host_src)\n+                    )\n+                    # Why: Creates 'new_dir' and copies file into it.\n+\n+                # Scenario C: sandbox_dest is a full file path.\n+                else:\n+                    final_target_file_path = dest\n+                    os.makedirs(os.path.dirname(final_target_file_path), exist_ok=True)\n+                    # Why: Copies file to a specific path, possibly renaming.\n+\n+                shutil.copy2(host_src, final_target_file_path)\n+\n+            else:  # Source is not a valid file or directory.\n+                raise FileNotFoundError(\n+                    f\"Source path '{host_src}' is not a valid file or directory.\"\n+                )\n+\n+        except FileNotFoundError as e:\n+            logger.error(f'File not found during copy: {str(e)}')\n+            raise\n+        except shutil.SameFileError as e:\n+            # We can be lenient here, just ignore this error.\n+            logger.debug(\n+                f'Skipping copy as source and destination are the same: {str(e)}'\n+            )\n+            pass\n+        except Exception as e:\n+            logger.error(f'Unexpected error copying file: {str(e)}')\n+            raise RuntimeError(f'Unexpected error copying file: {str(e)}')\n+\n+    def list_files(self, path: str | None = None) -> list[str]:\n+        \"\"\"List files in the sandbox.\"\"\"\n+        if not self._runtime_initialized:\n+            raise RuntimeError('Runtime not initialized')\n+\n+        if path is None:\n+            dir_path = self._workspace_path\n+        else:\n+            dir_path = self._sanitize_filename(path)\n+\n+        try:\n+            if not os.path.exists(dir_path):\n+                return []\n+\n+            if not os.path.isdir(dir_path):\n+                return [dir_path]\n+\n+            # List files in the directory\n+            return [os.path.join(dir_path, f) for f in os.listdir(dir_path)]\n+        except Exception as e:\n+            logger.error(f'Error listing files: {str(e)}')\n+            return []\n+\n+    def copy_from(self, path: str) -> Path:\n+        \"\"\"Zip all files in the sandbox and return a path in the local filesystem.\"\"\"\n+        if not self._runtime_initialized:\n+            raise RuntimeError('Runtime not initialized')\n+\n+        source_path = self._sanitize_filename(path)\n+\n+        if not os.path.exists(source_path):\n+            raise FileNotFoundError(f'Path not found: {path}')\n+\n+        # Create a temporary zip file\n+        temp_zip = tempfile.NamedTemporaryFile(suffix='.zip', delete=False)\n+        temp_zip.close()\n+\n+        try:\n+            with zipfile.ZipFile(temp_zip.name, 'w', zipfile.ZIP_DEFLATED) as zipf:\n+                if os.path.isdir(source_path):\n+                    # Add all files in the directory\n+                    for root, _, files in os.walk(source_path):\n+                        for file in files:\n+                            file_path = os.path.join(root, file)\n+                            arcname = os.path.relpath(file_path, source_path)\n+                            zipf.write(file_path, arcname)\n+                else:\n+                    # Add a single file\n+                    zipf.write(source_path, os.path.basename(source_path))\n+\n+            return Path(temp_zip.name)\n+        except Exception as e:\n+            logger.error(f'Error creating zip file: {str(e)}')\n+            raise RuntimeError(f'Error creating zip file: {str(e)}')\n+\n+    def close(self) -> None:\n+        self._runtime_initialized = False\n+        super().close()\n+\n+    @classmethod\n+    async def delete(cls, conversation_id: str) -> None:\n+        \"\"\"Delete any resources associated with a conversation.\"\"\"\n+        # Look for temporary directories that might be associated with this conversation\n+        temp_dir = tempfile.gettempdir()\n+        prefix = f'openhands_workspace_{conversation_id}_'\n+\n+        for item in os.listdir(temp_dir):\n+            if item.startswith(prefix):\n+                try:\n+                    path = os.path.join(temp_dir, item)\n+                    if os.path.isdir(path):\n+                        shutil.rmtree(path)\n+                        logger.info(f'Deleted workspace directory: {path}')\n+                except Exception as e:\n+                    logger.error(f'Error deleting workspace directory: {str(e)}')\n+\n+    @property\n+    def additional_agent_instructions(self) -> str:\n+        return '\\n\\n'.join(\n+            [\n+                f'Your working directory is {self._workspace_path}. You can only read and write files in this directory.',\n+                \"You are working directly on the user's machine. In most cases, the working environment is already set up.\",\n+            ]\n+        )\n+\n+    def get_mcp_config(\n+        self, extra_stdio_servers: list[MCPStdioServerConfig] | None = None\n+    ) -> MCPConfig:\n+        # TODO: Load MCP config from a local file\n+        return MCPConfig()\n+\n+    def subscribe_to_shell_stream(\n+        self, callback: Callable[[str], None] | None = None\n+    ) -> bool:\n+        \"\"\"\n+        Subscribe to shell command output stream.\n+\n+        Args:\n+            callback: A function that will be called with each line of output from shell commands.\n+                     If None, any existing subscription will be removed.\n+        \"\"\"\n+        self._shell_stream_callback = callback\n+        return True\ndiff --git a/tests/unit/core/config/test_config_utils.py b/tests/unit/core/config/test_config_utils.py\nnew file mode 100644\nindex 000000000000..a18b26b817e7\n--- /dev/null\n+++ b/tests/unit/core/config/test_config_utils.py\n@@ -0,0 +1,135 @@\n+import pytest\n+\n+from openhands.core.config.agent_config import AgentConfig\n+from openhands.core.config.app_config import AppConfig\n+from openhands.core.config.utils import finalize_config, load_from_env, load_from_toml\n+\n+# Define a dummy agent name often used in tests or as a default\n+DEFAULT_AGENT_NAME = 'CodeActAgent'\n+\n+def test_finalize_config_cli_disables_jupyter_and_browsing_when_true():\n+    \"\"\"\n+    Test that finalize_config sets enable_jupyter and enable_browsing to False\n+    when runtime is 'cli' and they were initially True.\n+    \"\"\"\n+    app_config = AppConfig()\n+    app_config.runtime = 'cli'\n+    \n+    agent_config = AgentConfig(enable_jupyter=True, enable_browsing=True)\n+    app_config.agents[DEFAULT_AGENT_NAME] = agent_config\n+    \n+    finalize_config(app_config)\n+    \n+    assert not app_config.agents[DEFAULT_AGENT_NAME].enable_jupyter, \\\n+        \"enable_jupyter should be False when runtime is 'cli'\"\n+    assert not app_config.agents[DEFAULT_AGENT_NAME].enable_browsing, \\\n+        \"enable_browsing should be False when runtime is 'cli'\"\n+\n+def test_finalize_config_cli_keeps_jupyter_and_browsing_false_when_false():\n+    \"\"\"\n+    Test that finalize_config keeps enable_jupyter and enable_browsing as False\n+    when runtime is 'cli' and they were initially False.\n+    \"\"\"\n+    app_config = AppConfig()\n+    app_config.runtime = 'cli'\n+    \n+    agent_config = AgentConfig(enable_jupyter=False, enable_browsing=False)\n+    app_config.agents[DEFAULT_AGENT_NAME] = agent_config\n+    \n+    finalize_config(app_config)\n+    \n+    assert not app_config.agents[DEFAULT_AGENT_NAME].enable_jupyter, \\\n+        \"enable_jupyter should remain False when runtime is 'cli' and initially False\"\n+    assert not app_config.agents[DEFAULT_AGENT_NAME].enable_browsing, \\\n+        \"enable_browsing should remain False when runtime is 'cli' and initially False\"\n+\n+def test_finalize_config_other_runtime_keeps_jupyter_and_browsing_true_by_default():\n+    \"\"\"\n+    Test that finalize_config keeps enable_jupyter and enable_browsing as True (default)\n+    when runtime is not 'cli'.\n+    \"\"\"\n+    app_config = AppConfig()\n+    app_config.runtime = 'docker'  # A non-cli runtime\n+    \n+    # AgentConfig defaults enable_jupyter and enable_browsing to True\n+    agent_config = AgentConfig()\n+    app_config.agents[DEFAULT_AGENT_NAME] = agent_config\n+    \n+    finalize_config(app_config)\n+    \n+    assert app_config.agents[DEFAULT_AGENT_NAME].enable_jupyter, \\\n+        \"enable_jupyter should remain True by default for non-cli runtimes\"\n+    assert app_config.agents[DEFAULT_AGENT_NAME].enable_browsing, \\\n+        \"enable_browsing should remain True by default for non-cli runtimes\"\n+\n+def test_finalize_config_other_runtime_keeps_jupyter_and_browsing_false_if_set():\n+    \"\"\"\n+    Test that finalize_config keeps enable_jupyter and enable_browsing as False\n+    when runtime is not 'cli' but they were explicitly set to False.\n+    \"\"\"\n+    app_config = AppConfig()\n+    app_config.runtime = 'docker'  # A non-cli runtime\n+    \n+    agent_config = AgentConfig(enable_jupyter=False, enable_browsing=False)\n+    app_config.agents[DEFAULT_AGENT_NAME] = agent_config\n+    \n+    finalize_config(app_config)\n+    \n+    assert not app_config.agents[DEFAULT_AGENT_NAME].enable_jupyter, \\\n+        \"enable_jupyter should remain False for non-cli runtimes if explicitly set to False\"\n+    assert not app_config.agents[DEFAULT_AGENT_NAME].enable_browsing, \\\n+        \"enable_browsing should remain False for non-cli runtimes if explicitly set to False\"\n+\n+def test_finalize_config_no_agents_defined():\n+    \"\"\"\n+    Test that finalize_config runs without error if no agents are defined in the config,\n+    even when runtime is 'cli'.\n+    \"\"\"\n+    app_config = AppConfig()\n+    app_config.runtime = 'cli'\n+    # No agents are added to app_config.agents\n+    \n+    try:\n+        finalize_config(app_config)\n+    except Exception as e:\n+        pytest.fail(f\"finalize_config raised an exception with no agents defined: {e}\")\n+\n+def test_finalize_config_multiple_agents_cli_runtime():\n+    \"\"\"\n+    Test that finalize_config correctly disables jupyter and browsing for multiple agents\n+    when runtime is 'cli'.\n+    \"\"\"\n+    app_config = AppConfig()\n+    app_config.runtime = 'cli'\n+    \n+    agent_config1 = AgentConfig(enable_jupyter=True, enable_browsing=True)\n+    agent_config2 = AgentConfig(enable_jupyter=True, enable_browsing=True)\n+    app_config.agents['Agent1'] = agent_config1\n+    app_config.agents['Agent2'] = agent_config2\n+    \n+    finalize_config(app_config)\n+    \n+    assert not app_config.agents['Agent1'].enable_jupyter, \"Jupyter should be disabled for Agent1\"\n+    assert not app_config.agents['Agent1'].enable_browsing, \"Browsing should be disabled for Agent1\"\n+    assert not app_config.agents['Agent2'].enable_jupyter, \"Jupyter should be disabled for Agent2\"\n+    assert not app_config.agents['Agent2'].enable_browsing, \"Browsing should be disabled for Agent2\"\n+\n+def test_finalize_config_multiple_agents_other_runtime():\n+    \"\"\"\n+    Test that finalize_config correctly keeps jupyter and browsing enabled (or as set)\n+    for multiple agents when runtime is not 'cli'.\n+    \"\"\"\n+    app_config = AppConfig()\n+    app_config.runtime = 'docker'\n+    \n+    agent_config1 = AgentConfig(enable_jupyter=True, enable_browsing=True) # Defaults\n+    agent_config2 = AgentConfig(enable_jupyter=False, enable_browsing=False) # Explicitly false\n+    app_config.agents['Agent1'] = agent_config1\n+    app_config.agents['Agent2'] = agent_config2\n+    \n+    finalize_config(app_config)\n+    \n+    assert app_config.agents['Agent1'].enable_jupyter, \"Jupyter should be True for Agent1\"\n+    assert app_config.agents['Agent1'].enable_browsing, \"Browsing should be True for Agent1\"\n+    assert not app_config.agents['Agent2'].enable_jupyter, \"Jupyter should be False for Agent2\"\n+    assert not app_config.agents['Agent2'].enable_browsing, \"Browsing should be False for Agent2\"\n\\ No newline at end of file\ndiff --git a/tests/unit/test_cli_workspace.py b/tests/unit/test_cli_workspace.py\nnew file mode 100644\nindex 000000000000..6360fbd2961d\n--- /dev/null\n+++ b/tests/unit/test_cli_workspace.py\n@@ -0,0 +1,82 @@\n+\"\"\"Test CLIRuntime class.\"\"\"\n+\n+import os\n+import tempfile\n+\n+import pytest\n+\n+from openhands.core.config import AppConfig\n+from openhands.core.exceptions import LLMMalformedActionError\n+from openhands.events import EventStream\n+from openhands.runtime.impl.cli.cli_runtime import CLIRuntime\n+from openhands.storage import get_file_store\n+\n+\n+@pytest.fixture\n+def temp_dir():\n+    \"\"\"Create a temporary directory for testing.\"\"\"\n+    with tempfile.TemporaryDirectory() as temp_dir:\n+        yield temp_dir\n+\n+\n+@pytest.fixture\n+def cli_runtime(temp_dir):\n+    \"\"\"Create a CLIRuntime instance for testing.\"\"\"\n+    file_store = get_file_store('local', temp_dir)\n+    event_stream = EventStream('test', file_store)\n+    config = AppConfig()\n+    config.workspace_base = temp_dir\n+    runtime = CLIRuntime(config, event_stream)\n+    runtime._runtime_initialized = True  # Skip initialization\n+    return runtime\n+\n+\n+def test_sanitize_filename_valid_path(cli_runtime):\n+    \"\"\"Test _sanitize_filename with a valid path.\"\"\"\n+    test_path = os.path.join(cli_runtime._workspace_path, 'test.txt')\n+    sanitized_path = cli_runtime._sanitize_filename(test_path)\n+    assert sanitized_path == os.path.realpath(test_path)\n+\n+\n+def test_sanitize_filename_relative_path(cli_runtime):\n+    \"\"\"Test _sanitize_filename with a relative path.\"\"\"\n+    test_path = 'test.txt'\n+    expected_path = os.path.join(cli_runtime._workspace_path, test_path)\n+    sanitized_path = cli_runtime._sanitize_filename(test_path)\n+    assert sanitized_path == os.path.realpath(expected_path)\n+\n+\n+def test_sanitize_filename_outside_workspace(cli_runtime):\n+    \"\"\"Test _sanitize_filename with a path outside the workspace.\"\"\"\n+    test_path = '/tmp/test.txt'  # Path outside workspace\n+    with pytest.raises(LLMMalformedActionError) as exc_info:\n+        cli_runtime._sanitize_filename(test_path)\n+    assert 'Invalid path:' in str(exc_info.value)\n+    assert 'You can only work with files in' in str(exc_info.value)\n+\n+\n+def test_sanitize_filename_path_traversal(cli_runtime):\n+    \"\"\"Test _sanitize_filename with path traversal attempt.\"\"\"\n+    test_path = os.path.join(cli_runtime._workspace_path, '..', 'test.txt')\n+    with pytest.raises(LLMMalformedActionError) as exc_info:\n+        cli_runtime._sanitize_filename(test_path)\n+    assert 'Invalid path traversal:' in str(exc_info.value)\n+    assert 'Path resolves outside the workspace' in str(exc_info.value)\n+\n+\n+def test_sanitize_filename_absolute_path_with_dots(cli_runtime):\n+    \"\"\"Test _sanitize_filename with absolute path containing dots.\"\"\"\n+    test_path = os.path.join(cli_runtime._workspace_path, 'subdir', '..', 'test.txt')\n+    # Create the parent directory\n+    os.makedirs(os.path.join(cli_runtime._workspace_path, 'subdir'), exist_ok=True)\n+    sanitized_path = cli_runtime._sanitize_filename(test_path)\n+    assert sanitized_path == os.path.join(cli_runtime._workspace_path, 'test.txt')\n+\n+\n+def test_sanitize_filename_nested_path(cli_runtime):\n+    \"\"\"Test _sanitize_filename with a nested path.\"\"\"\n+    nested_dir = os.path.join(cli_runtime._workspace_path, 'dir1', 'dir2')\n+    os.makedirs(nested_dir, exist_ok=True)\n+    test_path = os.path.join(nested_dir, 'test.txt')\n+    sanitized_path = cli_runtime._sanitize_filename(test_path)\n+    assert sanitized_path == os.path.realpath(test_path)\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR shows solid progress with runtime implementations added in `__init__.py` and security validations in `cli_runtime.py`. However, three unit tests are currently failing, which indicates that some edge cases might not be handled correctly. Specifically, ensure that `LLMMalformedActionError` is correctly raised for invalid paths, as mentioned in `agent_controller.py`. Additionally, don't forget to integrate the new `CliRuntime` into the runtime test workflow and resolve any merge conflicts before completion. Overall, the groundwork is strong, but attention to these points is crucial."
      }
    ],
    "token_estimation": 10773.25
  },
  {
    "index": 67,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/opendevin/runtime/plugins/agent_skills/repomap/LICENSE.txt b/opendevin/runtime/plugins/agent_skills/repomap/LICENSE.txt\nnew file mode 100644\nindex 000000000000..d64569567334\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/repomap/LICENSE.txt\n@@ -0,0 +1,202 @@\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\ndiff --git a/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-elixir-tags.scm b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-elixir-tags.scm\nnew file mode 100644\nindex 000000000000..9eb39d95d85b\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-elixir-tags.scm\n@@ -0,0 +1,54 @@\n+; Definitions\n+\n+; * modules and protocols\n+(call\n+  target: (identifier) @ignore\n+  (arguments (alias) @name.definition.module)\n+  (#match? @ignore \"^(defmodule|defprotocol)$\")) @definition.module\n+\n+; * functions/macros\n+(call\n+  target: (identifier) @ignore\n+  (arguments\n+    [\n+      ; zero-arity functions with no parentheses\n+      (identifier) @name.definition.function\n+      ; regular function clause\n+      (call target: (identifier) @name.definition.function)\n+      ; function clause with a guard clause\n+      (binary_operator\n+        left: (call target: (identifier) @name.definition.function)\n+        operator: \"when\")\n+    ])\n+  (#match? @ignore \"^(def|defp|defdelegate|defguard|defguardp|defmacro|defmacrop|defn|defnp)$\")) @definition.function\n+\n+; References\n+\n+; ignore calls to kernel/special-forms keywords\n+(call\n+  target: (identifier) @ignore\n+  (#match? @ignore \"^(def|defp|defdelegate|defguard|defguardp|defmacro|defmacrop|defn|defnp|defmodule|defprotocol|defimpl|defstruct|defexception|defoverridable|alias|case|cond|else|for|if|import|quote|raise|receive|require|reraise|super|throw|try|unless|unquote|unquote_splicing|use|with)$\"))\n+\n+; ignore module attributes\n+(unary_operator\n+  operator: \"@\"\n+  operand: (call\n+    target: (identifier) @ignore))\n+\n+; * function call\n+(call\n+  target: [\n+   ; local\n+   (identifier) @name.reference.call\n+   ; remote\n+   (dot\n+     right: (identifier) @name.reference.call)\n+  ]) @reference.call\n+\n+; * pipe into function call\n+(binary_operator\n+  operator: \"|>\"\n+  right: (identifier) @name.reference.call) @reference.call\n+\n+; * modules\n+(alias) @name.reference.module @reference.module\ndiff --git a/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-javascript-tags.scm b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-javascript-tags.scm\nnew file mode 100644\nindex 000000000000..3bc55c5c58cd\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-javascript-tags.scm\n@@ -0,0 +1,88 @@\n+(\n+  (comment)* @doc\n+  .\n+  (method_definition\n+    name: (property_identifier) @name.definition.method) @definition.method\n+  (#not-eq? @name.definition.method \"constructor\")\n+  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n+  (#select-adjacent! @doc @definition.method)\n+)\n+\n+(\n+  (comment)* @doc\n+  .\n+  [\n+    (class\n+      name: (_) @name.definition.class)\n+    (class_declaration\n+      name: (_) @name.definition.class)\n+  ] @definition.class\n+  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n+  (#select-adjacent! @doc @definition.class)\n+)\n+\n+(\n+  (comment)* @doc\n+  .\n+  [\n+    (function\n+      name: (identifier) @name.definition.function)\n+    (function_declaration\n+      name: (identifier) @name.definition.function)\n+    (generator_function\n+      name: (identifier) @name.definition.function)\n+    (generator_function_declaration\n+      name: (identifier) @name.definition.function)\n+  ] @definition.function\n+  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n+  (#select-adjacent! @doc @definition.function)\n+)\n+\n+(\n+  (comment)* @doc\n+  .\n+  (lexical_declaration\n+    (variable_declarator\n+      name: (identifier) @name.definition.function\n+      value: [(arrow_function) (function)]) @definition.function)\n+  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n+  (#select-adjacent! @doc @definition.function)\n+)\n+\n+(\n+  (comment)* @doc\n+  .\n+  (variable_declaration\n+    (variable_declarator\n+      name: (identifier) @name.definition.function\n+      value: [(arrow_function) (function)]) @definition.function)\n+  (#strip! @doc \"^[\\\\s\\\\*/]+|^[\\\\s\\\\*/]$\")\n+  (#select-adjacent! @doc @definition.function)\n+)\n+\n+(assignment_expression\n+  left: [\n+    (identifier) @name.definition.function\n+    (member_expression\n+      property: (property_identifier) @name.definition.function)\n+  ]\n+  right: [(arrow_function) (function)]\n+) @definition.function\n+\n+(pair\n+  key: (property_identifier) @name.definition.function\n+  value: [(arrow_function) (function)]) @definition.function\n+\n+(\n+  (call_expression\n+    function: (identifier) @name.reference.call) @reference.call\n+  (#not-match? @name.reference.call \"^(require)$\")\n+)\n+\n+(call_expression\n+  function: (member_expression\n+    property: (property_identifier) @name.reference.call)\n+  arguments: (_) @reference.call)\n+\n+(new_expression\n+  constructor: (_) @name.reference.class) @reference.class\ndiff --git a/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-ocaml-tags.scm b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-ocaml-tags.scm\nnew file mode 100644\nindex 000000000000..1799f8acf2d2\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-ocaml-tags.scm\n@@ -0,0 +1,116 @@\n+; Modules\n+;--------\n+\n+(\n+  (comment)? @doc .\n+  (module_definition (module_binding (module_name) @name.definition.module) @definition.module)\n+  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n+)\n+\n+(module_path (module_name) @name.reference.module) @reference.module\n+\n+; Modules types\n+;--------------\n+\n+(\n+  (comment)? @doc .\n+  (module_type_definition (module_type_name) @name.definition.interface) @definition.interface\n+  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n+)\n+\n+(module_type_path (module_type_name) @name.reference.implementation) @reference.implementation\n+\n+; Functions\n+;----------\n+\n+(\n+  (comment)? @doc .\n+  (value_definition\n+    [\n+      (let_binding\n+        pattern: (value_name) @name.definition.function\n+        (parameter))\n+      (let_binding\n+        pattern: (value_name) @name.definition.function\n+        body: [(fun_expression) (function_expression)])\n+    ] @definition.function\n+  )\n+  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n+)\n+\n+(\n+  (comment)? @doc .\n+  (external (value_name) @name.definition.function) @definition.function\n+  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n+)\n+\n+(application_expression\n+  function: (value_path (value_name) @name.reference.call)) @reference.call\n+\n+(infix_expression\n+  left: (value_path (value_name) @name.reference.call)\n+  (infix_operator) @reference.call\n+  (#eq? @reference.call \"@@\"))\n+\n+(infix_expression\n+  (infix_operator) @reference.call\n+  right: (value_path (value_name) @name.reference.call)\n+  (#eq? @reference.call \"|>\"))\n+\n+; Operator\n+;---------\n+\n+(\n+  (comment)? @doc .\n+  (value_definition\n+    (let_binding\n+      pattern: (parenthesized_operator [\n+        (prefix_operator)\n+        (infix_operator)\n+        (hash_operator)\n+        (indexing_operator)\n+        (let_operator)\n+        (and_operator)\n+        (match_operator)\n+      ] @name.definition.function)) @definition.function)\n+  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n+)\n+\n+[\n+  (prefix_operator)\n+  (sign_operator)\n+  (infix_operator)\n+  (hash_operator)\n+  (indexing_operator)\n+  (let_operator)\n+  (and_operator)\n+  (match_operator)\n+] @name.reference.call @reference.call\n+\n+; Classes\n+;--------\n+\n+(\n+  (comment)? @doc .\n+  [\n+    (class_definition (class_binding (class_name) @name.definition.class) @definition.class)\n+    (class_type_definition (class_type_binding (class_type_name) @name.definition.class) @definition.class)\n+  ]\n+  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n+)\n+\n+[\n+  (class_path (class_name) @name.reference.class)\n+  (class_type_path (class_type_name) @name.reference.class)\n+] @reference.class\n+\n+; Methods\n+;--------\n+\n+(\n+  (comment)? @doc .\n+  (method_definition (method_name) @name.definition.method) @definition.method\n+  (#strip! @doc \"^\\\\(\\\\*\\\\*?\\\\s*|\\\\s\\\\*\\\\)$\")\n+)\n+\n+(method_invocation (method_name) @name.reference.call) @reference.call\ndiff --git a/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-ruby-tags.scm b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-ruby-tags.scm\nnew file mode 100644\nindex 000000000000..79e71d2d646e\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-ruby-tags.scm\n@@ -0,0 +1,64 @@\n+; Method definitions\n+\n+(\n+  (comment)* @doc\n+  .\n+  [\n+    (method\n+      name: (_) @name.definition.method) @definition.method\n+    (singleton_method\n+      name: (_) @name.definition.method) @definition.method\n+  ]\n+  (#strip! @doc \"^#\\\\s*\")\n+  (#select-adjacent! @doc @definition.method)\n+)\n+\n+(alias\n+  name: (_) @name.definition.method) @definition.method\n+\n+(setter\n+  (identifier) @ignore)\n+\n+; Class definitions\n+\n+(\n+  (comment)* @doc\n+  .\n+  [\n+    (class\n+      name: [\n+        (constant) @name.definition.class\n+        (scope_resolution\n+          name: (_) @name.definition.class)\n+      ]) @definition.class\n+    (singleton_class\n+      value: [\n+        (constant) @name.definition.class\n+        (scope_resolution\n+          name: (_) @name.definition.class)\n+      ]) @definition.class\n+  ]\n+  (#strip! @doc \"^#\\\\s*\")\n+  (#select-adjacent! @doc @definition.class)\n+)\n+\n+; Module definitions\n+\n+(\n+  (module\n+    name: [\n+      (constant) @name.definition.module\n+      (scope_resolution\n+        name: (_) @name.definition.module)\n+    ]) @definition.module\n+)\n+\n+; Calls\n+\n+(call method: (identifier) @name.reference.call) @reference.call\n+\n+(\n+  [(identifier) (constant)] @name.reference.call @reference.call\n+  (#is-not? local)\n+  (#not-match? @name.reference.call \"^(lambda|load|require|require_relative|__FILE__|__LINE__)$\")\n+)\ndiff --git a/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-rust-tags.scm b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-rust-tags.scm\nnew file mode 100644\nindex 000000000000..dadfa7acb6f0\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/repomap/queries/tree-sitter-rust-tags.scm\n@@ -0,0 +1,60 @@\n+; ADT definitions\n+\n+(struct_item\n+    name: (type_identifier) @name.definition.class) @definition.class\n+\n+(enum_item\n+    name: (type_identifier) @name.definition.class) @definition.class\n+\n+(union_item\n+    name: (type_identifier) @name.definition.class) @definition.class\n+\n+; type aliases\n+\n+(type_item\n+    name: (type_identifier) @name.definition.class) @definition.class\n+\n+; method definitions\n+\n+(declaration_list\n+    (function_item\n+        name: (identifier) @name.definition.method)) @definition.method\n+\n+; function definitions\n+\n+(function_item\n+    name: (identifier) @name.definition.function) @definition.function\n+\n+; trait definitions\n+(trait_item\n+    name: (type_identifier) @name.definition.interface) @definition.interface\n+\n+; module definitions\n+(mod_item\n+    name: (identifier) @name.definition.module) @definition.module\n+\n+; macro definitions\n+\n+(macro_definition\n+    name: (identifier) @name.definition.macro) @definition.macro\n+\n+; references\n+\n+(call_expression\n+    function: (identifier) @name.reference.call) @reference.call\n+\n+(call_expression\n+    function: (field_expression\n+        field: (field_identifier) @name.reference.call)) @reference.call\n+\n+(macro_invocation\n+    macro: (identifier) @name.reference.call) @reference.call\n+\n+; implementations\n+\n+(impl_item\n+    trait: (type_identifier) @name.reference.implementation) @reference.implementation\n+\n+(impl_item\n+    type: (type_identifier) @name.reference.implementation\n+    !trait) @reference.implementation\ndiff --git a/opendevin/runtime/plugins/agent_skills/repomap/repomap.py b/opendevin/runtime/plugins/agent_skills/repomap/repomap.py\nnew file mode 100644\nindex 000000000000..38a596bea28f\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/repomap/repomap.py\n@@ -0,0 +1,841 @@\n+\"\"\"\n+Modifications made on June, 2024.\n+Description of changes: removed redundant methods, attributes, and adapted some classes to be OpenDevin-specific.\n+\"\"\"\n+\n+import base64\n+import os\n+import re\n+import warnings\n+from collections import Counter, defaultdict, namedtuple\n+from importlib import resources\n+from pathlib import Path, PurePosixPath\n+from typing import Any, Set\n+\n+import networkx as nx\n+import pathspec\n+from diskcache import Cache\n+from grep_ast import TreeContext, filename_to_lang\n+from pygments.lexers import guess_lexer_for_filename\n+from pygments.token import Token\n+from pygments.util import ClassNotFound\n+from tqdm import tqdm\n+from tree_sitter_languages import get_language, get_parser\n+\n+if __package__ is None or __package__ == '':\n+    from utils import get_token_count_from_text, is_image_file\n+else:\n+    from .utils import get_token_count_from_text, is_image_file\n+\n+# tree_sitter is throwing a FutureWarning\n+warnings.simplefilter('ignore', category=FutureWarning)\n+\n+Tag = namedtuple('Tag', ('rel_fname', 'fname', 'line', 'name', 'kind'))\n+\n+\n+class RepoMap:\n+    \"\"\"\n+    The RepoMap class represents a mapping of a repository's files and their associated tags.\n+    \"\"\"\n+\n+    CACHE_VERSION = 3\n+    TAGS_CACHE_DIR = f'.aider.tags.cache.v{CACHE_VERSION}'\n+\n+    cache_missing = False\n+    aider_ignore_ts = 0\n+\n+    warned_files: Set[str] = set()\n+\n+    def __init__(\n+        self,\n+        model_name,\n+        map_tokens=1024,\n+        root=None,\n+        repo_content_prefix=None,\n+        max_context_window=None,\n+        aider_ignore_file='.aiderignore',\n+    ):\n+        \"\"\"\n+        Initialize the Repomap object.\n+\n+        Args:\n+            llm (LLM): The LLM object used for token counting.\n+            io (InputOutput): The InputOutput object used for file I/O operations.\n+            map_tokens (int, optional): The maximum number of tokens to map. Defaults to 1024.\n+            root (str, optional): The root directory path. If not provided, the current working directory is used. Defaults to None.\n+            repo_content_prefix (str, optional): The prefix to add to the repository content paths. Defaults to None.\n+            verbose (bool, optional): Whether to enable verbose mode. Defaults to False.\n+            max_context_window (int, optional): The maximum context window size. Defaults to None.\n+        \"\"\"\n+        if not root:\n+            root = os.getcwd()\n+        self.root = root\n+\n+        self.load_tags_cache()\n+        self.model_name = model_name\n+        self.max_map_tokens = map_tokens\n+        self.max_context_window = max_context_window\n+\n+        self.token_count = get_token_count_from_text\n+        self.repo_content_prefix = repo_content_prefix\n+        self.abs_fnames: Any = set()\n+        if aider_ignore_file:\n+            self.aider_ignore_file = Path(aider_ignore_file)\n+\n+    def get_repo_map(\n+        self, chat_files, other_files, mentioned_fnames=None, mentioned_idents=None\n+    ):\n+        \"\"\"\n+        Generate a repository map based on the provided files and parameters.\n+\n+        Args:\n+            chat_files (list): List of files in the chat.\n+            other_files (list): List of other files in the repository.\n+            mentioned_fnames (set, optional): Set of mentioned filenames. Defaults to None.\n+            mentioned_idents (set, optional): Set of mentioned identifiers. Defaults to None.\n+\n+        Returns:\n+            str: The generated repository map as a string.\n+        \"\"\"\n+\n+        if self.max_map_tokens <= 0:\n+            return\n+        if not other_files:\n+            return\n+        if not mentioned_fnames:\n+            mentioned_fnames = set()\n+        if not mentioned_idents:\n+            mentioned_idents = set()\n+\n+        max_map_tokens = self.max_map_tokens\n+\n+        # With no files in the chat, give a bigger view of the entire repo\n+        MUL = 16\n+        padding = 4096\n+        if max_map_tokens and self.max_context_window:\n+            target = min(max_map_tokens * MUL, self.max_context_window - padding)\n+        else:\n+            target = 0\n+        if not chat_files and self.max_context_window and target > 0:\n+            max_map_tokens = target\n+\n+        try:\n+            files_listing = self.get_ranked_tags_map(\n+                chat_files,\n+                other_files,\n+                max_map_tokens,\n+                mentioned_fnames,\n+                mentioned_idents,\n+            )\n+        except RecursionError:\n+            self.log_error('Disabling repo map, git repo too large?')\n+            self.max_map_tokens = 0\n+            return\n+\n+        if not files_listing:\n+            return\n+\n+        # num_tokens = self.token_count(self.model_name, files_listing)\n+        # logger.info(f'Repo-map: {num_tokens/1024:.1f} k-tokens')\n+\n+        if chat_files:\n+            other = 'other '\n+        else:\n+            other = ''\n+\n+        if self.repo_content_prefix:\n+            repo_content = self.repo_content_prefix.format(other=other)\n+        else:\n+            repo_content = ''\n+\n+        repo_content += files_listing\n+\n+        return repo_content\n+\n+    def get_rel_fname(self, fname):\n+        \"\"\"\n+        Returns the relative path of a file with respect to the root directory.\n+\n+        Args:\n+            fname (str): The absolute path of the file.\n+\n+        Returns:\n+            str: The relative path of the file.\n+        \"\"\"\n+        return os.path.relpath(fname, self.root)\n+\n+    def load_tags_cache(self):\n+        \"\"\"\n+        Loads the tags cache from the specified path.\n+\n+        If the cache directory does not exist, sets the `cache_missing` flag to True.\n+        \"\"\"\n+        path = Path(self.root) / self.TAGS_CACHE_DIR\n+        if not path.exists():\n+            self.cache_missing = True\n+        self.TAGS_CACHE = Cache(path)\n+\n+    def save_tags_cache(self):\n+        pass\n+\n+    def get_mtime(self, fname):\n+        \"\"\"\n+        Get the modification time of a file.\n+\n+        Args:\n+            fname (str): The path to the file.\n+\n+        Returns:\n+            float: The modification time of the file in seconds since the epoch.\n+\n+        Raises:\n+            FileNotFoundError: If the file is not found.\n+        \"\"\"\n+        try:\n+            return os.path.getmtime(fname)\n+        except FileNotFoundError:\n+            self.log_error(f'File not found error: {fname}')\n+\n+    def get_tags(self, fname, rel_fname):\n+        \"\"\"\n+        Retrieves the tags associated with a file.\n+\n+        Args:\n+            fname (str): The absolute path of the file.\n+            rel_fname (str): The relative path of the file.\n+\n+        Returns:\n+            list: A list of tags associated with the file.\n+        \"\"\"\n+        # Check if the file is in the cache and if the modification time has not changed\n+        file_mtime = self.get_mtime(fname)\n+        if file_mtime is None:\n+            return []\n+\n+        cache_key = fname\n+        if (\n+            cache_key in self.TAGS_CACHE\n+            and self.TAGS_CACHE[cache_key]['mtime'] == file_mtime\n+        ):\n+            return self.TAGS_CACHE[cache_key]['data']\n+\n+        # miss!\n+\n+        data = list(self.get_tags_raw(fname, rel_fname))\n+\n+        # Update the cache\n+        self.TAGS_CACHE[cache_key] = {'mtime': file_mtime, 'data': data}\n+        self.save_tags_cache()\n+        return data\n+\n+    def get_tags_raw(self, fname, rel_fname):\n+        \"\"\"\n+        Retrieves tags from the given file.\n+\n+        Args:\n+            fname (str): The absolute path of the file.\n+            rel_fname (str): The relative path of the file.\n+\n+        Yields:\n+            Tag: A Tag object representing a tag found in the file.\n+\n+        Returns:\n+            None: If the language of the file is not supported or if the file is empty.\n+        \"\"\"\n+        lang = filename_to_lang(fname)\n+        if not lang:\n+            return\n+\n+        language = get_language(lang)\n+        parser = get_parser(lang)\n+\n+        # Load the tags queries\n+        try:\n+            scm_fname = (\n+                resources.files(__package__)\n+                .joinpath('queries')\n+                .joinpath(f'tree-sitter-{lang}-tags.scm')\n+            )\n+        except KeyError:\n+            return\n+        query_scm = str(scm_fname)\n+        if not Path(query_scm).exists():\n+            return\n+        query_scm = scm_fname.read_text()\n+\n+        code = self.read_text(fname)\n+        if not code:\n+            return\n+        tree = parser.parse(bytes(code, 'utf-8'))\n+\n+        # Run the tags queries\n+        query = language.query(query_scm)\n+        captures = query.captures(tree.root_node)\n+\n+        captures = list(captures)\n+\n+        saw = set()\n+        for node, tag in captures:\n+            if tag.startswith('name.definition.'):\n+                kind = 'def'\n+            elif tag.startswith('name.reference.'):\n+                kind = 'ref'\n+            else:\n+                continue\n+\n+            saw.add(kind)\n+\n+            result = Tag(\n+                rel_fname=rel_fname,\n+                fname=fname,\n+                name=node.text.decode('utf-8'),\n+                kind=kind,\n+                line=node.start_point[0],\n+            )\n+\n+            yield result\n+\n+        if 'ref' in saw:\n+            return\n+        if 'def' not in saw:\n+            return\n+\n+        # We saw defs, without any refs\n+        # Some tags files only provide defs (cpp, for example)\n+        # Use pygments to backfill refs\n+\n+        try:\n+            lexer = guess_lexer_for_filename(fname, code)\n+        except ClassNotFound:\n+            return\n+\n+        tokens = list(lexer.get_tokens(code))\n+        tokens = [token[1] for token in tokens if token[0] in Token.Name]\n+\n+        for token in tokens:\n+            yield Tag(\n+                rel_fname=rel_fname,\n+                fname=fname,\n+                name=token,\n+                kind='ref',\n+                line=-1,\n+            )\n+\n+    def get_ranked_tags(\n+        self, chat_fnames, other_fnames, mentioned_fnames, mentioned_idents\n+    ):\n+        \"\"\"\n+        Returns a list of ranked tags based on the provided file names and mentioned identifiers.\n+\n+        Args:\n+            chat_fnames (list): List of file names from the chat.\n+            other_fnames (list): List of other file names.\n+            mentioned_fnames (list): List of mentioned file names.\n+            mentioned_idents (list): List of mentioned identifiers.\n+\n+        Returns:\n+            list: A list of ranked tags.\n+        \"\"\"\n+        defines = defaultdict(set)\n+        references = defaultdict(list)\n+        definitions = defaultdict(set)\n+\n+        personalization = dict()\n+\n+        fnames_set = set(chat_fnames).union(set(other_fnames))\n+        chat_rel_fnames = set()\n+\n+        fnames = sorted(fnames_set)\n+\n+        # Default personalization for unspecified files is 1/num_nodes\n+        # https://networkx.org/documentation/stable/_modules/networkx/algorithms/link_analysis/pagerank_alg.html#pagerank\n+        personalize = 10 / len(fnames)\n+\n+        if self.cache_missing:\n+            fnames = tqdm(fnames)\n+        self.cache_missing = False\n+\n+        for fname in fnames:\n+            if not Path(fname).is_file():\n+                if fname not in self.warned_files:\n+                    if Path(fname).exists():\n+                        self.log_error(\n+                            f\"Repo-map can't include {fname}, it is not a normal file\"\n+                        )\n+                    else:\n+                        self.log_error(\n+                            f\"Repo-map can't include {fname}, it no longer exists\"\n+                        )\n+\n+                self.warned_files.add(fname)\n+                continue\n+\n+            # dump(fname)\n+            rel_fname = self.get_rel_fname(fname)\n+\n+            if fname in chat_fnames:\n+                personalization[rel_fname] = personalize\n+                chat_rel_fnames.add(rel_fname)\n+\n+            if fname in mentioned_fnames:\n+                personalization[rel_fname] = personalize\n+\n+            tags = list(self.get_tags(fname, rel_fname))\n+\n+            for tag in tags:\n+                if tag.kind == 'def':\n+                    defines[tag.name].add(rel_fname)\n+                    key = (rel_fname, tag.name)\n+                    definitions[key].add(tag)\n+\n+                if tag.kind == 'ref':\n+                    references[tag.name].append(rel_fname)\n+\n+        ##\n+        # dump(defines)\n+        # dump(references)\n+        # dump(personalization)\n+\n+        if not references:\n+            references = defaultdict(list)\n+            for k, v in defines.items():\n+                references[k] = list(v)\n+\n+        idents = set(defines.keys()).intersection(set(references.keys()))\n+\n+        G = nx.MultiDiGraph()\n+\n+        for ident in idents:\n+            definers = defines[ident]\n+            if ident in mentioned_idents:\n+                mul = 10\n+            else:\n+                mul = 1\n+            for referencer, num_refs in Counter(references[ident]).items():\n+                for definer in definers:\n+                    # if referencer == definer:\n+                    #    continue\n+                    G.add_edge(referencer, definer, weight=mul * num_refs, ident=ident)\n+\n+        if not references:\n+            pass\n+\n+        if personalization:\n+            pers_args = dict(personalization=personalization, dangling=personalization)\n+        else:\n+            pers_args = dict()\n+\n+        try:\n+            ranked = nx.pagerank(G, weight='weight', **pers_args)\n+        except ZeroDivisionError:\n+            return []\n+\n+        # distribute the rank from each source node, across all of its out edges\n+        ranked_definitions: Any = defaultdict(float)\n+        for src in G.nodes:\n+            src_rank = ranked[src]\n+            total_weight = sum(\n+                data['weight'] for _src, _dst, data in G.out_edges(src, data=True)\n+            )\n+            # dump(src, src_rank, total_weight)\n+            for _src, dst, data in G.out_edges(src, data=True):\n+                data['rank'] = src_rank * data['weight'] / total_weight\n+                ident = data['ident']\n+                ranked_definitions[(dst, ident)] += data['rank']\n+\n+        ranked_tags = []\n+        ranked_definitions = sorted(\n+            ranked_definitions.items(), reverse=True, key=lambda x: x[1]\n+        )\n+\n+        # dump(ranked_definitions)\n+\n+        for (fname, ident), rank in ranked_definitions:\n+            # print(f\"{rank:.03f} {fname} {ident}\")\n+            if fname in chat_rel_fnames:\n+                continue\n+            ranked_tags += list(definitions.get((fname, ident), []))\n+\n+        rel_other_fnames_without_tags = set(\n+            self.get_rel_fname(fname) for fname in other_fnames\n+        )\n+\n+        fnames_already_included = set(rt[0] for rt in ranked_tags)\n+\n+        top_rank = sorted(\n+            [(rank, node) for (node, rank) in ranked.items()], reverse=True\n+        )\n+        for rank, fname in top_rank:\n+            if fname in rel_other_fnames_without_tags:\n+                rel_other_fnames_without_tags.remove(fname)\n+            if fname not in fnames_already_included:\n+                ranked_tags.append((fname,))\n+\n+        for fname in rel_other_fnames_without_tags:\n+            ranked_tags.append((fname,))\n+\n+        return ranked_tags\n+\n+    def get_ranked_tags_map(\n+        self,\n+        chat_fnames,\n+        other_fnames=None,\n+        max_map_tokens=None,\n+        mentioned_fnames=None,\n+        mentioned_idents=None,\n+    ):\n+        \"\"\"\n+        Returns the best tree representation of ranked tags based on the given parameters.\n+\n+        Args:\n+            chat_fnames (list): A list of chat filenames.\n+            other_fnames (list, optional): A list of other filenames. Defaults to None.\n+            max_map_tokens (int, optional): The maximum number of tokens allowed in the map. Defaults to None.\n+            mentioned_fnames (set, optional): A set of mentioned filenames. Defaults to None.\n+            mentioned_idents (set, optional): A set of mentioned identifiers. Defaults to None.\n+\n+        Returns:\n+            The best tree representation of ranked tags.\n+        \"\"\"\n+        if not other_fnames:\n+            other_fnames = list()\n+        if not max_map_tokens:\n+            max_map_tokens = self.max_map_tokens\n+        if not mentioned_fnames:\n+            mentioned_fnames = set()\n+        if not mentioned_idents:\n+            mentioned_idents = set()\n+\n+        ranked_tags = self.get_ranked_tags(\n+            chat_fnames, other_fnames, mentioned_fnames, mentioned_idents\n+        )\n+\n+        num_tags = len(ranked_tags)\n+        lower_bound = 0\n+        upper_bound = num_tags\n+        best_tree = None\n+        best_tree_tokens = 0\n+\n+        chat_rel_fnames = {self.get_rel_fname(fname) for fname in chat_fnames}\n+\n+        # Guess a small starting number to help with giant repos\n+        middle = min(max_map_tokens // 25, num_tags)\n+\n+        self.tree_cache = dict()\n+\n+        while lower_bound <= upper_bound:\n+            tree = self.to_tree(ranked_tags[:middle], chat_rel_fnames)\n+            num_tokens = self.token_count(self.model_name, tree)\n+\n+            if num_tokens < max_map_tokens and num_tokens > best_tree_tokens:\n+                best_tree = tree\n+                best_tree_tokens = num_tokens\n+\n+            if num_tokens < max_map_tokens:\n+                lower_bound = middle + 1\n+            else:\n+                upper_bound = middle - 1\n+\n+            middle = (lower_bound + upper_bound) // 2\n+\n+        return best_tree\n+\n+    tree_cache: Any = dict()\n+\n+    def render_tree(self, abs_fname, rel_fname, lois):\n+        \"\"\"\n+        Renders the tree for a given file and lines of interest (lois).\n+\n+        Args:\n+            abs_fname (str): The absolute file path.\n+            rel_fname (str): The relative file path.\n+            lois (list): A list of lines of interest.\n+\n+        Returns:\n+            str: The rendered tree.\n+        \"\"\"\n+        key = (rel_fname, tuple(sorted(lois)))\n+\n+        if key in self.tree_cache:\n+            return self.tree_cache[key]\n+\n+        code = self.read_text(abs_fname) or ''\n+        if not code.endswith('\\n'):\n+            code += '\\n'\n+\n+        context = TreeContext(\n+            rel_fname,\n+            code,\n+            color=False,\n+            line_number=False,\n+            child_context=False,\n+            last_line=False,\n+            margin=0,\n+            mark_lois=False,\n+            loi_pad=0,\n+            # header_max=30,\n+            show_top_of_file_parent_scope=False,\n+        )\n+\n+        context.add_lines_of_interest(lois)\n+        context.add_context()\n+        res = context.format()\n+        self.tree_cache[key] = res\n+        return res\n+\n+    def to_tree(self, tags, chat_rel_fnames):\n+        \"\"\"\n+        Converts a list of tags into a tree-like structure.\n+\n+        Args:\n+            tags (list): A list of tags.\n+            chat_rel_fnames (list): A list of chat relative filenames.\n+\n+        Returns:\n+            str: The tree-like structure as a string.\n+        \"\"\"\n+        if not tags:\n+            return ''\n+\n+        tags = [tag for tag in tags if tag[0] not in chat_rel_fnames]\n+        tags = sorted(tags)\n+\n+        cur_fname: Any = None\n+        cur_abs_fname = None\n+        lois: Any = None\n+        output = ''\n+\n+        # add a bogus tag at the end so we trip the this_fname != cur_fname...\n+        dummy_tag = (None,)\n+        for tag in tags + [dummy_tag]:\n+            this_rel_fname = tag[0]\n+\n+            # ... here ... to output the final real entry in the list\n+            if this_rel_fname != cur_fname:\n+                if lois is not None:\n+                    output += cur_fname + ':\\n'\n+                    output += self.render_tree(cur_abs_fname, cur_fname, lois)\n+                    lois = None\n+                elif cur_fname:\n+                    output += '\\n' + cur_fname + '\\n'\n+\n+                if type(tag) is Tag:\n+                    lois = []\n+                    cur_abs_fname = tag.fname\n+                cur_fname = this_rel_fname\n+\n+            if lois is not None:\n+                lois.append(tag.line)\n+\n+        # truncate long lines, in case we get minified js or something else crazy\n+        output = '\\n'.join([line[:100] for line in output.splitlines()]) + '\\n'\n+\n+        return output\n+\n+    def get_history_aware_repo_map(self, messages: list) -> str:\n+        cur_msg_text = self.get_cur_message_text(messages)\n+        mentioned_fnames = self.get_file_mentions(cur_msg_text)\n+        mentioned_idents = self.get_ident_mentions(cur_msg_text)\n+\n+        other_files = set(self.get_all_abs_files()) - set(self.abs_fnames)\n+        repo_content = self.get_repo_map(\n+            self.abs_fnames,\n+            other_files,\n+            mentioned_fnames=mentioned_fnames,\n+            mentioned_idents=mentioned_idents,\n+        )\n+\n+        # fall back to global repo map if files in chat are disjoint from rest of repo\n+        if not repo_content:\n+            repo_content = self.get_repo_map(\n+                set(),\n+                set(self.get_all_abs_files()),\n+                mentioned_fnames=mentioned_fnames,\n+                mentioned_idents=mentioned_idents,\n+            )\n+\n+        # fall back to completely unhinted repo\n+        if not repo_content:\n+            repo_content = self.get_repo_map(\n+                set(),\n+                set(self.get_all_abs_files()),\n+            )\n+\n+        return repo_content\n+\n+    def get_cur_message_text(self, messages):\n+        text = ''\n+\n+        for msg in messages:\n+            text += msg['content'] + '\\n'\n+        return text\n+\n+    def get_ident_mentions(self, text):\n+        # Split the string on any character that is not alphanumeric\n+        # \\W+ matches one or more non-word characters (equivalent to [^a-zA-Z0-9_]+)\n+        words = set(re.split(r'\\W+', text))\n+        return words\n+\n+    def get_file_mentions(self, content):\n+        words = set(word for word in content.split())\n+\n+        # drop sentence punctuation from the end\n+        words = set(word.rstrip(',.!;:') for word in words)\n+\n+        # strip away all kinds of quotes\n+        quotes = ''.join(['\"', \"'\", '`'])\n+        words = set(word.strip(quotes) for word in words)\n+\n+        addable_rel_fnames = self.get_addable_relative_files()\n+\n+        mentioned_rel_fnames = set()\n+        fname_to_rel_fnames: Any = {}\n+        for rel_fname in addable_rel_fnames:\n+            if rel_fname in words:\n+                mentioned_rel_fnames.add(str(rel_fname))\n+\n+            fname = os.path.basename(rel_fname)\n+\n+            # Don't add basenames that could be plain words like \"run\" or \"make\"\n+            if '/' in fname or '.' in fname or '_' in fname or '-' in fname:\n+                if fname not in fname_to_rel_fnames:\n+                    fname_to_rel_fnames[fname] = []\n+                fname_to_rel_fnames[fname].append(rel_fname)\n+\n+        for fname, rel_fnames in fname_to_rel_fnames.items():\n+            if len(rel_fnames) == 1 and fname in words:\n+                mentioned_rel_fnames.add(rel_fnames[0])\n+\n+        return mentioned_rel_fnames\n+\n+    def get_all_relative_files(self):\n+        import git\n+\n+        # Construct a git repo object and get all the relative files tracked by git and staged files\n+        try:\n+            repo = git.Repo(self.root)\n+\n+            if repo.bare:\n+                raise Exception('The repository is bare.')\n+\n+            # Get a list of all tracked files\n+            tracked_files: Any = [\n+                item.path for item in repo.tree().traverse() if item.type == 'blob'\n+            ]\n+        except git.InvalidGitRepositoryError:\n+            # logger.error(\n+            #     'The directory is not a git repository. RepoMap will not be enabled.'\n+            # )\n+            return []\n+        except git.NoSuchPathError:\n+            # logger.error('The directory does not exist. RepoMap will not be enabled.')\n+            return []\n+        except Exception:\n+            # logger.error(\n+            #     f'An error occurred when getting tracked files in git repo: {e}'\n+            # )\n+            return []\n+\n+        # Add staged files\n+        index = repo.index\n+        staged_files = [path for path, _ in index.entries.keys()]\n+\n+        tracked_files.extend(staged_files)\n+\n+        # Normalize the paths\n+        tracked_files = set(self.normalize_path(path) for path in tracked_files)\n+        tracked_files = [\n+            fname for fname in tracked_files if not self.ignored_file(fname)\n+        ]\n+\n+        files = [\n+            fname\n+            for fname in tracked_files\n+            if Path(self.abs_root_path(fname)).is_file()\n+        ]\n+        return sorted(set(files))\n+\n+    def get_all_abs_files(self):\n+        files = self.get_all_relative_files()\n+        files = [self.abs_root_path(path) for path in files]\n+        return files\n+\n+    def abs_root_path(self, path):\n+        res = Path(self.root) / path\n+        return self.safe_abs_path(res)\n+\n+    def get_addable_relative_files(self):\n+        return set(self.get_all_relative_files()) - set(\n+            self.get_inchat_relative_files()\n+        )\n+\n+    def safe_abs_path(self, res):\n+        \"Gives an abs path, which safely returns a full (not 8.3) windows path\"\n+        res = Path(res).resolve()\n+        return str(res)\n+\n+    def get_inchat_relative_files(self):\n+        files = [self.get_rel_fname(fname) for fname in self.abs_fnames]\n+        return sorted(set(files))\n+\n+    def read_image(self, filename):\n+        try:\n+            with open(str(filename), 'rb') as image_file:\n+                encoded_string = base64.b64encode(image_file.read())\n+                return encoded_string.decode('utf-8')\n+        except FileNotFoundError:\n+            self.log_error(f'{filename}: file not found error')\n+            return\n+        except IsADirectoryError:\n+            self.log_error(f'{filename}: is a directory')\n+            return\n+        except Exception as e:\n+            self.log_error(f'{filename}: {e}')\n+            return\n+\n+    def read_text(self, filename):\n+        if is_image_file(filename):\n+            return self.read_image(filename)\n+\n+        try:\n+            with open(str(filename), 'r', encoding='utf-8') as f:\n+                return f.read()\n+        except FileNotFoundError:\n+            self.log_error(\n+                f'Error when constructing repomap: {filename}: file not found error'\n+            )\n+            return\n+        except IsADirectoryError:\n+            self.log_error(f'{filename}: is a directory')\n+            return\n+        except UnicodeError as e:\n+            self.log_error(f'{filename}: {e}')\n+            self.log_error('Use --encoding to set the unicode encoding.')\n+            return\n+\n+    def log_error(self, message):\n+        # logger.error(f'Error when constructing repomap: {message}')\n+        pass\n+\n+    def ignored_file(self, fname):\n+        if not self.aider_ignore_file or not self.aider_ignore_file.is_file():\n+            return\n+\n+        try:\n+            fname = self.normalize_path(fname)\n+        except ValueError:\n+            return\n+\n+        mtime = self.aider_ignore_file.stat().st_mtime\n+        if mtime != self.aider_ignore_ts:\n+            self.aider_ignore_ts = int(mtime)\n+            lines = self.aider_ignore_file.read_text().splitlines()\n+            self.aider_ignore_spec = pathspec.PathSpec.from_lines(\n+                pathspec.patterns.GitWildMatchPattern,\n+                lines,\n+            )\n+\n+        return self.aider_ignore_spec.match_file(fname)\n+\n+    def normalize_path(self, path):\n+        return str(Path(PurePosixPath((Path(self.root) / path).relative_to(self.root))))\ndiff --git a/opendevin/runtime/plugins/agent_skills/repomap/utils.py b/opendevin/runtime/plugins/agent_skills/repomap/utils.py\nnew file mode 100644\nindex 000000000000..a42d8d26b75d\n--- /dev/null\n+++ b/opendevin/runtime/plugins/agent_skills/repomap/utils.py\n@@ -0,0 +1,68 @@\n+\"\"\"\n+Modifications made on June, 2024.\n+Description of changes: removed redundant methods, attributes, and adapted some classes to be OpenDevin-specific.\n+\"\"\"\n+\n+import warnings\n+\n+with warnings.catch_warnings():\n+    warnings.simplefilter('ignore')\n+    import litellm\n+import tempfile\n+\n+IMAGE_EXTENSIONS = {'.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.webp'}\n+\n+\n+def is_image_file(file_name):\n+    \"\"\"\n+    Check if a file is an image file based on its extension.\n+\n+    Args:\n+        file_name (str): The name of the file.\n+    \"\"\"\n+    file_name = str(file_name)  # Convert file_name to string\n+    return any(file_name.endswith(ext) for ext in IMAGE_EXTENSIONS)\n+\n+\n+def get_token_count_from_text(model_name, text):\n+    \"\"\"\n+    Get the token count from the given text using the specified model.\n+\n+    Args:\n+        model_name (str): The name of the model to use for token counting.\n+        text (str): The input text.\n+    \"\"\"\n+    return litellm.token_counter(model=model_name, text=text)\n+\n+\n+def get_model_max_input_tokens(model_name: str):\n+    model_info = None\n+    try:\n+        if not model_name.startswith('openrouter'):\n+            model_info = litellm.get_model_info(model_name.split(':')[0])\n+        else:\n+            model_info = litellm.get_model_info(model_name)\n+    # noinspection PyBroadException\n+    except Exception:\n+        return 4096\n+\n+    if model_info is not None and 'max_input_tokens' in model_info:\n+        max_input_tokens = model_info['max_input_tokens']\n+    else:\n+        # Max input tokens for gpt3.5, so this is a safe fallback for any potentially viable model\n+        max_input_tokens = 4096\n+    return max_input_tokens\n+\n+\n+class IgnorantTemporaryDirectory:\n+    def __init__(self):\n+        self.temp_dir = tempfile.TemporaryDirectory()\n+\n+    def __enter__(self):\n+        return self.temp_dir.__enter__()\n+\n+    def __exit__(self, exc_type, exc_val, exc_tb):\n+        try:\n+            self.temp_dir.__exit__(exc_type, exc_val, exc_tb)\n+        except (OSError, PermissionError):\n+            pass  # Ignore errors (Windows)\ndiff --git a/poetry.lock b/poetry.lock\nindex b30a478b94af..b251aab36a77 100644\n--- a/poetry.lock\n+++ b/poetry.lock\n@@ -6779,6 +6814,122 @@ torchhub = [\"filelock\", \"huggingface-hub (>=0.23.0,<1.0)\", \"importlib-metadata\",\n video = [\"av (==9.2.0)\", \"decord (==0.6.0)\"]\n vision = [\"Pillow (>=10.0.1,<=15.0)\"]\n \n+[[package]]\n+name = \"tree-sitter\"\n+version = \"0.21.3\"\n+description = \"Python bindings for the Tree-Sitter parsing library\"\n+optional = false\n+python-versions = \">=3.8\"\n+files = [\n+    {file = \"tree-sitter-0.21.3.tar.gz\", hash = \"sha256:b5de3028921522365aa864d95b3c41926e0ba6a85ee5bd000e10dc49b0766988\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:351f302b6615230c9dac9829f0ba20a94362cd658206ca9a7b2d58d73373dfb0\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:766e79ae1e61271e7fdfecf35b6401ad9b47fc07a0965ad78e7f97fddfdf47a6\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:2c4d3d4d4b44857e87de55302af7f2d051c912c466ef20e8f18158e64df3542a\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:84eedb06615461b9e2847be7c47b9c5f2195d7d66d31b33c0a227eff4e0a0199\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:9d33ea425df8c3d6436926fe2991429d59c335431bf4e3c71e77c17eb508be5a\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:fae1ee0ff6d85e2fd5cd8ceb9fe4af4012220ee1e4cbe813305a316caf7a6f63\"},\n+    {file = \"tree_sitter-0.21.3-cp310-cp310-win_amd64.whl\", hash = \"sha256:bb41be86a987391f9970571aebe005ccd10222f39c25efd15826583c761a37e5\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:54b22c3c2aab3e3639a4b255d9df8455da2921d050c4829b6a5663b057f10db5\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:ab6e88c1e2d5e84ff0f9e5cd83f21b8e5074ad292a2cf19df3ba31d94fbcecd4\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:fc3fd34ed4cd5db445bc448361b5da46a2a781c648328dc5879d768f16a46771\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:fabc7182f6083269ce3cfcad202fe01516aa80df64573b390af6cd853e8444a1\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:4f874c3f7d2a2faf5c91982dc7d88ff2a8f183a21fe475c29bee3009773b0558\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:ee61ee3b7a4eedf9d8f1635c68ba4a6fa8c46929601fc48a907c6cfef0cfbcb2\"},\n+    {file = \"tree_sitter-0.21.3-cp311-cp311-win_amd64.whl\", hash = \"sha256:0b7256c723642de1c05fbb776b27742204a2382e337af22f4d9e279d77df7aa2\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:669b3e5a52cb1e37d60c7b16cc2221c76520445bb4f12dd17fd7220217f5abf3\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:2aa2a5099a9f667730ff26d57533cc893d766667f4d8a9877e76a9e74f48f0d3\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:6a3e06ae2a517cf6f1abb682974f76fa760298e6d5a3ecf2cf140c70f898adf0\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:af992dfe08b4fefcfcdb40548d0d26d5d2e0a0f2d833487372f3728cd0772b48\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:c7cbab1dd9765138505c4a55e2aa857575bac4f1f8a8b0457744a4fefa1288e6\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:e1e66aeb457d1529370fcb0997ae5584c6879e0e662f1b11b2f295ea57e22f54\"},\n+    {file = \"tree_sitter-0.21.3-cp312-cp312-win_amd64.whl\", hash = \"sha256:013c750252dc3bd0e069d82e9658de35ed50eecf31c6586d0de7f942546824c5\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:4986a8cb4acebd168474ec2e5db440e59c7888819b3449a43ce8b17ed0331b07\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:6e217fee2e7be7dbce4496caa3d1c466977d7e81277b677f954d3c90e3272ec2\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:f32a88afff4f2bc0f20632b0a2aa35fa9ae7d518f083409eca253518e0950929\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:f3652ac9e47cdddf213c5d5d6854194469097e62f7181c0a9aa8435449a163a9\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:60b4df3298ff467bc01e2c0f6c2fb43aca088038202304bf8e41edd9fa348f45\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:00e4d0c99dff595398ef5e88a1b1ddd53adb13233fb677c1fd8e497fb2361629\"},\n+    {file = \"tree_sitter-0.21.3-cp38-cp38-win_amd64.whl\", hash = \"sha256:50c91353a26946e4dd6779837ecaf8aa123aafa2d3209f261ab5280daf0962f5\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:b17b8648b296ccc21a88d72ca054b809ee82d4b14483e419474e7216240ea278\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:f2f057fd01d3a95cbce6794c6e9f6db3d376cb3bb14e5b0528d77f0ec21d6478\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:839759de30230ffd60687edbb119b31521d5ac016749358e5285816798bb804a\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:5df40aa29cb7e323898194246df7a03b9676955a0ac1f6bce06bc4903a70b5f7\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:1d9be27dde007b569fa78ff9af5fe40d2532c998add9997a9729e348bb78fa59\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:c4ac87735e6f98fe085244c7c020f0177d13d4c117db72ba041faa980d25d69d\"},\n+    {file = \"tree_sitter-0.21.3-cp39-cp39-win_amd64.whl\", hash = \"sha256:fbbd137f7d9a5309fb4cb82e2c3250ba101b0dd08a8abdce815661e6cf2cbc19\"},\n+]\n+\n+[[package]]\n+name = \"tree-sitter-languages\"\n+version = \"1.10.2\"\n+description = \"Binary Python wheels for all tree sitter languages.\"\n+optional = false\n+python-versions = \"*\"\n+files = [\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:5580348f0b20233b1d5431fa178ccd3d07423ca4a3275df02a44608fd72344b9\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:103c7466644486b1e9e03850df46fc6aa12f13ca636c74f173270276220ac80b\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d13db84511c6f1a7dc40383b66deafa74dabd8b877e3d65ab253f3719eccafd6\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:57adfa32be7e465b54aa72f915f6c78a2b66b227df4f656b5d4fbd1ca7a92b3f\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:1c6385e033e460ceb8f33f3f940335f422ef2b763700a04f0089391a68b56153\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:dfa3f38cc5381c5aba01dd7494f59b8a9050e82ff6e06e1233e3a0cbae297e3c\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:9f195155acf47f8bc5de7cee46ecd07b2f5697f007ba89435b51ef4c0b953ea5\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:2de330e2ac6d7426ca025a3ec0f10d5640c3682c1d0c7702e812dcfb44b58120\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-win32.whl\", hash = \"sha256:c9731cf745f135d9770eeba9bb4e2ff4dabc107b5ae9b8211e919f6b9100ea6d\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp310-cp310-win_amd64.whl\", hash = \"sha256:6dd75851c41d0c3c4987a9b7692d90fa8848706c23115669d8224ffd6571e357\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:7eb7d7542b2091c875fe52719209631fca36f8c10fa66970d2c576ae6a1b8289\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:6b41bcb00974b1c8a1800c7f1bb476a1d15a0463e760ee24872f2d53b08ee424\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:6f370cd7845c6c81df05680d5bd96db8a99d32b56f4728c5d05978911130a853\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:a1dc195c88ef4c72607e112a809a69190e096a2e5ebc6201548b3e05fdd169ad\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:9ae34ac314a7170be24998a0f994c1ac80761d8d4bd126af27ee53a023d3b849\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:01b5742d5f5bd675489486b582bd482215880b26dde042c067f8265a6e925d9c\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-musllinux_1_1_i686.whl\", hash = \"sha256:ab1cbc46244d34fd16f21edaa20231b2a57f09f092a06ee3d469f3117e6eb954\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:0b1149e7467a4e92b8a70e6005fe762f880f493cf811fc003554b29f04f5e7c8\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-win32.whl\", hash = \"sha256:049276343962f4696390ee555acc2c1a65873270c66a6cbe5cb0bca83bcdf3c6\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp311-cp311-win_amd64.whl\", hash = \"sha256:7f3fdd468a577f04db3b63454d939e26e360229b53c80361920aa1ebf2cd7491\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:c0f4c8b2734c45859edc7fcaaeaab97a074114111b5ba51ab4ec7ed52104763c\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:eecd3c1244ac3425b7a82ba9125b4ddb45d953bbe61de114c0334fd89b7fe782\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:15db3c8510bc39a80147ee7421bf4782c15c09581c1dc2237ea89cefbd95b846\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:92c6487a6feea683154d3e06e6db68c30e0ae749a7ce4ce90b9e4e46b78c85c7\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:6d2f1cd1d1bdd65332f9c2b67d49dcf148cf1ded752851d159ac3e5ee4f4d260\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:976c8039165b8e12f17a01ddee9f4e23ec6e352b165ad29b44d2bf04e2fbe77e\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-musllinux_1_1_i686.whl\", hash = \"sha256:dafbbdf16bf668a580902e1620f4baa1913e79438abcce721a50647564c687b9\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:1aeabd3d60d6d276b73cd8f3739d595b1299d123cc079a317f1a5b3c5461e2ca\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-win32.whl\", hash = \"sha256:fab8ee641914098e8933b87ea3d657bea4dd00723c1ee7038b847b12eeeef4f5\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp312-cp312-win_amd64.whl\", hash = \"sha256:5e606430d736367e5787fa5a7a0c5a1ec9b85eded0b3596bbc0d83532a40810b\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:838d5b48a7ed7a17658721952c77fda4570d2a069f933502653b17e15a9c39c9\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:987b3c71b1d278c2889e018ee77b8ee05c384e2e3334dec798f8b611c4ab2d1e\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:faa00abcb2c819027df58472da055d22fa7dfcb77c77413d8500c32ebe24d38b\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:0e102fbbf02322d9201a86a814e79a9734ac80679fdb9682144479044f401a73\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-musllinux_1_1_aarch64.whl\", hash = \"sha256:8f0b87cf1a7b03174ba18dfd81582be82bfed26803aebfe222bd20e444aba003\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-musllinux_1_1_i686.whl\", hash = \"sha256:c0f1b9af9cb67f0b942b020da9fdd000aad5e92f2383ae0ba7a330b318d31912\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-musllinux_1_1_x86_64.whl\", hash = \"sha256:5a4076c921f7a4d31e643843de7dfe040b65b63a238a5aa8d31d93aabe6572aa\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-win32.whl\", hash = \"sha256:fa6391a3a5d83d32db80815161237b67d70576f090ce5f38339206e917a6f8bd\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp37-cp37m-win_amd64.whl\", hash = \"sha256:55649d3f254585a064121513627cf9788c1cfdadbc5f097f33d5ba750685a4c0\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:6f85d1edaa2d22d80d4ea5b6d12b95cf3644017b6c227d0d42854439e02e8893\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:d78feed4a764ef3141cb54bf00fe94d514d8b6e26e09423e23b4c616fcb7938c\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:da1aca27531f9dd5308637d76643372856f0f65d0d28677d1bcf4211e8ed1ad0\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:1031ea440dafb72237437d754eff8940153a3b051e3d18932ac25e75ce060a15\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:99d3249beaef2c9fe558ecc9a97853c260433a849dcc68266d9770d196c2e102\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:59a4450f262a55148fb7e68681522f0c2a2f6b7d89666312a2b32708d8f416e1\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:ce74eab0e430370d5e15a96b6c6205f93405c177a8b2e71e1526643b2fb9bab1\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:9b4dd2b6b3d24c85dffe33d6c343448869eaf4f41c19ddba662eb5d65d8808f4\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-win32.whl\", hash = \"sha256:92d734fb968fe3927a7596d9f0459f81a8fa7b07e16569476b28e27d0d753348\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp38-cp38-win_amd64.whl\", hash = \"sha256:46a13f7d38f2eeb75f7cf127d1201346093748c270d686131f0cbc50e42870a1\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:f8c6a936ae99fdd8857e91f86c11c2f5e507ff30631d141d98132bb7ab2c8638\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:c283a61423f49cdfa7b5a5dfbb39221e3bd126fca33479cd80749d4d7a6b7349\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:76e60be6bdcff923386a54a5edcb6ff33fc38ab0118636a762024fa2bc98de55\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:c00069f9575bd831eabcce2cdfab158dde1ed151e7e5614c2d985ff7d78a7de1\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:475ff53203d8a43ccb19bb322fa2fb200d764001cc037793f1fadd714bb343da\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:26fe7c9c412e4141dea87ea4b3592fd12e385465b5bdab106b0d5125754d4f60\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:8fed27319957458340f24fe14daad467cd45021da034eef583519f83113a8c5e\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:3657a491a7f96cc75a3568ddd062d25f3be82b6a942c68801a7b226ff7130181\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-win32.whl\", hash = \"sha256:33f7d584d01a7a3c893072f34cfc64ec031f3cfe57eebc32da2f8ac046e101a7\"},\n+    {file = \"tree_sitter_languages-1.10.2-cp39-cp39-win_amd64.whl\", hash = \"sha256:1b944af3ee729fa70fc8ae82224a9ff597cdb63addea084e0ea2fa2b0ec39bb7\"},\n+]\n+\n+[package.dependencies]\n+tree-sitter = \"*\"\n+\n [[package]]\n name = \"triton\"\n version = \"2.2.0\"\n\ndiff --git a/tests/unit/test_repomap.py b/tests/unit/test_repomap.py\nnew file mode 100644\nindex 000000000000..3e040f5c5688\n--- /dev/null\n+++ b/tests/unit/test_repomap.py\n@@ -0,0 +1,198 @@\n+\"\"\"\n+Modifications made on June, 2024.\n+Description of changes: removed redundant methods, attributes, and adapted some classes to be OpenDevin-specific.\n+\"\"\"\n+\n+import os\n+import unittest\n+\n+from opendevin.runtime.plugins.agent_skills.repomap.repomap import RepoMap\n+from opendevin.runtime.plugins.agent_skills.repomap.utils import (\n+    IgnorantTemporaryDirectory,\n+)\n+\n+\n+class TestRepoMap(unittest.TestCase):\n+    def setUp(self):\n+        self.GPT35_MODEL_NAME = 'gpt-3.5-turbo'\n+\n+    def test_get_repo_map(self):\n+        # Create a temporary directory with sample files for testing\n+        test_files = [\n+            'test_file1.py',\n+            'test_file2.py',\n+            'test_file3.md',\n+            'test_file4.json',\n+        ]\n+\n+        with IgnorantTemporaryDirectory() as temp_dir:\n+            for file in test_files:\n+                with open(os.path.join(temp_dir, file), 'w') as f:\n+                    f.write('')\n+\n+            repo_map = RepoMap(model_name=self.GPT35_MODEL_NAME, root=temp_dir)\n+            other_files = [os.path.join(temp_dir, file) for file in test_files]\n+            result = repo_map.get_repo_map([], other_files)\n+\n+            # Check if the result contains the expected tags map\n+            self.assertIn('test_file1.py', result)\n+            self.assertIn('test_file2.py', result)\n+            self.assertIn('test_file3.md', result)\n+            self.assertIn('test_file4.json', result)\n+\n+    def test_get_repo_map_with_identifiers(self):\n+        # Create a temporary directory with a sample Python file containing identifiers\n+        test_file1 = 'test_file_with_identifiers.py'\n+        file_content1 = \"\"\"\\\n+class MyClass:\n+    def my_method(self, arg1, arg2):\n+        return arg1 + arg2\n+\n+def my_function(arg1, arg2):\n+    return arg1 * arg2\n+\"\"\"\n+\n+        test_file2 = 'test_file_import.py'\n+        file_content2 = \"\"\"\\\n+from test_file_with_identifiers import MyClass\n+\n+obj = MyClass()\n+print(obj.my_method(1, 2))\n+print(my_function(3, 4))\n+\"\"\"\n+\n+        test_file3 = 'test_file_pass.py'\n+        file_content3 = 'pass'\n+\n+        with IgnorantTemporaryDirectory() as temp_dir:\n+            with open(os.path.join(temp_dir, test_file1), 'w') as f:\n+                f.write(file_content1)\n+\n+            with open(os.path.join(temp_dir, test_file2), 'w') as f:\n+                f.write(file_content2)\n+\n+            with open(os.path.join(temp_dir, test_file3), 'w') as f:\n+                f.write(file_content3)\n+\n+            repo_map = RepoMap(model_name=self.GPT35_MODEL_NAME, root=temp_dir)\n+            other_files = [\n+                os.path.join(temp_dir, test_file1),\n+                os.path.join(temp_dir, test_file2),\n+                os.path.join(temp_dir, test_file3),\n+            ]\n+            result = repo_map.get_repo_map([], other_files)\n+\n+            # Check if the result contains the expected tags map with identifiers\n+            self.assertIn('test_file_with_identifiers.py', result)\n+            self.assertIn('MyClass', result)\n+            self.assertIn('my_method', result)\n+            self.assertIn('my_function', result)\n+            self.assertIn('test_file_pass.py', result)\n+\n+    def test_get_repo_map_all_files(self):\n+        test_files = [\n+            'test_file0.py',\n+            'test_file1.txt',\n+            'test_file2.md',\n+            'test_file3.json',\n+            'test_file4.html',\n+            'test_file5.css',\n+            'test_file6.js',\n+        ]\n+\n+        with IgnorantTemporaryDirectory() as temp_dir:\n+            for file in test_files:\n+                with open(os.path.join(temp_dir, file), 'w') as f:\n+                    f.write('')\n+\n+            repo_map = RepoMap(model_name=self.GPT35_MODEL_NAME, root=temp_dir)\n+\n+            other_files = [os.path.join(temp_dir, file) for file in test_files]\n+            result = repo_map.get_repo_map([], other_files)\n+\n+            # Check if the result contains each specific file in the expected tags map without ctags\n+            for file in test_files:\n+                self.assertIn(file, result)\n+\n+    def test_get_repo_map_excludes_added_files(self):\n+        # Create a temporary directory with sample files for testing\n+        test_files = [\n+            'test_file1.py',\n+            'test_file2.py',\n+            'test_file3.md',\n+            'test_file4.json',\n+        ]\n+\n+        with IgnorantTemporaryDirectory() as temp_dir:\n+            for file in test_files:\n+                with open(os.path.join(temp_dir, file), 'w') as f:\n+                    f.write('def foo(): pass\\n')\n+\n+            repo_map = RepoMap(model_name=self.GPT35_MODEL_NAME, root=temp_dir)\n+            test_files = [os.path.join(temp_dir, file) for file in test_files]\n+            result = repo_map.get_repo_map(test_files[:2], test_files[2:])\n+\n+            # Check if the result contains the expected tags map\n+            self.assertNotIn('test_file1.py', result)\n+            self.assertNotIn('test_file2.py', result)\n+            self.assertIn('test_file3.md', result)\n+            self.assertIn('test_file4.json', result)\n+\n+\n+class TestRepoMapTypescript(unittest.TestCase):\n+    def setUp(self):\n+        self.GPT35_MODEL_NAME = 'gpt-3.5-turbo'\n+\n+    def test_get_repo_map_typescript(self):\n+        # Create a temporary directory with a sample TypeScript file\n+        test_file_ts = 'test_file.ts'\n+        file_content_ts = \"\"\"\\\n+interface IMyInterface {\n+    someMethod(): void;\n+}\n+\n+type ExampleType = {\n+    key: string;\n+    value: number;\n+};\n+\n+enum Status {\n+    New,\n+    InProgress,\n+    Completed,\n+}\n+\n+export class MyClass {\n+    constructor(public value: number) {}\n+\n+    add(input: number): number {\n+        return this.value + input;\n+        return this.value + input;\n+    }\n+}\n+\n+export function myFunction(input: number): number {\n+    return input * 2;\n+}\n+\"\"\"\n+\n+        with IgnorantTemporaryDirectory() as temp_dir:\n+            with open(os.path.join(temp_dir, test_file_ts), 'w') as f:\n+                f.write(file_content_ts)\n+\n+            repo_map = RepoMap(model_name=self.GPT35_MODEL_NAME, root=temp_dir)\n+            other_files = [os.path.join(temp_dir, test_file_ts)]\n+            result = repo_map.get_repo_map([], other_files)\n+\n+            # Check if the result contains the expected tags map with TypeScript identifiers\n+            self.assertIn('test_file.ts', result)\n+            self.assertIn('IMyInterface', result)\n+            self.assertIn('ExampleType', result)\n+            self.assertIn('Status', result)\n+            self.assertIn('MyClass', result)\n+            self.assertIn('add', result)\n+            self.assertIn('myFunction', result)\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR raises important considerations about the `RepoMap` implementation. First, we might want to restrict its use to GitHub repos initially, as they are most likely where it's beneficial. Configuring `RepoMap` construction could address performance concerns with large workspaces, like OpenDevin. Additionally, the file permission issues when accessing Docker mounts highlight a need for a more robust solution, potentially integrating `RepoMap` into `agentskills` to avoid mounting complications. Finally, integrating comprehensive tests is crucial for maintaining stability as we move forward."
      }
    ],
    "token_estimation": 19453.25
  },
  {
    "index": 68,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/openhands/llm/fn_call_converter.py b/openhands/llm/fn_call_converter.py\nindex 04ce6eb6f43b..14166814f37e 100644\n--- a/openhands/llm/fn_call_converter.py\n+++ b/openhands/llm/fn_call_converter.py\n@@ -205,28 +235,100 @@ def index() -> str:\n     10      app.run(port=5000)\n Review the changes and make sure they are as expected. Edit the file again if necessary.\n \n+\"\"\",\n+    },\n+    'browser': {\n+        'view_page': \"\"\"\n ASSISTANT:\n-Running the updated file:\n-<function=execute_bash>\n-<parameter=command>\n-python3 app.py > server.log 2>&1 &\n+Let me check how the page looks in the browser:\n+<function=browser>\n+<parameter=code>\n+goto('http://127.0.0.1:5000')\n+noop(1000)  # Wait for page to load\n </parameter>\n </function>\n \n-USER: EXECUTION RESULT of [execute_bash]:\n-[1] 126\n-\n+USER: EXECUTION RESULT of [browser]:\n+[Browser shows the numbers in a table format]\n+\"\"\"\n+    },\n+    'finish': {\n+        'task_completed': \"\"\"\n ASSISTANT:\n The server is running on port 5000 with PID 126. You can access the list of numbers in a table format by visiting http://127.0.0.1:5000. Let me know if you have any further requests!\n <function=finish>\n+<parameter=message>The task has been completed. The web server is running and displaying numbers 1-10 in a table format at http://127.0.0.1:5000.</parameter>\n+<parameter=task_completed>true</parameter>\n </function>\n+\"\"\"\n+    },\n+}\n+\n+\n+def get_example_for_tools(tools: list[dict]) -> str:\n+    \"\"\"Generate an in-context learning example based on available tools.\"\"\"\n+    available_tools = set()\n+    for tool in tools:\n+        if tool['type'] == 'function':\n+            name = tool['function']['name']\n+            if name == EXECUTE_BASH_TOOL_NAME:\n+                available_tools.add('execute_bash')\n+            elif name == STR_REPLACE_EDITOR_TOOL_NAME:\n+                available_tools.add('str_replace_editor')\n+            elif name == BROWSER_TOOL_NAME:\n+                available_tools.add('browser')\n+            elif name == FINISH_TOOL_NAME:\n+                available_tools.add('finish')\n+\n+    if not available_tools:\n+        return ''\n+\n+    example = \"\"\"Here's a running example of how to perform a task with the provided tools.\n+\n+--------------------- START OF EXAMPLE ---------------------\n+\n+USER: Create a list of numbers from 1 to 10, and display them in a web page at port 5000.\n+\n+\"\"\"\n+\n+    # Build example based on available tools\n+    if 'execute_bash' in available_tools:\n+        example += TOOL_EXAMPLES['execute_bash']['check_dir']\n+\n+    if 'str_replace_editor' in available_tools:\n+        example += TOOL_EXAMPLES['str_replace_editor']['create_file']\n \n+    if 'execute_bash' in available_tools:\n+        example += TOOL_EXAMPLES['execute_bash']['run_server']\n+\n+    if 'browser' in available_tools:\n+        example += TOOL_EXAMPLES['browser']['view_page']\n+\n+    if 'execute_bash' in available_tools:\n+        example += TOOL_EXAMPLES['execute_bash']['kill_server']\n+\n+    if 'str_replace_editor' in available_tools:\n+        example += TOOL_EXAMPLES['str_replace_editor']['edit_file']\n+\n+    if 'execute_bash' in available_tools:\n+        example += TOOL_EXAMPLES['execute_bash']['run_server_again']\n+\n+    if 'finish' in available_tools:\n+        example += TOOL_EXAMPLES['finish']['task_completed']\n+\n+    example += \"\"\"\n --------------------- END OF EXAMPLE ---------------------\n \n Do NOT assume the environment is the same as in the example above.\n \n --------------------- NEW TASK DESCRIPTION ---------------------\n-\"\"\").lstrip()\n+\"\"\"\n+    example = example.lstrip()\n+\n+    return example\n+\n+\n+IN_CONTEXT_LEARNING_EXAMPLE_PREFIX = get_example_for_tools\n \n IN_CONTEXT_LEARNING_EXAMPLE_SUFFIX = \"\"\"\n --------------------- END OF NEW TASK DESCRIPTION ---------------------\n\ndiff --git a/tests/unit/test_llm_fncall_converter.py b/tests/unit/test_llm_fncall_converter.py\nindex 29a8e5475485..29cfd80840b7 100644\n--- a/tests/unit/test_llm_fncall_converter.py\n+++ b/tests/unit/test_llm_fncall_converter.py\n@@ -140,6 +142,264 @@ def test_convert_tools_to_description():\n     )\n \n \n+def test_get_example_for_tools_no_tools():\n+    \"\"\"Test that get_example_for_tools returns empty string when no tools are available.\"\"\"\n+    tools = []\n+    example = get_example_for_tools(tools)\n+    assert example == ''\n+\n+\n+def test_get_example_for_tools_single_tool():\n+    \"\"\"Test that get_example_for_tools generates correct example with a single tool.\"\"\"\n+    tools = [\n+        {\n+            'type': 'function',\n+            'function': {\n+                'name': 'execute_bash',\n+                'description': 'Execute a bash command in the terminal.',\n+                'parameters': {\n+                    'type': 'object',\n+                    'properties': {\n+                        'command': {\n+                            'type': 'string',\n+                            'description': 'The bash command to execute.',\n+                        }\n+                    },\n+                    'required': ['command'],\n+                },\n+            },\n+        }\n+    ]\n+    example = get_example_for_tools(tools)\n+    assert example.startswith(\n+        \"Here's a running example of how to perform a task with the provided tools.\"\n+    )\n+    assert (\n+        'USER: Create a list of numbers from 1 to 10, and display them in a web page at port 5000.'\n+        in example\n+    )\n+    assert TOOL_EXAMPLES['execute_bash']['check_dir'] in example\n+    assert TOOL_EXAMPLES['execute_bash']['run_server'] in example\n+    assert TOOL_EXAMPLES['execute_bash']['kill_server'] in example\n+    assert TOOL_EXAMPLES['str_replace_editor']['create_file'] not in example\n+    assert TOOL_EXAMPLES['browser']['view_page'] not in example\n+    assert TOOL_EXAMPLES['finish']['task_completed'] not in example\n+\n+\n+def test_get_example_for_tools_single_tool_is_finish():\n+    \"\"\"Test get_example_for_tools with only the finish tool.\"\"\"\n+    tools = [\n+        {\n+            'type': 'function',\n+            'function': {\n+                'name': 'finish',\n+                'description': 'Finish the interaction when the task is complete.',\n+            },\n+        }\n+    ]\n+    example = get_example_for_tools(tools)\n+    assert example.startswith(\n+        \"Here's a running example of how to perform a task with the provided tools.\"\n+    )\n+    assert (\n+        'USER: Create a list of numbers from 1 to 10, and display them in a web page at port 5000.'\n+        in example\n+    )\n+    assert TOOL_EXAMPLES['finish']['task_completed'] in example\n+    assert TOOL_EXAMPLES['execute_bash']['check_dir'] not in example\n+    assert TOOL_EXAMPLES['str_replace_editor']['create_file'] not in example\n+    assert TOOL_EXAMPLES['browser']['view_page'] not in example\n+\n+\n+def test_get_example_for_tools_multiple_tools():\n+    \"\"\"Test that get_example_for_tools generates correct example with multiple tools.\"\"\"\n+    tools = [\n+        {\n+            'type': 'function',\n+            'function': {\n+                'name': 'execute_bash',\n+                'description': 'Execute a bash command in the terminal.',\n+                'parameters': {\n+                    'type': 'object',\n+                    'properties': {\n+                        'command': {\n+                            'type': 'string',\n+                            'description': 'The bash command to execute.',\n+                        }\n+                    },\n+                    'required': ['command'],\n+                },\n+            },\n+        },\n+        {\n+            'type': 'function',\n+            'function': {\n+                'name': 'str_replace_editor',\n+                'description': 'Custom editing tool for viewing, creating and editing files.',\n+                'parameters': {\n+                    'type': 'object',\n+                    'properties': {\n+                        'command': {\n+                            'type': 'string',\n+                            'description': 'The commands to run.',\n+                            'enum': [\n+                                'view',\n+                                'create',\n+                                'str_replace',\n+                                'insert',\n+                                'undo_edit',\n+                            ],\n+                        },\n+                        'path': {\n+                            'type': 'string',\n+                            'description': 'Absolute path to file or directory.',\n+                        },\n+                    },\n+                    'required': ['command', 'path'],\n+                },\n+            },\n+        },\n+    ]\n+    example = get_example_for_tools(tools)\n+    assert example.startswith(\n+        \"Here's a running example of how to perform a task with the provided tools.\"\n+    )\n+    assert (\n+        'USER: Create a list of numbers from 1 to 10, and display them in a web page at port 5000.'\n+        in example\n+    )\n+    assert TOOL_EXAMPLES['execute_bash']['check_dir'] in example\n+    assert TOOL_EXAMPLES['execute_bash']['run_server'] in example\n+    assert TOOL_EXAMPLES['execute_bash']['kill_server'] in example\n+    assert TOOL_EXAMPLES['str_replace_editor']['create_file'] in example\n+    assert TOOL_EXAMPLES['str_replace_editor']['edit_file'] in example\n+    assert TOOL_EXAMPLES['browser']['view_page'] not in example\n+    assert TOOL_EXAMPLES['finish']['task_completed'] not in example\n+\n+\n+def test_get_example_for_tools_multiple_tools_with_finish():\n+    \"\"\"Test get_example_for_tools with multiple tools including finish.\"\"\"\n+    # Uses execute_bash and finish tools\n+    tools = [\n+        {\n+            'type': 'function',\n+            'function': {\n+                'name': 'execute_bash',\n+                'description': 'Execute a bash command in the terminal.',\n+                'parameters': {  # Params added for completeness, not strictly needed by get_example_for_tools\n+                    'type': 'object',\n+                    'properties': {\n+                        'command': {\n+                            'type': 'string',\n+                            'description': 'The bash command to execute.',\n+                        }\n+                    },\n+                    'required': ['command'],\n+                },\n+            },\n+        },\n+        {\n+            'type': 'function',\n+            'function': {\n+                'name': 'str_replace_editor',\n+                'description': 'Custom editing tool for viewing, creating and editing files.',\n+                'parameters': {\n+                    'type': 'object',\n+                    'properties': {\n+                        'command': {\n+                            'type': 'string',\n+                            'description': 'The commands to run.',\n+                            'enum': [\n+                                'view',\n+                                'create',\n+                                'str_replace',\n+                                'insert',\n+                                'undo_edit',\n+                            ],\n+                        },\n+                        'path': {\n+                            'type': 'string',\n+                            'description': 'Absolute path to file or directory.',\n+                        },\n+                    },\n+                    'required': ['command', 'path'],\n+                },\n+            },\n+        },\n+        {\n+            'type': 'function',\n+            'function': {\n+                'name': 'browser',\n+                'description': 'Interact with the browser.',\n+                'parameters': {\n+                    'type': 'object',\n+                    'properties': {\n+                        'code': {\n+                            'type': 'string',\n+                            'description': 'The Python code that interacts with the browser.',\n+                        }\n+                    },\n+                    'required': ['code'],\n+                },\n+            },\n+        },\n+        {\n+            'type': 'function',\n+            'function': {\n+                'name': 'finish',\n+                'description': 'Finish the interaction.',\n+            },\n+        },\n+    ]\n+    example = get_example_for_tools(tools)\n+    assert example.startswith(\n+        \"Here's a running example of how to perform a task with the provided tools.\"\n+    )\n+    assert (\n+        'USER: Create a list of numbers from 1 to 10, and display them in a web page at port 5000.'\n+        in example\n+    )\n+\n+    # Check for execute_bash parts (order matters for get_example_for_tools)\n+    assert TOOL_EXAMPLES['execute_bash']['check_dir'].strip() in example\n+    assert TOOL_EXAMPLES['execute_bash']['run_server'].strip() in example\n+    assert TOOL_EXAMPLES['execute_bash']['kill_server'].strip() in example\n+    assert TOOL_EXAMPLES['execute_bash']['run_server_again'].strip() in example\n+\n+    # Check for str_replace_editor parts\n+    assert TOOL_EXAMPLES['str_replace_editor']['create_file'] in example\n+    assert TOOL_EXAMPLES['str_replace_editor']['edit_file'] in example\n+\n+    # Check for browser part\n+    assert TOOL_EXAMPLES['browser']['view_page'] in example\n+\n+    # Check for finish part\n+    assert TOOL_EXAMPLES['finish']['task_completed'] in example\n+\n+\n+def test_get_example_for_tools_all_tools():\n+    \"\"\"Test that get_example_for_tools generates correct example with all tools.\"\"\"\n+    tools = FNCALL_TOOLS  # FNCALL_TOOLS already includes 'finish'\n+    example = get_example_for_tools(tools)\n+    assert example.startswith(\n+        \"Here's a running example of how to perform a task with the provided tools.\"\n+    )\n+    assert (\n+        'USER: Create a list of numbers from 1 to 10, and display them in a web page at port 5000.'\n+        in example\n+    )\n+    assert TOOL_EXAMPLES['execute_bash']['check_dir'] in example\n+    assert TOOL_EXAMPLES['execute_bash']['run_server'] in example\n+    assert TOOL_EXAMPLES['execute_bash']['kill_server'] in example\n+    assert TOOL_EXAMPLES['str_replace_editor']['create_file'] in example\n+    assert TOOL_EXAMPLES['str_replace_editor']['edit_file'] in example\n+    assert TOOL_EXAMPLES['finish']['task_completed'] in example\n+\n+    # These are not in global FNCALL_TOOLS\n+    # assert TOOL_EXAMPLES['web_read']['read_docs'] not in example # web_read is removed\n+    assert TOOL_EXAMPLES['browser']['view_page'] not in example\n+\n+\n FNCALL_MESSAGES = [\n     {\n         'content': [\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR addresses the compatibility of tool usage in the function call converter by implementing a dynamic example generation system. The key changes include the introduction of a `TOOL_EXAMPLES` dictionary and a `get_example_for_tools` function, which ensure only available tools are referenced. However, unit tests need to be updated for `fn_call_converter.py` to verify these changes. Careful attention is needed to retain all original example context during refactoring. Please ensure tests in `test_llm_fncall_converter.py` thoroughly cover the new logic."
      }
    ],
    "token_estimation": 3755.5
  },
  {
    "index": 70,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/agenthub/monologue_agent/utils/prompts.py b/agenthub/monologue_agent/utils/prompts.py\nindex d1b37a062dd5..6cb9ed9d4fd8 100644\n--- a/agenthub/monologue_agent/utils/prompts.py\n+++ b/agenthub/monologue_agent/utils/prompts.py\n@@ -134,37 +134,115 @@ def get_request_action_prompt(\n             elif latest_thought['action'] == 'error':\n                 hint = 'Looks like that last command failed. Maybe you need to fix it, or try something else.'\n \n-    bg_commands_message = ''\n-    if len(background_commands_obs) > 0:\n-        bg_commands_message = 'The following commands are running in the background:'\n-        for command_obs in background_commands_obs:\n-            bg_commands_message += (\n-                f'\\n`{command_obs.command_id}`: {command_obs.command}'\n-            )\n-        bg_commands_message += '\\nYou can end any process by sending a `kill` action with the numerical `command_id` above.'\n+    # FIXME are background commands already in recent events?\n+    bg_commands_message = format_background_commands(background_commands_obs)\n \n     user = 'opendevin' if config.run_as_devin else 'root'\n \n     return ACTION_PROMPT % {\n         'task': task,\n-        'monologue': json.dumps(thoughts, indent=2),\n+        'monologue': json.dumps(default_events + recent_events, indent=2),\n         'background_commands': bg_commands_message,\n         'hint': hint,\n         'user': user,\n         'timeout': config.sandbox_timeout,\n-        'WORKSPACE_MOUNT_PATH_IN_SANDBOX': config.workspace_mount_path_in_sandbox,\n+        # unused 'workspace_mount_path_in_sandbox': config.workspace_mount_path_in_sandbox,\n+    }\n+\n+\n+def get_action_prompt_template(\n+    task: str,\n+    default_events: list[dict],\n+    background_commands_obs: list[CmdOutputObservation],\n+) -> str:\n+    \"\"\"\n+    Gets the action prompt template with default_events pre-filled and a placeholder for recent_events and hint.\n+\n+    Parameters:\n+    - task: The current task the agent is trying to accomplish\n+    - default_events: The default events to include in the prompt\n+    - background_commands_obs: list of all observed background commands running\n+\n+    Returns:\n+    - str: Formatted prompt template string with default_events pre-filled and placeholders for recent_events and hint\n+    \"\"\"\n+    bg_commands_message = format_background_commands(background_commands_obs)\n+    user = 'opendevin' if config.run_as_devin else 'root'\n+\n+    return ACTION_PROMPT % {\n+        'task': task,\n+        'monologue': json.dumps(default_events, indent=2) + '%(recent_events)s',\n+        'background_commands': bg_commands_message,\n+        'hint': '%(hint)s',\n+        'user': user,\n+        'timeout': config.sandbox_timeout,\n+    }\n+\n+\n+def get_action_prompt_for_summarization(\n+    prompt_template: str,\n+    recent_events: list[dict],\n+) -> str:\n+    \"\"\"\n+    Gets the action prompt formatted with recent_events and a generated hint.\n+\n+    Parameters:\n+    - prompt_template: The prompt template with placeholders for recent_events and hint\n+    - recent_events: The recent events to include in the prompt\n+\n+    Returns:\n+    - str: Formatted prompt string with recent_events and a generated hint included\n+    \"\"\"\n+    hint = ''\n+    if recent_events is not None and len(recent_events) > 0:\n+        latest_thought = recent_events[-1]\n+        if 'action' in latest_thought:\n+            if latest_thought['action'] == 'message':\n+                if latest_thought['args']['content'].startswith('OK so my task is'):\n+                    hint = \"You're just getting started! What should you do first?\"\n+                else:\n+                    hint = \"You've been thinking a lot lately. Maybe it's time to take action?\"\n+            elif latest_thought['action'] == 'error':\n+                hint = 'Looks like that last command failed. Maybe you need to fix it, or try something else.'\n+\n+    return prompt_template % {\n+        'recent_events': json.dumps(recent_events, indent=2),\n+        'hint': hint,\n     }\n \n \n+def format_background_commands(\n+    background_commands_obs: list[CmdOutputObservation] | None,\n+) -> str:\n+    \"\"\"\n+    Formats the background commands for sending in the prompt\n+\n+    Parameters:\n+    - background_commands_obs: list of all background commands running\n+\n+    Returns:\n+    - Formatted string with all background commands\n+    \"\"\"\n+    if background_commands_obs is None or len(background_commands_obs) == 0:\n+        return ''\n+\n+    bg_commands_message = 'The following commands are running in the background:'\n+    for obs in background_commands_obs:\n+        bg_commands_message += f'\\n`{obs.command_id}`: {obs.command}'\n+    bg_commands_message += '\\nYou can end any process by sending a `kill` action with the numerical `command_id` above.'\n+\n+    return bg_commands_message\n+\n+\n def parse_action_response(orig_response: str) -> Action:\n     \"\"\"\n     Parses a string to find an action within it\n \n     Parameters:\n-    - response (str): The string to be parsed\n+    - orig_response: The string to be parsed\n \n     Returns:\n-    - Action: The action that was found in the response string\n+    - The action that was found in the response string\n     \"\"\"\n     # attempt to load the JSON dict from the response\n     action_dict = json.loads(orig_response)\n\ndiff --git a/opendevin/memory/condenser.py b/opendevin/memory/condenser.py\nindex b8b1842dc7e5..1fdd4b36bfe7 100644\n--- a/opendevin/memory/condenser.py\n+++ b/opendevin/memory/condenser.py\n@@ -1,26 +1,160 @@\n+from typing import Callable\n+\n from opendevin.core.logger import opendevin_logger as logger\n from opendevin.llm.llm import LLM\n \n+from . import get_summarize_prompt, parse_summary_response\n+\n+MAX_TOKEN_COUNT_PADDING = (\n+    512  # estimation of tokens to add to the prompt for the max token count\n+)\n+\n \n class MemoryCondenser:\n-    def condense(self, summarize_prompt: str, llm: LLM):\n+    \"\"\"\n+    Condenses the prompt with a call to the LLM.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        action_prompt: Callable[..., str],\n+        summarize_prompt: Callable[[list[dict]], str] = get_summarize_prompt,\n+    ):\n         \"\"\"\n-        Attempts to condense the monologue by using the llm\n+        Initialize the MemoryCondenser with the action and summarize prompts.\n+\n+        action_prompt is a callable that returns the prompt that is about to be sent to the LLM.\n+        The prompt callable will be called with recent events as arguments.\n+        summarize_prompt is a callable that returns a specific prompt that tells the LLM to summarize the recent events.\n+        The prompt callable will be called with events as argument.\n+        If not provided, the default summarize prompt will be used.\n \n         Parameters:\n-        - llm (LLM): llm to be used for summarization\n+        - action_prompt: The function to generate an action prompt. The function should accept recent events as arguments.\n+        - summarize_prompt: The function to generate a summarize prompt. The function should accept srecent events as arguments.\n+        \"\"\"\n+        self.action_prompt = action_prompt\n+        self.summarize_prompt = summarize_prompt\n \n-        Raises:\n-        - Exception: the same exception as it got from the llm or processing the response\n+    def condense(\n+        self,\n+        llm: LLM,\n+        recent_events: list[dict],\n+    ) -> tuple[list[dict], bool]:\n         \"\"\"\n+        Attempts to condense the recent events of the monologue by using the llm. Returns the condensed recent events if successful, or False if not.\n \n+        It includes default events in the prompt for context, but does not alter them.\n+        Condenses the events using a summary prompt.\n+\n+        Parameters:\n+        - llm: LLM to be used for summarization.\n+        - recent_events: List of recent events that may be condensed.\n+\n+        Returns:\n+        - The condensed recent events if successful, or False if condensation failed.\n+        \"\"\"\n         try:\n-            messages = [{'content': summarize_prompt, 'role': 'user'}]\n-            resp = llm.completion(messages=messages)\n-            summary_response = resp['choices'][0]['message']['content']\n-            return summary_response\n+            logger.debug('Condensing recent events')\n+\n+            # attempt to condense the recent events\n+            new_recent_events = self._attempt_condense(llm, recent_events)\n+\n+            if not new_recent_events or len(new_recent_events) == 0:\n+                logger.debug('Condensation failed: new_recent_events is empty')\n+                return [], False\n+\n+            # re-generate the action prompt with the condensed events\n+            new_action_prompt = self.action_prompt(new_recent_events)\n+\n+            # hope for the best\n+            return new_recent_events, True\n+\n         except Exception as e:\n-            logger.error('Error condensing thoughts: %s', str(e), exc_info=False)\n+            logger.error('Condensation failed: %s', str(e), exc_info=False)\n+            return [], False\n+\n+    def _attempt_condense(\n+        self,\n+        llm: LLM,\n+        recent_events: list[dict],\n+    ) -> list[dict] | None:\n+        \"\"\"\n+        Attempts to condense the recent events by splitting them in half and summarizing the first half.\n+\n+        Parameters:\n+        - llm: The llm to use for summarization.\n+        - default_events: The list of default events to include in the prompt.\n+        - recent_events: The list of recent events to include in the prompt.\n+\n+        Returns:\n+        - The condensed recent events if successful, None otherwise.\n+        \"\"\"\n \n-            # TODO If the llm fails with ContextWindowExceededError, we can try to condense the monologue chunk by chunk\n-            raise\n+        # Split events\n+        midpoint = len(recent_events) // 2\n+        first_half = recent_events[:midpoint].copy()\n+        second_half = recent_events[midpoint:].copy()\n+\n+        # attempt to condense the first half of the recent events\n+        summarize_prompt = self.summarize_prompt(first_half)\n+\n+        # send the summarize prompt to the LLM\n+        messages = [{'content': summarize_prompt, 'role': 'user'}]\n+        response = llm.completion(messages=messages)\n+        response_content = response['choices'][0]['message']['content']\n+\n+        # the new list of recent events will be source events or summarize actions\n+        condensed_events = parse_summary_response(response_content)\n+\n+        # new recent events list\n+        if (\n+            not condensed_events\n+            or not isinstance(condensed_events, list)\n+            or len(condensed_events) == 0\n+        ):\n+            return None\n+\n+        condensed_events.extend(second_half)\n+        return condensed_events\n+\n+    def _needs_condense(self, **kwargs):\n+        \"\"\"\n+        Checks if the prompt needs to be condensed based on the token count against the limits of the llm passed in the call.\n+\n+        Parameters:\n+        - llm: The llm to use for checking the token count.\n+        - action_prompt: The prompt to check for token count. If not provided, it will attempt to generate it using the available arguments.\n+        - default_events: The list of default events to include in the prompt.\n+        - recent_events: The list of recent events to include in the prompt.\n+\n+        Returns:\n+        - True if the prompt needs to be condensed, False otherwise.\n+        \"\"\"\n+        llm = kwargs.get('llm')\n+        action_prompt = kwargs.get('action_prompt')\n+\n+        if not llm:\n+            logger.warning(\"Missing argument 'llm', cannot check token count.\")\n+            return False\n+\n+        if not action_prompt:\n+            # Attempt to generate the action_prompt using the available arguments\n+            recent_events = kwargs.get('recent_events', [])\n+\n+            action_prompt = self.action_prompt(recent_events)\n+\n+        token_count = llm.get_token_count([{'content': action_prompt, 'role': 'user'}])\n+        return token_count >= self.get_token_limit(llm)\n+\n+    def get_token_limit(self, llm: LLM) -> int:\n+        \"\"\"\n+        Returns the token limit to use for the llm passed in the call.\n+\n+        Parameters:\n+        - llm: The llm to get the token limit from.\n+\n+        Returns:\n+        - The token limit of the llm.\n+        \"\"\"\n+        return llm.max_input_tokens - MAX_TOKEN_COUNT_PADDING\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Revert all current test artifact changes before regenerating to ensure a clean slate. The script functions well if tests pass without invoking the real LLM. Your approach to condensing events is promising, but make sure to address edge cases, like handling a last observation significantly larger than others. It’s essential to maintain clarity when summarizing, especially with potential ContextWindowExceeded errors. Iterating on these strategies will be necessary as we refine the implementation further."
      }
    ],
    "token_estimation": 3222.25
  },
  {
    "index": 72,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/interpreter/code_interpreters/container_utils/auto_remove.py b/interpreter/code_interpreters/container_utils/auto_remove.py\nnew file mode 100644\nindex 0000000000..a717151574\n--- /dev/null\n+++ b/interpreter/code_interpreters/container_utils/auto_remove.py\n@@ -0,0 +1,68 @@\n+import threading\n+import time\n+from functools import wraps\n+\n+def access_aware(cls):\n+    class AccessAwareWrapper:\n+        def __init__(self, wrapped, auto_remove_timeout, close_callback=None):\n+            self._wrapped = wrapped \n+            self._last_accessed = time.time()\n+            self._auto_remove = auto_remove_timeout is not None\n+            self._timeout = auto_remove_timeout\n+            self.close_callback = close_callback  # Store the callback\n+            if self._auto_remove:\n+                self._monitor_thread = threading.Thread(target=self._monitor_object, daemon=True)\n+                self._monitor_thread.start()\n+\n+        def _monitor_object(self):\n+            while True:\n+                time.sleep(1)  # Check every second\n+                if self._auto_remove and self.check_timeout():\n+                    # If a close_callback is defined, call it\n+                    if self.close_callback:\n+                        try:\n+                            self.close_callback()  # Call the callback\n+                        except Exception as e:\n+                            # Log or handle the exception as required\n+                            return f\"An error occurred during callback: {e}\"\n+                    \n+                    try:\n+                        self._wrapped.stop()\n+                    except Exception:\n+                        continue # why care? we are removing it anyway\n+\n+                    # If the wrapped object has a __del__ method, call it\n+                    if self._wrapped and hasattr(self._wrapped, '__del__'):\n+                        try:\n+                            self._wrapped.__del__()\n+                        except Exception as e:\n+                            # Log or handle the exception as required\n+                            return f\"An error occurred during deletion: {e}\"\n+\n+                    # Remove the strong reference to the wrapped object. this makes it go bye bye.\n+                    self._wrapped = None\n+                    break\n+\n+        def touch(self):\n+            self._last_accessed = time.time()\n+\n+        def check_timeout(self):\n+            return time.time() - self._last_accessed > self._timeout\n+\n+        def __getattr__(self, attr):\n+            if self._wrapped is None:\n+                raise ValueError(\"Object has been removed due to inactivity.\")\n+            self.touch()  # Update last accessed time\n+            return getattr(self._wrapped, attr)  # Use the actual object here\n+\n+        def __del__(self):\n+            if self._auto_remove:\n+                self._monitor_thread.join()  # Ensure the monitoring thread is cleaned up\n+\n+    @wraps(cls)\n+    def wrapper(*args, **kwargs):\n+        auto_remove_timeout = kwargs.pop('auto_remove_timeout', None)  # Extract the auto_remove_timeout argument\n+        close_callback = kwargs.pop('close_callback', None)  # Extract the close_callback argument\n+        obj = cls(*args, **kwargs)  # Create an instance of the original class\n+        return AccessAwareWrapper(obj, auto_remove_timeout, close_callback)  # Wrap it\n+    return wrapper\ndiff --git a/interpreter/code_interpreters/container_utils/build_image.py b/interpreter/code_interpreters/container_utils/build_image.py\nnew file mode 100644\nindex 0000000000..12d95286d6\n--- /dev/null\n+++ b/interpreter/code_interpreters/container_utils/build_image.py\n@@ -0,0 +1,108 @@\n+import os\n+import json\n+import hashlib\n+import subprocess\n+from docker import DockerClient\n+from docker.errors import DockerException\n+from rich import print as Print\n+\n+def get_files_hash(*file_paths):\n+    \"\"\"Return the SHA256 hash of multiple files.\"\"\"\n+    hasher = hashlib.sha256()\n+    for file_path in file_paths:\n+        with open(file_path, \"rb\") as f:\n+            while chunk := f.read(4096):\n+                hasher.update(chunk)\n+    return hasher.hexdigest()\n+\n+\n+def build_docker_images(\n+    dockerfile_dir = os.path.join(os.path.abspath(os.path.dirname(os.path.dirname(__file__))), \"dockerfiles\")\n+,\n+):\n+    \"\"\"\n+    Builds a Docker image for the Open Interpreter runtime container if needed.\n+\n+    Args:\n+        dockerfile_dir (str): The directory containing the Dockerfile and requirements.txt files.\n+\n+    Returns:\n+        None\n+    \"\"\"\n+    try:\n+        client = DockerClient.from_env()\n+    except DockerException:\n+        Print(\"[bold red]ERROR[/bold red]: Could not connect to Docker daemon. Is Docker Engine installed and running?\")\n+        Print(\n+            \"\\nFor information on Docker installation, visit: https://docs.docker.com/engine/install/ and follow the instructions for your system.\"\n+        )\n+        return\n+\n+    image_name = \"openinterpreter-runtime-container\"\n+    hash_file_path = os.path.join(dockerfile_dir, \"hash.json\")\n+\n+    dockerfile_name = \"Dockerfile\"\n+    requirements_name = \"requirements.txt\"\n+    dockerfile_path = os.path.join(dockerfile_dir, dockerfile_name)\n+    requirements_path = os.path.join(dockerfile_dir, requirements_name)\n+\n+    if not os.path.exists(dockerfile_path) or not os.path.exists(requirements_path):\n+        Print(\"ERROR: Dockerfile or requirements.txt not found. Did you delete or rename them?\")\n+        raise RuntimeError(\n+            \"No container Dockerfiles or requirements.txt found. Make sure they are in the dockerfiles/ subdir of the module.\"\n+        )\n+\n+    current_hash = get_files_hash(dockerfile_path, requirements_path)\n+\n+    stored_hashes = {}\n+    if os.path.exists(hash_file_path):\n+        with open(hash_file_path, \"rb\") as f:\n+            stored_hashes = json.load(f)\n+\n+    original_hash = stored_hashes.get(\"original_hash\")\n+    previous_hash = stored_hashes.get(\"last_hash\")\n+\n+    if current_hash == original_hash:\n+        images = client.images.list(name=image_name, all=True)\n+        if not images:\n+            Print(\"Downloading default image from Docker Hub, please wait...\")\n+            \n+            subprocess.run([\"docker\", \"pull\", \"unaidedelf/openinterpreter-runtime-container:latest\"])\n+            subprocess.run([\"docker\", \"tag\", \"unaidedelf/openinterpreter-runtime-container:latest\", image_name ],\n+                       check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n+    elif current_hash != previous_hash:\n+        Print(\"Dockerfile or requirements.txt has changed. Building container...\")\n+\n+        try:\n+            # Run the subprocess without capturing stdout and stderr\n+            # This will allow Docker's output to be printed to the console in real-time\n+            subprocess.run(\n+                [\n+                    \"docker\",\n+                    \"build\",\n+                    \"-t\",\n+                    f\"{image_name}:latest\",\n+                    dockerfile_dir,\n+                ],\n+                check=True,  # This will raise a CalledProcessError if the command returns a non-zero exit code\n+                text=True,\n+            )\n+\n+            # Update the stored current hash\n+            stored_hashes[\"last_hash\"] = current_hash\n+            with open(hash_file_path, \"w\") as f:\n+                json.dump(stored_hashes, f)\n+\n+        except subprocess.CalledProcessError:\n+            # Suppress Docker's error messages and display your own error message\n+            Print(\"Docker Build Error: Building Docker image failed. Please review the error message above and resolve the issue.\")\n+\n+        except FileNotFoundError:\n+            Print(\"ERROR: The 'docker' command was not found on your system.\")\n+            Print(\n+                \"Please ensure Docker Engine is installed and the 'docker' command is available in your PATH.\"\n+            )\n+            Print(\n+                \"For information on Docker installation, visit: https://docs.docker.com/engine/install/\"\n+            )\n+            Print(\"If Docker is installed, try starting a new terminal session.\")\ndiff --git a/interpreter/code_interpreters/container_utils/container_utils.py b/interpreter/code_interpreters/container_utils/container_utils.py\nnew file mode 100644\nindex 0000000000..da9c23a9f5\n--- /dev/null\n+++ b/interpreter/code_interpreters/container_utils/container_utils.py\n@@ -0,0 +1,255 @@\n+\"\"\"wrapper classes of the Docker python sdk which allows interaction like its a subprocess object.\"\"\"\n+import os\n+import re\n+import select\n+import struct\n+import threading\n+import time\n+\n+\n+# Third-party imports       \n+import appdirs\n+import docker\n+from docker.utils import kwargs_from_env\n+from docker.tls import TLSConfig\n+from rich import print as Print\n+\n+# Modules\n+from .auto_remove import access_aware\n+\n+class DockerStreamWrapper:\n+    def __init__(self, exec_id, sock):\n+        self.exec_id = exec_id\n+        self._sock = sock\n+        self._stdout_r, self._stdout_w = os.pipe()\n+        self._stderr_r, self._stderr_w = os.pipe()\n+        self.stdout = self.Stream(self, self._stdout_r)\n+        self.stderr = self.Stream(self, self._stderr_r)\n+\n+        ## stdin pipe and fd. dosent need a pipe, but its easier and thread safe and less mem intensive than a queue.Queue()\n+        self._stdin_r, self._stdin_w = os.pipe()  # Pipe for stdin\n+        self.stdin = os.fdopen(self._stdin_w, 'w')\n+        self._stdin_buffer = b\"\"  # Buffer for stdin data. more complex = better fr\n+\n+        ## start recieving thread to watch socket, and send data from stdin pipe.\n+        self._stop_event = threading.Event()\n+        self._thread = threading.Thread(target=self._listen, daemon=True)\n+        self._thread.start()\n+    \n+    class Stream:\n+        def __init__(self, parent, read_fd):\n+            self.parent = parent\n+            self._read_fd = read_fd\n+            self._buffer = \"\"\n+\n+        def readline(self):\n+            while '\\n' not in self._buffer:\n+                ready_to_read, _, _ = select.select([self._read_fd], [], [], None)\n+                if not ready_to_read:\n+                    return ''\n+                chunk = os.read(self._read_fd, 1024).decode('utf-8')\n+                self._buffer += chunk\n+\n+            newline_pos = self._buffer.find('\\n')\n+            line = self._buffer[:newline_pos]\n+            self._buffer = self._buffer[newline_pos + 1:]\n+            return line\n+\n+    def _listen(self):\n+        while not self._stop_event.is_set():\n+            ready_to_read, _, _ = select.select([self._sock, self._stdin_r], [], [], None)\n+            \n+            for s in ready_to_read:\n+                if s == self._sock:\n+                    raw_data = self._sock.recv(2048)\n+                    stdout, stderr = self.demux_docker_stream(raw_data)\n+                    os.write(self._stdout_w, stdout.encode())\n+                    os.write(self._stderr_w, stderr.encode())\n+                elif s == self._stdin_r:\n+                    # Read from the read end of the stdin pipe and add to the buffer\n+                    data_to_write = os.read(self._stdin_r, 2048).decode('utf-8')\n+                    \n+                    # Remove escape characters for quotes but leave other backslashes untouched\n+                    data_to_write =  re.sub(r'\\\\([\\'\"])', r'\\1', data_to_write)\n+\n+                    data_to_write = data_to_write.replace('\\\\n', '\\n')\n+\n+                    self._stdin_buffer += data_to_write.encode()\n+\n+                    # Check for newline and send line by line\n+                    while b'\\n' in self._stdin_buffer:\n+                        newline_pos = self._stdin_buffer.find(b'\\n')\n+                        line = self._stdin_buffer[:newline_pos + 1]  # Include the newline\n+                        self._stdin_buffer = self._stdin_buffer[newline_pos + 1:]\n+\n+\n+                        # Send the line to the Docker container\n+                        self._sock.sendall(line)\n+\n+\n+    def demux_docker_stream(self, data):\n+        stdout = \"\"\n+        stderr = \"\"\n+        offset = 0\n+        while offset + 8 <= len(data):\n+            header = data[offset:offset + 8]\n+            stream_type, length = struct.unpack('>BxxxL', header)\n+            offset += 8\n+            chunk = data[offset:offset + length].decode('utf-8')\n+            offset += length\n+            if stream_type == 1:\n+                stdout += chunk\n+            elif stream_type == 2:\n+                stderr += chunk\n+\n+        return stdout, stderr\n+\n+    def flush(self):\n+        pass\n+\n+    def terminate(self):\n+        self._stop_event.set()\n+        self._thread.join()\n+        os.close(self._stdout_r)\n+        os.close(self._stdout_w)\n+        os.close(self._stderr_r)\n+        os.close(self._stderr_w)\n+\n+\n+# The `@access_aware` decorator enables automatic container cleanup based on activity monitoring.\n+# It functions under the following conditions:\n+# 1. The container is subject to removal when it remains unaccessed beyond the duration specified by `auto_remove_timeout`.\n+# 2. This feature necessitates a non-None argument; absence of a valid argument renders this functionality inactive.\n+# 3. During interactive sessions, the auto-removal feature is disabled to prevent unintended interruptions.\n+# 4. The \"INTERPRETER_CONTAINER_TIMEOUT\" environment variable allows customization of the timeout period. \n+#    It accepts an integer value representing the desired timeout in seconds.\n+# 5. In the event of an unexpected program termination, the container is still ensured to be removed,\n+#    courtesy of the integration with the `atexit` module, safeguarding system resources from being unnecessarily occupied.\n+@access_aware \n+class DockerProcWrapper:\n+    def __init__(self, command, session_id, auto_remove_timeout=None, close_callback=None, mount=False): ## Mounting isnt implemented in main code, but i did it here prior so we just hide it behind a flag for now.\n+        \n+        # Docker stuff\n+        client_kwargs = kwargs_from_env()\n+        if client_kwargs.get('tls'):\n+            client_kwargs['tls'] = TLSConfig(**client_kwargs['tls'])\n+        self.client = docker.APIClient(**client_kwargs)\n+        self.image_name = \"openinterpreter-runtime-container:latest\"\n+        self.exec_id = None\n+        self.exec_socket = None\n+\n+        # close callback\n+        self.close_callback = close_callback\n+\n+        # session info\n+        self.session_id = session_id\n+        self.session_path = os.path.join(appdirs.user_data_dir(\"Open Interpreter\"), \"sessions\", session_id)\n+        self.mount = mount\n+\n+\n+        # Initialize container\n+        self.init_container()\n+\n+        self.init_exec_instance()\n+        \n+\n+        self.wrapper = DockerStreamWrapper(self.exec_id, self.exec_socket)\n+        self.stdout = self.wrapper.stdout\n+        self.stderr = self.wrapper.stderr\n+        self.stdin = self.wrapper.stdin\n+\n+        self.stdin.write(command + \"\\n\")\n+\n+    def init_container(self):\n+        self.container = None\n+        try:\n+            containers = self.client.containers(\n+                filters={\"label\": f\"session_id={self.session_id}\"}, all=True)\n+            if containers:\n+                self.container = containers[0]\n+                container_id = self.container.get('Id')\n+                container_info = self.client.inspect_container(container_id)\n+                if container_info.get('State', {}).get('Running') is False:\n+                    self.client.start(container=container_id)\n+                    self.wait_for_container_start(container_id)\n+            else:\n+                if self.mount:\n+\n+                    os.makedirs(self.session_path, exist_ok=True)\n+\n+                    host_config = self.client.create_host_config(\n+                        binds={self.session_path: {'bind': '/mnt/data', 'mode': 'rw'}}\n+                    )\n+                else:\n+                    host_config = None\n+                \n+                self.container = self.client.create_container(\n+                    image=self.image_name,\n+                    detach=True,\n+                    labels={'session_id': os.path.basename(self.session_path)},\n+                    host_config=host_config,\n+                    user=\"docker\",\n+                    stdin_open=True,\n+                    tty=False\n+                )\n+\n+                self.client.start(container=self.container.get('Id'))\n+                self.wait_for_container_start(self.container.get('Id'))\n+\n+\n+        except Exception as e:\n+            print(f\"An error occurred: {e}\")\n+\n+    def init_exec_instance(self):\n+        if self.container:\n+            container_info = self.client.inspect_container(self.container.get('Id'))\n+\n+            if container_info.get(\"State\").get('Running') is False: # Not sure of the cause of this, but this works for now.\n+                self.client.start(self.container.get(\"Id\"))\n+\n+            self.exec_id = self.client.exec_create(\n+                self.container.get(\"Id\"),\n+                cmd=\"/bin/bash\",\n+                stdin=True,\n+                stdout=True,\n+                stderr=True,\n+                workdir=\"/mnt/data\",\n+                user=\"docker\",\n+                tty=False\n+\n+            )['Id']\n+            # when socket=True, this returns a socketIO socket, so we just kinda hijack the underlying socket\n+            # since docker sets up the socketio wierd and tries to make it hard to mess with and write to.\n+            # We make the socket \"Cooperative\"\n+            self.exec_socket = self.client.exec_start(\n+                self.exec_id, socket=True, tty=False, demux=False)._sock  # type: ignore\n+\n+\n+    def wait_for_container_start(self, container_id, timeout=30):\n+        start_time = time.time()\n+        while True:\n+            container_info = self.client.inspect_container(container_id)\n+            if container_info.get('State', {}).get('Running') is True:\n+                return True\n+            elif time.time() - start_time > timeout:\n+                raise TimeoutError(\n+                    \"Container did not start within the specified timeout.\")\n+            time.sleep(1)\n+    \n+    def terminate(self):\n+        self.wrapper.terminate()\n+        self.client.stop(self.container.get(\"Id\"))\n+        self.client.remove_container(self.container.get(\"Id\"))\n+\n+    def stop(self):\n+        self.wrapper.terminate()\n+        self.client.stop(self.container.get(\"Id\"), 30)\n+\n+\n+    def __del__(self):\n+        self.terminate()\n+\n+\n+\n+\n+\ndiff --git a/interpreter/code_interpreters/container_utils/download_file.py b/interpreter/code_interpreters/container_utils/download_file.py\nnew file mode 100644\nindex 0000000000..dc3047e5d7\n--- /dev/null\n+++ b/interpreter/code_interpreters/container_utils/download_file.py\n@@ -0,0 +1,52 @@\n+import docker\n+import tarfile\n+import os\n+import tempfile\n+import appdirs\n+from tqdm import tqdm\n+\n+\n+def download_file_from_container(container_id, file_path_in_container, local_dir):\n+    # Check if the specified local directory exists\n+    if not os.path.isdir(local_dir):\n+        # If not, use a \"Downloads\" folder in the user's data directory as the default\n+        local_dir = os.path.join(appdirs.user_data_dir(), \"Open Interpreter\", \"downloads\")\n+        print(f\"file is being downloaded to {local_dir}\")\n+        # Create the Downloads directory if it doesn't exist\n+        os.makedirs(local_dir, exist_ok=True)\n+    \n+    # Create a Docker client\n+    client = docker.from_env()\n+\n+    # Get the container\n+    container = client.containers.get(container_id)\n+\n+    # Use get_archive to get a file from the container\n+    stream, stat = container.get_archive(os.path.join(\"/mnt/data/\", file_path_in_container))\n+    \n+    # Get the file name from the stat info\n+    file_name = os.path.basename(stat['name'])\n+    # Get the size of the file from the stat object for the progress bar\n+    total_size = stat['size']\n+    # Initialize the progress bar\n+    pbar = tqdm(total=total_size, unit=\"B\", unit_scale=True, desc=\"Downloading\")\n+\n+    # Update the progress bar within the loop where chunks are being written\n+    with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n+        for chunk in stream:\n+            temp_file.write(chunk)\n+            pbar.update(len(chunk))\n+            temp_file.flush()\n+    pbar.close()\n+    \n+    # Open the temporary tar file for reading\n+    with tarfile.open(temp_file.name, 'r') as tar:\n+        # Extract the file to the local directory\n+        tar.extractall(path=local_dir)\n+    \n+    # Delete the temporary tar file\n+    os.remove(temp_file.name)\n+\n+    # Return the path to the extracted file\n+    return os.path.join(local_dir, file_name)\n+\ndiff --git a/interpreter/code_interpreters/container_utils/upload_file.py b/interpreter/code_interpreters/container_utils/upload_file.py\nnew file mode 100644\nindex 0000000000..ecf79fd1de\n--- /dev/null\n+++ b/interpreter/code_interpreters/container_utils/upload_file.py\n@@ -0,0 +1,62 @@\n+\"\"\"Short function to upload a file to a docker container via the docker module. yes its hacky, but its easy and I didnt want to over complicate.\"\"\"\n+import io\n+import tarfile\n+import os\n+import docker\n+from tqdm import tqdm\n+\n+def copy_file_to_container(container_id, local_path, path_in_container, pbar=True):\n+    # Validate input\n+    if not os.path.exists(local_path):\n+        raise ValueError(f\"The specified local path {local_path} does not exist.\")\n+    \n+    # Create a Docker client\n+    client = docker.APIClient()\n+\n+    # Get the container\n+    container = client.containers()[0]\n+\n+    container_id = container.get(\"Id\")\n+\n+    # Get the directory path and name in the container\n+    dir_path_in_container = os.path.dirname(path_in_container)\n+    name = os.path.basename(path_in_container)\n+\n+    # Calculate the total size of the content to be uploaded\n+    total_size = 0\n+    for dirpath, dirnames, filenames in os.walk(local_path):\n+        for filename in filenames:\n+            filepath = os.path.join(dirpath, filename)\n+            total_size += os.path.getsize(filepath)\n+\n+    # Create a tarball in memory\n+    file_data = io.BytesIO()\n+    with tarfile.open(fileobj=file_data, mode='w') as tar:\n+        # Check if the local path is a directory or a file\n+        if os.path.isdir(local_path):\n+            # Add the entire directory to the tar archive with the specified name\n+            tar.add(local_path, arcname=name)\n+        else:\n+            # Add the local file to the tar archive with the specified file name\n+            tar.add(local_path, arcname=name)\n+\n+    # Seek to the beginning of the in-memory tarball\n+    file_data.seek(0)\n+\n+    # Create a tqdm progress bar\n+    with tqdm(total=total_size, unit='B', unit_scale=True, desc='Uploading') as pbar:\n+        # Define a generator to read the file data in chunks and update the progress bar\n+        def file_data_with_progress():\n+            chunk_size = 1024  # Define an appropriate chunk size\n+            while True:\n+                chunk = file_data.read(chunk_size)\n+                if not chunk:\n+                    break\n+                pbar.update(len(chunk))\n+                yield chunk\n+            file_data.close()\n+\n+        # Use put_archive to copy the file or directory into the container\n+        client.put_archive(container=container_id, path=dir_path_in_container, data=file_data_with_progress())\n+    \n+    return path_in_container\ndiff --git a/interpreter/code_interpreters/dockerfiles/Dockerfile b/interpreter/code_interpreters/dockerfiles/Dockerfile\nnew file mode 100644\nindex 0000000000..761207e7c0\n--- /dev/null\n+++ b/interpreter/code_interpreters/dockerfiles/Dockerfile\n@@ -0,0 +1,78 @@\n+# Base image\n+FROM debian:bullseye\n+\n+# Set environment variables to disable prompts\n+ENV DEBIAN_FRONTEND=noninteractive\n+\n+# Create user with sudo only in the container for security.\n+RUN useradd docker && echo \"docker:docker\" | chpasswd && mkdir -p /home/docker && chown docker:docker /home/docker\n+RUN mkdir -p /mnt/data && chown -R docker:docker /mnt/data\n+\n+RUN apt-get update && apt-get install -y sudo\n+\n+RUN usermod -aG sudo docker\n+\n+RUN echo \"docker ALL=(ALL) NOPASSWD: ALL\" >> /etc/sudoers\n+# add write perms for user 'docker' in the correct dirs ( where it cant mess things up much. it does have passwordless sudo, so it can override this if it figures out it has sudo.)\n+RUN chown -R docker:docker /mnt/data\n+\n+# Update package list and install essential utilities and runtimes\n+RUN sudo apt-get update && apt-get install -y \\\n+    jq \\\n+    build-essential \\\n+    python3 \\\n+    python3-pip \\\n+    python3-dev \\\n+    curl \\\n+    libssl-dev \\\n+    libexpat1 \\\n+    r-base \\\n+    r-base-dev\n+\n+# install nodejs stuff\n+RUN sudo apt-get update\n+RUN sudo apt-get install -y ca-certificates curl gnupg\n+RUN sudo mkdir -p /etc/apt/keyrings\n+RUN curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg\n+RUN NODE_MAJOR=20\n+RUN echo \"deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_18.x nodistro main\" | sudo tee /etc/apt/sources.list.d/nodesource.list\n+RUN sudo apt-get update\n+RUN sudo apt-get install nodejs -y\n+\n+\n+# Copy unified requirements.txt into the image\n+COPY ./requirements.txt /tmp/\n+\n+# Install Python packages\n+RUN awk '/\\[python\\]/, /^\\s*$/' /tmp/requirements.txt | grep -v '^\\[python\\]' > /tmp/python_requirements.txt && \\\n+    pip3 install --no-cache-dir -r /tmp/python_requirements.txt --no-input\n+\n+# Create an initial empty package.json\n+RUN echo '{}' > /tmp/package.json\n+\n+RUN awk '/\\[node\\]/, /^\\s*$/' /tmp/requirements.txt | grep -v '^\\[node\\]' > /tmp/node_requirements.txt && \\\n+    while read -r package; do \\\n+        name=$(echo $package | grep -Eo \"^[a-zA-Z0-9_-]+\") && \\\n+        version=$(echo $package | grep -Eo \"[>=<]+[0-9.]+\"); \\\n+        if [ -z \"$version\" ]; then version=\"*\"; fi && \\\n+        jq \".dependencies.\\\"$name\\\" = \\\"$version\\\"\" /tmp/package.json > /tmp/package_temp.json && mv /tmp/package_temp.json /tmp/package.json; \\\n+    done < /tmp/node_requirements.txt\n+\n+\n+\n+# Install NodeJS packages\n+RUN npm install --save --yes --no-package-lock --prefix /tmp\n+\n+# Install R packages\n+RUN awk '/\\[r\\]/,/^\\s*$/' /tmp/requirements.txt | grep -v '^\\[r\\]' > /tmp/r_requirements.txt && \\\n+    while read -r package; do \\\n+        R -e \"install.packages('$package', repos='http://cran.rstudio.com/', dependencies=TRUE, INSTALL_opts = c('--no-tests'))\"; \\\n+    done < /tmp/r_requirements.txt\n+\n+# Install NodeJS packages\n+\n+# Remove temporary files\n+RUN rm /tmp/package.json /tmp/node_requirements.txt /tmp/python_requirements.txt /tmp/r_requirements.txt\n+\n+# workdir set. pray it dosent try to go exploring.\n+WORKDIR /mnt/data\ndiff --git a/interpreter/code_interpreters/dockerfiles/docker_manager.py b/interpreter/code_interpreters/dockerfiles/docker_manager.py\nnew file mode 100644\nindex 0000000000..6446fd106b\n--- /dev/null\n+++ b/interpreter/code_interpreters/dockerfiles/docker_manager.py\n@@ -0,0 +1,59 @@\n+import os\n+\n+class DockerManager:\n+    \n+    here = os.path.abspath(__file__)\n+    requirements_file = os.path.normpath(os.path.join(here, \"..\", \"requirements.txt\"))\n+    docker_file = os.path.normpath(os.path.join(here,\"..\", \"Dockerfile\"))\n+\n+    def add_dependency(language, dependency):\n+        lines = []\n+        language_section_found = False\n+        dependency_name = dependency.split('==')[0]\n+\n+        with open(DockerManager.requirements_file, 'r') as f:\n+            lines = f.readlines()\n+\n+        for i, line in enumerate(lines):\n+            if line.strip() == f'[{language}]':\n+                language_section_found = True\n+            elif language_section_found:\n+                if line.strip() == '' or line.strip().startswith('['):\n+                    break\n+                existing_dependency_name = line.strip().split('==')[0]\n+                if existing_dependency_name == dependency_name:\n+                    print(f\"Dependency {dependency} already exists under [{language}].\")\n+                    return\n+\n+        if not language_section_found:\n+            print(f\"Error: Language section [{language}] not found. Please add it first.\")\n+            return\n+\n+        lines.insert(i, f\"{dependency}\\n\")\n+\n+        with open(DockerManager.requirements_file, 'w') as f:\n+            f.writelines(lines)\n+\n+    def remove_dependency(language, dependency_name):\n+        lines = []\n+        language_section_found = False\n+\n+        with open(DockerManager.requirements_file, 'r') as f:\n+            lines = f.readlines()\n+\n+        for i, line in enumerate(lines):\n+            if line.strip() == f'[{language}]':\n+                language_section_found = True\n+            elif language_section_found:\n+                if line.strip() == '' or line.strip().startswith('['):\n+                    break\n+                existing_dependency_name = line.strip().split('==')[0]\n+                if existing_dependency_name == dependency_name:\n+                    del lines[i]\n+                    break\n+        else:\n+            raise ValueError(f\"Error: Language section [{language}] or dependency {dependency_name} not found.\")\n+\n+        with open(DockerManager.requirements_file, 'w') as f:\n+            f.writelines(lines)\n+\ndiff --git a/interpreter/terminal_interface/magic_commands.py b/interpreter/terminal_interface/magic_commands.py\nindex fddfbc9335..5973659f7a 100644\n--- a/interpreter/terminal_interface/magic_commands.py\n+++ b/interpreter/terminal_interface/magic_commands.py\n@@ -74,33 +90,153 @@ def handle_debug(self, arguments=None):\n     else:\n         display_markdown_message(\"> Unknown argument to debug command.\")\n \n+\n def handle_reset(self, arguments):\n     self.reset()\n     display_markdown_message(\"> Reset Done\")\n \n+\n def default_handle(self, arguments):\n     display_markdown_message(\"> Unknown command\")\n     handle_help(self,arguments)\n \n def handle_save_message(self, json_path):\n     if json_path == \"\":\n-      json_path = \"messages.json\"\n+        json_path = \"messages.json\"\n     if not json_path.endswith(\".json\"):\n-      json_path += \".json\"\n+        json_path += \".json\"\n     with open(json_path, 'w') as f:\n-      json.dump(self.messages, f, indent=2)\n+        json.dump(self.messages, f, indent=2)\n+\n+    display_markdown_message(\n+        f\"> messages json export to {os.path.abspath(json_path)}\")\n \n-    display_markdown_message(f\"> messages json export to {os.path.abspath(json_path)}\")\n \n def handle_load_message(self, json_path):\n     if json_path == \"\":\n-      json_path = \"messages.json\"\n+        json_path = \"messages.json\"\n     if not json_path.endswith(\".json\"):\n-      json_path += \".json\"\n+        json_path += \".json\"\n     with open(json_path, 'r') as f:\n-      self.messages = json.load(f)\n+        self.messages = json.load(f)\n+\n+    display_markdown_message(\n+        f\"> messages json loaded from {os.path.abspath(json_path)}\")\n+\n+def handle_container_upload(self,type=None, *args):\n+    def is_gui_available():\n+        try:\n+            from PyQt5.QtWidgets import QApplication\n+            app = QApplication([])\n+            del app\n+            return True\n+        except Exception as e:\n+            print(f\"An error occurred: {str(e)}\")\n+            return False\n+        \n+    args = list(args)\n+    if self.use_containers:\n+        try:\n+            client = docker.APIClient()\n+        except:\n+            error_message = (\n+                \"We were not able to connect to the Docker Container daemon. \"\n+                \"Please ensure Docker is installed and running. If you have not run any code yet, \"\n+                \"you will need to in order to start a container.\"\n+            )\n+            display_markdown_message(f\"{error_message}\")\n+            return\n+        if len(args) == 0:\n+            if is_gui_available():\n+                try:\n+                    from .components.file_dialog import FileDialog\n+\n+                    fd = FileDialog()\n+                    if type is not None:\n+                        path = fd.get_path(type=type)\n+                    else:\n+                        path = fd.get_path(type=None)\n+                    if path is not None: # if none, they exited\n+                        \n+                        args.append(path)\n+                    else: # We shall now exit on them out of spite\n+                        return\n+                except ImportError as e:\n+                    Print(f\"Internal import error {e}\")\n+                    return \n+            else:\n+                Print(f\"No GUI available for your system.\\n please provide a filepath manually. use the command %upload <filetype (file or folder)> <path>\")\n+                return\n+                 \n+        for filepath in args:\n+            if os.path.exists(filepath):\n+                session_id = self.session_id\n+                if session_id is None:\n+                    Print(\"[BOLD] [RED] No session found. Please run any code to start one. [/RED] [/BOLD]\")\n+                    return\n+                containers = client.containers(filters={\"label\": f\"session_id={session_id}\"})\n+                if containers:\n+                    container_id = containers[0]['Id']\n+                    # /mnt/data is default workdir for container\n+                    copy_file_to_container(\n+                        container_id=container_id, local_path=filepath, path_in_container=f\"/mnt/data/{os.path.basename(filepath)}\"\n+                    )\n+                    success_message = f\"[{filepath}](#) successfully uploaded to container in dir `/mnt/data`.\"\n+                    display_markdown_message(success_message)\n+                else:\n+                    no_container_message = (\n+                        \"No container found to upload to. Please run any code to start one. \"\n+                        \"This will be fixed in a later update.\"\n+                    )\n+                    display_markdown_message(f\"**'{no_container_message}'**\")\n+            else:\n+                file_not_found_message = f\"File `{filepath}` does not exist.\"\n+                display_markdown_message(file_not_found_message)\n+    else:\n+        ignore_command_message = \"File uploads are only used when using containerized code execution. Ignoring command.\"\n+        display_markdown_message(f\"**{ignore_command_message}**\")\n+        \n+def handle_container_download(self, *args):\n+    if self.use_containers:\n+        try:\n+            client = docker.APIClient()\n+        except Exception as e:\n+            print(\"[BOLD][RED]Unable to connect to the Docker Container daemon. Please ensure Docker is installed and running. ignoring command[/RED][/BOLD]\")\n+            return\n+        \n+        session_id = self.session_id\n+        if session_id is None:\n+            print(\"No session found. Please run any code to start one.\")\n+            return\n+\n+        containers = client.containers(filters={\"label\": f\"session_id={session_id}\"})\n+        if not containers:\n+            print(\"No container found to download from. Please run any code to start one.\")\n+            return\n+        \n+        container_id = containers[0]['Id']\n+\n+        # Define the local directory where the files will be downloaded.\n+        # Using 'Open Interpreter' as the appname and no author.\n+        local_dir = appdirs.user_data_dir(appname=\"Open Interpreter\")\n+\n+        for file_path_in_container in args:\n+\n+            if not file_path_in_container.startswith(\"/mnt/data\"):\n+                file_path_in_container = os.path.join(\"/mnt/data\", file_path_in_container)\n+\n+            # Construct the local file path\n+            local_file_path = os.path.join(local_dir, os.path.basename(file_path_in_container))\n+            \n+            # Attempt to download the file and handle exceptions\n+            try:\n+                download_file_from_container(container_id, file_path_in_container, local_file_path)\n+                print(f\"File downloaded to {local_file_path}\")\n+            except docker.errors.NotFound:\n+                print(f\"File {file_path_in_container} not found in the container.\")\n+    else:\n+        print(\"File downloads are only used when using containerized code execution. Ignoring command.\")\n \n-    display_markdown_message(f\"> messages json loaded from {os.path.abspath(json_path)}\")\n \n def handle_count_tokens(self, prompt):\n     messages = [{\"role\": \"system\", \"message\": self.system_message}] + self.messages\n\ndiff --git a/poetry.lock b/poetry.lock\nindex b7b908b9f8..d4d50a06d3 100644\n--- a/poetry.lock\n+++ b/poetry.lock\n@@ -1633,6 +1784,67 @@ files = [\n     {file = \"PyPika-0.48.9.tar.gz\", hash = \"sha256:838836a61747e7c8380cd1b7ff638694b7a7335345d0f559b04b2cd832ad5378\"},\n ]\n \n+[[package]]\n+name = \"pyqt5\"\n+version = \"5.15.10\"\n+description = \"Python bindings for the Qt cross platform application toolkit\"\n+optional = false\n+python-versions = \">=3.7\"\n+files = [\n+    {file = \"PyQt5-5.15.10-cp37-abi3-macosx_10_13_x86_64.whl\", hash = \"sha256:93288d62ebd47b1933d80c27f5d43c7c435307b84d480af689cef2474e87e4c8\"},\n+    {file = \"PyQt5-5.15.10-cp37-abi3-manylinux_2_17_x86_64.whl\", hash = \"sha256:b89478d16d4118664ff58ed609e0a804d002703c9420118de7e4e70fa1cb5486\"},\n+    {file = \"PyQt5-5.15.10-cp37-abi3-win32.whl\", hash = \"sha256:ff99b4f91aa8eb60510d5889faad07116d3340041916e46c07d519f7cad344e1\"},\n+    {file = \"PyQt5-5.15.10-cp37-abi3-win_amd64.whl\", hash = \"sha256:501355f327e9a2c38db0428e1a236d25ebcb99304cd6e668c05d1188d514adec\"},\n+    {file = \"PyQt5-5.15.10.tar.gz\", hash = \"sha256:d46b7804b1b10a4ff91753f8113e5b5580d2b4462f3226288e2d84497334898a\"},\n+]\n+\n+[package.dependencies]\n+PyQt5-Qt5 = \">=5.15.2\"\n+PyQt5-sip = \">=12.13,<13\"\n+\n+[[package]]\n+name = \"pyqt5-qt5\"\n+version = \"5.15.2\"\n+description = \"The subset of a Qt installation needed by PyQt5.\"\n+optional = false\n+python-versions = \"*\"\n+files = [\n+    {file = \"PyQt5_Qt5-5.15.2-py3-none-macosx_10_13_intel.whl\", hash = \"sha256:76980cd3d7ae87e3c7a33bfebfaee84448fd650bad6840471d6cae199b56e154\"},\n+    {file = \"PyQt5_Qt5-5.15.2-py3-none-manylinux2014_x86_64.whl\", hash = \"sha256:1988f364ec8caf87a6ee5d5a3a5210d57539988bf8e84714c7d60972692e2f4a\"},\n+    {file = \"PyQt5_Qt5-5.15.2-py3-none-win32.whl\", hash = \"sha256:9cc7a768b1921f4b982ebc00a318ccb38578e44e45316c7a4a850e953e1dd327\"},\n+    {file = \"PyQt5_Qt5-5.15.2-py3-none-win_amd64.whl\", hash = \"sha256:750b78e4dba6bdf1607febedc08738e318ea09e9b10aea9ff0d73073f11f6962\"},\n+]\n+\n+[[package]]\n+name = \"pyqt5-sip\"\n+version = \"12.13.0\"\n+description = \"The sip module support for PyQt5\"\n+optional = false\n+python-versions = \">=3.7\"\n+files = [\n+    {file = \"PyQt5_sip-12.13.0-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:a7e3623b2c743753625c4650ec7696362a37fb36433b61824cf257f6d3d43cca\"},\n+    {file = \"PyQt5_sip-12.13.0-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.whl\", hash = \"sha256:6e4ac714252370ca037c7d609da92388057165edd4f94e63354f6d65c3ed9d53\"},\n+    {file = \"PyQt5_sip-12.13.0-cp310-cp310-win32.whl\", hash = \"sha256:d5032da3fff62da055104926ffe76fd6044c1221f8ad35bb60804bcb422fe866\"},\n+    {file = \"PyQt5_sip-12.13.0-cp310-cp310-win_amd64.whl\", hash = \"sha256:9a8cdd6cb66adcbe5c941723ed1544eba05cf19b6c961851b58ccdae1c894afb\"},\n+    {file = \"PyQt5_sip-12.13.0-cp311-cp311-macosx_10_9_universal2.whl\", hash = \"sha256:0f85fb633a522f04e48008de49dce1ff1d947011b48885b8428838973fbca412\"},\n+    {file = \"PyQt5_sip-12.13.0-cp311-cp311-manylinux_2_5_x86_64.manylinux1_x86_64.whl\", hash = \"sha256:ec60162e034c42fb99859206d62b83b74f987d58937b3a82bdc07b5c3d190dec\"},\n+    {file = \"PyQt5_sip-12.13.0-cp311-cp311-win32.whl\", hash = \"sha256:205cd449d08a2b024a468fb6100cd7ed03e946b4f49706f508944006f955ae1a\"},\n+    {file = \"PyQt5_sip-12.13.0-cp311-cp311-win_amd64.whl\", hash = \"sha256:1c8371682f77852256f1f2d38c41e2e684029f43330f0635870895ab01c02f6c\"},\n+    {file = \"PyQt5_sip-12.13.0-cp312-cp312-macosx_10_9_universal2.whl\", hash = \"sha256:7fe3375b508c5bc657d73b9896bba8a768791f1f426c68053311b046bcebdddf\"},\n+    {file = \"PyQt5_sip-12.13.0-cp312-cp312-manylinux_2_5_x86_64.manylinux1_x86_64.whl\", hash = \"sha256:773731b1b5ab1a7cf5621249f2379c95e3d2905e9bd96ff3611b119586daa876\"},\n+    {file = \"PyQt5_sip-12.13.0-cp312-cp312-win32.whl\", hash = \"sha256:fb4a5271fa3f6bc2feb303269a837a95a6d8dd16be553aa40e530de7fb81bfdf\"},\n+    {file = \"PyQt5_sip-12.13.0-cp312-cp312-win_amd64.whl\", hash = \"sha256:3a4498f3b1b15f43f5d12963accdce0fd652b0bcaae6baf8008663365827444c\"},\n+    {file = \"PyQt5_sip-12.13.0-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:9b984c2620a7a7eaf049221b09ae50a345317add2624c706c7d2e9e6632a9587\"},\n+    {file = \"PyQt5_sip-12.13.0-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.whl\", hash = \"sha256:3188a06956aef86f604fb0d14421a110fad70d2a9e943dbacbfc3303f651dade\"},\n+    {file = \"PyQt5_sip-12.13.0-cp38-cp38-win32.whl\", hash = \"sha256:108a15f603e1886988c4b0d9d41cb74c9f9815bf05cefc843d559e8c298a10ce\"},\n+    {file = \"PyQt5_sip-12.13.0-cp38-cp38-win_amd64.whl\", hash = \"sha256:db228cd737f5cbfc66a3c3e50042140cb80b30b52edc5756dbbaa2346ec73137\"},\n+    {file = \"PyQt5_sip-12.13.0-cp39-cp39-macosx_10_9_universal2.whl\", hash = \"sha256:5338773bbaedaa4f16a73c142fb23cc18c327be6c338813af70260b756c7bc92\"},\n+    {file = \"PyQt5_sip-12.13.0-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.whl\", hash = \"sha256:29fa9cc964517c9fc3f94f072b9a2aeef4e7a2eda1879cb835d9e06971161cdf\"},\n+    {file = \"PyQt5_sip-12.13.0-cp39-cp39-win32.whl\", hash = \"sha256:96414c93f3d33963887cf562d50d88b955121fbfd73f937c8eca46643e77bf61\"},\n+    {file = \"PyQt5_sip-12.13.0-cp39-cp39-win_amd64.whl\", hash = \"sha256:bbc7cd498bf19e0862097be1ad2243e824dea56726f00c11cff1b547c2d31d01\"},\n+    {file = \"PyQt5_sip-12.13.0.tar.gz\", hash = \"sha256:7f321daf84b9c9dbca61b80e1ef37bdaffc0e93312edae2cd7da25b953971d91\"},\n+]\n+\n [[package]]\n name = \"pyreadline3\"\n version = \"3.4.1\"\n@@ -1915,6 +2198,214 @@ pygments = \">=2.13.0,<3.0.0\"\n [package.extras]\n jupyter = [\"ipywidgets (>=7.5.1,<9)\"]\n \n+[[package]]\n+name = \"rpds-py\"\n+version = \"0.10.6\"\n+description = \"Python bindings to Rust's persistent data structures (rpds)\"\n+optional = false\n+python-versions = \">=3.8\"\n+files = [\n+    {file = \"rpds_py-0.10.6-cp310-cp310-macosx_10_7_x86_64.whl\", hash = \"sha256:6bdc11f9623870d75692cc33c59804b5a18d7b8a4b79ef0b00b773a27397d1f6\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:26857f0f44f0e791f4a266595a7a09d21f6b589580ee0585f330aaccccb836e3\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:d7f5e15c953ace2e8dde9824bdab4bec50adb91a5663df08d7d994240ae6fa31\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:61fa268da6e2e1cd350739bb61011121fa550aa2545762e3dc02ea177ee4de35\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:c48f3fbc3e92c7dd6681a258d22f23adc2eb183c8cb1557d2fcc5a024e80b094\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:c0503c5b681566e8b722fe8c4c47cce5c7a51f6935d5c7012c4aefe952a35eed\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:734c41f9f57cc28658d98270d3436dba65bed0cfc730d115b290e970150c540d\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:a5d7ed104d158c0042a6a73799cf0eb576dfd5fc1ace9c47996e52320c37cb7c\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-musllinux_1_2_aarch64.whl\", hash = \"sha256:e3df0bc35e746cce42579826b89579d13fd27c3d5319a6afca9893a9b784ff1b\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-musllinux_1_2_i686.whl\", hash = \"sha256:73e0a78a9b843b8c2128028864901f55190401ba38aae685350cf69b98d9f7c9\"},\n+    {file = \"rpds_py-0.10.6-cp310-cp310-musllinux_1_2_x86_64.whl\", hash = \"sha256:5ed505ec6305abd2c2c9586a7b04fbd4baf42d4d684a9c12ec6110deefe2a063\"},\n+    {file = \"rpds_py-0.10.6-cp310-none-win32.whl\", hash = \"sha256:d97dd44683802000277bbf142fd9f6b271746b4846d0acaf0cefa6b2eaf2a7ad\"},\n+    {file = \"rpds_py-0.10.6-cp310-none-win_amd64.whl\", hash = \"sha256:b455492cab07107bfe8711e20cd920cc96003e0da3c1f91297235b1603d2aca7\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-macosx_10_7_x86_64.whl\", hash = \"sha256:e8cdd52744f680346ff8c1ecdad5f4d11117e1724d4f4e1874f3a67598821069\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:66414dafe4326bca200e165c2e789976cab2587ec71beb80f59f4796b786a238\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:cc435d059f926fdc5b05822b1be4ff2a3a040f3ae0a7bbbe672babb468944722\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:8e7f2219cb72474571974d29a191714d822e58be1eb171f229732bc6fdedf0ac\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:3953c6926a63f8ea5514644b7afb42659b505ece4183fdaaa8f61d978754349e\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:2bb2e4826be25e72013916eecd3d30f66fd076110de09f0e750163b416500721\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:7bf347b495b197992efc81a7408e9a83b931b2f056728529956a4d0858608b80\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:102eac53bb0bf0f9a275b438e6cf6904904908562a1463a6fc3323cf47d7a532\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-musllinux_1_2_aarch64.whl\", hash = \"sha256:40f93086eef235623aa14dbddef1b9fb4b22b99454cb39a8d2e04c994fb9868c\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-musllinux_1_2_i686.whl\", hash = \"sha256:e22260a4741a0e7a206e175232867b48a16e0401ef5bce3c67ca5b9705879066\"},\n+    {file = \"rpds_py-0.10.6-cp311-cp311-musllinux_1_2_x86_64.whl\", hash = \"sha256:f4e56860a5af16a0fcfa070a0a20c42fbb2012eed1eb5ceeddcc7f8079214281\"},\n+    {file = \"rpds_py-0.10.6-cp311-none-win32.whl\", hash = \"sha256:0774a46b38e70fdde0c6ded8d6d73115a7c39d7839a164cc833f170bbf539116\"},\n+    {file = \"rpds_py-0.10.6-cp311-none-win_amd64.whl\", hash = \"sha256:4a5ee600477b918ab345209eddafde9f91c0acd931f3776369585a1c55b04c57\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-macosx_10_7_x86_64.whl\", hash = \"sha256:5ee97c683eaface61d38ec9a489e353d36444cdebb128a27fe486a291647aff6\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:0713631d6e2d6c316c2f7b9320a34f44abb644fc487b77161d1724d883662e31\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:b5a53f5998b4bbff1cb2e967e66ab2addc67326a274567697379dd1e326bded7\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:6a555ae3d2e61118a9d3e549737bb4a56ff0cec88a22bd1dfcad5b4e04759175\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:945eb4b6bb8144909b203a88a35e0a03d22b57aefb06c9b26c6e16d72e5eb0f0\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:52c215eb46307c25f9fd2771cac8135d14b11a92ae48d17968eda5aa9aaf5071\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:c1b3cd23d905589cb205710b3988fc8f46d4a198cf12862887b09d7aaa6bf9b9\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:64ccc28683666672d7c166ed465c09cee36e306c156e787acef3c0c62f90da5a\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-musllinux_1_2_aarch64.whl\", hash = \"sha256:516a611a2de12fbea70c78271e558f725c660ce38e0006f75139ba337d56b1f6\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-musllinux_1_2_i686.whl\", hash = \"sha256:9ff93d3aedef11f9c4540cf347f8bb135dd9323a2fc705633d83210d464c579d\"},\n+    {file = \"rpds_py-0.10.6-cp312-cp312-musllinux_1_2_x86_64.whl\", hash = \"sha256:d858532212f0650be12b6042ff4378dc2efbb7792a286bee4489eaa7ba010586\"},\n+    {file = \"rpds_py-0.10.6-cp312-none-win32.whl\", hash = \"sha256:3c4eff26eddac49d52697a98ea01b0246e44ca82ab09354e94aae8823e8bda02\"},\n+    {file = \"rpds_py-0.10.6-cp312-none-win_amd64.whl\", hash = \"sha256:150eec465dbc9cbca943c8e557a21afdcf9bab8aaabf386c44b794c2f94143d2\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-macosx_10_7_x86_64.whl\", hash = \"sha256:cf693eb4a08eccc1a1b636e4392322582db2a47470d52e824b25eca7a3977b53\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:4134aa2342f9b2ab6c33d5c172e40f9ef802c61bb9ca30d21782f6e035ed0043\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:e782379c2028a3611285a795b89b99a52722946d19fc06f002f8b53e3ea26ea9\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:2f6da6d842195fddc1cd34c3da8a40f6e99e4a113918faa5e60bf132f917c247\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:b4a9fe992887ac68256c930a2011255bae0bf5ec837475bc6f7edd7c8dfa254e\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:b788276a3c114e9f51e257f2a6f544c32c02dab4aa7a5816b96444e3f9ffc336\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:caa1afc70a02645809c744eefb7d6ee8fef7e2fad170ffdeacca267fd2674f13\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:bddd4f91eede9ca5275e70479ed3656e76c8cdaaa1b354e544cbcf94c6fc8ac4\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-musllinux_1_2_aarch64.whl\", hash = \"sha256:775049dfa63fb58293990fc59473e659fcafd953bba1d00fc5f0631a8fd61977\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-musllinux_1_2_i686.whl\", hash = \"sha256:c6c45a2d2b68c51fe3d9352733fe048291e483376c94f7723458cfd7b473136b\"},\n+    {file = \"rpds_py-0.10.6-cp38-cp38-musllinux_1_2_x86_64.whl\", hash = \"sha256:0699ab6b8c98df998c3eacf51a3b25864ca93dab157abe358af46dc95ecd9801\"},\n+    {file = \"rpds_py-0.10.6-cp38-none-win32.whl\", hash = \"sha256:ebdab79f42c5961682654b851f3f0fc68e6cc7cd8727c2ac4ffff955154123c1\"},\n+    {file = \"rpds_py-0.10.6-cp38-none-win_amd64.whl\", hash = \"sha256:24656dc36f866c33856baa3ab309da0b6a60f37d25d14be916bd3e79d9f3afcf\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-macosx_10_7_x86_64.whl\", hash = \"sha256:0898173249141ee99ffcd45e3829abe7bcee47d941af7434ccbf97717df020e5\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:9e9184fa6c52a74a5521e3e87badbf9692549c0fcced47443585876fcc47e469\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:5752b761902cd15073a527b51de76bbae63d938dc7c5c4ad1e7d8df10e765138\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:99a57006b4ec39dbfb3ed67e5b27192792ffb0553206a107e4aadb39c5004cd5\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:09586f51a215d17efdb3a5f090d7cbf1633b7f3708f60a044757a5d48a83b393\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:e225a6a14ecf44499aadea165299092ab0cba918bb9ccd9304eab1138844490b\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:b2039f8d545f20c4e52713eea51a275e62153ee96c8035a32b2abb772b6fc9e5\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:34ad87a831940521d462ac11f1774edf867c34172010f5390b2f06b85dcc6014\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-musllinux_1_2_aarch64.whl\", hash = \"sha256:dcdc88b6b01015da066da3fb76545e8bb9a6880a5ebf89e0f0b2e3ca557b3ab7\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-musllinux_1_2_i686.whl\", hash = \"sha256:25860ed5c4e7f5e10c496ea78af46ae8d8468e0be745bd233bab9ca99bfd2647\"},\n+    {file = \"rpds_py-0.10.6-cp39-cp39-musllinux_1_2_x86_64.whl\", hash = \"sha256:7854a207ef77319ec457c1eb79c361b48807d252d94348305db4f4b62f40f7f3\"},\n+    {file = \"rpds_py-0.10.6-cp39-none-win32.whl\", hash = \"sha256:e6fcc026a3f27c1282c7ed24b7fcac82cdd70a0e84cc848c0841a3ab1e3dea2d\"},\n+    {file = \"rpds_py-0.10.6-cp39-none-win_amd64.whl\", hash = \"sha256:e98c4c07ee4c4b3acf787e91b27688409d918212dfd34c872201273fdd5a0e18\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-macosx_10_7_x86_64.whl\", hash = \"sha256:68fe9199184c18d997d2e4293b34327c0009a78599ce703e15cd9a0f47349bba\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:3339eca941568ed52d9ad0f1b8eb9fe0958fa245381747cecf2e9a78a5539c42\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:a360cfd0881d36c6dc271992ce1eda65dba5e9368575663de993eeb4523d895f\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:031f76fc87644a234883b51145e43985aa2d0c19b063e91d44379cd2786144f8\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:1f36a9d751f86455dc5278517e8b65580eeee37d61606183897f122c9e51cef3\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:052a832078943d2b2627aea0d19381f607fe331cc0eb5df01991268253af8417\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:023574366002bf1bd751ebaf3e580aef4a468b3d3c216d2f3f7e16fdabd885ed\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:defa2c0c68734f4a82028c26bcc85e6b92cced99866af118cd6a89b734ad8e0d\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-musllinux_1_2_aarch64.whl\", hash = \"sha256:879fb24304ead6b62dbe5034e7b644b71def53c70e19363f3c3be2705c17a3b4\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-musllinux_1_2_i686.whl\", hash = \"sha256:53c43e10d398e365da2d4cc0bcaf0854b79b4c50ee9689652cdc72948e86f487\"},\n+    {file = \"rpds_py-0.10.6-pp310-pypy310_pp73-musllinux_1_2_x86_64.whl\", hash = \"sha256:3777cc9dea0e6c464e4b24760664bd8831738cc582c1d8aacf1c3f546bef3f65\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-macosx_10_7_x86_64.whl\", hash = \"sha256:40578a6469e5d1df71b006936ce95804edb5df47b520c69cf5af264d462f2cbb\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:cf71343646756a072b85f228d35b1d7407da1669a3de3cf47f8bbafe0c8183a4\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:10f32b53f424fc75ff7b713b2edb286fdbfc94bf16317890260a81c2c00385dc\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:81de24a1c51cfb32e1fbf018ab0bdbc79c04c035986526f76c33e3f9e0f3356c\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:ac17044876e64a8ea20ab132080ddc73b895b4abe9976e263b0e30ee5be7b9c2\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:5e8a78bd4879bff82daef48c14d5d4057f6856149094848c3ed0ecaf49f5aec2\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:78ca33811e1d95cac8c2e49cb86c0fb71f4d8409d8cbea0cb495b6dbddb30a55\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:c63c3ef43f0b3fb00571cff6c3967cc261c0ebd14a0a134a12e83bdb8f49f21f\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-musllinux_1_2_aarch64.whl\", hash = \"sha256:7fde6d0e00b2fd0dbbb40c0eeec463ef147819f23725eda58105ba9ca48744f4\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-musllinux_1_2_i686.whl\", hash = \"sha256:79edd779cfc46b2e15b0830eecd8b4b93f1a96649bcb502453df471a54ce7977\"},\n+    {file = \"rpds_py-0.10.6-pp38-pypy38_pp73-musllinux_1_2_x86_64.whl\", hash = \"sha256:9164ec8010327ab9af931d7ccd12ab8d8b5dc2f4c6a16cbdd9d087861eaaefa1\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-macosx_10_7_x86_64.whl\", hash = \"sha256:d29ddefeab1791e3c751e0189d5f4b3dbc0bbe033b06e9c333dca1f99e1d523e\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-macosx_11_0_arm64.whl\", hash = \"sha256:30adb75ecd7c2a52f5e76af50644b3e0b5ba036321c390b8e7ec1bb2a16dd43c\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:dd609fafdcdde6e67a139898196698af37438b035b25ad63704fd9097d9a3482\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-manylinux_2_17_armv7l.manylinux2014_armv7l.whl\", hash = \"sha256:6eef672de005736a6efd565577101277db6057f65640a813de6c2707dc69f396\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl\", hash = \"sha256:6cf4393c7b41abbf07c88eb83e8af5013606b1cdb7f6bc96b1b3536b53a574b8\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-manylinux_2_17_s390x.manylinux2014_s390x.whl\", hash = \"sha256:ad857f42831e5b8d41a32437f88d86ead6c191455a3499c4b6d15e007936d4cf\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:1d7360573f1e046cb3b0dceeb8864025aa78d98be4bb69f067ec1c40a9e2d9df\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-manylinux_2_5_i686.manylinux1_i686.whl\", hash = \"sha256:d08f63561c8a695afec4975fae445245386d645e3e446e6f260e81663bfd2e38\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-musllinux_1_2_aarch64.whl\", hash = \"sha256:f0f17f2ce0f3529177a5fff5525204fad7b43dd437d017dd0317f2746773443d\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-musllinux_1_2_i686.whl\", hash = \"sha256:442626328600bde1d09dc3bb00434f5374948838ce75c41a52152615689f9403\"},\n+    {file = \"rpds_py-0.10.6-pp39-pypy39_pp73-musllinux_1_2_x86_64.whl\", hash = \"sha256:e9616f5bd2595f7f4a04b67039d890348ab826e943a9bfdbe4938d0eba606971\"},\n+    {file = \"rpds_py-0.10.6.tar.gz\", hash = \"sha256:4ce5a708d65a8dbf3748d2474b580d606b1b9f91b5c6ab2a316e0b0cf7a4ba50\"},\n+]\n+\n+[[package]]\n+name = \"ruamel-yaml\"\n+version = \"0.17.40\"\n+description = \"ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order\"\n+optional = false\n+python-versions = \">=3\"\n+files = [\n+    {file = \"ruamel.yaml-0.17.40-py3-none-any.whl\", hash = \"sha256:b16b6c3816dff0a93dca12acf5e70afd089fa5acb80604afd1ffa8b465b7722c\"},\n+    {file = \"ruamel.yaml-0.17.40.tar.gz\", hash = \"sha256:6024b986f06765d482b5b07e086cc4b4cd05dd22ddcbc758fa23d54873cf313d\"},\n+]\n+\n+[package.dependencies]\n+\"ruamel.yaml.clib\" = {version = \">=0.2.7\", markers = \"platform_python_implementation == \\\"CPython\\\" and python_version < \\\"3.13\\\"\"}\n+\n+[package.extras]\n+docs = [\"mercurial (>5.7)\", \"ryd\"]\n+jinja2 = [\"ruamel.yaml.jinja2 (>=0.2)\"]\n+\n+[[package]]\n+name = \"ruamel-yaml-clib\"\n+version = \"0.2.8\"\n+description = \"C version of reader, parser and emitter for ruamel.yaml derived from libyaml\"\n+optional = false\n+python-versions = \">=3.6\"\n+files = [\n+    {file = \"ruamel.yaml.clib-0.2.8-cp310-cp310-macosx_10_9_universal2.whl\", hash = \"sha256:b42169467c42b692c19cf539c38d4602069d8c1505e97b86387fcf7afb766e1d\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp310-cp310-macosx_13_0_arm64.whl\", hash = \"sha256:07238db9cbdf8fc1e9de2489a4f68474e70dffcb32232db7c08fa61ca0c7c462\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp310-cp310-manylinux2014_aarch64.whl\", hash = \"sha256:d92f81886165cb14d7b067ef37e142256f1c6a90a65cd156b063a43da1708cfd\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_24_x86_64.whl\", hash = \"sha256:fff3573c2db359f091e1589c3d7c5fc2f86f5bdb6f24252c2d8e539d4e45f412\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp310-cp310-win32.whl\", hash = \"sha256:c69212f63169ec1cfc9bb44723bf2917cbbd8f6191a00ef3410f5a7fe300722d\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp310-cp310-win_amd64.whl\", hash = \"sha256:cabddb8d8ead485e255fe80429f833172b4cadf99274db39abc080e068cbcc31\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp311-cp311-macosx_10_9_universal2.whl\", hash = \"sha256:bef08cd86169d9eafb3ccb0a39edb11d8e25f3dae2b28f5c52fd997521133069\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp311-cp311-macosx_13_0_arm64.whl\", hash = \"sha256:b16420e621d26fdfa949a8b4b47ade8810c56002f5389970db4ddda51dbff248\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp311-cp311-manylinux2014_aarch64.whl\", hash = \"sha256:b5edda50e5e9e15e54a6a8a0070302b00c518a9d32accc2346ad6c984aacd279\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_24_x86_64.whl\", hash = \"sha256:25c515e350e5b739842fc3228d662413ef28f295791af5e5110b543cf0b57d9b\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp311-cp311-win32.whl\", hash = \"sha256:53a300ed9cea38cf5a2a9b069058137c2ca1ce658a874b79baceb8f892f915a7\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp311-cp311-win_amd64.whl\", hash = \"sha256:c2a72e9109ea74e511e29032f3b670835f8a59bbdc9ce692c5b4ed91ccf1eedb\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp312-cp312-macosx_10_9_universal2.whl\", hash = \"sha256:ebc06178e8821efc9692ea7544aa5644217358490145629914d8020042c24aa1\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp312-cp312-macosx_13_0_arm64.whl\", hash = \"sha256:edaef1c1200c4b4cb914583150dcaa3bc30e592e907c01117c08b13a07255ec2\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp312-cp312-manylinux2014_aarch64.whl\", hash = \"sha256:7048c338b6c86627afb27faecf418768acb6331fc24cfa56c93e8c9780f815fa\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_28_x86_64.whl\", hash = \"sha256:d176b57452ab5b7028ac47e7b3cf644bcfdc8cacfecf7e71759f7f51a59e5c92\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp36-cp36m-manylinux_2_5_x86_64.manylinux1_x86_64.whl\", hash = \"sha256:a5aa27bad2bb83670b71683aae140a1f52b0857a2deff56ad3f6c13a017a26ed\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp37-cp37m-macosx_10_9_x86_64.whl\", hash = \"sha256:c58ecd827313af6864893e7af0a3bb85fd529f862b6adbefe14643947cfe2942\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp37-cp37m-macosx_12_0_arm64.whl\", hash = \"sha256:f481f16baec5290e45aebdc2a5168ebc6d35189ae6fea7a58787613a25f6e875\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp37-cp37m-manylinux2014_aarch64.whl\", hash = \"sha256:3fcc54cb0c8b811ff66082de1680b4b14cf8a81dce0d4fbf665c2265a81e07a1\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp37-cp37m-manylinux_2_5_x86_64.manylinux1_x86_64.whl\", hash = \"sha256:7f67a1ee819dc4562d444bbafb135832b0b909f81cc90f7aa00260968c9ca1b3\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp37-cp37m-win32.whl\", hash = \"sha256:75e1ed13e1f9de23c5607fe6bd1aeaae21e523b32d83bb33918245361e9cc51b\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp37-cp37m-win_amd64.whl\", hash = \"sha256:3f215c5daf6a9d7bbed4a0a4f760f3113b10e82ff4c5c44bec20a68c8014f675\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:1b617618914cb00bf5c34d4357c37aa15183fa229b24767259657746c9077615\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp38-cp38-macosx_12_0_arm64.whl\", hash = \"sha256:a6a9ffd280b71ad062eae53ac1659ad86a17f59a0fdc7699fd9be40525153337\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp38-cp38-manylinux2014_aarch64.whl\", hash = \"sha256:665f58bfd29b167039f714c6998178d27ccd83984084c286110ef26b230f259f\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.whl\", hash = \"sha256:700e4ebb569e59e16a976857c8798aee258dceac7c7d6b50cab63e080058df91\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp38-cp38-win32.whl\", hash = \"sha256:955eae71ac26c1ab35924203fda6220f84dce57d6d7884f189743e2abe3a9fbe\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp38-cp38-win_amd64.whl\", hash = \"sha256:56f4252222c067b4ce51ae12cbac231bce32aee1d33fbfc9d17e5b8d6966c312\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:03d1162b6d1df1caa3a4bd27aa51ce17c9afc2046c31b0ad60a0a96ec22f8001\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp39-cp39-macosx_12_0_arm64.whl\", hash = \"sha256:bba64af9fa9cebe325a62fa398760f5c7206b215201b0ec825005f1b18b9bccf\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp39-cp39-manylinux2014_aarch64.whl\", hash = \"sha256:9eb5dee2772b0f704ca2e45b1713e4e5198c18f515b52743576d196348f374d3\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.whl\", hash = \"sha256:da09ad1c359a728e112d60116f626cc9f29730ff3e0e7db72b9a2dbc2e4beed5\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp39-cp39-win32.whl\", hash = \"sha256:84b554931e932c46f94ab306913ad7e11bba988104c5cff26d90d03f68258cd5\"},\n+    {file = \"ruamel.yaml.clib-0.2.8-cp39-cp39-win_amd64.whl\", hash = \"sha256:25ac8c08322002b06fa1d49d1646181f0b2c72f5cbc15a85e80b4c30a544bb15\"},\n+    {file = \"ruamel.yaml.clib-0.2.8.tar.gz\", hash = \"sha256:beb2e0404003de9a4cab9753a8805a8fe9320ee6673136ed7f04255fe60bb512\"},\n+]\n+\n+[[package]]\n+name = \"semgrep\"\n+version = \"1.45.0\"\n+description = \"Lightweight static analysis for many languages. Find bug variants with patterns that look like source code.\"\n+optional = false\n+python-versions = \">=3.7\"\n+files = [\n+    {file = \"semgrep-1.45.0-cp37.cp38.cp39.cp310.cp311.py37.py38.py39.py310.py311-none-any.whl\", hash = \"sha256:b466501971f9491ab089d01e29dec6fab404b5f99e1279c888d4a8e6aac3b443\"},\n+    {file = \"semgrep-1.45.0-cp37.cp38.cp39.cp310.cp311.py37.py38.py39.py310.py311-none-macosx_10_14_x86_64.whl\", hash = \"sha256:4f2bc7482746d3383d909d46a0d878184580eac1b2cafe65c4192f2d226d3df5\"},\n+    {file = \"semgrep-1.45.0-cp37.cp38.cp39.cp310.cp311.py37.py38.py39.py310.py311-none-macosx_11_0_arm64.whl\", hash = \"sha256:7bac4ac8c613ba9851cce28537117636f7356489324cb55503a6f90be51d6e91\"},\n+    {file = \"semgrep-1.45.0-cp37.cp38.cp39.cp310.cp311.py37.py38.py39.py310.py311-none-musllinux_1_0_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:519aa0752d206b2442895be6ba279d4826783f1db0b994f87a5855bdce310078\"},\n+    {file = \"semgrep-1.45.0.tar.gz\", hash = \"sha256:f2efad4236a0cf8b397e8f367b49d77a5ea0ec92de518f158247160041dbd980\"},\n+]\n+\n+[package.dependencies]\n+attrs = \">=21.3\"\n+boltons = \">=21.0,<22.0\"\n+click = \">=8.1,<9.0\"\n+click-option-group = \">=0.5,<1.0\"\n+colorama = \">=0.4.0,<0.5.0\"\n+defusedxml = \">=0.7.1,<0.8.0\"\n+glom = \">=22.1,<23.0\"\n+jsonschema = \">=4.6,<5.0\"\n+packaging = \">=21.0\"\n+peewee = \">=3.14,<4.0\"\n+python-lsp-jsonrpc = \">=1.0.0,<1.1.0\"\n+requests = \">=2.22,<3.0\"\n+rich = \">=12.6.0\"\n+\"ruamel.yaml\" = \">=0.16.0,<0.18\"\n+tomli = \">=2.0.1,<2.1.0\"\n+typing-extensions = \">=4.2,<5.0\"\n+urllib3 = \">=1.26,<2.0\"\n+wcmatch = \">=8.3,<9.0\"\n+\n+[package.extras]\n+experiments = [\"jsonnet (>=0.18,<1.0)\"]\n+\n [[package]]\n name = \"setuptools\"\n version = \"68.2.2\"\n@@ -2246,22 +2737,91 @@ files = [\n     {file = \"typing_extensions-4.8.0.tar.gz\", hash = \"sha256:df8e4339e9cb77357558cbdbceca33c303714cf861d1eef15e1070055ae8b7ef\"},\n ]\n \n+[[package]]\n+name = \"ujson\"\n+version = \"5.8.0\"\n+description = \"Ultra fast JSON encoder and decoder for Python\"\n+optional = false\n+python-versions = \">=3.8\"\n+files = [\n+    {file = \"ujson-5.8.0-cp310-cp310-macosx_10_9_x86_64.whl\", hash = \"sha256:f4511560d75b15ecb367eef561554959b9d49b6ec3b8d5634212f9fed74a6df1\"},\n+    {file = \"ujson-5.8.0-cp310-cp310-macosx_11_0_arm64.whl\", hash = \"sha256:9399eaa5d1931a0ead49dce3ffacbea63f3177978588b956036bfe53cdf6af75\"},\n+    {file = \"ujson-5.8.0-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:c4e7bb7eba0e1963f8b768f9c458ecb193e5bf6977090182e2b4f4408f35ac76\"},\n+    {file = \"ujson-5.8.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:40931d7c08c4ce99adc4b409ddb1bbb01635a950e81239c2382cfe24251b127a\"},\n+    {file = \"ujson-5.8.0-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:d53039d39de65360e924b511c7ca1a67b0975c34c015dd468fca492b11caa8f7\"},\n+    {file = \"ujson-5.8.0-cp310-cp310-musllinux_1_1_aarch64.whl\", hash = \"sha256:bdf04c6af3852161be9613e458a1fb67327910391de8ffedb8332e60800147a2\"},\n+    {file = \"ujson-5.8.0-cp310-cp310-musllinux_1_1_i686.whl\", hash = \"sha256:a70f776bda2e5072a086c02792c7863ba5833d565189e09fabbd04c8b4c3abba\"},\n+    {file = \"ujson-5.8.0-cp310-cp310-musllinux_1_1_x86_64.whl\", hash = \"sha256:f26629ac531d712f93192c233a74888bc8b8212558bd7d04c349125f10199fcf\"},\n+    {file = \"ujson-5.8.0-cp310-cp310-win32.whl\", hash = \"sha256:7ecc33b107ae88405aebdb8d82c13d6944be2331ebb04399134c03171509371a\"},\n+    {file = \"ujson-5.8.0-cp310-cp310-win_amd64.whl\", hash = \"sha256:3b27a8da7a080add559a3b73ec9ebd52e82cc4419f7c6fb7266e62439a055ed0\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-macosx_10_9_x86_64.whl\", hash = \"sha256:193349a998cd821483a25f5df30b44e8f495423840ee11b3b28df092ddfd0f7f\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-macosx_11_0_arm64.whl\", hash = \"sha256:4ddeabbc78b2aed531f167d1e70387b151900bc856d61e9325fcdfefb2a51ad8\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:5ce24909a9c25062e60653073dd6d5e6ec9d6ad7ed6e0069450d5b673c854405\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:27a2a3c7620ebe43641e926a1062bc04e92dbe90d3501687957d71b4bdddaec4\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:2b852bdf920fe9f84e2a2c210cc45f1b64f763b4f7d01468b33f7791698e455e\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-musllinux_1_1_aarch64.whl\", hash = \"sha256:20768961a6a706170497129960762ded9c89fb1c10db2989c56956b162e2a8a3\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-musllinux_1_1_i686.whl\", hash = \"sha256:e0147d41e9fb5cd174207c4a2895c5e24813204499fd0839951d4c8784a23bf5\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-musllinux_1_1_x86_64.whl\", hash = \"sha256:e3673053b036fd161ae7a5a33358ccae6793ee89fd499000204676baafd7b3aa\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-win32.whl\", hash = \"sha256:a89cf3cd8bf33a37600431b7024a7ccf499db25f9f0b332947fbc79043aad879\"},\n+    {file = \"ujson-5.8.0-cp311-cp311-win_amd64.whl\", hash = \"sha256:3659deec9ab9eb19e8646932bfe6fe22730757c4addbe9d7d5544e879dc1b721\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-macosx_10_9_x86_64.whl\", hash = \"sha256:102bf31c56f59538cccdfec45649780ae00657e86247c07edac434cb14d5388c\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-macosx_11_0_arm64.whl\", hash = \"sha256:299a312c3e85edee1178cb6453645217ba23b4e3186412677fa48e9a7f986de6\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:f2e385a7679b9088d7bc43a64811a7713cc7c33d032d020f757c54e7d41931ae\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:ad24ec130855d4430a682c7a60ca0bc158f8253ec81feed4073801f6b6cb681b\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:16fde596d5e45bdf0d7de615346a102510ac8c405098e5595625015b0d4b5296\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-musllinux_1_1_aarch64.whl\", hash = \"sha256:6d230d870d1ce03df915e694dcfa3f4e8714369cce2346686dbe0bc8e3f135e7\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-musllinux_1_1_i686.whl\", hash = \"sha256:9571de0c53db5cbc265945e08f093f093af2c5a11e14772c72d8e37fceeedd08\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-musllinux_1_1_x86_64.whl\", hash = \"sha256:7cba16b26efe774c096a5e822e4f27097b7c81ed6fb5264a2b3f5fd8784bab30\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-win32.whl\", hash = \"sha256:48c7d373ff22366eecfa36a52b9b55b0ee5bd44c2b50e16084aa88b9de038916\"},\n+    {file = \"ujson-5.8.0-cp312-cp312-win_amd64.whl\", hash = \"sha256:5ac97b1e182d81cf395ded620528c59f4177eee024b4b39a50cdd7b720fdeec6\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-macosx_10_9_x86_64.whl\", hash = \"sha256:2a64cc32bb4a436e5813b83f5aab0889927e5ea1788bf99b930fad853c5625cb\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-macosx_11_0_arm64.whl\", hash = \"sha256:e54578fa8838ddc722539a752adfce9372474114f8c127bb316db5392d942f8b\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:9721cd112b5e4687cb4ade12a7b8af8b048d4991227ae8066d9c4b3a6642a582\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:9d9707e5aacf63fb919f6237d6490c4e0244c7f8d3dc2a0f84d7dec5db7cb54c\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:0be81bae295f65a6896b0c9030b55a106fb2dec69ef877253a87bc7c9c5308f7\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-musllinux_1_1_aarch64.whl\", hash = \"sha256:ae7f4725c344bf437e9b881019c558416fe84ad9c6b67426416c131ad577df67\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-musllinux_1_1_i686.whl\", hash = \"sha256:9ab282d67ef3097105552bf151438b551cc4bedb3f24d80fada830f2e132aeb9\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-musllinux_1_1_x86_64.whl\", hash = \"sha256:94c7bd9880fa33fcf7f6d7f4cc032e2371adee3c5dba2922b918987141d1bf07\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-win32.whl\", hash = \"sha256:bf5737dbcfe0fa0ac8fa599eceafae86b376492c8f1e4b84e3adf765f03fb564\"},\n+    {file = \"ujson-5.8.0-cp38-cp38-win_amd64.whl\", hash = \"sha256:11da6bed916f9bfacf13f4fc6a9594abd62b2bb115acfb17a77b0f03bee4cfd5\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-macosx_10_9_x86_64.whl\", hash = \"sha256:69b3104a2603bab510497ceabc186ba40fef38ec731c0ccaa662e01ff94a985c\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-macosx_11_0_arm64.whl\", hash = \"sha256:9249fdefeb021e00b46025e77feed89cd91ffe9b3a49415239103fc1d5d9c29a\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:2873d196725a8193f56dde527b322c4bc79ed97cd60f1d087826ac3290cf9207\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:6a4dafa9010c366589f55afb0fd67084acd8added1a51251008f9ff2c3e44042\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:7a42baa647a50fa8bed53d4e242be61023bd37b93577f27f90ffe521ac9dc7a3\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-musllinux_1_1_aarch64.whl\", hash = \"sha256:f3554eaadffe416c6f543af442066afa6549edbc34fe6a7719818c3e72ebfe95\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-musllinux_1_1_i686.whl\", hash = \"sha256:fb87decf38cc82bcdea1d7511e73629e651bdec3a43ab40985167ab8449b769c\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-musllinux_1_1_x86_64.whl\", hash = \"sha256:407d60eb942c318482bbfb1e66be093308bb11617d41c613e33b4ce5be789adc\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-win32.whl\", hash = \"sha256:0fe1b7edaf560ca6ab023f81cbeaf9946a240876a993b8c5a21a1c539171d903\"},\n+    {file = \"ujson-5.8.0-cp39-cp39-win_amd64.whl\", hash = \"sha256:3f9b63530a5392eb687baff3989d0fb5f45194ae5b1ca8276282fb647f8dcdb3\"},\n+    {file = \"ujson-5.8.0-pp38-pypy38_pp73-macosx_10_9_x86_64.whl\", hash = \"sha256:efeddf950fb15a832376c0c01d8d7713479fbeceaed1eaecb2665aa62c305aec\"},\n+    {file = \"ujson-5.8.0-pp38-pypy38_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:7d8283ac5d03e65f488530c43d6610134309085b71db4f675e9cf5dff96a8282\"},\n+    {file = \"ujson-5.8.0-pp38-pypy38_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:eb0142f6f10f57598655340a3b2c70ed4646cbe674191da195eb0985a9813b83\"},\n+    {file = \"ujson-5.8.0-pp38-pypy38_pp73-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:07d459aca895eb17eb463b00441986b021b9312c6c8cc1d06880925c7f51009c\"},\n+    {file = \"ujson-5.8.0-pp38-pypy38_pp73-win_amd64.whl\", hash = \"sha256:d524a8c15cfc863705991d70bbec998456a42c405c291d0f84a74ad7f35c5109\"},\n+    {file = \"ujson-5.8.0-pp39-pypy39_pp73-macosx_10_9_x86_64.whl\", hash = \"sha256:d6f84a7a175c75beecde53a624881ff618e9433045a69fcfb5e154b73cdaa377\"},\n+    {file = \"ujson-5.8.0-pp39-pypy39_pp73-manylinux_2_17_aarch64.manylinux2014_aarch64.whl\", hash = \"sha256:b748797131ac7b29826d1524db1cc366d2722ab7afacc2ce1287cdafccddbf1f\"},\n+    {file = \"ujson-5.8.0-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl\", hash = \"sha256:2e72ba76313d48a1a3a42e7dc9d1db32ea93fac782ad8dde6f8b13e35c229130\"},\n+    {file = \"ujson-5.8.0-pp39-pypy39_pp73-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl\", hash = \"sha256:f504117a39cb98abba4153bf0b46b4954cc5d62f6351a14660201500ba31fe7f\"},\n+    {file = \"ujson-5.8.0-pp39-pypy39_pp73-win_amd64.whl\", hash = \"sha256:a8c91b6f4bf23f274af9002b128d133b735141e867109487d17e344d38b87d94\"},\n+    {file = \"ujson-5.8.0.tar.gz\", hash = \"sha256:78e318def4ade898a461b3d92a79f9441e7e0e4d2ad5419abed4336d702c7425\"},\n+]\n+\n [[package]]\n name = \"urllib3\"\n-version = \"2.0.7\"\n+version = \"1.26.18\"\n description = \"HTTP library with thread-safe connection pooling, file post, and more.\"\n optional = false\n-python-versions = \">=3.7\"\n+python-versions = \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*\"\n files = [\n-    {file = \"urllib3-2.0.7-py3-none-any.whl\", hash = \"sha256:fdb6d215c776278489906c2f8916e6e7d4f5a9b602ccbcfdf7f016fc8da0596e\"},\n-    {file = \"urllib3-2.0.7.tar.gz\", hash = \"sha256:c97dfde1f7bd43a71c8d2a58e369e9b2bf692d1334ea9f9cae55add7d0dd0f84\"},\n+    {file = \"urllib3-1.26.18-py2.py3-none-any.whl\", hash = \"sha256:34b97092d7e0a3a8cf7cd10e386f401b3737364026c45e622aa02903dffe0f07\"},\n+    {file = \"urllib3-1.26.18.tar.gz\", hash = \"sha256:f8ecc1bba5667413457c529ab955bf8c67b45db799d159066261719e328580a0\"},\n ]\n \n [package.extras]\n-brotli = [\"brotli (>=1.0.9)\", \"brotlicffi (>=0.8.0)\"]\n-secure = [\"certifi\", \"cryptography (>=1.9)\", \"idna (>=2.0.0)\", \"pyopenssl (>=17.1.0)\", \"urllib3-secure-extra\"]\n-socks = [\"pysocks (>=1.5.6,!=1.5.7,<2.0)\"]\n-zstd = [\"zstandard (>=0.18.0)\"]\n+brotli = [\"brotli (==1.0.9)\", \"brotli (>=1.0.9)\", \"brotlicffi (>=0.8.0)\", \"brotlipy (>=0.6.0)\"]\n+secure = [\"certifi\", \"cryptography (>=1.3.4)\", \"idna (>=2.0.0)\", \"ipaddress\", \"pyOpenSSL (>=0.14)\", \"urllib3-secure-extra\"]\n+socks = [\"PySocks (>=1.5.6,!=1.5.7,<2.0)\"]\n \n [[package]]\n name = \"uvicorn\"\n\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Great effort on this PR! The functionality to use containers is impressive and can enhance security for running LLMs. However, there were several issues with local runs, particularly around directory permissions and container management. Your approach to bind mounts needs reassessment; consider simplifying the setup to avoid persistent errors. The inclusion of unrelated files also clutters the scope. Let's focus on merging this MVP version to facilitate easier future improvements while tidying up these issues. Keep pushing forward!"
      }
    ],
    "token_estimation": 19598.5
  },
  {
    "index": 73,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/source_documents/state_of_the_union.txt b/source_documents/state_of_the_union.txt\ndeleted file mode 100644\nindex d50175de40..0000000000\n--- a/source_documents/state_of_the_union.txt\n+++ /dev/null\n@@ -1,723 +0,0 @@\n-Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.  \n-\n-Last year COVID-19 kept us apart. This year we are finally together again. \n-\n-Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. \n-\n-With a duty to one another to the American people to the Constitution. \n-\n-And with an unwavering resolve that freedom will always triumph over tyranny. \n-\n-Six days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. \n-\n-He thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. \n-\n-He met the Ukrainian people. \n-\n-From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world. \n-\n-Groups of citizens blocking tanks with their bodies. Everyone from students to retirees teachers turned soldiers defending their homeland. \n-\n-In this struggle as President Zelenskyy said in his speech to the European Parliament “Light will win over darkness.” The Ukrainian Ambassador to the United States is here tonight. \n-\n-Let each of us here tonight in this Chamber send an unmistakable signal to Ukraine and to the world. \n-\n-Please rise if you are able and show that, Yes, we the United States of America stand with the Ukrainian people. \n-\n-Throughout our history we’ve learned this lesson when dictators do not pay a price for their aggression they cause more chaos.   \n-\n-They keep moving.   \n-\n-And the costs and the threats to America and the world keep rising.   \n-\n-That’s why the NATO Alliance was created to secure peace and stability in Europe after World War 2. \n-\n-The United States is a member along with 29 other nations. \n-\n-It matters. American diplomacy matters. American resolve matters. \n-\n-Putin’s latest attack on Ukraine was premeditated and unprovoked. \n-\n-He rejected repeated efforts at diplomacy. \n-\n-He thought the West and NATO wouldn’t respond. And he thought he could divide us at home. Putin was wrong. We were ready.  Here is what we did.   \n-\n-We prepared extensively and carefully. \n-\n-We spent months building a coalition of other freedom-loving nations from Europe and the Americas to Asia and Africa to confront Putin. \n-\n-I spent countless hours unifying our European allies. We shared with the world in advance what we knew Putin was planning and precisely how he would try to falsely justify his aggression.  \n-\n-We countered Russia’s lies with truth.   \n-\n-And now that he has acted the free world is holding him accountable. \n-\n-Along with twenty-seven members of the European Union including France, Germany, Italy, as well as countries like the United Kingdom, Canada, Japan, Korea, Australia, New Zealand, and many others, even Switzerland. \n-\n-We are inflicting pain on Russia and supporting the people of Ukraine. Putin is now isolated from the world more than ever. \n-\n-Together with our allies –we are right now enforcing powerful economic sanctions. \n-\n-We are cutting off Russia’s largest banks from the international financial system.  \n-\n-Preventing Russia’s central bank from defending the Russian Ruble making Putin’s $630 Billion “war fund” worthless.   \n-\n-We are choking off Russia’s access to technology that will sap its economic strength and weaken its military for years to come.  \n-\n-Tonight I say to the Russian oligarchs and corrupt leaders who have bilked billions of dollars off this violent regime no more. \n-\n-The U.S. Department of Justice is assembling a dedicated task force to go after the crimes of Russian oligarchs.  \n-\n-We are joining with our European allies to find and seize your yachts your luxury apartments your private jets. We are coming for your ill-begotten gains. \n-\n-And tonight I am announcing that we will join our allies in closing off American air space to all Russian flights – further isolating Russia – and adding an additional squeeze –on their economy. The Ruble has lost 30% of its value. \n-\n-The Russian stock market has lost 40% of its value and trading remains suspended. Russia’s economy is reeling and Putin alone is to blame. \n-\n-Together with our allies we are providing support to the Ukrainians in their fight for freedom. Military assistance. Economic assistance. Humanitarian assistance. \n-\n-We are giving more than $1 Billion in direct assistance to Ukraine. \n-\n-And we will continue to aid the Ukrainian people as they defend their country and to help ease their suffering.  \n-\n-Let me be clear, our forces are not engaged and will not engage in conflict with Russian forces in Ukraine.  \n-\n-Our forces are not going to Europe to fight in Ukraine, but to defend our NATO Allies – in the event that Putin decides to keep moving west.  \n-\n-For that purpose we’ve mobilized American ground forces, air squadrons, and ship deployments to protect NATO countries including Poland, Romania, Latvia, Lithuania, and Estonia. \n-\n-As I have made crystal clear the United States and our Allies will defend every inch of territory of NATO countries with the full force of our collective power.  \n-\n-And we remain clear-eyed. The Ukrainians are fighting back with pure courage. But the next few days weeks, months, will be hard on them.  \n-\n-Putin has unleashed violence and chaos.  But while he may make gains on the battlefield – he will pay a continuing high price over the long run. \n-\n-And a proud Ukrainian people, who have known 30 years  of independence, have repeatedly shown that they will not tolerate anyone who tries to take their country backwards.  \n-\n-To all Americans, I will be honest with you, as I’ve always promised. A Russian dictator, invading a foreign country, has costs around the world. \n-\n-And I’m taking robust action to make sure the pain of our sanctions  is targeted at Russia’s economy. And I will use every tool at our disposal to protect American businesses and consumers. \n-\n-Tonight, I can announce that the United States has worked with 30 other countries to release 60 Million barrels of oil from reserves around the world.  \n-\n-America will lead that effort, releasing 30 Million barrels from our own Strategic Petroleum Reserve. And we stand ready to do more if necessary, unified with our allies.  \n-\n-These steps will help blunt gas prices here at home. And I know the news about what’s happening can seem alarming. \n-\n-But I want you to know that we are going to be okay. \n-\n-When the history of this era is written Putin’s war on Ukraine will have left Russia weaker and the rest of the world stronger. \n-\n-While it shouldn’t have taken something so terrible for people around the world to see what’s at stake now everyone sees it clearly. \n-\n-We see the unity among leaders of nations and a more unified Europe a more unified West. And we see unity among the people who are gathering in cities in large crowds around the world even in Russia to demonstrate their support for Ukraine.  \n-\n-In the battle between democracy and autocracy, democracies are rising to the moment, and the world is clearly choosing the side of peace and security. \n-\n-This is a real test. It’s going to take time. So let us continue to draw inspiration from the iron will of the Ukrainian people. \n-\n-To our fellow Ukrainian Americans who forge a deep bond that connects our two nations we stand with you. \n-\n-Putin may circle Kyiv with tanks, but he will never gain the hearts and souls of the Ukrainian people. \n-\n-He will never extinguish their love of freedom. He will never weaken the resolve of the free world. \n-\n-We meet tonight in an America that has lived through two of the hardest years this nation has ever faced. \n-\n-The pandemic has been punishing. \n-\n-And so many families are living paycheck to paycheck, struggling to keep up with the rising cost of food, gas, housing, and so much more. \n-\n-I understand. \n-\n-I remember when my Dad had to leave our home in Scranton, Pennsylvania to find work. I grew up in a family where if the price of food went up, you felt it. \n-\n-That’s why one of the first things I did as President was fight to pass the American Rescue Plan.  \n-\n-Because people were hurting. We needed to act, and we did. \n-\n-Few pieces of legislation have done more in a critical moment in our history to lift us out of crisis. \n-\n-It fueled our efforts to vaccinate the nation and combat COVID-19. It delivered immediate economic relief for tens of millions of Americans.  \n-\n-Helped put food on their table, keep a roof over their heads, and cut the cost of health insurance. \n-\n-And as my Dad used to say, it gave people a little breathing room. \n-\n-And unlike the $2 Trillion tax cut passed in the previous administration that benefitted the top 1% of Americans, the American Rescue Plan helped working people—and left no one behind. \n-\n-And it worked. It created jobs. Lots of jobs. \n-\n-In fact—our economy created over 6.5 Million new jobs just last year, more jobs created in one year  \n-than ever before in the history of America. \n-\n-Our economy grew at a rate of 5.7% last year, the strongest growth in nearly 40 years, the first step in bringing fundamental change to an economy that hasn’t worked for the working people of this nation for too long.  \n-\n-For the past 40 years we were told that if we gave tax breaks to those at the very top, the benefits would trickle down to everyone else. \n-\n-But that trickle-down theory led to weaker economic growth, lower wages, bigger deficits, and the widest gap between those at the top and everyone else in nearly a century. \n-\n-Vice President Harris and I ran for office with a new economic vision for America. \n-\n-Invest in America. Educate Americans. Grow the workforce. Build the economy from the bottom up  \n-and the middle out, not from the top down.  \n-\n-Because we know that when the middle class grows, the poor have a ladder up and the wealthy do very well. \n-\n-America used to have the best roads, bridges, and airports on Earth. \n-\n-Now our infrastructure is ranked 13th in the world. \n-\n-We won’t be able to compete for the jobs of the 21st Century if we don’t fix that. \n-\n-That’s why it was so important to pass the Bipartisan Infrastructure Law—the most sweeping investment to rebuild America in history. \n-\n-This was a bipartisan effort, and I want to thank the members of both parties who worked to make it happen. \n-\n-We’re done talking about infrastructure weeks. \n-\n-We’re going to have an infrastructure decade. \n-\n-It is going to transform America and put us on a path to win the economic competition of the 21st Century that we face with the rest of the world—particularly with China.  \n-\n-As I’ve told Xi Jinping, it is never a good bet to bet against the American people. \n-\n-We’ll create good jobs for millions of Americans, modernizing roads, airports, ports, and waterways all across America. \n-\n-And we’ll do it all to withstand the devastating effects of the climate crisis and promote environmental justice. \n-\n-We’ll build a national network of 500,000 electric vehicle charging stations, begin to replace poisonous lead pipes—so every child—and every American—has clean water to drink at home and at school, provide affordable high-speed internet for every American—urban, suburban, rural, and tribal communities. \n-\n-4,000 projects have already been announced. \n-\n-And tonight, I’m announcing that this year we will start fixing over 65,000 miles of highway and 1,500 bridges in disrepair. \n-\n-When we use taxpayer dollars to rebuild America – we are going to Buy American: buy American products to support American jobs. \n-\n-The federal government spends about $600 Billion a year to keep the country safe and secure. \n-\n-There’s been a law on the books for almost a century \n-to make sure taxpayers’ dollars support American jobs and businesses. \n-\n-Every Administration says they’ll do it, but we are actually doing it. \n-\n-We will buy American to make sure everything from the deck of an aircraft carrier to the steel on highway guardrails are made in America. \n-\n-But to compete for the best jobs of the future, we also need to level the playing field with China and other competitors. \n-\n-That’s why it is so important to pass the Bipartisan Innovation Act sitting in Congress that will make record investments in emerging technologies and American manufacturing. \n-\n-Let me give you one example of why it’s so important to pass it. \n-\n-If you travel 20 miles east of Columbus, Ohio, you’ll find 1,000 empty acres of land. \n-\n-It won’t look like much, but if you stop and look closely, you’ll see a “Field of dreams,” the ground on which America’s future will be built. \n-\n-This is where Intel, the American company that helped build Silicon Valley, is going to build its $20 billion semiconductor “mega site”. \n-\n-Up to eight state-of-the-art factories in one place. 10,000 new good-paying jobs. \n-\n-Some of the most sophisticated manufacturing in the world to make computer chips the size of a fingertip that power the world and our everyday lives. \n-\n-Smartphones. The Internet. Technology we have yet to invent. \n-\n-But that’s just the beginning. \n-\n-Intel’s CEO, Pat Gelsinger, who is here tonight, told me they are ready to increase their investment from  \n-$20 billion to $100 billion. \n-\n-That would be one of the biggest investments in manufacturing in American history. \n-\n-And all they’re waiting for is for you to pass this bill. \n-\n-So let’s not wait any longer. Send it to my desk. I’ll sign it.  \n-\n-And we will really take off. \n-\n-And Intel is not alone. \n-\n-There’s something happening in America. \n-\n-Just look around and you’ll see an amazing story. \n-\n-The rebirth of the pride that comes from stamping products “Made In America.” The revitalization of American manufacturing.   \n-\n-Companies are choosing to build new factories here, when just a few years ago, they would have built them overseas. \n-\n-That’s what is happening. Ford is investing $11 billion to build electric vehicles, creating 11,000 jobs across the country. \n-\n-GM is making the largest investment in its history—$7 billion to build electric vehicles, creating 4,000 jobs in Michigan. \n-\n-All told, we created 369,000 new manufacturing jobs in America just last year. \n-\n-Powered by people I’ve met like JoJo Burgess, from generations of union steelworkers from Pittsburgh, who’s here with us tonight. \n-\n-As Ohio Senator Sherrod Brown says, “It’s time to bury the label “Rust Belt.” \n-\n-It’s time. \n-\n-But with all the bright spots in our economy, record job growth and higher wages, too many families are struggling to keep up with the bills.  \n-\n-Inflation is robbing them of the gains they might otherwise feel. \n-\n-I get it. That’s why my top priority is getting prices under control. \n-\n-Look, our economy roared back faster than most predicted, but the pandemic meant that businesses had a hard time hiring enough workers to keep up production in their factories. \n-\n-The pandemic also disrupted global supply chains. \n-\n-When factories close, it takes longer to make goods and get them from the warehouse to the store, and prices go up. \n-\n-Look at cars. \n-\n-Last year, there weren’t enough semiconductors to make all the cars that people wanted to buy. \n-\n-And guess what, prices of automobiles went up. \n-\n-So—we have a choice. \n-\n-One way to fight inflation is to drive down wages and make Americans poorer.  \n-\n-I have a better plan to fight inflation. \n-\n-Lower your costs, not your wages. \n-\n-Make more cars and semiconductors in America. \n-\n-More infrastructure and innovation in America. \n-\n-More goods moving faster and cheaper in America. \n-\n-More jobs where you can earn a good living in America. \n-\n-And instead of relying on foreign supply chains, let’s make it in America. \n-\n-Economists call it “increasing the productive capacity of our economy.” \n-\n-I call it building a better America. \n-\n-My plan to fight inflation will lower your costs and lower the deficit. \n-\n-17 Nobel laureates in economics say my plan will ease long-term inflationary pressures. Top business leaders and most Americans support my plan. And here’s the plan: \n-\n-First – cut the cost of prescription drugs. Just look at insulin. One in ten Americans has diabetes. In Virginia, I met a 13-year-old boy named Joshua Davis.  \n-\n-He and his Dad both have Type 1 diabetes, which means they need insulin every day. Insulin costs about $10 a vial to make.  \n-\n-But drug companies charge families like Joshua and his Dad up to 30 times more. I spoke with Joshua’s mom. \n-\n-Imagine what it’s like to look at your child who needs insulin and have no idea how you’re going to pay for it.  \n-\n-What it does to your dignity, your ability to look your child in the eye, to be the parent you expect to be. \n-\n-Joshua is here with us tonight. Yesterday was his birthday. Happy birthday, buddy.  \n-\n-For Joshua, and for the 200,000 other young people with Type 1 diabetes, let’s cap the cost of insulin at $35 a month so everyone can afford it.  \n-\n-Drug companies will still do very well. And while we’re at it let Medicare negotiate lower prices for prescription drugs, like the VA already does. \n-\n-Look, the American Rescue Plan is helping millions of families on Affordable Care Act plans save $2,400 a year on their health care premiums. Let’s close the coverage gap and make those savings permanent. \n-\n-Second – cut energy costs for families an average of $500 a year by combatting climate change.  \n-\n-Let’s provide investments and tax credits to weatherize your homes and businesses to be energy efficient and you get a tax credit; double America’s clean energy production in solar, wind, and so much more;  lower the price of electric vehicles, saving you another $80 a month because you’ll never have to pay at the gas pump again. \n-\n-Third – cut the cost of child care. Many families pay up to $14,000 a year for child care per child.  \n-\n-Middle-class and working families shouldn’t have to pay more than 7% of their income for care of young children.  \n-\n-My plan will cut the cost in half for most families and help parents, including millions of women, who left the workforce during the pandemic because they couldn’t afford child care, to be able to get back to work. \n-\n-My plan doesn’t stop there. It also includes home and long-term care. More affordable housing. And Pre-K for every 3- and 4-year-old.  \n-\n-All of these will lower costs. \n-\n-And under my plan, nobody earning less than $400,000 a year will pay an additional penny in new taxes. Nobody.  \n-\n-The one thing all Americans agree on is that the tax system is not fair. We have to fix it.  \n-\n-I’m not looking to punish anyone. But let’s make sure corporations and the wealthiest Americans start paying their fair share. \n-\n-Just last year, 55 Fortune 500 corporations earned $40 billion in profits and paid zero dollars in federal income tax.  \n-\n-That’s simply not fair. That’s why I’ve proposed a 15% minimum tax rate for corporations. \n-\n-We got more than 130 countries to agree on a global minimum tax rate so companies can’t get out of paying their taxes at home by shipping jobs and factories overseas. \n-\n-That’s why I’ve proposed closing loopholes so the very wealthy don’t pay a lower tax rate than a teacher or a firefighter.  \n-\n-So that’s my plan. It will grow the economy and lower costs for families. \n-\n-So what are we waiting for? Let’s get this done. And while you’re at it, confirm my nominees to the Federal Reserve, which plays a critical role in fighting inflation.  \n-\n-My plan will not only lower costs to give families a fair shot, it will lower the deficit. \n-\n-The previous Administration not only ballooned the deficit with tax cuts for the very wealthy and corporations, it undermined the watchdogs whose job was to keep pandemic relief funds from being wasted. \n-\n-But in my administration, the watchdogs have been welcomed back. \n-\n-We’re going after the criminals who stole billions in relief money meant for small businesses and millions of Americans.  \n-\n-And tonight, I’m announcing that the Justice Department will name a chief prosecutor for pandemic fraud. \n-\n-By the end of this year, the deficit will be down to less than half what it was before I took office.  \n-\n-The only president ever to cut the deficit by more than one trillion dollars in a single year. \n-\n-Lowering your costs also means demanding more competition. \n-\n-I’m a capitalist, but capitalism without competition isn’t capitalism. \n-\n-It’s exploitation—and it drives up prices. \n-\n-When corporations don’t have to compete, their profits go up, your prices go up, and small businesses and family farmers and ranchers go under. \n-\n-We see it happening with ocean carriers moving goods in and out of America. \n-\n-During the pandemic, these foreign-owned companies raised prices by as much as 1,000% and made record profits. \n-\n-Tonight, I’m announcing a crackdown on these companies overcharging American businesses and consumers. \n-\n-And as Wall Street firms take over more nursing homes, quality in those homes has gone down and costs have gone up.  \n-\n-That ends on my watch. \n-\n-Medicare is going to set higher standards for nursing homes and make sure your loved ones get the care they deserve and expect. \n-\n-We’ll also cut costs and keep the economy going strong by giving workers a fair shot, provide more training and apprenticeships, hire them based on their skills not degrees. \n-\n-Let’s pass the Paycheck Fairness Act and paid leave.  \n-\n-Raise the minimum wage to $15 an hour and extend the Child Tax Credit, so no one has to raise a family in poverty. \n-\n-Let’s increase Pell Grants and increase our historic support of HBCUs, and invest in what Jill—our First Lady who teaches full-time—calls America’s best-kept secret: community colleges. \n-\n-And let’s pass the PRO Act when a majority of workers want to form a union—they shouldn’t be stopped.  \n-\n-When we invest in our workers, when we build the economy from the bottom up and the middle out together, we can do something we haven’t done in a long time: build a better America. \n-\n-For more than two years, COVID-19 has impacted every decision in our lives and the life of the nation. \n-\n-And I know you’re tired, frustrated, and exhausted. \n-\n-But I also know this. \n-\n-Because of the progress we’ve made, because of your resilience and the tools we have, tonight I can say  \n-we are moving forward safely, back to more normal routines.  \n-\n-We’ve reached a new moment in the fight against COVID-19, with severe cases down to a level not seen since last July.  \n-\n-Just a few days ago, the Centers for Disease Control and Prevention—the CDC—issued new mask guidelines. \n-\n-Under these new guidelines, most Americans in most of the country can now be mask free.   \n-\n-And based on the projections, more of the country will reach that point across the next couple of weeks. \n-\n-Thanks to the progress we have made this past year, COVID-19 need no longer control our lives.  \n-\n-I know some are talking about “living with COVID-19”. Tonight – I say that we will never just accept living with COVID-19. \n-\n-We will continue to combat the virus as we do other diseases. And because this is a virus that mutates and spreads, we will stay on guard. \n-\n-Here are four common sense steps as we move forward safely.  \n-\n-First, stay protected with vaccines and treatments. We know how incredibly effective vaccines are. If you’re vaccinated and boosted you have the highest degree of protection. \n-\n-We will never give up on vaccinating more Americans. Now, I know parents with kids under 5 are eager to see a vaccine authorized for their children. \n-\n-The scientists are working hard to get that done and we’ll be ready with plenty of vaccines when they do. \n-\n-We’re also ready with anti-viral treatments. If you get COVID-19, the Pfizer pill reduces your chances of ending up in the hospital by 90%.  \n-\n-We’ve ordered more of these pills than anyone in the world. And Pfizer is working overtime to get us 1 Million pills this month and more than double that next month.  \n-\n-And we’re launching the “Test to Treat” initiative so people can get tested at a pharmacy, and if they’re positive, receive antiviral pills on the spot at no cost.  \n-\n-If you’re immunocompromised or have some other vulnerability, we have treatments and free high-quality masks. \n-\n-We’re leaving no one behind or ignoring anyone’s needs as we move forward. \n-\n-And on testing, we have made hundreds of millions of tests available for you to order for free.   \n-\n-Even if you already ordered free tests tonight, I am announcing that you can order more from covidtests.gov starting next week. \n-\n-Second – we must prepare for new variants. Over the past year, we’ve gotten much better at detecting new variants. \n-\n-If necessary, we’ll be able to deploy new vaccines within 100 days instead of many more months or years.  \n-\n-And, if Congress provides the funds we need, we’ll have new stockpiles of tests, masks, and pills ready if needed. \n-\n-I cannot promise a new variant won’t come. But I can promise you we’ll do everything within our power to be ready if it does.  \n-\n-Third – we can end the shutdown of schools and businesses. We have the tools we need. \n-\n-It’s time for Americans to get back to work and fill our great downtowns again.  People working from home can feel safe to begin to return to the office.   \n-\n-We’re doing that here in the federal government. The vast majority of federal workers will once again work in person. \n-\n-Our schools are open. Let’s keep it that way. Our kids need to be in school. \n-\n-And with 75% of adult Americans fully vaccinated and hospitalizations down by 77%, most Americans can remove their masks, return to work, stay in the classroom, and move forward safely. \n-\n-We achieved this because we provided free vaccines, treatments, tests, and masks. \n-\n-Of course, continuing this costs money. \n-\n-I will soon send Congress a request. \n-\n-The vast majority of Americans have used these tools and may want to again, so I expect Congress to pass it quickly.   \n-\n-Fourth, we will continue vaccinating the world.     \n-\n-We’ve sent 475 Million vaccine doses to 112 countries, more than any other nation. \n-\n-And we won’t stop. \n-\n-We have lost so much to COVID-19. Time with one another. And worst of all, so much loss of life. \n-\n-Let’s use this moment to reset. Let’s stop looking at COVID-19 as a partisan dividing line and see it for what it is: A God-awful disease.  \n-\n-Let’s stop seeing each other as enemies, and start seeing each other for who we really are: Fellow Americans.  \n-\n-We can’t change how divided we’ve been. But we can change how we move forward—on COVID-19 and other issues we must face together. \n-\n-I recently visited the New York City Police Department days after the funerals of Officer Wilbert Mora and his partner, Officer Jason Rivera. \n-\n-They were responding to a 9-1-1 call when a man shot and killed them with a stolen gun. \n-\n-Officer Mora was 27 years old. \n-\n-Officer Rivera was 22. \n-\n-Both Dominican Americans who’d grown up on the same streets they later chose to patrol as police officers. \n-\n-I spoke with their families and told them that we are forever in debt for their sacrifice, and we will carry on their mission to restore the trust and safety every community deserves. \n-\n-I’ve worked on these issues a long time. \n-\n-I know what works: Investing in crime preventionand community police officers who’ll walk the beat, who’ll know the neighborhood, and who can restore trust and safety. \n-\n-So let’s not abandon our streets. Or choose between safety and equal justice. \n-\n-Let’s come together to protect our communities, restore trust, and hold law enforcement accountable. \n-\n-That’s why the Justice Department required body cameras, banned chokeholds, and restricted no-knock warrants for its officers. \n-\n-That’s why the American Rescue Plan provided $350 Billion that cities, states, and counties can use to hire more police and invest in proven strategies like community violence interruption—trusted messengers breaking the cycle of violence and trauma and giving young people hope.  \n-\n-We should all agree: The answer is not to Defund the police. The answer is to FUND the police with the resources and training they need to protect our communities. \n-\n-I ask Democrats and Republicans alike: Pass my budget and keep our neighborhoods safe.  \n-\n-And I will keep doing everything in my power to crack down on gun trafficking and ghost guns you can buy online and make at home—they have no serial numbers and can’t be traced. \n-\n-And I ask Congress to pass proven measures to reduce gun violence. Pass universal background checks. Why should anyone on a terrorist list be able to purchase a weapon? \n-\n-Ban assault weapons and high-capacity magazines. \n-\n-Repeal the liability shield that makes gun manufacturers the only industry in America that can’t be sued. \n-\n-These laws don’t infringe on the Second Amendment. They save lives. \n-\n-The most fundamental right in America is the right to vote – and to have it counted. And it’s under assault. \n-\n-In state after state, new laws have been passed, not only to suppress the vote, but to subvert entire elections. \n-\n-We cannot let this happen. \n-\n-Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections. \n-\n-Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. \n-\n-One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. \n-\n-And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence. \n-\n-A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans. \n-\n-And if we are to advance liberty and justice, we need to secure the Border and fix the immigration system. \n-\n-We can do both. At our border, we’ve installed new technology like cutting-edge scanners to better detect drug smuggling.  \n-\n-We’ve set up joint patrols with Mexico and Guatemala to catch more human traffickers.  \n-\n-We’re putting in place dedicated immigration judges so families fleeing persecution and violence can have their cases heard faster. \n-\n-We’re securing commitments and supporting partners in South and Central America to host more refugees and secure their own borders. \n-\n-We can do all this while keeping lit the torch of liberty that has led generations of immigrants to this land—my forefathers and so many of yours. \n-\n-Provide a pathway to citizenship for Dreamers, those on temporary status, farm workers, and essential workers. \n-\n-Revise our laws so businesses have the workers they need and families don’t wait decades to reunite. \n-\n-It’s not only the right thing to do—it’s the economically smart thing to do. \n-\n-That’s why immigration reform is supported by everyone from labor unions to religious leaders to the U.S. Chamber of Commerce. \n-\n-Let’s get it done once and for all. \n-\n-Advancing liberty and justice also requires protecting the rights of women. \n-\n-The constitutional right affirmed in Roe v. Wade—standing precedent for half a century—is under attack as never before. \n-\n-If we want to go forward—not backward—we must protect access to health care. Preserve a woman’s right to choose. And let’s continue to advance maternal health care in America. \n-\n-And for our LGBTQ+ Americans, let’s finally get the bipartisan Equality Act to my desk. The onslaught of state laws targeting transgender Americans and their families is wrong. \n-\n-As I said last year, especially to our younger transgender Americans, I will always have your back as your President, so you can be yourself and reach your God-given potential. \n-\n-While it often appears that we never agree, that isn’t true. I signed 80 bipartisan bills into law last year. From preventing government shutdowns to protecting Asian-Americans from still-too-common hate crimes to reforming military justice. \n-\n-And soon, we’ll strengthen the Violence Against Women Act that I first wrote three decades ago. It is important for us to show the nation that we can come together and do big things. \n-\n-So tonight I’m offering a Unity Agenda for the Nation. Four big things we can do together.  \n-\n-First, beat the opioid epidemic. \n-\n-There is so much we can do. Increase funding for prevention, treatment, harm reduction, and recovery.  \n-\n-Get rid of outdated rules that stop doctors from prescribing treatments. And stop the flow of illicit drugs by working with state and local law enforcement to go after traffickers. \n-\n-If you’re suffering from addiction, know you are not alone. I believe in recovery, and I celebrate the 23 million Americans in recovery. \n-\n-Second, let’s take on mental health. Especially among our children, whose lives and education have been turned upside down.  \n-\n-The American Rescue Plan gave schools money to hire teachers and help students make up for lost learning.  \n-\n-I urge every parent to make sure your school does just that. And we can all play a part—sign up to be a tutor or a mentor. \n-\n-Children were also struggling before the pandemic. Bullying, violence, trauma, and the harms of social media. \n-\n-As Frances Haugen, who is here with us tonight, has shown, we must hold social media platforms accountable for the national experiment they’re conducting on our children for profit. \n-\n-It’s time to strengthen privacy protections, ban targeted advertising to children, demand tech companies stop collecting personal data on our children. \n-\n-And let’s get all Americans the mental health services they need. More people they can turn to for help, and full parity between physical and mental health care. \n-\n-Third, support our veterans. \n-\n-Veterans are the best of us. \n-\n-I’ve always believed that we have a sacred obligation to equip all those we send to war and care for them and their families when they come home. \n-\n-My administration is providing assistance with job training and housing, and now helping lower-income veterans get VA care debt-free.  \n-\n-Our troops in Iraq and Afghanistan faced many dangers. \n-\n-One was stationed at bases and breathing in toxic smoke from “burn pits” that incinerated wastes of war—medical and hazard material, jet fuel, and more. \n-\n-When they came home, many of the world’s fittest and best trained warriors were never the same. \n-\n-Headaches. Numbness. Dizziness. \n-\n-A cancer that would put them in a flag-draped coffin. \n-\n-I know. \n-\n-One of those soldiers was my son Major Beau Biden. \n-\n-We don’t know for sure if a burn pit was the cause of his brain cancer, or the diseases of so many of our troops. \n-\n-But I’m committed to finding out everything we can. \n-\n-Committed to military families like Danielle Robinson from Ohio. \n-\n-The widow of Sergeant First Class Heath Robinson.  \n-\n-He was born a soldier. Army National Guard. Combat medic in Kosovo and Iraq. \n-\n-Stationed near Baghdad, just yards from burn pits the size of football fields. \n-\n-Heath’s widow Danielle is here with us tonight. They loved going to Ohio State football games. He loved building Legos with their daughter. \n-\n-But cancer from prolonged exposure to burn pits ravaged Heath’s lungs and body. \n-\n-Danielle says Heath was a fighter to the very end. \n-\n-He didn’t know how to stop fighting, and neither did she. \n-\n-Through her pain she found purpose to demand we do better. \n-\n-Tonight, Danielle—we are. \n-\n-The VA is pioneering new ways of linking toxic exposures to diseases, already helping more veterans get benefits. \n-\n-And tonight, I’m announcing we’re expanding eligibility to veterans suffering from nine respiratory cancers. \n-\n-I’m also calling on Congress: pass a law to make sure veterans devastated by toxic exposures in Iraq and Afghanistan finally get the benefits and comprehensive health care they deserve. \n-\n-And fourth, let’s end cancer as we know it. \n-\n-This is personal to me and Jill, to Kamala, and to so many of you. \n-\n-Cancer is the #2 cause of death in America–second only to heart disease. \n-\n-Last month, I announced our plan to supercharge  \n-the Cancer Moonshot that President Obama asked me to lead six years ago. \n-\n-Our goal is to cut the cancer death rate by at least 50% over the next 25 years, turn more cancers from death sentences into treatable diseases.  \n-\n-More support for patients and families. \n-\n-To get there, I call on Congress to fund ARPA-H, the Advanced Research Projects Agency for Health. \n-\n-It’s based on DARPA—the Defense Department project that led to the Internet, GPS, and so much more.  \n-\n-ARPA-H will have a singular purpose—to drive breakthroughs in cancer, Alzheimer’s, diabetes, and more. \n-\n-A unity agenda for the nation. \n-\n-We can do this. \n-\n-My fellow Americans—tonight , we have gathered in a sacred space—the citadel of our democracy. \n-\n-In this Capitol, generation after generation, Americans have debated great questions amid great strife, and have done great things. \n-\n-We have fought for freedom, expanded liberty, defeated totalitarianism and terror. \n-\n-And built the strongest, freest, and most prosperous nation the world has ever known. \n-\n-Now is the hour. \n-\n-Our moment of responsibility. \n-\n-Our test of resolve and conscience, of history itself. \n-\n-It is in this moment that our character is formed. Our purpose is found. Our future is forged. \n-\n-Well I know this nation.  \n-\n-We will meet the test. \n-\n-To protect freedom and liberty, to expand fairness and opportunity. \n-\n-We will save democracy. \n-\n-As hard as these times have been, I am more optimistic about America today than I have been my whole life. \n-\n-Because I see the future that is within our grasp. \n-\n-Because I know there is simply nothing beyond our capacity. \n-\n-We are the only nation on Earth that has always turned every crisis we have faced into an opportunity. \n-\n-The only nation that can be defined by a single word: possibilities. \n-\n-So on this night, in our 245th year as a nation, I have come to report on the State of the Union. \n-\n-And my report is this: the State of the Union is strong—because you, the American people, are strong. \n-\n-We are stronger today than we were a year ago. \n-\n-And we will be stronger a year from now than we are today. \n-\n-Now is our moment to meet and overcome the challenges of our time. \n-\n-And we will, as one people. \n-\n-One America. \n-\n-The United States of America. \n-\n-May God bless you all. May God protect our troops.\n\\ No newline at end of file\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The addition of `n_gpu_layers` and `use_mlock` can indeed enhance performance by utilizing GPU resources more effectively. However, your installation issues indicate potential compatibility or configuration problems, especially with the CUDA setup. The error regarding ‘native’ architecture is common when mismatched versions or unsupported options are used. Your approach to environment activation is crucial—follow the bash script guidelines strictly for consistency. Consider isolating changes in separate pull requests for easier management and evaluation. Lastly, assess your CPU as it may become the limiting factor in performance."
      }
    ],
    "token_estimation": 10038.75
  },
  {
    "index": 74,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/docker-compose.yml b/docker-compose.yml\nnew file mode 100644\nindex 0000000000..9d14df3388\n--- /dev/null\n+++ b/docker-compose.yml\n@@ -0,0 +1,125 @@\n+---\n+version: '3.9'\n+\n+x-ingest: &ingest\n+  command: [ python, src/ingest.py ]\n+  environment:\n+    - SOURCE_DIRECTORY=${SOURCE_DIRECTORY:-/home/privategpt/source_documents}\n+  volumes:\n+    - ${SOURCE_MOUNT:-./source_documents}:/home/privategpt/source_documents\n+\n+services:\n+  #\n+  # Base service, without CUDA\n+  #\n+  privategpt:\n+    build:\n+      context: .\n+      dockerfile: ./Dockerfile\n+      args: [ --rm, \"BASEIMAGE=python:3.10.11\", LLAMA_CMAKE= ]\n+    image: privategpt:test\n+    command: [ python, src/privateGPT.py ]\n+    environment:\n+      - PERSIST_DIRECTORY=${PERSIST_DIRECTORY:-/home/privategpt/db}\n+      - LLAMA_EMBEDDINGS_MODEL=${LLAMA_EMBEDDINGS_MODEL:-/home/privategpt/models/ggml-model-q4_0.bin}\n+      - EMBEDDINGS_MODEL_NAME=${EMBEDDINGS_MODEL_NAME:-all-MiniLM-L6-v2}\n+      - MODEL_TYPE=${MODEL_TYPE:-GPT4All}\n+      - MODEL_PATH=${MODEL_PATH:-/home/privategpt/models/ggml-gpt4all-j-v1.3-groovy.bin}\n+      - MODEL_N_CTX=${MODEL_N_CTX:-1000}\n+    volumes:\n+      - ${CACHE_MOUNT:-./cache}:/home/privategpt/.cache/torch\n+      - ${MODEL_MOUNT:-./models}:/home/privategpt/models\n+      - ${PERSIST_MOUNT:-./db}:/home/privategpt/db\n+\n+  #\n+  # To run with CUDA 11.6\n+  #\n+  #  docker compose run --rm --build privategpt-cuda-11.6\n+  #\n+  privategpt-cuda-11.6:\n+    extends: privategpt\n+    image: privategpt:cuda-11.6\n+    build:\n+      args:\n+        - BASEIMAGE=wallies/python-cuda:3.10-cuda11.6-runtime\n+        - LLAMA_CMAKE=CMAKE_ARGS='-DLLAMA_OPENBLAS=on' FORCE_CMAKE=1\n+    deploy:\n+      resources:\n+        reservations:\n+          devices:\n+            - driver: nvidia\n+              count: 1\n+              capabilities: [ gpu ]\n+\n+  #\n+  # To run with CUDA 11.7\n+  #\n+  #  docker compose run --rm --build privategpt-cuda-11.7\n+  #\n+  privategpt-cuda-11.7:\n+    extends: privategpt-cuda-11.6\n+    image: privategpt:cuda-11.7\n+    build:\n+      args: [ \"BASEIMAGE=wallies/python-cuda:3.10-cuda11.7-runtime\" ]\n+\n+  #\n+  # For ingest without cuda:\n+  #\n+  #  docker compose run --rm --build privategpt-ingest\n+  #\n+  privategpt-ingest:\n+    extends: privategpt\n+    <<: *ingest\n+\n+  #\n+  # To ingest using cuda 11.6:\n+  #\n+  #  docker compose run --rm --build privategpt-cuda-11.6-ingest\n+  #\n+  privategpt-cuda-11.6-ingest:\n+    extends: privategpt-cuda-11.6\n+    image: privategpt:cuda-11.6\n+    <<: *ingest\n+\n+  #\n+  # To ingest using cuda 11.7:\n+  #\n+  #  docker compose run --rm --build privategpt-cuda-11.7-ingest\n+  #\n+  privategpt-cuda-11.7-ingest:\n+    extends: privategpt-cuda-11.7\n+    image: privategpt:cuda-11.7\n+    <<: *ingest\n+\n+  # Check your system's version using\n+  #\n+  #  docker compose run --rm check-cuda-version\n+  #\n+  # then build and test the privateGPT container\n+  # using\n+  #\n+  #  docker compose run --rm check-cuda-<CUDAVERSION>\n+  #\n+  # Where <CUDAVERSION> is the version you found using 'check-cuda-version'.\n+  #\n+  # Example if CUDAVERSION == 11.6\n+  #\n+  #  docker compose run --rm --build check-cuda-11.6\n+  #\n+  #\n+  #\n+  # You can update your host's CUDA installation by downloading\n+  # a recent version from\n+  #\n+  # https://developer.nvidia.com/cuda-downloads .\n+  #\n+\n+  check-cuda-version:\n+    image: ubuntu\n+    command: [ nvidia-smi ]\n+  check-cuda-11.6:\n+    extends: privategpt-cuda-11.6\n+    command: [ nvidia-smi ]\n+  check-cuda-11.7:\n+    extends: privategpt-cuda-11.7\n+    command: [ nvidia-smi ]\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR comments suggest several improvements. First, consider using a `.env` file to set environment variables like `MODELS`, enabling easier configuration without modifying YAML files. Regarding line endings, switch to LF in the YAML and Dockerfile for consistency. The duplication in `docker-compose.yml` can be resolved by leveraging YAML anchors and aliases to promote DRY practices. Lastly, ensure models are automatically downloaded in your entrypoint script to avoid runtime errors. Overall, this streamlines usability and maintains clean architecture."
      }
    ],
    "token_estimation": 1027.5
  },
  {
    "index": 75,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/gpu_installer_cuda.bat b/gpu_installer_cuda.bat\nnew file mode 100644\nindex 0000000000..12869909bc\n--- /dev/null\n+++ b/gpu_installer_cuda.bat\n@@ -0,0 +1,103 @@\n+@echo off\n+\n+setlocal\n+pip --version >nul 2>&1\n+if %errorlevel% EQU 0 (\n+    set PIP_COMMAND=pip\n+) else (\n+    pip3 --version >nul 2>&1\n+    if %errorlevel% EQU 0 (\n+        set PIP_COMMAND=pip3\n+    ) else (\n+        echo Error: pip or pip3 is required.\n+        exit /b 1\n+    )\n+)\n+\n+%PIP_COMMAND% --version | findstr /C:\"python 3\" >nul 2>&1 && (\n+    echo pip is for Python 3.x.\n+) || (\n+    echo pip is not for Python 3.x.\n+    echo trying pip3...\n+    pip3 --version | findstr /C:\"python 3\" >nul 2>&1 && (\n+        set PIP_COMMAND=pip3\n+        echo pip3 is for Python 3.x.\n+    ) || (\n+        echo pip3 is not for Python 3.x.\n+        echo Error: pip or pip3 is required.\n+        exit /b 1\n+    )\n+)\n+\n+python --version >nul 2>&1 && (\n+    python -c \"import sys; assert sys.version_info >= (3, 10), 'Error: Python version should be larger than 3.10.'\" >nul 2>&1 && (\n+        set PYTHON_COMMAND=python\n+    ) || (\n+        py --version >nul 2>&1 && (\n+            py -c \"import sys; assert sys.version_info >= (3, 10), 'Error: Python version should be larger than 3.10.'\" >nul 2>&1 && (\n+                set PYTHON_COMMAND=py\n+            ) || (\n+                echo Error: Python version should be larger than 3.10.\n+                exit /b 1\n+            )\n+        )\n+    )\n+) || (\n+     echo Error: python or py is required.\n+    exit /b 1\n+)\n+\n+\n+\n+set /p use_venv=\"Do you want to use a virtual environment (venv) for the installation? (y/n): \"\n+if /i \"%use_venv%\"==\"y\" (\n+    %PYTHON_COMMAND% -c \"import venv\" >nul 2>&1\n+    if %errorlevel% NEQ 0 (\n+        echo Error: 'venv' module is not installed. Please install it using 'pip install virtualenv'.\n+        exit /b 1\n+    )\n+    echo Creating a virtual environment...\n+    %PYTHON_COMMAND% -m venv venv\n+    if exist \"venv\\Scripts\\activate.bat\" (\n+        echo Activating the virtual environment...\n+        call venv\\Scripts\\activate.bat\n+    ) else (\n+        echo Error: Virtual environment 'venv' not found.\n+        exit /b 1\n+    )\n+)\n+\n+where nvcc >nul 2>&1\n+if %errorlevel% equ 0 (\n+    nvcc --version | findstr /C:\"release 11.8\" >nul 2>&1\n+    if %errorlevel% equ 0 (\n+        echo CUDA 11.8 is installed.\n+    ) else (\n+        echo Error: CUDA 11.8 is not installed. \n+        exit /b 1\n+    )\n+) else (\n+    echo Error: nvcc is not found. Please install CUDA 11.8.\n+    exit /b 1\n+)\n+\n+echo Installing requirements...\n+%PIP_COMMAND% install -r requirements.txt -q\n+\n+%PYTHON_COMMAND% -c \"import torch; assert torch.version.cuda.startswith('11.8'), 'Error: CUDA version should be 11.8.'\" >nul 2>&1 && (\n+    echo PyTorch version is compatible with CUDA 11.8.\n+) || (\n+    echo Error: PyTorch version should be compatible with CUDA 11.8.\n+    echo Installing PyTorch for CUDA 11.8...\n+    %PIP_COMMAND% install torch torchvision --force-reinstall --upgrade --no-cache-dir --index-url https://download.pytorch.org/whl/cu118\n+)\n+\n+echo Building and installing llama-cpp-python package...\n+set CMAKE_ARGS=\"-DLLAMA_CUBLAS=on\"\n+set FORCE_CMAKE=1\n+%PIP_COMMAND% uninstall llama-cpp-python -y\n+%PIP_COMMAND% install llama-cpp-python --force-reinstall --upgrade --no-cache-dir\n+\n+echo Installation completed. You can now run ingest.py and privateGPT.py.\n+\n+endlocal\ndiff --git a/gpu_installer_cuda.sh b/gpu_installer_cuda.sh\nnew file mode 100644\nindex 0000000000..fe1f318d1d\n--- /dev/null\n+++ b/gpu_installer_cuda.sh\n@@ -0,0 +1,110 @@\n+#!/usr/bin/bash\n+\n+set -e\n+\n+pip --version > /dev/null 2>&1\n+if [ $? -eq 0 ]; then\n+    PIP_COMMAND=\"pip\"\n+else\n+    pip3 --version > /dev/null 2>&1\n+    if [ $? -eq 0 ]; then\n+        PIP_COMMAND=\"pip3\"\n+    else\n+        echo \"Error: pip or pip3 is required.\"\n+        exit 1\n+    fi\n+fi\n+\n+PIP_OUTPUT=\"$($PIP_COMMAND --version 2>&1)\"\n+if [[ $PIP_OUTPUT == *\"python 3\"* ]]; then\n+    echo \"pip is for Python 3.x.\"\n+else\n+    echo \"pip is not for Python 3.x.\"\n+    echo \"Trying pip3...\"\n+    PIP_OUTPUT=\"$($PIP_COMMAND --version 2>&1)\"\n+    if [[ $PIP_OUTPUT == *\"python 3\"* ]]; then\n+        PIP_COMMAND=\"pip3\"\n+        echo \"pip3 is for Python 3.x.\"\n+    else\n+        echo \"pip3 is not for Python 3.x.\"\n+        echo \"Error: pip or pip3 is required.\"\n+        exit 1\n+    fi\n+fi\n+\n+\n+python --version > /dev/null 2>&1\n+if [ $? -eq 0 ]; then\n+    python -c \"import sys; assert sys.version_info >= (3, 10), 'Error: Python version should be larger than 3.10.'\" > /dev/null 2>&1\n+    if [ $? -eq 0 ]; then\n+        PYTHON_COMMAND=\"python\"\n+    else\n+        py --version > /dev/null 2>&1\n+        if [ $? -eq 0 ]; then\n+            py -c \"import sys; assert sys.version_info >= (3, 10), 'Error: Python version should be larger than 3.10.'\" > /dev/null 2>&1\n+            if [ $? -eq 0 ]; then\n+                PYTHON_COMMAND=\"py\"\n+            else\n+                echo \"Error: Python version should be larger than 3.10.\"\n+                exit 1\n+            fi\n+        fi\n+    fi\n+else\n+    echo \"Error: python or py is required.\"\n+    exit 1\n+fi\n+\n+read -p \"Do you want to use a virtual environment (venv) for the installation? (y/n): \" use_venv\n+if [[ \"$use_venv\" == [Yy]* ]]; then\n+    # Check if virtualenv module is installed\n+    PYTHON_COMMAND -c \"import venv\" > /dev/null 2>&1\n+    if [ $? -ne 0 ]; then\n+        echo \"Error: 'venv' module is not installed. Please install it using 'pip install virtualenv'.\"\n+        exit 1\n+    fi\n+\n+    echo \"Creating a virtual environment...\"\n+    PYTHON_COMMAND -m venv venv\n+\n+    if [ -f \"venv/bin/activate\" ]; then\n+        echo \"Activating the virtual environment...\"\n+        source venv/bin/activate\n+    else\n+        echo \"Error: Virtual environment 'venv' not found.\"\n+        exit 1\n+    fi\n+fi\n+nvcc --version > /dev/null 2>&1\n+if [ $? -eq 0 ]; then\n+    nvcc --version | grep \"release 11.8\" > /dev/null 2>&1\n+    if [ $? -eq 0 ]; then\n+        echo \"CUDA 11.8 is installed.\"\n+    else\n+        echo \"Error: CUDA 11.8 is not installed.\"\n+        exit 1\n+    fi\n+else\n+    echo \"Error: nvcc is not found. Please install CUDA 11.8.\"\n+    exit 1\n+fi\n+\n+echo \"Installing requirements...\"\n+$PIP_COMMAND install -r requirements.txt -q\n+\n+$PYTHON_COMMAND -c \"import torch; assert torch.version.cuda.startswith('11.8'), 'Error: CUDA version should be 11.8.'\" > /dev/null 2>&1\n+if [ $? -eq 0 ]; then\n+    echo \"PyTorch version is compatible with CUDA 11.8.\"\n+else\n+    echo \"Error: PyTorch version should be compatible with CUDA 11.8.\"\n+    echo \"Installing PyTorch for CUDA 11.8...\"\n+    $PIP_COMMAND install torch torchvision --force-reinstall --upgrade --no-cache-dir --index-url https://download.pytorch.org/whl/cu118\n+fi\n+\n+echo \"Building and installing llama-cpp-python package...\"\n+CMAKE_ARGS=\"-DLLAMA_CUBLAS=on\"\n+FORCE_CMAKE=1\n+$PIP_COMMAND uninstall llama-cpp-python -y\n+$PIP_COMMAND install llama-cpp-python --force-reinstall --upgrade --no-cache-dir\n+\n+echo \"Installation completed. You can now run ingest.py and privateGPT.py.\"\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Your README.md requires a command adjustment for the installation process; ensure users run `cd llama-cpp-python` before executing setup. Several users faced issues likely due to CMake versions; highlight the need for an updated version in docs. The suggestion to utilize pycuda for GPU memory checks is valid, as shell scraping can introduce vulnerabilities. Consider implementing better error feedback, especially regarding GPU usage, since some users found it unclear. Lastly, clarify model specifications and add guidance for installing PyTorch with CUDA for GPU support."
      }
    ],
    "token_estimation": 1912.0
  },
  {
    "index": 76,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/models/tf.py b/models/tf.py\nnew file mode 100644\nindex 000000000000..40e7d20a9d84\n--- /dev/null\n+++ b/models/tf.py\n@@ -0,0 +1,558 @@\n+# YOLOv5 🚀 by Ultralytics, GPL-3.0 license\n+\"\"\"\n+TensorFlow/Keras and TFLite versions of YOLOv5\n+Authored by https://github.com/zldrobit in PR https://github.com/ultralytics/yolov5/pull/1127\n+\n+Usage:\n+    $ python models/tf.py --weights yolov5s.pt --cfg yolov5s.yaml\n+\n+Export int8 TFLite models:\n+    $ python models/tf.py --weights yolov5s.pt --cfg models/yolov5s.yaml --tfl-int8 \\\n+        --source path/to/images/ --ncalib 100\n+\n+Detection:\n+    $ python detect.py --weights yolov5s.pb          --img 320\n+    $ python detect.py --weights yolov5s_saved_model --img 320\n+    $ python detect.py --weights yolov5s-fp16.tflite --img 320\n+    $ python detect.py --weights yolov5s-int8.tflite --img 320 --tfl-int8\n+\n+For TensorFlow.js:\n+    $ python models/tf.py --weights yolov5s.pt --cfg models/yolov5s.yaml --img 320 --tf-nms --agnostic-nms\n+    $ pip install tensorflowjs\n+    $ tensorflowjs_converter \\\n+          --input_format=tf_frozen_model \\\n+          --output_node_names='Identity,Identity_1,Identity_2,Identity_3' \\\n+          yolov5s.pb \\\n+          web_model\n+    $ # Edit web_model/model.json to sort Identity* in ascending order\n+    $ cd .. && git clone https://github.com/zldrobit/tfjs-yolov5-example.git && cd tfjs-yolov5-example\n+    $ npm install\n+    $ ln -s ../../yolov5/web_model public/web_model\n+    $ npm start\n+\"\"\"\n+\n+import argparse\n+import logging\n+import os\n+import sys\n+import traceback\n+from copy import deepcopy\n+from pathlib import Path\n+\n+sys.path.append('./')  # to run '$ python *.py' files in subdirectories\n+\n+import numpy as np\n+import tensorflow as tf\n+import torch\n+import torch.nn as nn\n+import yaml\n+from tensorflow import keras\n+from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2\n+\n+from models.common import Conv, Bottleneck, SPP, DWConv, Focus, BottleneckCSP, Concat, autopad, C3\n+from models.experimental import MixConv2d, CrossConv, attempt_load\n+from models.yolo import Detect\n+from utils.datasets import LoadImages\n+from utils.general import make_divisible, check_file, check_dataset\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class tf_BN(keras.layers.Layer):\n+    # TensorFlow BatchNormalization wrapper\n+    def __init__(self, w=None):\n+        super(tf_BN, self).__init__()\n+        self.bn = keras.layers.BatchNormalization(\n+            beta_initializer=keras.initializers.Constant(w.bias.numpy()),\n+            gamma_initializer=keras.initializers.Constant(w.weight.numpy()),\n+            moving_mean_initializer=keras.initializers.Constant(w.running_mean.numpy()),\n+            moving_variance_initializer=keras.initializers.Constant(w.running_var.numpy()),\n+            epsilon=w.eps)\n+\n+    def call(self, inputs):\n+        return self.bn(inputs)\n+\n+\n+class tf_Pad(keras.layers.Layer):\n+    def __init__(self, pad):\n+        super(tf_Pad, self).__init__()\n+        self.pad = tf.constant([[0, 0], [pad, pad], [pad, pad], [0, 0]])\n+\n+    def call(self, inputs):\n+        return tf.pad(inputs, self.pad, mode='constant', constant_values=0)\n+\n+\n+class tf_Conv(keras.layers.Layer):\n+    # Standard convolution\n+    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True, w=None):\n+        # ch_in, ch_out, weights, kernel, stride, padding, groups\n+        super(tf_Conv, self).__init__()\n+        assert g == 1, \"TF v2.2 Conv2D does not support 'groups' argument\"\n+        assert isinstance(k, int), \"Convolution with multiple kernels are not allowed.\"\n+        # TensorFlow convolution padding is inconsistent with PyTorch (e.g. k=3 s=2 'SAME' padding)\n+        # see https://stackoverflow.com/questions/52975843/comparing-conv2d-with-padding-between-tensorflow-and-pytorch\n+\n+        conv = keras.layers.Conv2D(\n+            c2, k, s, 'SAME' if s == 1 else 'VALID', use_bias=False,\n+            kernel_initializer=keras.initializers.Constant(w.conv.weight.permute(2, 3, 1, 0).numpy()))\n+        self.conv = conv if s == 1 else keras.Sequential([tf_Pad(autopad(k, p)), conv])\n+        self.bn = tf_BN(w.bn) if hasattr(w, 'bn') else tf.identity\n+\n+        # YOLOv5 activations\n+        if isinstance(w.act, nn.LeakyReLU):\n+            self.act = (lambda x: keras.activations.relu(x, alpha=0.1)) if act else tf.identity\n+        elif isinstance(w.act, nn.Hardswish):\n+            self.act = (lambda x: x * tf.nn.relu6(x + 3) * 0.166666667) if act else tf.identity\n+        elif isinstance(w.act, nn.SiLU):\n+            self.act = (lambda x: keras.activations.swish(x)) if act else tf.identity\n+\n+    def call(self, inputs):\n+        return self.act(self.bn(self.conv(inputs)))\n+\n+\n+class tf_Focus(keras.layers.Layer):\n+    # Focus wh information into c-space\n+    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True, w=None):\n+        # ch_in, ch_out, kernel, stride, padding, groups\n+        super(tf_Focus, self).__init__()\n+        self.conv = tf_Conv(c1 * 4, c2, k, s, p, g, act, w.conv)\n+\n+    def call(self, inputs):  # x(b,w,h,c) -> y(b,w/2,h/2,4c)\n+        # inputs = inputs / 255.  # normalize 0-255 to 0-1\n+        return self.conv(tf.concat([inputs[:, ::2, ::2, :],\n+                                    inputs[:, 1::2, ::2, :],\n+                                    inputs[:, ::2, 1::2, :],\n+                                    inputs[:, 1::2, 1::2, :]], 3))\n+\n+\n+class tf_Bottleneck(keras.layers.Layer):\n+    # Standard bottleneck\n+    def __init__(self, c1, c2, shortcut=True, g=1, e=0.5, w=None):  # ch_in, ch_out, shortcut, groups, expansion\n+        super(tf_Bottleneck, self).__init__()\n+        c_ = int(c2 * e)  # hidden channels\n+        self.cv1 = tf_Conv(c1, c_, 1, 1, w=w.cv1)\n+        self.cv2 = tf_Conv(c_, c2, 3, 1, g=g, w=w.cv2)\n+        self.add = shortcut and c1 == c2\n+\n+    def call(self, inputs):\n+        return inputs + self.cv2(self.cv1(inputs)) if self.add else self.cv2(self.cv1(inputs))\n+\n+\n+class tf_Conv2d(keras.layers.Layer):\n+    # Substitution for PyTorch nn.Conv2D\n+    def __init__(self, c1, c2, k, s=1, g=1, bias=True, w=None):\n+        super(tf_Conv2d, self).__init__()\n+        assert g == 1, \"TF v2.2 Conv2D does not support 'groups' argument\"\n+        self.conv = keras.layers.Conv2D(\n+            c2, k, s, 'VALID', use_bias=bias,\n+            kernel_initializer=keras.initializers.Constant(w.weight.permute(2, 3, 1, 0).numpy()),\n+            bias_initializer=keras.initializers.Constant(w.bias.numpy()) if bias else None, )\n+\n+    def call(self, inputs):\n+        return self.conv(inputs)\n+\n+\n+class tf_BottleneckCSP(keras.layers.Layer):\n+    # CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks\n+    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5, w=None):\n+        # ch_in, ch_out, number, shortcut, groups, expansion\n+        super(tf_BottleneckCSP, self).__init__()\n+        c_ = int(c2 * e)  # hidden channels\n+        self.cv1 = tf_Conv(c1, c_, 1, 1, w=w.cv1)\n+        self.cv2 = tf_Conv2d(c1, c_, 1, 1, bias=False, w=w.cv2)\n+        self.cv3 = tf_Conv2d(c_, c_, 1, 1, bias=False, w=w.cv3)\n+        self.cv4 = tf_Conv(2 * c_, c2, 1, 1, w=w.cv4)\n+        self.bn = tf_BN(w.bn)\n+        self.act = lambda x: keras.activations.relu(x, alpha=0.1)\n+        self.m = keras.Sequential([tf_Bottleneck(c_, c_, shortcut, g, e=1.0, w=w.m[j]) for j in range(n)])\n+\n+    def call(self, inputs):\n+        y1 = self.cv3(self.m(self.cv1(inputs)))\n+        y2 = self.cv2(inputs)\n+        return self.cv4(self.act(self.bn(tf.concat((y1, y2), axis=3))))\n+\n+\n+class tf_C3(keras.layers.Layer):\n+    # CSP Bottleneck with 3 convolutions\n+    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5, w=None):\n+        # ch_in, ch_out, number, shortcut, groups, expansion\n+        super(tf_C3, self).__init__()\n+        c_ = int(c2 * e)  # hidden channels\n+        self.cv1 = tf_Conv(c1, c_, 1, 1, w=w.cv1)\n+        self.cv2 = tf_Conv(c1, c_, 1, 1, w=w.cv2)\n+        self.cv3 = tf_Conv(2 * c_, c2, 1, 1, w=w.cv3)\n+        self.m = keras.Sequential([tf_Bottleneck(c_, c_, shortcut, g, e=1.0, w=w.m[j]) for j in range(n)])\n+\n+    def call(self, inputs):\n+        return self.cv3(tf.concat((self.m(self.cv1(inputs)), self.cv2(inputs)), axis=3))\n+\n+\n+class tf_SPP(keras.layers.Layer):\n+    # Spatial pyramid pooling layer used in YOLOv3-SPP\n+    def __init__(self, c1, c2, k=(5, 9, 13), w=None):\n+        super(tf_SPP, self).__init__()\n+        c_ = c1 // 2  # hidden channels\n+        self.cv1 = tf_Conv(c1, c_, 1, 1, w=w.cv1)\n+        self.cv2 = tf_Conv(c_ * (len(k) + 1), c2, 1, 1, w=w.cv2)\n+        self.m = [keras.layers.MaxPool2D(pool_size=x, strides=1, padding='SAME') for x in k]\n+\n+    def call(self, inputs):\n+        x = self.cv1(inputs)\n+        return self.cv2(tf.concat([x] + [m(x) for m in self.m], 3))\n+\n+\n+class tf_Detect(keras.layers.Layer):\n+    def __init__(self, nc=80, anchors=(), ch=(), w=None):  # detection layer\n+        super(tf_Detect, self).__init__()\n+        self.stride = tf.convert_to_tensor(w.stride.numpy(), dtype=tf.float32)\n+        self.nc = nc  # number of classes\n+        self.no = nc + 5  # number of outputs per anchor\n+        self.nl = len(anchors)  # number of detection layers\n+        self.na = len(anchors[0]) // 2  # number of anchors\n+        self.grid = [tf.zeros(1)] * self.nl  # init grid\n+        self.anchors = tf.convert_to_tensor(w.anchors.numpy(), dtype=tf.float32)\n+        self.anchor_grid = tf.reshape(tf.convert_to_tensor(w.anchor_grid.numpy(), dtype=tf.float32),\n+                                      [self.nl, 1, -1, 1, 2])\n+        self.m = [tf_Conv2d(x, self.no * self.na, 1, w=w.m[i]) for i, x in enumerate(ch)]\n+        self.export = False  # onnx export\n+        self.training = True  # set to False after building model\n+        for i in range(self.nl):\n+            ny, nx = opt.img_size[0] // self.stride[i], opt.img_size[1] // self.stride[i]\n+            self.grid[i] = self._make_grid(nx, ny)\n+\n+    def call(self, inputs):\n+        # x = x.copy()  # for profiling\n+        z = []  # inference output\n+        self.training |= self.export\n+        x = []\n+        for i in range(self.nl):\n+            x.append(self.m[i](inputs[i]))\n+            # x(bs,20,20,255) to x(bs,3,20,20,85)\n+            ny, nx = opt.img_size[0] // self.stride[i], opt.img_size[1] // self.stride[i]\n+            x[i] = tf.transpose(tf.reshape(x[i], [-1, ny * nx, self.na, self.no]), [0, 2, 1, 3])\n+\n+            if not self.training:  # inference\n+                y = tf.sigmoid(x[i])\n+                xy = (y[..., 0:2] * 2. - 0.5 + self.grid[i]) * self.stride[i]  # xy\n+                wh = (y[..., 2:4] * 2) ** 2 * self.anchor_grid[i]\n+                # Normalize xywh to 0-1 to reduce calibration error\n+                xy /= tf.constant([[opt.img_size[1], opt.img_size[0]]], dtype=tf.float32)\n+                wh /= tf.constant([[opt.img_size[1], opt.img_size[0]]], dtype=tf.float32)\n+                y = tf.concat([xy, wh, y[..., 4:]], -1)\n+                z.append(tf.reshape(y, [-1, 3 * ny * nx, self.no]))\n+\n+        return x if self.training else (tf.concat(z, 1), x)\n+\n+    @staticmethod\n+    def _make_grid(nx=20, ny=20):\n+        # yv, xv = torch.meshgrid([torch.arange(ny), torch.arange(nx)])\n+        # return torch.stack((xv, yv), 2).view((1, 1, ny, nx, 2)).float()\n+        xv, yv = tf.meshgrid(tf.range(nx), tf.range(ny))\n+        return tf.cast(tf.reshape(tf.stack([xv, yv], 2), [1, 1, ny * nx, 2]), dtype=tf.float32)\n+\n+\n+class tf_Upsample(keras.layers.Layer):\n+    def __init__(self, size, scale_factor, mode, w=None):\n+        super(tf_Upsample, self).__init__()\n+        assert scale_factor == 2, \"scale_factor must be 2\"\n+        # self.upsample = keras.layers.UpSampling2D(size=scale_factor, interpolation=mode)\n+        if opt.tf_raw_resize:\n+            # with default arguments: align_corners=False, half_pixel_centers=False\n+            self.upsample = lambda x: tf.raw_ops.ResizeNearestNeighbor(images=x,\n+                                                                       size=(x.shape[1] * 2, x.shape[2] * 2))\n+        else:\n+            self.upsample = lambda x: tf.image.resize(x, (x.shape[1] * 2, x.shape[2] * 2), method=mode)\n+\n+    def call(self, inputs):\n+        return self.upsample(inputs)\n+\n+\n+class tf_Concat(keras.layers.Layer):\n+    def __init__(self, dimension=1, w=None):\n+        super(tf_Concat, self).__init__()\n+        assert dimension == 1, \"convert only NCHW to NHWC concat\"\n+        self.d = 3\n+\n+    def call(self, inputs):\n+        return tf.concat(inputs, self.d)\n+\n+\n+def parse_model(d, ch, model):  # model_dict, input_channels(3)\n+    logger.info('\\n%3s%18s%3s%10s  %-40s%-30s' % ('', 'from', 'n', 'params', 'module', 'arguments'))\n+    anchors, nc, gd, gw = d['anchors'], d['nc'], d['depth_multiple'], d['width_multiple']\n+    na = (len(anchors[0]) // 2) if isinstance(anchors, list) else anchors  # number of anchors\n+    no = na * (nc + 5)  # number of outputs = anchors * (classes + 5)\n+\n+    layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out\n+    for i, (f, n, m, args) in enumerate(d['backbone'] + d['head']):  # from, number, module, args\n+        m_str = m\n+        m = eval(m) if isinstance(m, str) else m  # eval strings\n+        for j, a in enumerate(args):\n+            try:\n+                args[j] = eval(a) if isinstance(a, str) else a  # eval strings\n+            except:\n+                pass\n+\n+        n = max(round(n * gd), 1) if n > 1 else n  # depth gain\n+        if m in [nn.Conv2d, Conv, Bottleneck, SPP, DWConv, MixConv2d, Focus, CrossConv, BottleneckCSP, C3]:\n+            c1, c2 = ch[f], args[0]\n+            c2 = make_divisible(c2 * gw, 8) if c2 != no else c2\n+\n+            args = [c1, c2, *args[1:]]\n+            if m in [BottleneckCSP, C3]:\n+                args.insert(2, n)\n+                n = 1\n+        elif m is nn.BatchNorm2d:\n+            args = [ch[f]]\n+        elif m is Concat:\n+            c2 = sum([ch[-1 if x == -1 else x + 1] for x in f])\n+        elif m is Detect:\n+            args.append([ch[x + 1] for x in f])\n+            if isinstance(args[1], int):  # number of anchors\n+                args[1] = [list(range(args[1] * 2))] * len(f)\n+        else:\n+            c2 = ch[f]\n+\n+        tf_m = eval('tf_' + m_str.replace('nn.', ''))\n+        m_ = keras.Sequential([tf_m(*args, w=model.model[i][j]) for j in range(n)]) if n > 1 \\\n+            else tf_m(*args, w=model.model[i])  # module\n+\n+        torch_m_ = nn.Sequential(*[m(*args) for _ in range(n)]) if n > 1 else m(*args)  # module\n+        t = str(m)[8:-2].replace('__main__.', '')  # module type\n+        np = sum([x.numel() for x in torch_m_.parameters()])  # number params\n+        m_.i, m_.f, m_.type, m_.np = i, f, t, np  # attach index, 'from' index, type, number params\n+        logger.info('%3s%18s%3s%10.0f  %-40s%-30s' % (i, f, n, np, t, args))  # print\n+        save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist\n+        layers.append(m_)\n+        ch.append(c2)\n+    return keras.Sequential(layers), sorted(save)\n+\n+\n+class tf_Model():\n+    def __init__(self, cfg='yolov5s.yaml', ch=3, nc=None, model=None):  # model, input channels, number of classes\n+        super(tf_Model, self).__init__()\n+        if isinstance(cfg, dict):\n+            self.yaml = cfg  # model dict\n+        else:  # is *.yaml\n+            import yaml  # for torch hub\n+            self.yaml_file = Path(cfg).name\n+            with open(cfg) as f:\n+                self.yaml = yaml.load(f, Loader=yaml.FullLoader)  # model dict\n+\n+        # Define model\n+        if nc and nc != self.yaml['nc']:\n+            print('Overriding %s nc=%g with nc=%g' % (cfg, self.yaml['nc'], nc))\n+            self.yaml['nc'] = nc  # override yaml value\n+        self.model, self.savelist = parse_model(deepcopy(self.yaml), ch=[ch], model=model)  # model, savelist, ch_out\n+\n+    def predict(self, inputs, profile=False):\n+        y = []  # outputs\n+        x = inputs\n+        for i, m in enumerate(self.model.layers):\n+            if m.f != -1:  # if not from previous layer\n+                x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers\n+\n+            x = m(x)  # run\n+            y.append(x if m.i in self.savelist else None)  # save output\n+\n+        # Add TensorFlow NMS\n+        if opt.tf_nms:\n+            boxes = xywh2xyxy(x[0][..., :4])\n+            probs = x[0][:, :, 4:5]\n+            classes = x[0][:, :, 5:]\n+            scores = probs * classes\n+            if opt.agnostic_nms:\n+                nms = agnostic_nms_layer()((boxes, classes, scores))\n+                return nms, x[1]\n+            else:\n+                boxes = tf.expand_dims(boxes, 2)\n+                nms = tf.image.combined_non_max_suppression(\n+                    boxes, scores, opt.topk_per_class, opt.topk_all, opt.iou_thres, opt.score_thres, clip_boxes=False)\n+                return nms, x[1]\n+\n+        return x[0]  # output only first tensor [1,6300,85] = [xywh, conf, class0, class1, ...]\n+        # x = x[0][0]  # [x(1,6300,85), ...] to x(6300,85)\n+        # xywh = x[..., :4]  # x(6300,4) boxes\n+        # conf = x[..., 4:5]  # x(6300,1) confidences\n+        # cls = tf.reshape(tf.cast(tf.argmax(x[..., 5:], axis=1), tf.float32), (-1, 1))  # x(6300,1)  classes\n+        # return tf.concat([conf, cls, xywh], 1)\n+\n+\n+class agnostic_nms_layer(keras.layers.Layer):\n+    # wrap map_fn to avoid TypeSpec related error https://stackoverflow.com/a/65809989/3036450\n+    def call(self, input):\n+        return tf.map_fn(agnostic_nms, input,\n+                         fn_output_signature=(tf.float32, tf.float32, tf.float32, tf.int32),\n+                         name='agnostic_nms')\n+\n+\n+def agnostic_nms(x):\n+    boxes, classes, scores = x\n+    class_inds = tf.cast(tf.argmax(classes, axis=-1), tf.float32)\n+    scores_inp = tf.reduce_max(scores, -1)\n+    selected_inds = tf.image.non_max_suppression(\n+        boxes, scores_inp, max_output_size=opt.topk_all, iou_threshold=opt.iou_thres, score_threshold=opt.score_thres)\n+    selected_boxes = tf.gather(boxes, selected_inds)\n+    padded_boxes = tf.pad(selected_boxes,\n+                          paddings=[[0, opt.topk_all - tf.shape(selected_boxes)[0]], [0, 0]],\n+                          mode=\"CONSTANT\", constant_values=0.0)\n+    selected_scores = tf.gather(scores_inp, selected_inds)\n+    padded_scores = tf.pad(selected_scores,\n+                           paddings=[[0, opt.topk_all - tf.shape(selected_boxes)[0]]],\n+                           mode=\"CONSTANT\", constant_values=-1.0)\n+    selected_classes = tf.gather(class_inds, selected_inds)\n+    padded_classes = tf.pad(selected_classes,\n+                            paddings=[[0, opt.topk_all - tf.shape(selected_boxes)[0]]],\n+                            mode=\"CONSTANT\", constant_values=-1.0)\n+    valid_detections = tf.shape(selected_inds)[0]\n+    return padded_boxes, padded_scores, padded_classes, valid_detections\n+\n+\n+def xywh2xyxy(xywh):\n+    # Convert nx4 boxes from [x, y, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right\n+    x, y, w, h = tf.split(xywh, num_or_size_splits=4, axis=-1)\n+    return tf.concat([x - w / 2, y - h / 2, x + w / 2, y + h / 2], axis=-1)\n+\n+\n+def representative_dataset_gen():\n+    # Representative dataset for use with converter.representative_dataset\n+    n = 0\n+    for path, img, im0s, vid_cap in dataset:\n+        # Get sample input data as a numpy array in a method of your choosing.\n+        n += 1\n+        input = np.transpose(img, [1, 2, 0])\n+        input = np.expand_dims(input, axis=0).astype(np.float32)\n+        input /= 255.0\n+        yield [input]\n+        if n >= opt.ncalib:\n+            break\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cfg', type=str, default='yolov5s.yaml', help='cfg path')\n+    parser.add_argument('--weights', type=str, default='yolov5s.pt', help='weights path')\n+    parser.add_argument('--img-size', nargs='+', type=int, default=[320, 320], help='image size')  # height, width\n+    parser.add_argument('--batch-size', type=int, default=1, help='batch size')\n+    parser.add_argument('--dynamic-batch-size', action='store_true', help='dynamic batch size')\n+    parser.add_argument('--source', type=str, default='../data/coco128.yaml', help='dir of images or data.yaml file')\n+    parser.add_argument('--ncalib', type=int, default=100, help='number of calibration images')\n+    parser.add_argument('--tfl-int8', action='store_true', dest='tfl_int8', help='export TFLite int8 model')\n+    parser.add_argument('--tf-nms', action='store_true', dest='tf_nms', help='TF NMS (without TFLite export)')\n+    parser.add_argument('--agnostic-nms', action='store_true', help='class-agnostic NMS')\n+    parser.add_argument('--tf-raw-resize', action='store_true', dest='tf_raw_resize',\n+                        help='use tf.raw_ops.ResizeNearestNeighbor for resize')\n+    parser.add_argument('--topk-per-class', type=int, default=100, help='topk per class to keep in NMS')\n+    parser.add_argument('--topk-all', type=int, default=100, help='topk for all classes to keep in NMS')\n+    parser.add_argument('--iou-thres', type=float, default=0.5, help='IOU threshold for NMS')\n+    parser.add_argument('--score-thres', type=float, default=0.4, help='score threshold for NMS')\n+    opt = parser.parse_args()\n+    opt.cfg = check_file(opt.cfg)  # check file\n+    opt.img_size *= 2 if len(opt.img_size) == 1 else 1  # expand\n+    print(opt)\n+\n+    # Input\n+    img = torch.zeros((opt.batch_size, 3, *opt.img_size))  # image size(1,3,320,192) iDetection\n+\n+    # Load PyTorch model\n+    model = attempt_load(opt.weights, map_location=torch.device('cpu'), inplace=True, fuse=False)\n+    model.model[-1].export = False  # set Detect() layer export=True\n+    y = model(img)  # dry run\n+    nc = y[0].shape[-1] - 5\n+\n+    # TensorFlow saved_model export\n+    try:\n+        print('\\nStarting TensorFlow saved_model export with TensorFlow %s...' % tf.__version__)\n+        tf_model = tf_Model(opt.cfg, model=model, nc=nc)\n+        img = tf.zeros((opt.batch_size, *opt.img_size, 3))  # NHWC Input for TensorFlow\n+\n+        m = tf_model.model.layers[-1]\n+        assert isinstance(m, tf_Detect), \"the last layer must be Detect\"\n+        m.training = False\n+        y = tf_model.predict(img)\n+\n+        inputs = keras.Input(shape=(*opt.img_size, 3), batch_size=None if opt.dynamic_batch_size else opt.batch_size)\n+        keras_model = keras.Model(inputs=inputs, outputs=tf_model.predict(inputs))\n+        keras_model.summary()\n+        path = opt.weights.replace('.pt', '_saved_model')  # filename\n+        keras_model.save(path, save_format='tf')\n+        print('TensorFlow saved_model export success, saved as %s' % path)\n+    except Exception as e:\n+        print('TensorFlow saved_model export failure: %s' % e)\n+        traceback.print_exc(file=sys.stdout)\n+\n+    # TensorFlow GraphDef export\n+    try:\n+        print('\\nStarting TensorFlow GraphDef export with TensorFlow %s...' % tf.__version__)\n+\n+        # https://github.com/leimao/Frozen_Graph_TensorFlow\n+        full_model = tf.function(lambda x: keras_model(x))\n+        full_model = full_model.get_concrete_function(\n+            tf.TensorSpec(keras_model.inputs[0].shape, keras_model.inputs[0].dtype))\n+\n+        frozen_func = convert_variables_to_constants_v2(full_model)\n+        frozen_func.graph.as_graph_def()\n+        f = opt.weights.replace('.pt', '.pb')  # filename\n+        tf.io.write_graph(graph_or_graph_def=frozen_func.graph,\n+                          logdir=os.path.dirname(f),\n+                          name=os.path.basename(f),\n+                          as_text=False)\n+\n+        print('TensorFlow GraphDef export success, saved as %s' % f)\n+    except Exception as e:\n+        print('TensorFlow GraphDef export failure: %s' % e)\n+        traceback.print_exc(file=sys.stdout)\n+\n+    # TFLite model export\n+    if not opt.tf_nms:\n+        try:\n+            print('\\nStarting TFLite export with TensorFlow %s...' % tf.__version__)\n+\n+            # fp32 TFLite model export ---------------------------------------------------------------------------------\n+            # converter = tf.lite.TFLiteConverter.from_keras_model(keras_model)\n+            # converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS]\n+            # converter.allow_custom_ops = False\n+            # converter.experimental_new_converter = True\n+            # tflite_model = converter.convert()\n+            # f = opt.weights.replace('.pt', '.tflite')  # filename\n+            # open(f, \"wb\").write(tflite_model)\n+\n+            # fp16 TFLite model export ---------------------------------------------------------------------------------\n+            converter = tf.lite.TFLiteConverter.from_keras_model(keras_model)\n+            converter.optimizations = [tf.lite.Optimize.DEFAULT]\n+            # converter.representative_dataset = representative_dataset_gen\n+            # converter.target_spec.supported_types = [tf.float16]\n+            converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS]\n+            converter.allow_custom_ops = False\n+            converter.experimental_new_converter = True\n+            tflite_model = converter.convert()\n+            f = opt.weights.replace('.pt', '-fp16.tflite')  # filename\n+            open(f, \"wb\").write(tflite_model)\n+            print('\\nTFLite export success, saved as %s' % f)\n+\n+            # int8 TFLite model export ---------------------------------------------------------------------------------\n+            if opt.tfl_int8:\n+                # Representative Dataset\n+                if opt.source.endswith('.yaml'):\n+                    with open(check_file(opt.source)) as f:\n+                        data = yaml.load(f, Loader=yaml.FullLoader)  # data dict\n+                        check_dataset(data)  # check\n+                    opt.source = data['train']\n+                dataset = LoadImages(opt.source, img_size=opt.img_size, auto=False)\n+                converter = tf.lite.TFLiteConverter.from_keras_model(keras_model)\n+                converter.optimizations = [tf.lite.Optimize.DEFAULT]\n+                converter.representative_dataset = representative_dataset_gen\n+                converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS_INT8]\n+                converter.inference_input_type = tf.uint8  # or tf.int8\n+                converter.inference_output_type = tf.uint8  # or tf.int8\n+                converter.allow_custom_ops = False\n+                converter.experimental_new_converter = True\n+                converter.experimental_new_quantizer = False\n+                tflite_model = converter.convert()\n+                f = opt.weights.replace('.pt', '-int8.tflite')  # filename\n+                open(f, \"wb\").write(tflite_model)\n+                print('\\nTFLite (int8) export success, saved as %s' % f)\n+\n+        except Exception as e:\n+            print('\\nTFLite export failure: %s' % e)\n+            traceback.print_exc(file=sys.stdout)\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Thanks for the clarifications regarding the input size and handling in TensorFlow. It's good to see that you correctly set `auto=False` to maintain consistent preprocessing. However, the model loading error in the Android emulator indicates a potential mismatch in input expectations. Check that the input shapes align with your model's architecture, especially since the error points to a concatenation operation expecting two inputs instead of one. Also verify you’re using the correct model configuration when exporting to TFLite."
      }
    ],
    "token_estimation": 6925.0
  },
  {
    "index": 77,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/data/coco128-seg.yaml b/data/coco128-seg.yaml\nnew file mode 100644\nindex 000000000000..5e81910cc456\n--- /dev/null\n+++ b/data/coco128-seg.yaml\n@@ -0,0 +1,101 @@\n+# YOLOv5 🚀 by Ultralytics, GPL-3.0 license\n+# COCO128-seg dataset https://www.kaggle.com/ultralytics/coco128 (first 128 images from COCO train2017) by Ultralytics\n+# Example usage: python train.py --data coco128.yaml\n+# parent\n+# ├── yolov5\n+# └── datasets\n+#     └── coco128-seg  ← downloads here (7 MB)\n+\n+\n+# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\n+path: ../datasets/coco128-seg  # dataset root dir\n+train: images/train2017  # train images (relative to 'path') 128 images\n+val: images/train2017  # val images (relative to 'path') 128 images\n+test:  # test images (optional)\n+\n+# Classes\n+names:\n+  0: person\n+  1: bicycle\n+  2: car\n+  3: motorcycle\n+  4: airplane\n+  5: bus\n+  6: train\n+  7: truck\n+  8: boat\n+  9: traffic light\n+  10: fire hydrant\n+  11: stop sign\n+  12: parking meter\n+  13: bench\n+  14: bird\n+  15: cat\n+  16: dog\n+  17: horse\n+  18: sheep\n+  19: cow\n+  20: elephant\n+  21: bear\n+  22: zebra\n+  23: giraffe\n+  24: backpack\n+  25: umbrella\n+  26: handbag\n+  27: tie\n+  28: suitcase\n+  29: frisbee\n+  30: skis\n+  31: snowboard\n+  32: sports ball\n+  33: kite\n+  34: baseball bat\n+  35: baseball glove\n+  36: skateboard\n+  37: surfboard\n+  38: tennis racket\n+  39: bottle\n+  40: wine glass\n+  41: cup\n+  42: fork\n+  43: knife\n+  44: spoon\n+  45: bowl\n+  46: banana\n+  47: apple\n+  48: sandwich\n+  49: orange\n+  50: broccoli\n+  51: carrot\n+  52: hot dog\n+  53: pizza\n+  54: donut\n+  55: cake\n+  56: chair\n+  57: couch\n+  58: potted plant\n+  59: bed\n+  60: dining table\n+  61: toilet\n+  62: tv\n+  63: laptop\n+  64: mouse\n+  65: remote\n+  66: keyboard\n+  67: cell phone\n+  68: microwave\n+  69: oven\n+  70: toaster\n+  71: sink\n+  72: refrigerator\n+  73: book\n+  74: clock\n+  75: vase\n+  76: scissors\n+  77: teddy bear\n+  78: hair drier\n+  79: toothbrush\n+\n+\n+# Download script/URL (optional)\n+download: https://ultralytics.com/assets/coco128-seg.zip\ndiff --git a/segment/predict.py b/segment/predict.py\nnew file mode 100644\nindex 000000000000..ba4cf2905255\n--- /dev/null\n+++ b/segment/predict.py\n@@ -0,0 +1,266 @@\n+# YOLOv5 🚀 by Ultralytics, GPL-3.0 license\n+\"\"\"\n+Run YOLOv5 segmentation inference on images, videos, directories, streams, etc.\n+\n+Usage - sources:\n+    $ python segment/predict.py --weights yolov5s-seg.pt --source 0                               # webcam\n+                                                                  img.jpg                         # image\n+                                                                  vid.mp4                         # video\n+                                                                  path/                           # directory\n+                                                                  'path/*.jpg'                    # glob\n+                                                                  'https://youtu.be/Zgi9g1ksQHc'  # YouTube\n+                                                                  'rtsp://example.com/media.mp4'  # RTSP, RTMP, HTTP stream\n+\n+Usage - formats:\n+    $ python segment/predict.py --weights yolov5s-seg.pt                 # PyTorch\n+                                          yolov5s-seg.torchscript        # TorchScript\n+                                          yolov5s-seg.onnx               # ONNX Runtime or OpenCV DNN with --dnn\n+                                          yolov5s-seg.xml                # OpenVINO\n+                                          yolov5s-seg.engine             # TensorRT\n+                                          yolov5s-seg.mlmodel            # CoreML (macOS-only)\n+                                          yolov5s-seg_saved_model        # TensorFlow SavedModel\n+                                          yolov5s-seg.pb                 # TensorFlow GraphDef\n+                                          yolov5s-seg.tflite             # TensorFlow Lite\n+                                          yolov5s-seg_edgetpu.tflite     # TensorFlow Edge TPU\n+                                          yolov5s-seg_paddle_model       # PaddlePaddle\n+\"\"\"\n+\n+import argparse\n+import os\n+import platform\n+import sys\n+from pathlib import Path\n+\n+import torch\n+\n+FILE = Path(__file__).resolve()\n+ROOT = FILE.parents[1]  # YOLOv5 root directory\n+if str(ROOT) not in sys.path:\n+    sys.path.append(str(ROOT))  # add ROOT to PATH\n+ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n+\n+from models.common import DetectMultiBackend\n+from utils.dataloaders import IMG_FORMATS, VID_FORMATS, LoadImages, LoadStreams\n+from utils.general import (LOGGER, Profile, check_file, check_img_size, check_imshow, check_requirements, colorstr, cv2,\n+                           increment_path, non_max_suppression, print_args, scale_coords, strip_optimizer, xyxy2xywh)\n+from utils.plots import Annotator, colors, save_one_box\n+from utils.segment.general import process_mask\n+from utils.torch_utils import select_device, smart_inference_mode\n+\n+\n+@smart_inference_mode()\n+def run(\n+    weights=ROOT / 'yolov5s-seg.pt',  # model.pt path(s)\n+    source=ROOT / 'data/images',  # file/dir/URL/glob, 0 for webcam\n+    data=ROOT / 'data/coco128.yaml',  # dataset.yaml path\n+    imgsz=(640, 640),  # inference size (height, width)\n+    conf_thres=0.25,  # confidence threshold\n+    iou_thres=0.45,  # NMS IOU threshold\n+    max_det=1000,  # maximum detections per image\n+    device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n+    view_img=False,  # show results\n+    save_txt=False,  # save results to *.txt\n+    save_conf=False,  # save confidences in --save-txt labels\n+    save_crop=False,  # save cropped prediction boxes\n+    nosave=False,  # do not save images/videos\n+    classes=None,  # filter by class: --class 0, or --class 0 2 3\n+    agnostic_nms=False,  # class-agnostic NMS\n+    augment=False,  # augmented inference\n+    visualize=False,  # visualize features\n+    update=False,  # update all models\n+    project=ROOT / 'runs/predict-seg',  # save results to project/name\n+    name='exp',  # save results to project/name\n+    exist_ok=False,  # existing project/name ok, do not increment\n+    line_thickness=3,  # bounding box thickness (pixels)\n+    hide_labels=False,  # hide labels\n+    hide_conf=False,  # hide confidences\n+    half=False,  # use FP16 half-precision inference\n+    dnn=False,  # use OpenCV DNN for ONNX inference\n+    vid_stride=1,  # video frame-rate stride\n+    retina_masks=False,\n+):\n+    source = str(source)\n+    save_img = not nosave and not source.endswith('.txt')  # save inference images\n+    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n+    is_url = source.lower().startswith(('rtsp://', 'rtmp://', 'http://', 'https://'))\n+    webcam = source.isnumeric() or source.endswith('.txt') or (is_url and not is_file)\n+    if is_url and is_file:\n+        source = check_file(source)  # download\n+\n+    # Directories\n+    save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n+    (save_dir / 'labels' if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n+\n+    # Load model\n+    device = select_device(device)\n+    model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n+    stride, names, pt = model.stride, model.names, model.pt\n+    imgsz = check_img_size(imgsz, s=stride)  # check image size\n+\n+    # Dataloader\n+    if webcam:\n+        view_img = check_imshow()\n+        dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n+        bs = len(dataset)  # batch_size\n+    else:\n+        dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)\n+        bs = 1  # batch_size\n+    vid_path, vid_writer = [None] * bs, [None] * bs\n+\n+    # Run inference\n+    model.warmup(imgsz=(1 if pt else bs, 3, *imgsz))  # warmup\n+    seen, windows, dt = 0, [], (Profile(), Profile(), Profile())\n+    for path, im, im0s, vid_cap, s in dataset:\n+        with dt[0]:\n+            im = torch.from_numpy(im).to(device)\n+            im = im.half() if model.fp16 else im.float()  # uint8 to fp16/32\n+            im /= 255  # 0 - 255 to 0.0 - 1.0\n+            if len(im.shape) == 3:\n+                im = im[None]  # expand for batch dim\n+\n+        # Inference\n+        with dt[1]:\n+            visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False\n+            pred, proto = model(im, augment=augment, visualize=visualize)[:2]\n+\n+        # NMS\n+        with dt[2]:\n+            pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det, nm=32)\n+\n+        # Second-stage classifier (optional)\n+        # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)\n+\n+        # Process predictions\n+        for i, det in enumerate(pred):  # per image\n+            seen += 1\n+            if webcam:  # batch_size >= 1\n+                p, im0, frame = path[i], im0s[i].copy(), dataset.count\n+                s += f'{i}: '\n+            else:\n+                p, im0, frame = path, im0s.copy(), getattr(dataset, 'frame', 0)\n+\n+            p = Path(p)  # to Path\n+            save_path = str(save_dir / p.name)  # im.jpg\n+            txt_path = str(save_dir / 'labels' / p.stem) + ('' if dataset.mode == 'image' else f'_{frame}')  # im.txt\n+            s += '%gx%g ' % im.shape[2:]  # print string\n+            gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # normalization gain whwh\n+            imc = im0.copy() if save_crop else im0  # for save_crop\n+            annotator = Annotator(im0, line_width=line_thickness, example=str(names))\n+            if len(det):\n+                masks = process_mask(proto[i], det[:, 6:], det[:, :4], im.shape[2:], upsample=True)  # HWC\n+\n+                # Rescale boxes from img_size to im0 size\n+                det[:, :4] = scale_coords(im.shape[2:], det[:, :4], im0.shape).round()\n+\n+                # Print results\n+                for c in det[:, 5].unique():\n+                    n = (det[:, 5] == c).sum()  # detections per class\n+                    s += f\"{n} {names[int(c)]}{'s' * (n > 1)}, \"  # add to string\n+\n+                # Mask plotting\n+                annotator.masks(masks,\n+                                colors=[colors(x, True) for x in det[:, 5]],\n+                                im_gpu=None if retina_masks else im[i])\n+\n+                # Write results\n+                for *xyxy, conf, cls in reversed(det[:, :6]):\n+                    if save_txt:  # Write to file\n+                        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n+                        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n+                        with open(f'{txt_path}.txt', 'a') as f:\n+                            f.write(('%g ' * len(line)).rstrip() % line + '\\n')\n+\n+                    if save_img or save_crop or view_img:  # Add bbox to image\n+                        c = int(cls)  # integer class\n+                        label = None if hide_labels else (names[c] if hide_conf else f'{names[c]} {conf:.2f}')\n+                        annotator.box_label(xyxy, label, color=colors(c, True))\n+                    if save_crop:\n+                        save_one_box(xyxy, imc, file=save_dir / 'crops' / names[c] / f'{p.stem}.jpg', BGR=True)\n+\n+            # Stream results\n+            im0 = annotator.result()\n+            if view_img:\n+                if platform.system() == 'Linux' and p not in windows:\n+                    windows.append(p)\n+                    cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n+                    cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n+                cv2.imshow(str(p), im0)\n+                if cv2.waitKey(1) == ord('q'):  # 1 millisecond\n+                    exit()\n+\n+            # Save results (image with detections)\n+            if save_img:\n+                if dataset.mode == 'image':\n+                    cv2.imwrite(save_path, im0)\n+                else:  # 'video' or 'stream'\n+                    if vid_path[i] != save_path:  # new video\n+                        vid_path[i] = save_path\n+                        if isinstance(vid_writer[i], cv2.VideoWriter):\n+                            vid_writer[i].release()  # release previous video writer\n+                        if vid_cap:  # video\n+                            fps = vid_cap.get(cv2.CAP_PROP_FPS)\n+                            w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n+                            h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n+                        else:  # stream\n+                            fps, w, h = 30, im0.shape[1], im0.shape[0]\n+                        save_path = str(Path(save_path).with_suffix('.mp4'))  # force *.mp4 suffix on results videos\n+                        vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*'mp4v'), fps, (w, h))\n+                    vid_writer[i].write(im0)\n+\n+        # Print time (inference-only)\n+        LOGGER.info(f\"{s}{'' if len(det) else '(no detections), '}{dt[1].dt * 1E3:.1f}ms\")\n+\n+    # Print results\n+    t = tuple(x.t / seen * 1E3 for x in dt)  # speeds per image\n+    LOGGER.info(f'Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {(1, 3, *imgsz)}' % t)\n+    if save_txt or save_img:\n+        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else ''\n+        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n+    if update:\n+        strip_optimizer(weights[0])  # update model (to fix SourceChangeWarning)\n+\n+\n+def parse_opt():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolov5s-seg.pt', help='model path(s)')\n+    parser.add_argument('--source', type=str, default=ROOT / 'data/images', help='file/dir/URL/glob, 0 for webcam')\n+    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128.yaml', help='(optional) dataset.yaml path')\n+    parser.add_argument('--imgsz', '--img', '--img-size', nargs='+', type=int, default=[640], help='inference size h,w')\n+    parser.add_argument('--conf-thres', type=float, default=0.25, help='confidence threshold')\n+    parser.add_argument('--iou-thres', type=float, default=0.45, help='NMS IoU threshold')\n+    parser.add_argument('--max-det', type=int, default=1000, help='maximum detections per image')\n+    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n+    parser.add_argument('--view-img', action='store_true', help='show results')\n+    parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')\n+    parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')\n+    parser.add_argument('--save-crop', action='store_true', help='save cropped prediction boxes')\n+    parser.add_argument('--nosave', action='store_true', help='do not save images/videos')\n+    parser.add_argument('--classes', nargs='+', type=int, help='filter by class: --classes 0, or --classes 0 2 3')\n+    parser.add_argument('--agnostic-nms', action='store_true', help='class-agnostic NMS')\n+    parser.add_argument('--augment', action='store_true', help='augmented inference')\n+    parser.add_argument('--visualize', action='store_true', help='visualize features')\n+    parser.add_argument('--update', action='store_true', help='update all models')\n+    parser.add_argument('--project', default=ROOT / 'runs/predict-seg', help='save results to project/name')\n+    parser.add_argument('--name', default='exp', help='save results to project/name')\n+    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n+    parser.add_argument('--line-thickness', default=3, type=int, help='bounding box thickness (pixels)')\n+    parser.add_argument('--hide-labels', default=False, action='store_true', help='hide labels')\n+    parser.add_argument('--hide-conf', default=False, action='store_true', help='hide confidences')\n+    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n+    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')\n+    parser.add_argument('--vid-stride', type=int, default=1, help='video frame-rate stride')\n+    parser.add_argument('--retina-masks', action='store_true', help='whether to plot masks in native resolution')\n+    opt = parser.parse_args()\n+    opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # expand\n+    print_args(vars(opt))\n+    return opt\n+\n+\n+def main(opt):\n+    check_requirements(exclude=('tensorboard', 'thop'))\n+    run(**vars(opt))\n+\n+\n+if __name__ == \"__main__\":\n+    opt = parse_opt()\n+    main(opt)\ndiff --git a/segment/train.py b/segment/train.py\nnew file mode 100644\nindex 000000000000..bda379176151\n--- /dev/null\n+++ b/segment/train.py\n@@ -0,0 +1,676 @@\n+# YOLOv5 🚀 by Ultralytics, GPL-3.0 license\n+\"\"\"\n+Train a YOLOv5 segment model on a segment dataset\n+Models and datasets download automatically from the latest YOLOv5 release.\n+\n+Usage - Single-GPU training:\n+    $ python segment/train.py --data coco128-seg.yaml --weights yolov5s-seg.pt --img 640  # from pretrained (recommended)\n+    $ python segment/train.py --data coco128-seg.yaml --weights '' --cfg yolov5s-seg.yaml --img 640  # from scratch\n+\n+Usage - Multi-GPU DDP training:\n+    $ python -m torch.distributed.run --nproc_per_node 4 --master_port 1 segment/train.py --data coco128-seg.yaml --weights yolov5s-seg.pt --img 640 --device 0,1,2,3\n+\n+Models:     https://github.com/ultralytics/yolov5/tree/master/models\n+Datasets:   https://github.com/ultralytics/yolov5/tree/master/data\n+Tutorial:   https://github.com/ultralytics/yolov5/wiki/Train-Custom-Data\n+\"\"\"\n+\n+import argparse\n+import math\n+import os\n+import random\n+import sys\n+import time\n+from copy import deepcopy\n+from datetime import datetime\n+from pathlib import Path\n+\n+import numpy as np\n+import torch\n+import torch.distributed as dist\n+import torch.nn as nn\n+import yaml\n+from torch.optim import lr_scheduler\n+from tqdm import tqdm\n+\n+FILE = Path(__file__).resolve()\n+ROOT = FILE.parents[1]  # YOLOv5 root directory\n+if str(ROOT) not in sys.path:\n+    sys.path.append(str(ROOT))  # add ROOT to PATH\n+ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n+\n+import torch.nn.functional as F\n+\n+import segment.val as validate  # for end-of-epoch mAP\n+from models.experimental import attempt_load\n+from models.yolo import SegmentationModel\n+from utils.autoanchor import check_anchors\n+from utils.autobatch import check_train_batch_size\n+from utils.callbacks import Callbacks\n+from utils.downloads import attempt_download, is_url\n+from utils.general import (LOGGER, check_amp, check_dataset, check_file, check_git_status, check_img_size,\n+                           check_requirements, check_suffix, check_yaml, colorstr, get_latest_run, increment_path,\n+                           init_seeds, intersect_dicts, labels_to_class_weights, labels_to_image_weights, one_cycle,\n+                           print_args, print_mutation, strip_optimizer, yaml_save)\n+from utils.loggers import GenericLogger\n+from utils.plots import plot_evolve, plot_labels\n+from utils.segment.dataloaders import create_dataloader\n+from utils.segment.loss import ComputeLoss\n+from utils.segment.metrics import KEYS, fitness\n+from utils.segment.plots import plot_images_and_masks, plot_results_with_masks\n+from utils.torch_utils import (EarlyStopping, ModelEMA, de_parallel, select_device, smart_DDP, smart_optimizer,\n+                               smart_resume, torch_distributed_zero_first)\n+\n+LOCAL_RANK = int(os.getenv('LOCAL_RANK', -1))  # https://pytorch.org/docs/stable/elastic/run.html\n+RANK = int(os.getenv('RANK', -1))\n+WORLD_SIZE = int(os.getenv('WORLD_SIZE', 1))\n+\n+\n+def train(hyp, opt, device, callbacks):  # hyp is path/to/hyp.yaml or hyp dictionary\n+    save_dir, epochs, batch_size, weights, single_cls, evolve, data, cfg, resume, noval, nosave, workers, freeze, mask_ratio = \\\n+        Path(opt.save_dir), opt.epochs, opt.batch_size, opt.weights, opt.single_cls, opt.evolve, opt.data, opt.cfg, \\\n+        opt.resume, opt.noval, opt.nosave, opt.workers, opt.freeze, opt.mask_ratio\n+    # callbacks.run('on_pretrain_routine_start')\n+\n+    # Directories\n+    w = save_dir / 'weights'  # weights dir\n+    (w.parent if evolve else w).mkdir(parents=True, exist_ok=True)  # make dir\n+    last, best = w / 'last.pt', w / 'best.pt'\n+\n+    # Hyperparameters\n+    if isinstance(hyp, str):\n+        with open(hyp, errors='ignore') as f:\n+            hyp = yaml.safe_load(f)  # load hyps dict\n+    LOGGER.info(colorstr('hyperparameters: ') + ', '.join(f'{k}={v}' for k, v in hyp.items()))\n+    opt.hyp = hyp.copy()  # for saving hyps to checkpoints\n+\n+    # Save run settings\n+    if not evolve:\n+        yaml_save(save_dir / 'hyp.yaml', hyp)\n+        yaml_save(save_dir / 'opt.yaml', vars(opt))\n+\n+    # Loggers\n+    data_dict = None\n+    if RANK in {-1, 0}:\n+        logger = GenericLogger(opt=opt, console_logger=LOGGER)\n+        # loggers = Loggers(save_dir, weights, opt, hyp, LOGGER)  # loggers instance\n+        # if loggers.clearml:\n+        #     data_dict = loggers.clearml.data_dict  # None if no ClearML dataset or filled in by ClearML\n+        # if loggers.wandb:\n+        #     data_dict = loggers.wandb.data_dict\n+        #     if resume:\n+        #         weights, epochs, hyp, batch_size = opt.weights, opt.epochs, opt.hyp, opt.batch_size\n+        #\n+        # # Register actions\n+        # for k in methods(loggers):\n+        #     callbacks.register_action(k, callback=getattr(loggers, k))\n+\n+    # Config\n+    plots = not evolve and not opt.noplots  # create plots\n+    overlap = not opt.no_overlap\n+    cuda = device.type != 'cpu'\n+    init_seeds(opt.seed + 1 + RANK, deterministic=True)\n+    with torch_distributed_zero_first(LOCAL_RANK):\n+        data_dict = data_dict or check_dataset(data)  # check if None\n+    train_path, val_path = data_dict['train'], data_dict['val']\n+    nc = 1 if single_cls else int(data_dict['nc'])  # number of classes\n+    names = {0: 'item'} if single_cls and len(data_dict['names']) != 1 else data_dict['names']  # class names\n+    is_coco = isinstance(val_path, str) and val_path.endswith('coco/val2017.txt')  # COCO dataset\n+\n+    # Model\n+    check_suffix(weights, '.pt')  # check weights\n+    pretrained = weights.endswith('.pt')\n+    if pretrained:\n+        with torch_distributed_zero_first(LOCAL_RANK):\n+            weights = attempt_download(weights)  # download if not found locally\n+        ckpt = torch.load(weights, map_location='cpu')  # load checkpoint to CPU to avoid CUDA memory leak\n+        model = SegmentationModel(cfg or ckpt['model'].yaml, ch=3, nc=nc, anchors=hyp.get('anchors')).to(device)\n+        exclude = ['anchor'] if (cfg or hyp.get('anchors')) and not resume else []  # exclude keys\n+        csd = ckpt['model'].float().state_dict()  # checkpoint state_dict as FP32\n+        csd = intersect_dicts(csd, model.state_dict(), exclude=exclude)  # intersect\n+        model.load_state_dict(csd, strict=False)  # load\n+        LOGGER.info(f'Transferred {len(csd)}/{len(model.state_dict())} items from {weights}')  # report\n+    else:\n+        model = SegmentationModel(cfg, ch=3, nc=nc, anchors=hyp.get('anchors')).to(device)  # create\n+    amp = check_amp(model)  # check AMP\n+\n+    # Freeze\n+    freeze = [f'model.{x}.' for x in (freeze if len(freeze) > 1 else range(freeze[0]))]  # layers to freeze\n+    for k, v in model.named_parameters():\n+        v.requires_grad = True  # train all layers\n+        # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN to 0 (commented for erratic training results)\n+        if any(x in k for x in freeze):\n+            LOGGER.info(f'freezing {k}')\n+            v.requires_grad = False\n+\n+    # Image size\n+    gs = max(int(model.stride.max()), 32)  # grid size (max stride)\n+    imgsz = check_img_size(opt.imgsz, gs, floor=gs * 2)  # verify imgsz is gs-multiple\n+\n+    # Batch size\n+    if RANK == -1 and batch_size == -1:  # single-GPU only, estimate best batch size\n+        batch_size = check_train_batch_size(model, imgsz, amp)\n+        logger.update_params({\"batch_size\": batch_size})\n+        # loggers.on_params_update({\"batch_size\": batch_size})\n+\n+    # Optimizer\n+    nbs = 64  # nominal batch size\n+    accumulate = max(round(nbs / batch_size), 1)  # accumulate loss before optimizing\n+    hyp['weight_decay'] *= batch_size * accumulate / nbs  # scale weight_decay\n+    optimizer = smart_optimizer(model, opt.optimizer, hyp['lr0'], hyp['momentum'], hyp['weight_decay'])\n+\n+    # Scheduler\n+    if opt.cos_lr:\n+        lf = one_cycle(1, hyp['lrf'], epochs)  # cosine 1->hyp['lrf']\n+    else:\n+        lf = lambda x: (1 - x / epochs) * (1.0 - hyp['lrf']) + hyp['lrf']  # linear\n+    scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)  # plot_lr_scheduler(optimizer, scheduler, epochs)\n+\n+    # EMA\n+    ema = ModelEMA(model) if RANK in {-1, 0} else None\n+\n+    # Resume\n+    best_fitness, start_epoch = 0.0, 0\n+    if pretrained:\n+        if resume:\n+            best_fitness, start_epoch, epochs = smart_resume(ckpt, optimizer, ema, weights, epochs, resume)\n+        del ckpt, csd\n+\n+    # DP mode\n+    if cuda and RANK == -1 and torch.cuda.device_count() > 1:\n+        LOGGER.warning('WARNING: DP not recommended, use torch.distributed.run for best DDP Multi-GPU results.\\n'\n+                       'See Multi-GPU Tutorial at https://github.com/ultralytics/yolov5/issues/475 to get started.')\n+        model = torch.nn.DataParallel(model)\n+\n+    # SyncBatchNorm\n+    if opt.sync_bn and cuda and RANK != -1:\n+        model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device)\n+        LOGGER.info('Using SyncBatchNorm()')\n+\n+    # Trainloader\n+    train_loader, dataset = create_dataloader(\n+        train_path,\n+        imgsz,\n+        batch_size // WORLD_SIZE,\n+        gs,\n+        single_cls,\n+        hyp=hyp,\n+        augment=True,\n+        cache=None if opt.cache == 'val' else opt.cache,\n+        rect=opt.rect,\n+        rank=LOCAL_RANK,\n+        workers=workers,\n+        image_weights=opt.image_weights,\n+        quad=opt.quad,\n+        prefix=colorstr('train: '),\n+        shuffle=True,\n+        mask_downsample_ratio=mask_ratio,\n+        overlap_mask=overlap,\n+    )\n+    labels = np.concatenate(dataset.labels, 0)\n+    mlc = int(labels[:, 0].max())  # max label class\n+    assert mlc < nc, f'Label class {mlc} exceeds nc={nc} in {data}. Possible class labels are 0-{nc - 1}'\n+\n+    # Process 0\n+    if RANK in {-1, 0}:\n+        val_loader = create_dataloader(val_path,\n+                                       imgsz,\n+                                       batch_size // WORLD_SIZE * 2,\n+                                       gs,\n+                                       single_cls,\n+                                       hyp=hyp,\n+                                       cache=None if noval else opt.cache,\n+                                       rect=True,\n+                                       rank=-1,\n+                                       workers=workers * 2,\n+                                       pad=0.5,\n+                                       mask_downsample_ratio=mask_ratio,\n+                                       overlap_mask=overlap,\n+                                       prefix=colorstr('val: '))[0]\n+\n+        if not resume:\n+            if not opt.noautoanchor:\n+                check_anchors(dataset, model=model, thr=hyp['anchor_t'], imgsz=imgsz)  # run AutoAnchor\n+            model.half().float()  # pre-reduce anchor precision\n+\n+            if plots:\n+                plot_labels(labels, names, save_dir)\n+        # callbacks.run('on_pretrain_routine_end', labels, names)\n+\n+    # DDP mode\n+    if cuda and RANK != -1:\n+        model = smart_DDP(model)\n+\n+    # Model attributes\n+    nl = de_parallel(model).model[-1].nl  # number of detection layers (to scale hyps)\n+    hyp['box'] *= 3 / nl  # scale to layers\n+    hyp['cls'] *= nc / 80 * 3 / nl  # scale to classes and layers\n+    hyp['obj'] *= (imgsz / 640) ** 2 * 3 / nl  # scale to image size and layers\n+    hyp['label_smoothing'] = opt.label_smoothing\n+    model.nc = nc  # attach number of classes to model\n+    model.hyp = hyp  # attach hyperparameters to model\n+    model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc  # attach class weights\n+    model.names = names\n+\n+    # Start training\n+    t0 = time.time()\n+    nb = len(train_loader)  # number of batches\n+    nw = max(round(hyp['warmup_epochs'] * nb), 100)  # number of warmup iterations, max(3 epochs, 100 iterations)\n+    # nw = min(nw, (epochs - start_epoch) / 2 * nb)  # limit warmup to < 1/2 of training\n+    last_opt_step = -1\n+    maps = np.zeros(nc)  # mAP per class\n+    results = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)  # P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)\n+    scheduler.last_epoch = start_epoch - 1  # do not move\n+    scaler = torch.cuda.amp.GradScaler(enabled=amp)\n+    stopper, stop = EarlyStopping(patience=opt.patience), False\n+    compute_loss = ComputeLoss(model, overlap=overlap)  # init loss class\n+    # callbacks.run('on_train_start')\n+    LOGGER.info(f'Image sizes {imgsz} train, {imgsz} val\\n'\n+                f'Using {train_loader.num_workers * WORLD_SIZE} dataloader workers\\n'\n+                f\"Logging results to {colorstr('bold', save_dir)}\\n\"\n+                f'Starting training for {epochs} epochs...')\n+    for epoch in range(start_epoch, epochs):  # epoch ------------------------------------------------------------------\n+        # callbacks.run('on_train_epoch_start')\n+        model.train()\n+\n+        # Update image weights (optional, single-GPU only)\n+        if opt.image_weights:\n+            cw = model.class_weights.cpu().numpy() * (1 - maps) ** 2 / nc  # class weights\n+            iw = labels_to_image_weights(dataset.labels, nc=nc, class_weights=cw)  # image weights\n+            dataset.indices = random.choices(range(dataset.n), weights=iw, k=dataset.n)  # rand weighted idx\n+\n+        # Update mosaic border (optional)\n+        # b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)\n+        # dataset.mosaic_border = [b - imgsz, -b]  # height, width borders\n+\n+        mloss = torch.zeros(4, device=device)  # mean losses\n+        if RANK != -1:\n+            train_loader.sampler.set_epoch(epoch)\n+        pbar = enumerate(train_loader)\n+        LOGGER.info(('\\n' + '%11s' * 8) %\n+                    ('Epoch', 'GPU_mem', 'box_loss', 'seg_loss', 'obj_loss', 'cls_loss', 'Instances', 'Size'))\n+        if RANK in {-1, 0}:\n+            pbar = tqdm(pbar, total=nb, bar_format='{l_bar}{bar:10}{r_bar}{bar:-10b}')  # progress bar\n+        optimizer.zero_grad()\n+        for i, (imgs, targets, paths, _, masks) in pbar:  # batch ------------------------------------------------------\n+            # callbacks.run('on_train_batch_start')\n+            ni = i + nb * epoch  # number integrated batches (since train start)\n+            imgs = imgs.to(device, non_blocking=True).float() / 255  # uint8 to float32, 0-255 to 0.0-1.0\n+\n+            # Warmup\n+            if ni <= nw:\n+                xi = [0, nw]  # x interp\n+                # compute_loss.gr = np.interp(ni, xi, [0.0, 1.0])  # iou loss ratio (obj_loss = 1.0 or iou)\n+                accumulate = max(1, np.interp(ni, xi, [1, nbs / batch_size]).round())\n+                for j, x in enumerate(optimizer.param_groups):\n+                    # bias lr falls from 0.1 to lr0, all other lrs rise from 0.0 to lr0\n+                    x['lr'] = np.interp(ni, xi, [hyp['warmup_bias_lr'] if j == 0 else 0.0, x['initial_lr'] * lf(epoch)])\n+                    if 'momentum' in x:\n+                        x['momentum'] = np.interp(ni, xi, [hyp['warmup_momentum'], hyp['momentum']])\n+\n+            # Multi-scale\n+            if opt.multi_scale:\n+                sz = random.randrange(imgsz * 0.5, imgsz * 1.5 + gs) // gs * gs  # size\n+                sf = sz / max(imgs.shape[2:])  # scale factor\n+                if sf != 1:\n+                    ns = [math.ceil(x * sf / gs) * gs for x in imgs.shape[2:]]  # new shape (stretched to gs-multiple)\n+                    imgs = nn.functional.interpolate(imgs, size=ns, mode='bilinear', align_corners=False)\n+\n+            # Forward\n+            with torch.cuda.amp.autocast(amp):\n+                pred = model(imgs)  # forward\n+                loss, loss_items = compute_loss(pred, targets.to(device), masks=masks.to(device).float())\n+                if RANK != -1:\n+                    loss *= WORLD_SIZE  # gradient averaged between devices in DDP mode\n+                if opt.quad:\n+                    loss *= 4.\n+\n+            # Backward\n+            scaler.scale(loss).backward()\n+\n+            # Optimize - https://pytorch.org/docs/master/notes/amp_examples.html\n+            if ni - last_opt_step >= accumulate:\n+                scaler.unscale_(optimizer)  # unscale gradients\n+                torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=10.0)  # clip gradients\n+                scaler.step(optimizer)  # optimizer.step\n+                scaler.update()\n+                optimizer.zero_grad()\n+                if ema:\n+                    ema.update(model)\n+                last_opt_step = ni\n+\n+            # Log\n+            if RANK in {-1, 0}:\n+                mloss = (mloss * i + loss_items) / (i + 1)  # update mean losses\n+                mem = f'{torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g}G'  # (GB)\n+                pbar.set_description(('%11s' * 2 + '%11.4g' * 6) %\n+                                     (f'{epoch}/{epochs - 1}', mem, *mloss, targets.shape[0], imgs.shape[-1]))\n+                # callbacks.run('on_train_batch_end', model, ni, imgs, targets, paths)\n+                # if callbacks.stop_training:\n+                #    return\n+\n+                # Mosaic plots\n+                if plots:\n+                    if ni < 3:\n+                        plot_images_and_masks(imgs, targets, masks, paths, save_dir / f\"train_batch{ni}.jpg\")\n+                    if ni == 10:\n+                        files = sorted(save_dir.glob('train*.jpg'))\n+                        logger.log_images(files, \"Mosaics\", epoch)\n+            # end batch ------------------------------------------------------------------------------------------------\n+\n+        # Scheduler\n+        lr = [x['lr'] for x in optimizer.param_groups]  # for loggers\n+        scheduler.step()\n+\n+        if RANK in {-1, 0}:\n+            # mAP\n+            # callbacks.run('on_train_epoch_end', epoch=epoch)\n+            ema.update_attr(model, include=['yaml', 'nc', 'hyp', 'names', 'stride', 'class_weights'])\n+            final_epoch = (epoch + 1 == epochs) or stopper.possible_stop\n+            if not noval or final_epoch:  # Calculate mAP\n+                results, maps, _ = validate.run(data_dict,\n+                                                batch_size=batch_size // WORLD_SIZE * 2,\n+                                                imgsz=imgsz,\n+                                                half=amp,\n+                                                model=ema.ema,\n+                                                single_cls=single_cls,\n+                                                dataloader=val_loader,\n+                                                save_dir=save_dir,\n+                                                plots=False,\n+                                                callbacks=callbacks,\n+                                                compute_loss=compute_loss,\n+                                                mask_downsample_ratio=mask_ratio,\n+                                                overlap=overlap)\n+\n+            # Update best mAP\n+            fi = fitness(np.array(results).reshape(1, -1))  # weighted combination of [P, R, mAP@.5, mAP@.5-.95]\n+            stop = stopper(epoch=epoch, fitness=fi)  # early stop check\n+            if fi > best_fitness:\n+                best_fitness = fi\n+            log_vals = list(mloss) + list(results) + lr\n+            # callbacks.run('on_fit_epoch_end', log_vals, epoch, best_fitness, fi)\n+            # Log val metrics and media\n+            metrics_dict = dict(zip(KEYS, log_vals))\n+            logger.log_metrics(metrics_dict, epoch)\n+\n+            # Save model\n+            if (not nosave) or (final_epoch and not evolve):  # if save\n+                ckpt = {\n+                    'epoch': epoch,\n+                    'best_fitness': best_fitness,\n+                    'model': deepcopy(de_parallel(model)).half(),\n+                    'ema': deepcopy(ema.ema).half(),\n+                    'updates': ema.updates,\n+                    'optimizer': optimizer.state_dict(),\n+                    # 'wandb_id': loggers.wandb.wandb_run.id if loggers.wandb else None,\n+                    'opt': vars(opt),\n+                    'date': datetime.now().isoformat()}\n+\n+                # Save last, best and delete\n+                torch.save(ckpt, last)\n+                if best_fitness == fi:\n+                    torch.save(ckpt, best)\n+                if opt.save_period > 0 and epoch % opt.save_period == 0:\n+                    torch.save(ckpt, w / f'epoch{epoch}.pt')\n+                    logger.log_model(w / f'epoch{epoch}.pt')\n+                del ckpt\n+                # callbacks.run('on_model_save', last, epoch, final_epoch, best_fitness, fi)\n+\n+        # EarlyStopping\n+        if RANK != -1:  # if DDP training\n+            broadcast_list = [stop if RANK == 0 else None]\n+            dist.broadcast_object_list(broadcast_list, 0)  # broadcast 'stop' to all ranks\n+            if RANK != 0:\n+                stop = broadcast_list[0]\n+        if stop:\n+            break  # must break all DDP ranks\n+\n+        # end epoch ----------------------------------------------------------------------------------------------------\n+    # end training -----------------------------------------------------------------------------------------------------\n+    if RANK in {-1, 0}:\n+        LOGGER.info(f'\\n{epoch - start_epoch + 1} epochs completed in {(time.time() - t0) / 3600:.3f} hours.')\n+        for f in last, best:\n+            if f.exists():\n+                strip_optimizer(f)  # strip optimizers\n+                if f is best:\n+                    LOGGER.info(f'\\nValidating {f}...')\n+                    results, _, _ = validate.run(\n+                        data_dict,\n+                        batch_size=batch_size // WORLD_SIZE * 2,\n+                        imgsz=imgsz,\n+                        model=attempt_load(f, device).half(),\n+                        iou_thres=0.65 if is_coco else 0.60,  # best pycocotools at iou 0.65\n+                        single_cls=single_cls,\n+                        dataloader=val_loader,\n+                        save_dir=save_dir,\n+                        save_json=is_coco,\n+                        verbose=True,\n+                        plots=plots,\n+                        callbacks=callbacks,\n+                        compute_loss=compute_loss,\n+                        mask_downsample_ratio=mask_ratio,\n+                        overlap=overlap)  # val best model with plots\n+                    if is_coco:\n+                        # callbacks.run('on_fit_epoch_end', list(mloss) + list(results) + lr, epoch, best_fitness, fi)\n+                        metrics_dict = dict(zip(KEYS, list(mloss) + list(results) + lr))\n+                        logger.log_metrics(metrics_dict, epoch)\n+\n+        # callbacks.run('on_train_end', last, best, epoch, results)\n+        # on train end callback using genericLogger\n+        logger.log_metrics(dict(zip(KEYS[4:16], results)), epochs)\n+        if not opt.evolve:\n+            logger.log_model(best, epoch)\n+        if plots:\n+            plot_results_with_masks(file=save_dir / 'results.csv')  # save results.png\n+            files = ['results.png', 'confusion_matrix.png', *(f'{x}_curve.png' for x in ('F1', 'PR', 'P', 'R'))]\n+            files = [(save_dir / f) for f in files if (save_dir / f).exists()]  # filter\n+            LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}\")\n+            logger.log_images(files, \"Results\", epoch + 1)\n+            logger.log_images(sorted(save_dir.glob('val*.jpg')), \"Validation\", epoch + 1)\n+    torch.cuda.empty_cache()\n+    return results\n+\n+\n+def parse_opt(known=False):\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--weights', type=str, default=ROOT / 'yolov5s-seg.pt', help='initial weights path')\n+    parser.add_argument('--cfg', type=str, default='', help='model.yaml path')\n+    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128-seg.yaml', help='dataset.yaml path')\n+    parser.add_argument('--hyp', type=str, default=ROOT / 'data/hyps/hyp.scratch-low.yaml', help='hyperparameters path')\n+    parser.add_argument('--epochs', type=int, default=300, help='total training epochs')\n+    parser.add_argument('--batch-size', type=int, default=16, help='total batch size for all GPUs, -1 for autobatch')\n+    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='train, val image size (pixels)')\n+    parser.add_argument('--rect', action='store_true', help='rectangular training')\n+    parser.add_argument('--resume', nargs='?', const=True, default=False, help='resume most recent training')\n+    parser.add_argument('--nosave', action='store_true', help='only save final checkpoint')\n+    parser.add_argument('--noval', action='store_true', help='only validate final epoch')\n+    parser.add_argument('--noautoanchor', action='store_true', help='disable AutoAnchor')\n+    parser.add_argument('--noplots', action='store_true', help='save no plot files')\n+    parser.add_argument('--evolve', type=int, nargs='?', const=300, help='evolve hyperparameters for x generations')\n+    parser.add_argument('--bucket', type=str, default='', help='gsutil bucket')\n+    parser.add_argument('--cache', type=str, nargs='?', const='ram', help='--cache images in \"ram\" (default) or \"disk\"')\n+    parser.add_argument('--image-weights', action='store_true', help='use weighted image selection for training')\n+    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n+    parser.add_argument('--multi-scale', action='store_true', help='vary img-size +/- 50%%')\n+    parser.add_argument('--single-cls', action='store_true', help='train multi-class data as single-class')\n+    parser.add_argument('--optimizer', type=str, choices=['SGD', 'Adam', 'AdamW'], default='SGD', help='optimizer')\n+    parser.add_argument('--sync-bn', action='store_true', help='use SyncBatchNorm, only available in DDP mode')\n+    parser.add_argument('--workers', type=int, default=8, help='max dataloader workers (per RANK in DDP mode)')\n+    parser.add_argument('--project', default=ROOT / 'runs/train-seg', help='save to project/name')\n+    parser.add_argument('--name', default='exp', help='save to project/name')\n+    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n+    parser.add_argument('--quad', action='store_true', help='quad dataloader')\n+    parser.add_argument('--cos-lr', action='store_true', help='cosine LR scheduler')\n+    parser.add_argument('--label-smoothing', type=float, default=0.0, help='Label smoothing epsilon')\n+    parser.add_argument('--patience', type=int, default=100, help='EarlyStopping patience (epochs without improvement)')\n+    parser.add_argument('--freeze', nargs='+', type=int, default=[0], help='Freeze layers: backbone=10, first3=0 1 2')\n+    parser.add_argument('--save-period', type=int, default=-1, help='Save checkpoint every x epochs (disabled if < 1)')\n+    parser.add_argument('--seed', type=int, default=0, help='Global training seed')\n+    parser.add_argument('--local_rank', type=int, default=-1, help='Automatic DDP Multi-GPU argument, do not modify')\n+\n+    # Instance Segmentation Args\n+    parser.add_argument('--mask-ratio', type=int, default=4, help='Downsample the truth masks to saving memory')\n+    parser.add_argument('--no-overlap', action='store_true', help='Overlap masks train faster at slightly less mAP')\n+\n+    # Weights & Biases arguments\n+    # parser.add_argument('--entity', default=None, help='W&B: Entity')\n+    # parser.add_argument('--upload_dataset', nargs='?', const=True, default=False, help='W&B: Upload data, \"val\" option')\n+    # parser.add_argument('--bbox_interval', type=int, default=-1, help='W&B: Set bounding-box image logging interval')\n+    # parser.add_argument('--artifact_alias', type=str, default='latest', help='W&B: Version of dataset artifact to use')\n+\n+    return parser.parse_known_args()[0] if known else parser.parse_args()\n+\n+\n+def main(opt, callbacks=Callbacks()):\n+    # Checks\n+    if RANK in {-1, 0}:\n+        print_args(vars(opt))\n+        check_git_status()\n+        check_requirements()\n+\n+    # Resume\n+    if opt.resume and not opt.evolve:  # resume from specified or most recent last.pt\n+        last = Path(check_file(opt.resume) if isinstance(opt.resume, str) else get_latest_run())\n+        opt_yaml = last.parent.parent / 'opt.yaml'  # train options yaml\n+        opt_data = opt.data  # original dataset\n+        if opt_yaml.is_file():\n+            with open(opt_yaml, errors='ignore') as f:\n+                d = yaml.safe_load(f)\n+        else:\n+            d = torch.load(last, map_location='cpu')['opt']\n+        opt = argparse.Namespace(**d)  # replace\n+        opt.cfg, opt.weights, opt.resume = '', str(last), True  # reinstate\n+        if is_url(opt_data):\n+            opt.data = check_file(opt_data)  # avoid HUB resume auth timeout\n+    else:\n+        opt.data, opt.cfg, opt.hyp, opt.weights, opt.project = \\\n+            check_file(opt.data), check_yaml(opt.cfg), check_yaml(opt.hyp), str(opt.weights), str(opt.project)  # checks\n+        assert len(opt.cfg) or len(opt.weights), 'either --cfg or --weights must be specified'\n+        if opt.evolve:\n+            if opt.project == str(ROOT / 'runs/train'):  # if default project name, rename to runs/evolve\n+                opt.project = str(ROOT / 'runs/evolve')\n+            opt.exist_ok, opt.resume = opt.resume, False  # pass resume to exist_ok and disable resume\n+        if opt.name == 'cfg':\n+            opt.name = Path(opt.cfg).stem  # use model.yaml as name\n+        opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))\n+\n+    # DDP mode\n+    device = select_device(opt.device, batch_size=opt.batch_size)\n+    if LOCAL_RANK != -1:\n+        msg = 'is not compatible with YOLOv5 Multi-GPU DDP training'\n+        assert not opt.image_weights, f'--image-weights {msg}'\n+        assert not opt.evolve, f'--evolve {msg}'\n+        assert opt.batch_size != -1, f'AutoBatch with --batch-size -1 {msg}, please pass a valid --batch-size'\n+        assert opt.batch_size % WORLD_SIZE == 0, f'--batch-size {opt.batch_size} must be multiple of WORLD_SIZE'\n+        assert torch.cuda.device_count() > LOCAL_RANK, 'insufficient CUDA devices for DDP command'\n+        torch.cuda.set_device(LOCAL_RANK)\n+        device = torch.device('cuda', LOCAL_RANK)\n+        dist.init_process_group(backend=\"nccl\" if dist.is_nccl_available() else \"gloo\")\n+\n+    # Train\n+    if not opt.evolve:\n+        train(opt.hyp, opt, device, callbacks)\n+\n+    # Evolve hyperparameters (optional)\n+    else:\n+        # Hyperparameter evolution metadata (mutation scale 0-1, lower_limit, upper_limit)\n+        meta = {\n+            'lr0': (1, 1e-5, 1e-1),  # initial learning rate (SGD=1E-2, Adam=1E-3)\n+            'lrf': (1, 0.01, 1.0),  # final OneCycleLR learning rate (lr0 * lrf)\n+            'momentum': (0.3, 0.6, 0.98),  # SGD momentum/Adam beta1\n+            'weight_decay': (1, 0.0, 0.001),  # optimizer weight decay\n+            'warmup_epochs': (1, 0.0, 5.0),  # warmup epochs (fractions ok)\n+            'warmup_momentum': (1, 0.0, 0.95),  # warmup initial momentum\n+            'warmup_bias_lr': (1, 0.0, 0.2),  # warmup initial bias lr\n+            'box': (1, 0.02, 0.2),  # box loss gain\n+            'cls': (1, 0.2, 4.0),  # cls loss gain\n+            'cls_pw': (1, 0.5, 2.0),  # cls BCELoss positive_weight\n+            'obj': (1, 0.2, 4.0),  # obj loss gain (scale with pixels)\n+            'obj_pw': (1, 0.5, 2.0),  # obj BCELoss positive_weight\n+            'iou_t': (0, 0.1, 0.7),  # IoU training threshold\n+            'anchor_t': (1, 2.0, 8.0),  # anchor-multiple threshold\n+            'anchors': (2, 2.0, 10.0),  # anchors per output grid (0 to ignore)\n+            'fl_gamma': (0, 0.0, 2.0),  # focal loss gamma (efficientDet default gamma=1.5)\n+            'hsv_h': (1, 0.0, 0.1),  # image HSV-Hue augmentation (fraction)\n+            'hsv_s': (1, 0.0, 0.9),  # image HSV-Saturation augmentation (fraction)\n+            'hsv_v': (1, 0.0, 0.9),  # image HSV-Value augmentation (fraction)\n+            'degrees': (1, 0.0, 45.0),  # image rotation (+/- deg)\n+            'translate': (1, 0.0, 0.9),  # image translation (+/- fraction)\n+            'scale': (1, 0.0, 0.9),  # image scale (+/- gain)\n+            'shear': (1, 0.0, 10.0),  # image shear (+/- deg)\n+            'perspective': (0, 0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001\n+            'flipud': (1, 0.0, 1.0),  # image flip up-down (probability)\n+            'fliplr': (0, 0.0, 1.0),  # image flip left-right (probability)\n+            'mosaic': (1, 0.0, 1.0),  # image mixup (probability)\n+            'mixup': (1, 0.0, 1.0),  # image mixup (probability)\n+            'copy_paste': (1, 0.0, 1.0)}  # segment copy-paste (probability)\n+\n+        with open(opt.hyp, errors='ignore') as f:\n+            hyp = yaml.safe_load(f)  # load hyps dict\n+            if 'anchors' not in hyp:  # anchors commented in hyp.yaml\n+                hyp['anchors'] = 3\n+        if opt.noautoanchor:\n+            del hyp['anchors'], meta['anchors']\n+        opt.noval, opt.nosave, save_dir = True, True, Path(opt.save_dir)  # only val/save final epoch\n+        # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # evolvable indices\n+        evolve_yaml, evolve_csv = save_dir / 'hyp_evolve.yaml', save_dir / 'evolve.csv'\n+        if opt.bucket:\n+            os.system(f'gsutil cp gs://{opt.bucket}/evolve.csv {evolve_csv}')  # download evolve.csv if exists\n+\n+        for _ in range(opt.evolve):  # generations to evolve\n+            if evolve_csv.exists():  # if evolve.csv exists: select best hyps and mutate\n+                # Select parent(s)\n+                parent = 'single'  # parent selection method: 'single' or 'weighted'\n+                x = np.loadtxt(evolve_csv, ndmin=2, delimiter=',', skiprows=1)\n+                n = min(5, len(x))  # number of previous results to consider\n+                x = x[np.argsort(-fitness(x))][:n]  # top n mutations\n+                w = fitness(x) - fitness(x).min() + 1E-6  # weights (sum > 0)\n+                if parent == 'single' or len(x) == 1:\n+                    # x = x[random.randint(0, n - 1)]  # random selection\n+                    x = x[random.choices(range(n), weights=w)[0]]  # weighted selection\n+                elif parent == 'weighted':\n+                    x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # weighted combination\n+\n+                # Mutate\n+                mp, s = 0.8, 0.2  # mutation probability, sigma\n+                npr = np.random\n+                npr.seed(int(time.time()))\n+                g = np.array([meta[k][0] for k in hyp.keys()])  # gains 0-1\n+                ng = len(meta)\n+                v = np.ones(ng)\n+                while all(v == 1):  # mutate until a change occurs (prevent duplicates)\n+                    v = (g * (npr.random(ng) < mp) * npr.randn(ng) * npr.random() * s + 1).clip(0.3, 3.0)\n+                for i, k in enumerate(hyp.keys()):  # plt.hist(v.ravel(), 300)\n+                    hyp[k] = float(x[i + 7] * v[i])  # mutate\n+\n+            # Constrain to limits\n+            for k, v in meta.items():\n+                hyp[k] = max(hyp[k], v[1])  # lower limit\n+                hyp[k] = min(hyp[k], v[2])  # upper limit\n+                hyp[k] = round(hyp[k], 5)  # significant digits\n+\n+            # Train mutation\n+            results = train(hyp.copy(), opt, device, callbacks)\n+            callbacks = Callbacks()\n+            # Write mutation results\n+            print_mutation(results, hyp.copy(), save_dir, opt.bucket)\n+\n+        # Plot results\n+        plot_evolve(evolve_csv)\n+        LOGGER.info(f'Hyperparameter evolution finished {opt.evolve} generations\\n'\n+                    f\"Results saved to {colorstr('bold', save_dir)}\\n\"\n+                    f'Usage example: $ python train.py --hyp {evolve_yaml}')\n+\n+\n+def run(**kwargs):\n+    # Usage: import train; train.run(data='coco128.yaml', imgsz=320, weights='yolov5m.pt')\n+    opt = parse_opt(True)\n+    for k, v in kwargs.items():\n+        setattr(opt, k, v)\n+    main(opt)\n+    return opt\n+\n+\n+if __name__ == \"__main__\":\n+    opt = parse_opt()\n+    main(opt)\ndiff --git a/segment/val.py b/segment/val.py\nnew file mode 100644\nindex 000000000000..138aa00aaed3\n--- /dev/null\n+++ b/segment/val.py\n@@ -0,0 +1,471 @@\n+# YOLOv5 🚀 by Ultralytics, GPL-3.0 license\n+\"\"\"\n+Validate a trained YOLOv5 segment model on a segment dataset\n+\n+Usage:\n+    $ bash data/scripts/get_coco.sh --val --segments  # download COCO-segments val split (1G, 5000 images)\n+    $ python segment/val.py --weights yolov5s-seg.pt --data coco.yaml --img 640-  # validate COCO-segments\n+\n+Usage - formats:\n+    $ python segment/val.py --weights yolov5s-seg.pt                 # PyTorch\n+                                      yolov5s-seg.torchscript        # TorchScript\n+                                      yolov5s-seg.onnx               # ONNX Runtime or OpenCV DNN with --dnn\n+                                      yolov5s-seg.xml                # OpenVINO\n+                                      yolov5s-seg.engine             # TensorRT\n+                                      yolov5s-seg.mlmodel            # CoreML (macOS-only)\n+                                      yolov5s-seg_saved_model        # TensorFlow SavedModel\n+                                      yolov5s-seg.pb                 # TensorFlow GraphDef\n+                                      yolov5s-seg.tflite             # TensorFlow Lite\n+                                      yolov5s-seg_edgetpu.tflite     # TensorFlow Edge TPU\n+                                      yolov5s-seg_paddle_model       # PaddlePaddle\n+\"\"\"\n+\n+import argparse\n+import json\n+import os\n+import sys\n+from multiprocessing.pool import ThreadPool\n+from pathlib import Path\n+\n+import numpy as np\n+import torch\n+from tqdm import tqdm\n+\n+FILE = Path(__file__).resolve()\n+ROOT = FILE.parents[1]  # YOLOv5 root directory\n+if str(ROOT) not in sys.path:\n+    sys.path.append(str(ROOT))  # add ROOT to PATH\n+ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative\n+\n+import torch.nn.functional as F\n+\n+from models.common import DetectMultiBackend\n+from models.yolo import SegmentationModel\n+from utils.callbacks import Callbacks\n+from utils.general import (LOGGER, NUM_THREADS, Profile, check_dataset, check_img_size, check_requirements, check_yaml,\n+                           coco80_to_coco91_class, colorstr, increment_path, non_max_suppression, print_args,\n+                           scale_coords, xywh2xyxy, xyxy2xywh)\n+from utils.metrics import ConfusionMatrix, box_iou\n+from utils.plots import output_to_target, plot_val_study\n+from utils.segment.dataloaders import create_dataloader\n+from utils.segment.general import mask_iou, process_mask, process_mask_upsample, scale_image\n+from utils.segment.metrics import Metrics, ap_per_class_box_and_mask\n+from utils.segment.plots import plot_images_and_masks\n+from utils.torch_utils import de_parallel, select_device, smart_inference_mode\n+\n+\n+def save_one_txt(predn, save_conf, shape, file):\n+    # Save one txt result\n+    gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh\n+    for *xyxy, conf, cls in predn.tolist():\n+        xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n+        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n+        with open(file, 'a') as f:\n+            f.write(('%g ' * len(line)).rstrip() % line + '\\n')\n+\n+\n+def save_one_json(predn, jdict, path, class_map, pred_masks):\n+    # Save one JSON result {\"image_id\": 42, \"category_id\": 18, \"bbox\": [258.15, 41.29, 348.26, 243.78], \"score\": 0.236}\n+    from pycocotools.mask import encode\n+\n+    def single_encode(x):\n+        rle = encode(np.asarray(x[:, :, None], order=\"F\", dtype=\"uint8\"))[0]\n+        rle[\"counts\"] = rle[\"counts\"].decode(\"utf-8\")\n+        return rle\n+\n+    image_id = int(path.stem) if path.stem.isnumeric() else path.stem\n+    box = xyxy2xywh(predn[:, :4])  # xywh\n+    box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n+    pred_masks = np.transpose(pred_masks, (2, 0, 1))\n+    with ThreadPool(NUM_THREADS) as pool:\n+        rles = pool.map(single_encode, pred_masks)\n+    for i, (p, b) in enumerate(zip(predn.tolist(), box.tolist())):\n+        jdict.append({\n+            'image_id': image_id,\n+            'category_id': class_map[int(p[5])],\n+            'bbox': [round(x, 3) for x in b],\n+            'score': round(p[4], 5),\n+            'segmentation': rles[i]})\n+\n+\n+def process_batch(detections, labels, iouv, pred_masks=None, gt_masks=None, overlap=False, masks=False):\n+    \"\"\"\n+    Return correct prediction matrix\n+    Arguments:\n+        detections (array[N, 6]), x1, y1, x2, y2, conf, class\n+        labels (array[M, 5]), class, x1, y1, x2, y2\n+    Returns:\n+        correct (array[N, 10]), for 10 IoU levels\n+    \"\"\"\n+    if masks:\n+        if overlap:\n+            nl = len(labels)\n+            index = torch.arange(nl, device=gt_masks.device).view(nl, 1, 1) + 1\n+            gt_masks = gt_masks.repeat(nl, 1, 1)  # shape(1,640,640) -> (n,640,640)\n+            gt_masks = torch.where(gt_masks == index, 1.0, 0.0)\n+        if gt_masks.shape[1:] != pred_masks.shape[1:]:\n+            gt_masks = F.interpolate(gt_masks[None], pred_masks.shape[1:], mode=\"bilinear\", align_corners=False)[0]\n+            gt_masks = gt_masks.gt_(0.5)\n+        iou = mask_iou(gt_masks.view(gt_masks.shape[0], -1), pred_masks.view(pred_masks.shape[0], -1))\n+    else:  # boxes\n+        iou = box_iou(labels[:, 1:], detections[:, :4])\n+\n+    correct = np.zeros((detections.shape[0], iouv.shape[0])).astype(bool)\n+    correct_class = labels[:, 0:1] == detections[:, 5]\n+    for i in range(len(iouv)):\n+        x = torch.where((iou >= iouv[i]) & correct_class)  # IoU > threshold and classes match\n+        if x[0].shape[0]:\n+            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()  # [label, detect, iou]\n+            if x[0].shape[0] > 1:\n+                matches = matches[matches[:, 2].argsort()[::-1]]\n+                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n+                # matches = matches[matches[:, 2].argsort()[::-1]]\n+                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n+            correct[matches[:, 1].astype(int), i] = True\n+    return torch.tensor(correct, dtype=torch.bool, device=iouv.device)\n+\n+\n+@smart_inference_mode()\n+def run(\n+        data,\n+        weights=None,  # model.pt path(s)\n+        batch_size=32,  # batch size\n+        imgsz=640,  # inference size (pixels)\n+        conf_thres=0.001,  # confidence threshold\n+        iou_thres=0.6,  # NMS IoU threshold\n+        max_det=300,  # maximum detections per image\n+        task='val',  # train, val, test, speed or study\n+        device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu\n+        workers=8,  # max dataloader workers (per RANK in DDP mode)\n+        single_cls=False,  # treat as single-class dataset\n+        augment=False,  # augmented inference\n+        verbose=False,  # verbose output\n+        save_txt=False,  # save results to *.txt\n+        save_hybrid=False,  # save label+prediction hybrid results to *.txt\n+        save_conf=False,  # save confidences in --save-txt labels\n+        save_json=False,  # save a COCO-JSON results file\n+        project=ROOT / 'runs/val-seg',  # save to project/name\n+        name='exp',  # save to project/name\n+        exist_ok=False,  # existing project/name ok, do not increment\n+        half=True,  # use FP16 half-precision inference\n+        dnn=False,  # use OpenCV DNN for ONNX inference\n+        model=None,\n+        dataloader=None,\n+        save_dir=Path(''),\n+        plots=True,\n+        overlap=False,\n+        mask_downsample_ratio=1,\n+        compute_loss=None,\n+        callbacks=Callbacks(),\n+):\n+    if save_json:\n+        check_requirements(['pycocotools'])\n+        process = process_mask_upsample  # more accurate\n+    else:\n+        process = process_mask  # faster\n+\n+    # Initialize/load model and set device\n+    training = model is not None\n+    if training:  # called by train.py\n+        device, pt, jit, engine = next(model.parameters()).device, True, False, False  # get model device, PyTorch model\n+        half &= device.type != 'cpu'  # half precision only supported on CUDA\n+        model.half() if half else model.float()\n+        nm = de_parallel(model).model[-1].nm  # number of masks\n+    else:  # called directly\n+        device = select_device(device, batch_size=batch_size)\n+\n+        # Directories\n+        save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # increment run\n+        (save_dir / 'labels' if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # make dir\n+\n+        # Load model\n+        model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)\n+        stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine\n+        imgsz = check_img_size(imgsz, s=stride)  # check image size\n+        half = model.fp16  # FP16 supported on limited backends with CUDA\n+        nm = de_parallel(model).model.model[-1].nm if isinstance(model, SegmentationModel) else 32  # number of masks\n+        if engine:\n+            batch_size = model.batch_size\n+        else:\n+            device = model.device\n+            if not (pt or jit):\n+                batch_size = 1  # export.py models default to batch-size 1\n+                LOGGER.info(f'Forcing --batch-size 1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models')\n+\n+        # Data\n+        data = check_dataset(data)  # check\n+\n+    # Configure\n+    model.eval()\n+    cuda = device.type != 'cpu'\n+    is_coco = isinstance(data.get('val'), str) and data['val'].endswith(f'coco{os.sep}val2017.txt')  # COCO dataset\n+    nc = 1 if single_cls else int(data['nc'])  # number of classes\n+    iouv = torch.linspace(0.5, 0.95, 10, device=device)  # iou vector for mAP@0.5:0.95\n+    niou = iouv.numel()\n+\n+    # Dataloader\n+    if not training:\n+        if pt and not single_cls:  # check --weights are trained on --data\n+            ncm = model.model.nc\n+            assert ncm == nc, f'{weights} ({ncm} classes) trained on different --data than what you passed ({nc} ' \\\n+                              f'classes). Pass correct combination of --weights and --data that are trained together.'\n+        model.warmup(imgsz=(1 if pt else batch_size, 3, imgsz, imgsz))  # warmup\n+        pad = 0.0 if task in ('speed', 'benchmark') else 0.5\n+        rect = False if task == 'benchmark' else pt  # square inference for benchmarks\n+        task = task if task in ('train', 'val', 'test') else 'val'  # path to train/val/test images\n+        dataloader = create_dataloader(data[task],\n+                                       imgsz,\n+                                       batch_size,\n+                                       stride,\n+                                       single_cls,\n+                                       pad=pad,\n+                                       rect=rect,\n+                                       workers=workers,\n+                                       prefix=colorstr(f'{task}: '),\n+                                       overlap_mask=overlap,\n+                                       mask_downsample_ratio=mask_downsample_ratio)[0]\n+\n+    seen = 0\n+    confusion_matrix = ConfusionMatrix(nc=nc)\n+    names = model.names if hasattr(model, 'names') else model.module.names  # get class names\n+    if isinstance(names, (list, tuple)):  # old format\n+        names = dict(enumerate(names))\n+    class_map = coco80_to_coco91_class() if is_coco else list(range(1000))\n+    s = ('%22s' + '%11s' * 10) % ('Class', 'Images', 'Instances', 'Box(P', \"R\", \"mAP50\", \"mAP50-95)\", \"Mask(P\", \"R\",\n+                                  \"mAP50\", \"mAP50-95)\")\n+    dt = Profile(), Profile(), Profile()\n+    metrics = Metrics()\n+    loss = torch.zeros(4, device=device)\n+    jdict, stats = [], []\n+    # callbacks.run('on_val_start')\n+    pbar = tqdm(dataloader, desc=s, bar_format='{l_bar}{bar:10}{r_bar}{bar:-10b}')  # progress bar\n+    for batch_i, (im, targets, paths, shapes, masks) in enumerate(pbar):\n+        # callbacks.run('on_val_batch_start')\n+        with dt[0]:\n+            if cuda:\n+                im = im.to(device, non_blocking=True)\n+                targets = targets.to(device)\n+                masks = masks.to(device)\n+            masks = masks.float()\n+            im = im.half() if half else im.float()  # uint8 to fp16/32\n+            im /= 255  # 0 - 255 to 0.0 - 1.0\n+            nb, _, height, width = im.shape  # batch size, channels, height, width\n+\n+        # Inference\n+        with dt[1]:\n+            preds, protos, train_out = model(im) if compute_loss else (*model(im, augment=augment)[:2], None)\n+\n+        # Loss\n+        if compute_loss:\n+            loss += compute_loss((train_out, protos), targets, masks)[1]  # box, obj, cls\n+\n+        # NMS\n+        targets[:, 2:] *= torch.tensor((width, height, width, height), device=device)  # to pixels\n+        lb = [targets[targets[:, 0] == i, 1:] for i in range(nb)] if save_hybrid else []  # for autolabelling\n+        with dt[2]:\n+            preds = non_max_suppression(preds,\n+                                        conf_thres,\n+                                        iou_thres,\n+                                        labels=lb,\n+                                        multi_label=True,\n+                                        agnostic=single_cls,\n+                                        max_det=max_det,\n+                                        nm=nm)\n+\n+        # Metrics\n+        plot_masks = []  # masks for plotting\n+        for si, (pred, proto) in enumerate(zip(preds, protos)):\n+            labels = targets[targets[:, 0] == si, 1:]\n+            nl, npr = labels.shape[0], pred.shape[0]  # number of labels, predictions\n+            path, shape = Path(paths[si]), shapes[si][0]\n+            correct_masks = torch.zeros(npr, niou, dtype=torch.bool, device=device)  # init\n+            correct_bboxes = torch.zeros(npr, niou, dtype=torch.bool, device=device)  # init\n+            seen += 1\n+\n+            if npr == 0:\n+                if nl:\n+                    stats.append((correct_masks, correct_bboxes, *torch.zeros((2, 0), device=device), labels[:, 0]))\n+                    if plots:\n+                        confusion_matrix.process_batch(detections=None, labels=labels[:, 0])\n+                continue\n+\n+            # Masks\n+            midx = [si] if overlap else targets[:, 0] == si\n+            gt_masks = masks[midx]\n+            pred_masks = process(proto, pred[:, 6:], pred[:, :4], shape=im[si].shape[1:])\n+\n+            # Predictions\n+            if single_cls:\n+                pred[:, 5] = 0\n+            predn = pred.clone()\n+            scale_coords(im[si].shape[1:], predn[:, :4], shape, shapes[si][1])  # native-space pred\n+\n+            # Evaluate\n+            if nl:\n+                tbox = xywh2xyxy(labels[:, 1:5])  # target boxes\n+                scale_coords(im[si].shape[1:], tbox, shape, shapes[si][1])  # native-space labels\n+                labelsn = torch.cat((labels[:, 0:1], tbox), 1)  # native-space labels\n+                correct_bboxes = process_batch(predn, labelsn, iouv)\n+                correct_masks = process_batch(predn, labelsn, iouv, pred_masks, gt_masks, overlap=overlap, masks=True)\n+                if plots:\n+                    confusion_matrix.process_batch(predn, labelsn)\n+            stats.append((correct_masks, correct_bboxes, pred[:, 4], pred[:, 5], labels[:, 0]))  # (conf, pcls, tcls)\n+\n+            pred_masks = torch.as_tensor(pred_masks, dtype=torch.uint8)\n+            if plots and batch_i < 3:\n+                plot_masks.append(pred_masks[:15].cpu())  # filter top 15 to plot\n+\n+            # Save/log\n+            if save_txt:\n+                save_one_txt(predn, save_conf, shape, file=save_dir / 'labels' / f'{path.stem}.txt')\n+            if save_json:\n+                pred_masks = scale_image(im[si].shape[1:],\n+                                         pred_masks.permute(1, 2, 0).contiguous().cpu().numpy(), shape, shapes[si][1])\n+                save_one_json(predn, jdict, path, class_map, pred_masks)  # append to COCO-JSON dictionary\n+            # callbacks.run('on_val_image_end', pred, predn, path, names, im[si])\n+\n+        # Plot images\n+        if plots and batch_i < 3:\n+            if len(plot_masks):\n+                plot_masks = torch.cat(plot_masks, dim=0)\n+            plot_images_and_masks(im, targets, masks, paths, save_dir / f'val_batch{batch_i}_labels.jpg', names)\n+            plot_images_and_masks(im, output_to_target(preds, max_det=15), plot_masks, paths,\n+                                  save_dir / f'val_batch{batch_i}_pred.jpg', names)  # pred\n+\n+        # callbacks.run('on_val_batch_end')\n+\n+    # Compute metrics\n+    stats = [torch.cat(x, 0).cpu().numpy() for x in zip(*stats)]  # to numpy\n+    if len(stats) and stats[0].any():\n+        results = ap_per_class_box_and_mask(*stats, plot=plots, save_dir=save_dir, names=names)\n+        metrics.update(results)\n+    nt = np.bincount(stats[4].astype(int), minlength=nc)  # number of targets per class\n+\n+    # Print results\n+    pf = '%22s' + '%11i' * 2 + '%11.3g' * 8  # print format\n+    LOGGER.info(pf % (\"all\", seen, nt.sum(), *metrics.mean_results()))\n+    if nt.sum() == 0:\n+        LOGGER.warning(f'WARNING: no labels found in {task} set, can not compute metrics without labels ⚠️')\n+\n+    # Print results per class\n+    if (verbose or (nc < 50 and not training)) and nc > 1 and len(stats):\n+        for i, c in enumerate(metrics.ap_class_index):\n+            LOGGER.info(pf % (names[c], seen, nt[c], *metrics.class_result(i)))\n+\n+    # Print speeds\n+    t = tuple(x.t / seen * 1E3 for x in dt)  # speeds per image\n+    if not training:\n+        shape = (batch_size, 3, imgsz, imgsz)\n+        LOGGER.info(f'Speed: %.1fms pre-process, %.1fms inference, %.1fms NMS per image at shape {shape}' % t)\n+\n+    # Plots\n+    if plots:\n+        confusion_matrix.plot(save_dir=save_dir, names=list(names.values()))\n+    # callbacks.run('on_val_end')\n+\n+    mp_bbox, mr_bbox, map50_bbox, map_bbox, mp_mask, mr_mask, map50_mask, map_mask = metrics.mean_results()\n+\n+    # Save JSON\n+    if save_json and len(jdict):\n+        w = Path(weights[0] if isinstance(weights, list) else weights).stem if weights is not None else ''  # weights\n+        anno_json = str(Path(data.get('path', '../coco')) / 'annotations/instances_val2017.json')  # annotations json\n+        pred_json = str(save_dir / f\"{w}_predictions.json\")  # predictions json\n+        LOGGER.info(f'\\nEvaluating pycocotools mAP... saving {pred_json}...')\n+        with open(pred_json, 'w') as f:\n+            json.dump(jdict, f)\n+\n+        try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n+            from pycocotools.coco import COCO\n+            from pycocotools.cocoeval import COCOeval\n+\n+            anno = COCO(anno_json)  # init annotations api\n+            pred = anno.loadRes(pred_json)  # init predictions api\n+            results = []\n+            for eval in COCOeval(anno, pred, 'bbox'), COCOeval(anno, pred, 'segm'):\n+                if is_coco:\n+                    eval.params.imgIds = [int(Path(x).stem) for x in dataloader.dataset.im_files]  # img ID to evaluate\n+                eval.evaluate()\n+                eval.accumulate()\n+                eval.summarize()\n+                results.extend(eval.stats[:2])  # update results (mAP@0.5:0.95, mAP@0.5)\n+            map_bbox, map50_bbox, map_mask, map50_mask = results\n+        except Exception as e:\n+            LOGGER.info(f'pycocotools unable to run: {e}')\n+\n+    # Return results\n+    model.float()  # for training\n+    if not training:\n+        s = f\"\\n{len(list(save_dir.glob('labels/*.txt')))} labels saved to {save_dir / 'labels'}\" if save_txt else ''\n+        LOGGER.info(f\"Results saved to {colorstr('bold', save_dir)}{s}\")\n+    final_metric = mp_bbox, mr_bbox, map50_bbox, map_bbox, mp_mask, mr_mask, map50_mask, map_mask\n+    return (*final_metric, *(loss.cpu() / len(dataloader)).tolist()), metrics.get_maps(nc), t\n+\n+\n+def parse_opt():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--data', type=str, default=ROOT / 'data/coco128-seg.yaml', help='dataset.yaml path')\n+    parser.add_argument('--weights', nargs='+', type=str, default=ROOT / 'yolov5s-seg.pt', help='model path(s)')\n+    parser.add_argument('--batch-size', type=int, default=32, help='batch size')\n+    parser.add_argument('--imgsz', '--img', '--img-size', type=int, default=640, help='inference size (pixels)')\n+    parser.add_argument('--conf-thres', type=float, default=0.001, help='confidence threshold')\n+    parser.add_argument('--iou-thres', type=float, default=0.6, help='NMS IoU threshold')\n+    parser.add_argument('--max-det', type=int, default=300, help='maximum detections per image')\n+    parser.add_argument('--task', default='val', help='train, val, test, speed or study')\n+    parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')\n+    parser.add_argument('--workers', type=int, default=8, help='max dataloader workers (per RANK in DDP mode)')\n+    parser.add_argument('--single-cls', action='store_true', help='treat as single-class dataset')\n+    parser.add_argument('--augment', action='store_true', help='augmented inference')\n+    parser.add_argument('--verbose', action='store_true', help='report mAP by class')\n+    parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')\n+    parser.add_argument('--save-hybrid', action='store_true', help='save label+prediction hybrid results to *.txt')\n+    parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')\n+    parser.add_argument('--save-json', action='store_true', help='save a COCO-JSON results file')\n+    parser.add_argument('--project', default=ROOT / 'runs/val-seg', help='save results to project/name')\n+    parser.add_argument('--name', default='exp', help='save to project/name')\n+    parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')\n+    parser.add_argument('--half', action='store_true', help='use FP16 half-precision inference')\n+    parser.add_argument('--dnn', action='store_true', help='use OpenCV DNN for ONNX inference')\n+    opt = parser.parse_args()\n+    opt.data = check_yaml(opt.data)  # check YAML\n+    # opt.save_json |= opt.data.endswith('coco.yaml')\n+    opt.save_txt |= opt.save_hybrid\n+    print_args(vars(opt))\n+    return opt\n+\n+\n+def main(opt):\n+    check_requirements(requirements=ROOT / 'requirements.txt', exclude=('tensorboard', 'thop'))\n+\n+    if opt.task in ('train', 'val', 'test'):  # run normally\n+        if opt.conf_thres > 0.001:  # https://github.com/ultralytics/yolov5/issues/1466\n+            LOGGER.info(f'WARNING: confidence threshold {opt.conf_thres} > 0.001 produces invalid results ⚠️')\n+        if opt.save_hybrid:\n+            LOGGER.info('WARNING: --save-hybrid will return high mAP from hybrid labels, not from predictions alone ⚠️')\n+        run(**vars(opt))\n+\n+    else:\n+        weights = opt.weights if isinstance(opt.weights, list) else [opt.weights]\n+        opt.half = True  # FP16 for fastest results\n+        if opt.task == 'speed':  # speed benchmarks\n+            # python val.py --task speed --data coco.yaml --batch 1 --weights yolov5n.pt yolov5s.pt...\n+            opt.conf_thres, opt.iou_thres, opt.save_json = 0.25, 0.45, False\n+            for opt.weights in weights:\n+                run(**vars(opt), plots=False)\n+\n+        elif opt.task == 'study':  # speed vs mAP benchmarks\n+            # python val.py --task study --data coco.yaml --iou 0.7 --weights yolov5n.pt yolov5s.pt...\n+            for opt.weights in weights:\n+                f = f'study_{Path(opt.data).stem}_{Path(opt.weights).stem}.txt'  # filename to save to\n+                x, y = list(range(256, 1536 + 128, 128)), []  # x axis (image sizes), y axis\n+                for opt.imgsz in x:  # img-size\n+                    LOGGER.info(f'\\nRunning {f} --imgsz {opt.imgsz}...')\n+                    r, _, t = run(**vars(opt), plots=False)\n+                    y.append(r + t)  # results and times\n+                np.savetxt(f, y, fmt='%10.4g')  # save\n+            os.system('zip -r study.zip study_*.txt')\n+            plot_val_study(x=x)  # plot\n+\n+\n+if __name__ == \"__main__\":\n+    opt = parse_opt()\n+    main(opt)\ndiff --git a/utils/segment/augmentations.py b/utils/segment/augmentations.py\nnew file mode 100644\nindex 000000000000..169addedf0f5\n--- /dev/null\n+++ b/utils/segment/augmentations.py\n@@ -0,0 +1,104 @@\n+# YOLOv5 🚀 by Ultralytics, GPL-3.0 license\n+\"\"\"\n+Image augmentation functions\n+\"\"\"\n+\n+import math\n+import random\n+\n+import cv2\n+import numpy as np\n+\n+from ..augmentations import box_candidates\n+from ..general import resample_segments, segment2box\n+\n+\n+def mixup(im, labels, segments, im2, labels2, segments2):\n+    # Applies MixUp augmentation https://arxiv.org/pdf/1710.09412.pdf\n+    r = np.random.beta(32.0, 32.0)  # mixup ratio, alpha=beta=32.0\n+    im = (im * r + im2 * (1 - r)).astype(np.uint8)\n+    labels = np.concatenate((labels, labels2), 0)\n+    segments = np.concatenate((segments, segments2), 0)\n+    return im, labels, segments\n+\n+\n+def random_perspective(im,\n+                       targets=(),\n+                       segments=(),\n+                       degrees=10,\n+                       translate=.1,\n+                       scale=.1,\n+                       shear=10,\n+                       perspective=0.0,\n+                       border=(0, 0)):\n+    # torchvision.transforms.RandomAffine(degrees=(-10, 10), translate=(.1, .1), scale=(.9, 1.1), shear=(-10, 10))\n+    # targets = [cls, xyxy]\n+\n+    height = im.shape[0] + border[0] * 2  # shape(h,w,c)\n+    width = im.shape[1] + border[1] * 2\n+\n+    # Center\n+    C = np.eye(3)\n+    C[0, 2] = -im.shape[1] / 2  # x translation (pixels)\n+    C[1, 2] = -im.shape[0] / 2  # y translation (pixels)\n+\n+    # Perspective\n+    P = np.eye(3)\n+    P[2, 0] = random.uniform(-perspective, perspective)  # x perspective (about y)\n+    P[2, 1] = random.uniform(-perspective, perspective)  # y perspective (about x)\n+\n+    # Rotation and Scale\n+    R = np.eye(3)\n+    a = random.uniform(-degrees, degrees)\n+    # a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations\n+    s = random.uniform(1 - scale, 1 + scale)\n+    # s = 2 ** random.uniform(-scale, scale)\n+    R[:2] = cv2.getRotationMatrix2D(angle=a, center=(0, 0), scale=s)\n+\n+    # Shear\n+    S = np.eye(3)\n+    S[0, 1] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # x shear (deg)\n+    S[1, 0] = math.tan(random.uniform(-shear, shear) * math.pi / 180)  # y shear (deg)\n+\n+    # Translation\n+    T = np.eye(3)\n+    T[0, 2] = (random.uniform(0.5 - translate, 0.5 + translate) * width)  # x translation (pixels)\n+    T[1, 2] = (random.uniform(0.5 - translate, 0.5 + translate) * height)  # y translation (pixels)\n+\n+    # Combined rotation matrix\n+    M = T @ S @ R @ P @ C  # order of operations (right to left) is IMPORTANT\n+    if (border[0] != 0) or (border[1] != 0) or (M != np.eye(3)).any():  # image changed\n+        if perspective:\n+            im = cv2.warpPerspective(im, M, dsize=(width, height), borderValue=(114, 114, 114))\n+        else:  # affine\n+            im = cv2.warpAffine(im, M[:2], dsize=(width, height), borderValue=(114, 114, 114))\n+\n+    # Visualize\n+    # import matplotlib.pyplot as plt\n+    # ax = plt.subplots(1, 2, figsize=(12, 6))[1].ravel()\n+    # ax[0].imshow(im[:, :, ::-1])  # base\n+    # ax[1].imshow(im2[:, :, ::-1])  # warped\n+\n+    # Transform label coordinates\n+    n = len(targets)\n+    new_segments = []\n+    if n:\n+        new = np.zeros((n, 4))\n+        segments = resample_segments(segments)  # upsample\n+        for i, segment in enumerate(segments):\n+            xy = np.ones((len(segment), 3))\n+            xy[:, :2] = segment\n+            xy = xy @ M.T  # transform\n+            xy = (xy[:, :2] / xy[:, 2:3] if perspective else xy[:, :2])  # perspective rescale or affine\n+\n+            # clip\n+            new[i] = segment2box(xy, width, height)\n+            new_segments.append(xy)\n+\n+        # filter candidates\n+        i = box_candidates(box1=targets[:, 1:5].T * s, box2=new.T, area_thr=0.01)\n+        targets = targets[i]\n+        targets[:, 1:5] = new[i]\n+        new_segments = np.array(new_segments)[i]\n+\n+    return im, targets, new_segments\ndiff --git a/utils/segment/dataloaders.py b/utils/segment/dataloaders.py\nnew file mode 100644\nindex 000000000000..f6fe642d077f\n--- /dev/null\n+++ b/utils/segment/dataloaders.py\n@@ -0,0 +1,330 @@\n+# YOLOv5 🚀 by Ultralytics, GPL-3.0 license\n+\"\"\"\n+Dataloaders\n+\"\"\"\n+\n+import os\n+import random\n+\n+import cv2\n+import numpy as np\n+import torch\n+from torch.utils.data import DataLoader, distributed\n+\n+from ..augmentations import augment_hsv, copy_paste, letterbox\n+from ..dataloaders import InfiniteDataLoader, LoadImagesAndLabels, seed_worker\n+from ..general import LOGGER, xyn2xy, xywhn2xyxy, xyxy2xywhn\n+from ..torch_utils import torch_distributed_zero_first\n+from .augmentations import mixup, random_perspective\n+\n+\n+def create_dataloader(path,\n+                      imgsz,\n+                      batch_size,\n+                      stride,\n+                      single_cls=False,\n+                      hyp=None,\n+                      augment=False,\n+                      cache=False,\n+                      pad=0.0,\n+                      rect=False,\n+                      rank=-1,\n+                      workers=8,\n+                      image_weights=False,\n+                      quad=False,\n+                      prefix='',\n+                      shuffle=False,\n+                      mask_downsample_ratio=1,\n+                      overlap_mask=False):\n+    if rect and shuffle:\n+        LOGGER.warning('WARNING: --rect is incompatible with DataLoader shuffle, setting shuffle=False')\n+        shuffle = False\n+    with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP\n+        dataset = LoadImagesAndLabelsAndMasks(\n+            path,\n+            imgsz,\n+            batch_size,\n+            augment=augment,  # augmentation\n+            hyp=hyp,  # hyperparameters\n+            rect=rect,  # rectangular batches\n+            cache_images=cache,\n+            single_cls=single_cls,\n+            stride=int(stride),\n+            pad=pad,\n+            image_weights=image_weights,\n+            prefix=prefix,\n+            downsample_ratio=mask_downsample_ratio,\n+            overlap=overlap_mask)\n+\n+    batch_size = min(batch_size, len(dataset))\n+    nd = torch.cuda.device_count()  # number of CUDA devices\n+    nw = min([os.cpu_count() // max(nd, 1), batch_size if batch_size > 1 else 0, workers])  # number of workers\n+    sampler = None if rank == -1 else distributed.DistributedSampler(dataset, shuffle=shuffle)\n+    loader = DataLoader if image_weights else InfiniteDataLoader  # only DataLoader allows for attribute updates\n+    # generator = torch.Generator()\n+    # generator.manual_seed(0)\n+    return loader(\n+        dataset,\n+        batch_size=batch_size,\n+        shuffle=shuffle and sampler is None,\n+        num_workers=nw,\n+        sampler=sampler,\n+        pin_memory=True,\n+        collate_fn=LoadImagesAndLabelsAndMasks.collate_fn4 if quad else LoadImagesAndLabelsAndMasks.collate_fn,\n+        worker_init_fn=seed_worker,\n+        # generator=generator,\n+    ), dataset\n+\n+\n+class LoadImagesAndLabelsAndMasks(LoadImagesAndLabels):  # for training/testing\n+\n+    def __init__(\n+        self,\n+        path,\n+        img_size=640,\n+        batch_size=16,\n+        augment=False,\n+        hyp=None,\n+        rect=False,\n+        image_weights=False,\n+        cache_images=False,\n+        single_cls=False,\n+        stride=32,\n+        pad=0,\n+        prefix=\"\",\n+        downsample_ratio=1,\n+        overlap=False,\n+    ):\n+        super().__init__(path, img_size, batch_size, augment, hyp, rect, image_weights, cache_images, single_cls,\n+                         stride, pad, prefix)\n+        self.downsample_ratio = downsample_ratio\n+        self.overlap = overlap\n+\n+    def __getitem__(self, index):\n+        index = self.indices[index]  # linear, shuffled, or image_weights\n+\n+        hyp = self.hyp\n+        mosaic = self.mosaic and random.random() < hyp['mosaic']\n+        masks = []\n+        if mosaic:\n+            # Load mosaic\n+            img, labels, segments = self.load_mosaic(index)\n+            shapes = None\n+\n+            # MixUp augmentation\n+            if random.random() < hyp[\"mixup\"]:\n+                img, labels, segments = mixup(img, labels, segments, *self.load_mosaic(random.randint(0, self.n - 1)))\n+\n+        else:\n+            # Load image\n+            img, (h0, w0), (h, w) = self.load_image(index)\n+\n+            # Letterbox\n+            shape = self.batch_shapes[self.batch[index]] if self.rect else self.img_size  # final letterboxed shape\n+            img, ratio, pad = letterbox(img, shape, auto=False, scaleup=self.augment)\n+            shapes = (h0, w0), ((h / h0, w / w0), pad)  # for COCO mAP rescaling\n+\n+            labels = self.labels[index].copy()\n+            # [array, array, ....], array.shape=(num_points, 2), xyxyxyxy\n+            segments = self.segments[index].copy()\n+            if len(segments):\n+                for i_s in range(len(segments)):\n+                    segments[i_s] = xyn2xy(\n+                        segments[i_s],\n+                        ratio[0] * w,\n+                        ratio[1] * h,\n+                        padw=pad[0],\n+                        padh=pad[1],\n+                    )\n+            if labels.size:  # normalized xywh to pixel xyxy format\n+                labels[:, 1:] = xywhn2xyxy(labels[:, 1:], ratio[0] * w, ratio[1] * h, padw=pad[0], padh=pad[1])\n+\n+            if self.augment:\n+                img, labels, segments = random_perspective(\n+                    img,\n+                    labels,\n+                    segments=segments,\n+                    degrees=hyp[\"degrees\"],\n+                    translate=hyp[\"translate\"],\n+                    scale=hyp[\"scale\"],\n+                    shear=hyp[\"shear\"],\n+                    perspective=hyp[\"perspective\"],\n+                    return_seg=True,\n+                )\n+\n+        nl = len(labels)  # number of labels\n+        if nl:\n+            labels[:, 1:5] = xyxy2xywhn(labels[:, 1:5], w=img.shape[1], h=img.shape[0], clip=True, eps=1e-3)\n+            if self.overlap:\n+                masks, sorted_idx = polygons2masks_overlap(img.shape[:2],\n+                                                           segments,\n+                                                           downsample_ratio=self.downsample_ratio)\n+                masks = masks[None]  # (640, 640) -> (1, 640, 640)\n+                labels = labels[sorted_idx]\n+            else:\n+                masks = polygons2masks(img.shape[:2], segments, color=1, downsample_ratio=self.downsample_ratio)\n+\n+        masks = (torch.from_numpy(masks) if len(masks) else torch.zeros(1 if self.overlap else nl, img.shape[0] //\n+                                                                        self.downsample_ratio, img.shape[1] //\n+                                                                        self.downsample_ratio))\n+        # TODO: albumentations support\n+        if self.augment:\n+            # Albumentations\n+            # there are some augmentation that won't change boxes and masks,\n+            # so just be it for now.\n+            img, labels = self.albumentations(img, labels)\n+            nl = len(labels)  # update after albumentations\n+\n+            # HSV color-space\n+            augment_hsv(img, hgain=hyp[\"hsv_h\"], sgain=hyp[\"hsv_s\"], vgain=hyp[\"hsv_v\"])\n+\n+            # Flip up-down\n+            if random.random() < hyp[\"flipud\"]:\n+                img = np.flipud(img)\n+                if nl:\n+                    labels[:, 2] = 1 - labels[:, 2]\n+                    masks = torch.flip(masks, dims=[1])\n+\n+            # Flip left-right\n+            if random.random() < hyp[\"fliplr\"]:\n+                img = np.fliplr(img)\n+                if nl:\n+                    labels[:, 1] = 1 - labels[:, 1]\n+                    masks = torch.flip(masks, dims=[2])\n+\n+            # Cutouts  # labels = cutout(img, labels, p=0.5)\n+\n+        labels_out = torch.zeros((nl, 6))\n+        if nl:\n+            labels_out[:, 1:] = torch.from_numpy(labels)\n+\n+        # Convert\n+        img = img.transpose((2, 0, 1))[::-1]  # HWC to CHW, BGR to RGB\n+        img = np.ascontiguousarray(img)\n+\n+        return (torch.from_numpy(img), labels_out, self.im_files[index], shapes, masks)\n+\n+    def load_mosaic(self, index):\n+        # YOLOv5 4-mosaic loader. Loads 1 image + 3 random images into a 4-image mosaic\n+        labels4, segments4 = [], []\n+        s = self.img_size\n+        yc, xc = (int(random.uniform(-x, 2 * s + x)) for x in self.mosaic_border)  # mosaic center x, y\n+\n+        # 3 additional image indices\n+        indices = [index] + random.choices(self.indices, k=3)  # 3 additional image indices\n+        for i, index in enumerate(indices):\n+            # Load image\n+            img, _, (h, w) = self.load_image(index)\n+\n+            # place img in img4\n+            if i == 0:  # top left\n+                img4 = np.full((s * 2, s * 2, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles\n+                x1a, y1a, x2a, y2a = max(xc - w, 0), max(yc - h, 0), xc, yc  # xmin, ymin, xmax, ymax (large image)\n+                x1b, y1b, x2b, y2b = w - (x2a - x1a), h - (y2a - y1a), w, h  # xmin, ymin, xmax, ymax (small image)\n+            elif i == 1:  # top right\n+                x1a, y1a, x2a, y2a = xc, max(yc - h, 0), min(xc + w, s * 2), yc\n+                x1b, y1b, x2b, y2b = 0, h - (y2a - y1a), min(w, x2a - x1a), h\n+            elif i == 2:  # bottom left\n+                x1a, y1a, x2a, y2a = max(xc - w, 0), yc, xc, min(s * 2, yc + h)\n+                x1b, y1b, x2b, y2b = w - (x2a - x1a), 0, w, min(y2a - y1a, h)\n+            elif i == 3:  # bottom right\n+                x1a, y1a, x2a, y2a = xc, yc, min(xc + w, s * 2), min(s * 2, yc + h)\n+                x1b, y1b, x2b, y2b = 0, 0, min(w, x2a - x1a), min(y2a - y1a, h)\n+\n+            img4[y1a:y2a, x1a:x2a] = img[y1b:y2b, x1b:x2b]  # img4[ymin:ymax, xmin:xmax]\n+            padw = x1a - x1b\n+            padh = y1a - y1b\n+\n+            labels, segments = self.labels[index].copy(), self.segments[index].copy()\n+\n+            if labels.size:\n+                labels[:, 1:] = xywhn2xyxy(labels[:, 1:], w, h, padw, padh)  # normalized xywh to pixel xyxy format\n+                segments = [xyn2xy(x, w, h, padw, padh) for x in segments]\n+            labels4.append(labels)\n+            segments4.extend(segments)\n+\n+        # Concat/clip labels\n+        labels4 = np.concatenate(labels4, 0)\n+        for x in (labels4[:, 1:], *segments4):\n+            np.clip(x, 0, 2 * s, out=x)  # clip when using random_perspective()\n+        # img4, labels4 = replicate(img4, labels4)  # replicate\n+\n+        # Augment\n+        img4, labels4, segments4 = copy_paste(img4, labels4, segments4, p=self.hyp[\"copy_paste\"])\n+        img4, labels4, segments4 = random_perspective(img4,\n+                                                      labels4,\n+                                                      segments4,\n+                                                      degrees=self.hyp[\"degrees\"],\n+                                                      translate=self.hyp[\"translate\"],\n+                                                      scale=self.hyp[\"scale\"],\n+                                                      shear=self.hyp[\"shear\"],\n+                                                      perspective=self.hyp[\"perspective\"],\n+                                                      border=self.mosaic_border)  # border to remove\n+        return img4, labels4, segments4\n+\n+    @staticmethod\n+    def collate_fn(batch):\n+        img, label, path, shapes, masks = zip(*batch)  # transposed\n+        batched_masks = torch.cat(masks, 0)\n+        for i, l in enumerate(label):\n+            l[:, 0] = i  # add target image index for build_targets()\n+        return torch.stack(img, 0), torch.cat(label, 0), path, shapes, batched_masks\n+\n+\n+def polygon2mask(img_size, polygons, color=1, downsample_ratio=1):\n+    \"\"\"\n+    Args:\n+        img_size (tuple): The image size.\n+        polygons (np.ndarray): [N, M], N is the number of polygons,\n+            M is the number of points(Be divided by 2).\n+    \"\"\"\n+    mask = np.zeros(img_size, dtype=np.uint8)\n+    polygons = np.asarray(polygons)\n+    polygons = polygons.astype(np.int32)\n+    shape = polygons.shape\n+    polygons = polygons.reshape(shape[0], -1, 2)\n+    cv2.fillPoly(mask, polygons, color=color)\n+    nh, nw = (img_size[0] // downsample_ratio, img_size[1] // downsample_ratio)\n+    # NOTE: fillPoly firstly then resize is trying the keep the same way\n+    # of loss calculation when mask-ratio=1.\n+    mask = cv2.resize(mask, (nw, nh))\n+    return mask\n+\n+\n+def polygons2masks(img_size, polygons, color, downsample_ratio=1):\n+    \"\"\"\n+    Args:\n+        img_size (tuple): The image size.\n+        polygons (list[np.ndarray]): each polygon is [N, M],\n+            N is the number of polygons,\n+            M is the number of points(Be divided by 2).\n+    \"\"\"\n+    masks = []\n+    for si in range(len(polygons)):\n+        mask = polygon2mask(img_size, [polygons[si].reshape(-1)], color, downsample_ratio)\n+        masks.append(mask)\n+    return np.array(masks)\n+\n+\n+def polygons2masks_overlap(img_size, segments, downsample_ratio=1):\n+    \"\"\"Return a (640, 640) overlap mask.\"\"\"\n+    masks = np.zeros((img_size[0] // downsample_ratio, img_size[1] // downsample_ratio), dtype=np.uint8)\n+    areas = []\n+    ms = []\n+    for si in range(len(segments)):\n+        mask = polygon2mask(\n+            img_size,\n+            [segments[si].reshape(-1)],\n+            downsample_ratio=downsample_ratio,\n+            color=1,\n+        )\n+        ms.append(mask)\n+        areas.append(mask.sum())\n+    areas = np.asarray(areas)\n+    index = np.argsort(-areas)\n+    ms = np.array(ms)[index]\n+    for i in range(len(segments)):\n+        mask = ms[i] * (i + 1)\n+        masks = masks + mask\n+        masks = np.clip(masks, a_min=0, a_max=i + 1)\n+    return masks, index\ndiff --git a/utils/segment/general.py b/utils/segment/general.py\nnew file mode 100644\nindex 000000000000..36547ed0889c\n--- /dev/null\n+++ b/utils/segment/general.py\n@@ -0,0 +1,120 @@\n+import cv2\n+import torch\n+import torch.nn.functional as F\n+\n+\n+def crop_mask(masks, boxes):\n+    \"\"\"\n+    \"Crop\" predicted masks by zeroing out everything not in the predicted bbox.\n+    Vectorized by Chong (thanks Chong).\n+\n+    Args:\n+        - masks should be a size [h, w, n] tensor of masks\n+        - boxes should be a size [n, 4] tensor of bbox coords in relative point form\n+    \"\"\"\n+\n+    n, h, w = masks.shape\n+    x1, y1, x2, y2 = torch.chunk(boxes[:, :, None], 4, 1)  # x1 shape(1,1,n)\n+    r = torch.arange(w, device=masks.device, dtype=x1.dtype)[None, None, :]  # rows shape(1,w,1)\n+    c = torch.arange(h, device=masks.device, dtype=x1.dtype)[None, :, None]  # cols shape(h,1,1)\n+\n+    return masks * ((r >= x1) * (r < x2) * (c >= y1) * (c < y2))\n+\n+\n+def process_mask_upsample(protos, masks_in, bboxes, shape):\n+    \"\"\"\n+    Crop after upsample.\n+    proto_out: [mask_dim, mask_h, mask_w]\n+    out_masks: [n, mask_dim], n is number of masks after nms\n+    bboxes: [n, 4], n is number of masks after nms\n+    shape:input_image_size, (h, w)\n+\n+    return: h, w, n\n+    \"\"\"\n+\n+    c, mh, mw = protos.shape  # CHW\n+    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)\n+    masks = F.interpolate(masks[None], shape, mode='bilinear', align_corners=False)[0]  # CHW\n+    masks = crop_mask(masks, bboxes)  # CHW\n+    return masks.gt_(0.5)\n+\n+\n+def process_mask(protos, masks_in, bboxes, shape, upsample=False):\n+    \"\"\"\n+    Crop before upsample.\n+    proto_out: [mask_dim, mask_h, mask_w]\n+    out_masks: [n, mask_dim], n is number of masks after nms\n+    bboxes: [n, 4], n is number of masks after nms\n+    shape:input_image_size, (h, w)\n+\n+    return: h, w, n\n+    \"\"\"\n+\n+    c, mh, mw = protos.shape  # CHW\n+    ih, iw = shape\n+    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)  # CHW\n+\n+    downsampled_bboxes = bboxes.clone()\n+    downsampled_bboxes[:, 0] *= mw / iw\n+    downsampled_bboxes[:, 2] *= mw / iw\n+    downsampled_bboxes[:, 3] *= mh / ih\n+    downsampled_bboxes[:, 1] *= mh / ih\n+\n+    masks = crop_mask(masks, downsampled_bboxes)  # CHW\n+    if upsample:\n+        masks = F.interpolate(masks[None], shape, mode='bilinear', align_corners=False)[0]  # CHW\n+    return masks.gt_(0.5)\n+\n+\n+def scale_image(im1_shape, masks, im0_shape, ratio_pad=None):\n+    \"\"\"\n+    img1_shape: model input shape, [h, w]\n+    img0_shape: origin pic shape, [h, w, 3]\n+    masks: [h, w, num]\n+    \"\"\"\n+    # Rescale coordinates (xyxy) from im1_shape to im0_shape\n+    if ratio_pad is None:  # calculate from im0_shape\n+        gain = min(im1_shape[0] / im0_shape[0], im1_shape[1] / im0_shape[1])  # gain  = old / new\n+        pad = (im1_shape[1] - im0_shape[1] * gain) / 2, (im1_shape[0] - im0_shape[0] * gain) / 2  # wh padding\n+    else:\n+        pad = ratio_pad[1]\n+    top, left = int(pad[1]), int(pad[0])  # y, x\n+    bottom, right = int(im1_shape[0] - pad[1]), int(im1_shape[1] - pad[0])\n+\n+    if len(masks.shape) < 2:\n+        raise ValueError(f'\"len of masks shape\" should be 2 or 3, but got {len(masks.shape)}')\n+    masks = masks[top:bottom, left:right]\n+    # masks = masks.permute(2, 0, 1).contiguous()\n+    # masks = F.interpolate(masks[None], im0_shape[:2], mode='bilinear', align_corners=False)[0]\n+    # masks = masks.permute(1, 2, 0).contiguous()\n+    masks = cv2.resize(masks, (im0_shape[1], im0_shape[0]))\n+\n+    if len(masks.shape) == 2:\n+        masks = masks[:, :, None]\n+    return masks\n+\n+\n+def mask_iou(mask1, mask2, eps=1e-7):\n+    \"\"\"\n+    mask1: [N, n] m1 means number of predicted objects\n+    mask2: [M, n] m2 means number of gt objects\n+    Note: n means image_w x image_h\n+\n+    return: masks iou, [N, M]\n+    \"\"\"\n+    intersection = torch.matmul(mask1, mask2.t()).clamp(0)\n+    union = (mask1.sum(1)[:, None] + mask2.sum(1)[None]) - intersection  # (area1 + area2) - intersection\n+    return intersection / (union + eps)\n+\n+\n+def masks_iou(mask1, mask2, eps=1e-7):\n+    \"\"\"\n+    mask1: [N, n] m1 means number of predicted objects\n+    mask2: [N, n] m2 means number of gt objects\n+    Note: n means image_w x image_h\n+\n+    return: masks iou, (N, )\n+    \"\"\"\n+    intersection = (mask1 * mask2).sum(1).clamp(0)  # (N, )\n+    union = (mask1.sum(1) + mask2.sum(1))[None] - intersection  # (area1 + area2) - intersection\n+    return intersection / (union + eps)\ndiff --git a/utils/segment/loss.py b/utils/segment/loss.py\nnew file mode 100644\nindex 000000000000..b45b2c27e0a0\n--- /dev/null\n+++ b/utils/segment/loss.py\n@@ -0,0 +1,186 @@\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+\n+from ..general import xywh2xyxy\n+from ..loss import FocalLoss, smooth_BCE\n+from ..metrics import bbox_iou\n+from ..torch_utils import de_parallel\n+from .general import crop_mask\n+\n+\n+class ComputeLoss:\n+    # Compute losses\n+    def __init__(self, model, autobalance=False, overlap=False):\n+        self.sort_obj_iou = False\n+        self.overlap = overlap\n+        device = next(model.parameters()).device  # get model device\n+        h = model.hyp  # hyperparameters\n+        self.device = device\n+\n+        # Define criteria\n+        BCEcls = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h['cls_pw']], device=device))\n+        BCEobj = nn.BCEWithLogitsLoss(pos_weight=torch.tensor([h['obj_pw']], device=device))\n+\n+        # Class label smoothing https://arxiv.org/pdf/1902.04103.pdf eqn 3\n+        self.cp, self.cn = smooth_BCE(eps=h.get('label_smoothing', 0.0))  # positive, negative BCE targets\n+\n+        # Focal loss\n+        g = h['fl_gamma']  # focal loss gamma\n+        if g > 0:\n+            BCEcls, BCEobj = FocalLoss(BCEcls, g), FocalLoss(BCEobj, g)\n+\n+        m = de_parallel(model).model[-1]  # Detect() module\n+        self.balance = {3: [4.0, 1.0, 0.4]}.get(m.nl, [4.0, 1.0, 0.25, 0.06, 0.02])  # P3-P7\n+        self.ssi = list(m.stride).index(16) if autobalance else 0  # stride 16 index\n+        self.BCEcls, self.BCEobj, self.gr, self.hyp, self.autobalance = BCEcls, BCEobj, 1.0, h, autobalance\n+        self.na = m.na  # number of anchors\n+        self.nc = m.nc  # number of classes\n+        self.nl = m.nl  # number of layers\n+        self.nm = m.nm  # number of masks\n+        self.anchors = m.anchors\n+        self.device = device\n+\n+    def __call__(self, preds, targets, masks):  # predictions, targets, model\n+        p, proto = preds\n+        bs, nm, mask_h, mask_w = proto.shape  # batch size, number of masks, mask height, mask width\n+        lcls = torch.zeros(1, device=self.device)\n+        lbox = torch.zeros(1, device=self.device)\n+        lobj = torch.zeros(1, device=self.device)\n+        lseg = torch.zeros(1, device=self.device)\n+        tcls, tbox, indices, anchors, tidxs, xywhn = self.build_targets(p, targets)  # targets\n+\n+        # Losses\n+        for i, pi in enumerate(p):  # layer index, layer predictions\n+            b, a, gj, gi = indices[i]  # image, anchor, gridy, gridx\n+            tobj = torch.zeros(pi.shape[:4], dtype=pi.dtype, device=self.device)  # target obj\n+\n+            n = b.shape[0]  # number of targets\n+            if n:\n+                pxy, pwh, _, pcls, pmask = pi[b, a, gj, gi].split((2, 2, 1, self.nc, nm), 1)  # subset of predictions\n+\n+                # Box regression\n+                pxy = pxy.sigmoid() * 2 - 0.5\n+                pwh = (pwh.sigmoid() * 2) ** 2 * anchors[i]\n+                pbox = torch.cat((pxy, pwh), 1)  # predicted box\n+                iou = bbox_iou(pbox, tbox[i], CIoU=True).squeeze()  # iou(prediction, target)\n+                lbox += (1.0 - iou).mean()  # iou loss\n+\n+                # Objectness\n+                iou = iou.detach().clamp(0).type(tobj.dtype)\n+                if self.sort_obj_iou:\n+                    j = iou.argsort()\n+                    b, a, gj, gi, iou = b[j], a[j], gj[j], gi[j], iou[j]\n+                if self.gr < 1:\n+                    iou = (1.0 - self.gr) + self.gr * iou\n+                tobj[b, a, gj, gi] = iou  # iou ratio\n+\n+                # Classification\n+                if self.nc > 1:  # cls loss (only if multiple classes)\n+                    t = torch.full_like(pcls, self.cn, device=self.device)  # targets\n+                    t[range(n), tcls[i]] = self.cp\n+                    lcls += self.BCEcls(pcls, t)  # BCE\n+\n+                # Mask regression\n+                if tuple(masks.shape[-2:]) != (mask_h, mask_w):  # downsample\n+                    masks = F.interpolate(masks[None], (mask_h, mask_w), mode=\"nearest\")[0]\n+                marea = xywhn[i][:, 2:].prod(1)  # mask width, height normalized\n+                mxyxy = xywh2xyxy(xywhn[i] * torch.tensor([mask_w, mask_h, mask_w, mask_h], device=self.device))\n+                for bi in b.unique():\n+                    j = b == bi  # matching index\n+                    if self.overlap:\n+                        mask_gti = torch.where(masks[bi][None] == tidxs[i][j].view(-1, 1, 1), 1.0, 0.0)\n+                    else:\n+                        mask_gti = masks[tidxs[i]][j]\n+                    lseg += self.single_mask_loss(mask_gti, pmask[j], proto[bi], mxyxy[j], marea[j])\n+\n+            obji = self.BCEobj(pi[..., 4], tobj)\n+            lobj += obji * self.balance[i]  # obj loss\n+            if self.autobalance:\n+                self.balance[i] = self.balance[i] * 0.9999 + 0.0001 / obji.detach().item()\n+\n+        if self.autobalance:\n+            self.balance = [x / self.balance[self.ssi] for x in self.balance]\n+        lbox *= self.hyp[\"box\"]\n+        lobj *= self.hyp[\"obj\"]\n+        lcls *= self.hyp[\"cls\"]\n+        lseg *= self.hyp[\"box\"] / bs\n+\n+        loss = lbox + lobj + lcls + lseg\n+        return loss * bs, torch.cat((lbox, lseg, lobj, lcls)).detach()\n+\n+    def single_mask_loss(self, gt_mask, pred, proto, xyxy, area):\n+        # Mask loss for one image\n+        pred_mask = (pred @ proto.view(self.nm, -1)).view(-1, *proto.shape[1:])  # (n,32) @ (32,80,80) -> (n,80,80)\n+        loss = F.binary_cross_entropy_with_logits(pred_mask, gt_mask, reduction=\"none\")\n+        return (crop_mask(loss, xyxy).mean(dim=(1, 2)) / area).mean()\n+\n+    def build_targets(self, p, targets):\n+        # Build targets for compute_loss(), input targets(image,class,x,y,w,h)\n+        na, nt = self.na, targets.shape[0]  # number of anchors, targets\n+        tcls, tbox, indices, anch, tidxs, xywhn = [], [], [], [], [], []\n+        gain = torch.ones(8, device=self.device)  # normalized to gridspace gain\n+        ai = torch.arange(na, device=self.device).float().view(na, 1).repeat(1, nt)  # same as .repeat_interleave(nt)\n+        if self.overlap:\n+            batch = p[0].shape[0]\n+            ti = []\n+            for i in range(batch):\n+                num = (targets[:, 0] == i).sum()  # find number of targets of each image\n+                ti.append(torch.arange(num, device=self.device).float().view(1, num).repeat(na, 1) + 1)  # (na, num)\n+            ti = torch.cat(ti, 1)  # (na, nt)\n+        else:\n+            ti = torch.arange(nt, device=self.device).float().view(1, nt).repeat(na, 1)\n+        targets = torch.cat((targets.repeat(na, 1, 1), ai[..., None], ti[..., None]), 2)  # append anchor indices\n+\n+        g = 0.5  # bias\n+        off = torch.tensor(\n+            [\n+                [0, 0],\n+                [1, 0],\n+                [0, 1],\n+                [-1, 0],\n+                [0, -1],  # j,k,l,m\n+                # [1, 1], [1, -1], [-1, 1], [-1, -1],  # jk,jm,lk,lm\n+            ],\n+            device=self.device).float() * g  # offsets\n+\n+        for i in range(self.nl):\n+            anchors, shape = self.anchors[i], p[i].shape\n+            gain[2:6] = torch.tensor(shape)[[3, 2, 3, 2]]  # xyxy gain\n+\n+            # Match targets to anchors\n+            t = targets * gain  # shape(3,n,7)\n+            if nt:\n+                # Matches\n+                r = t[..., 4:6] / anchors[:, None]  # wh ratio\n+                j = torch.max(r, 1 / r).max(2)[0] < self.hyp['anchor_t']  # compare\n+                # j = wh_iou(anchors, t[:, 4:6]) > model.hyp['iou_t']  # iou(3,n)=wh_iou(anchors(3,2), gwh(n,2))\n+                t = t[j]  # filter\n+\n+                # Offsets\n+                gxy = t[:, 2:4]  # grid xy\n+                gxi = gain[[2, 3]] - gxy  # inverse\n+                j, k = ((gxy % 1 < g) & (gxy > 1)).T\n+                l, m = ((gxi % 1 < g) & (gxi > 1)).T\n+                j = torch.stack((torch.ones_like(j), j, k, l, m))\n+                t = t.repeat((5, 1, 1))[j]\n+                offsets = (torch.zeros_like(gxy)[None] + off[:, None])[j]\n+            else:\n+                t = targets[0]\n+                offsets = 0\n+\n+            # Define\n+            bc, gxy, gwh, at = t.chunk(4, 1)  # (image, class), grid xy, grid wh, anchors\n+            (a, tidx), (b, c) = at.long().T, bc.long().T  # anchors, image, class\n+            gij = (gxy - offsets).long()\n+            gi, gj = gij.T  # grid indices\n+\n+            # Append\n+            indices.append((b, a, gj.clamp_(0, shape[2] - 1), gi.clamp_(0, shape[3] - 1)))  # image, anchor, grid\n+            tbox.append(torch.cat((gxy - gij, gwh), 1))  # box\n+            anch.append(anchors[a])  # anchors\n+            tcls.append(c)  # class\n+            tidxs.append(tidx)\n+            xywhn.append(torch.cat((gxy, gwh), 1) / gain[2:6])  # xywh normalized\n+\n+        return tcls, tbox, indices, anch, tidxs, xywhn\ndiff --git a/utils/segment/metrics.py b/utils/segment/metrics.py\nnew file mode 100644\nindex 000000000000..b09ce23fb9e3\n--- /dev/null\n+++ b/utils/segment/metrics.py\n@@ -0,0 +1,210 @@\n+# YOLOv5 🚀 by Ultralytics, GPL-3.0 license\n+\"\"\"\n+Model validation metrics\n+\"\"\"\n+\n+import numpy as np\n+\n+from ..metrics import ap_per_class\n+\n+\n+def fitness(x):\n+    # Model fitness as a weighted combination of metrics\n+    w = [0.0, 0.0, 0.1, 0.9, 0.0, 0.0, 0.1, 0.9]\n+    return (x[:, :8] * w).sum(1)\n+\n+\n+def ap_per_class_box_and_mask(\n+        tp_m,\n+        tp_b,\n+        conf,\n+        pred_cls,\n+        target_cls,\n+        plot=False,\n+        save_dir=\".\",\n+        names=(),\n+):\n+    \"\"\"\n+    Args:\n+        tp_b: tp of boxes.\n+        tp_m: tp of masks.\n+        other arguments see `func: ap_per_class`.\n+    \"\"\"\n+    results_boxes = ap_per_class(tp_b,\n+                                 conf,\n+                                 pred_cls,\n+                                 target_cls,\n+                                 plot=plot,\n+                                 save_dir=save_dir,\n+                                 names=names,\n+                                 prefix=\"Box\")[2:]\n+    results_masks = ap_per_class(tp_m,\n+                                 conf,\n+                                 pred_cls,\n+                                 target_cls,\n+                                 plot=plot,\n+                                 save_dir=save_dir,\n+                                 names=names,\n+                                 prefix=\"Mask\")[2:]\n+\n+    results = {\n+        \"boxes\": {\n+            \"p\": results_boxes[0],\n+            \"r\": results_boxes[1],\n+            \"ap\": results_boxes[3],\n+            \"f1\": results_boxes[2],\n+            \"ap_class\": results_boxes[4]},\n+        \"masks\": {\n+            \"p\": results_masks[0],\n+            \"r\": results_masks[1],\n+            \"ap\": results_masks[3],\n+            \"f1\": results_masks[2],\n+            \"ap_class\": results_masks[4]}}\n+    return results\n+\n+\n+class Metric:\n+\n+    def __init__(self) -> None:\n+        self.p = []  # (nc, )\n+        self.r = []  # (nc, )\n+        self.f1 = []  # (nc, )\n+        self.all_ap = []  # (nc, 10)\n+        self.ap_class_index = []  # (nc, )\n+\n+    @property\n+    def ap50(self):\n+        \"\"\"AP@0.5 of all classes.\n+        Return:\n+            (nc, ) or [].\n+        \"\"\"\n+        return self.all_ap[:, 0] if len(self.all_ap) else []\n+\n+    @property\n+    def ap(self):\n+        \"\"\"AP@0.5:0.95\n+        Return:\n+            (nc, ) or [].\n+        \"\"\"\n+        return self.all_ap.mean(1) if len(self.all_ap) else []\n+\n+    @property\n+    def mp(self):\n+        \"\"\"mean precision of all classes.\n+        Return:\n+            float.\n+        \"\"\"\n+        return self.p.mean() if len(self.p) else 0.0\n+\n+    @property\n+    def mr(self):\n+        \"\"\"mean recall of all classes.\n+        Return:\n+            float.\n+        \"\"\"\n+        return self.r.mean() if len(self.r) else 0.0\n+\n+    @property\n+    def map50(self):\n+        \"\"\"Mean AP@0.5 of all classes.\n+        Return:\n+            float.\n+        \"\"\"\n+        return self.all_ap[:, 0].mean() if len(self.all_ap) else 0.0\n+\n+    @property\n+    def map(self):\n+        \"\"\"Mean AP@0.5:0.95 of all classes.\n+        Return:\n+            float.\n+        \"\"\"\n+        return self.all_ap.mean() if len(self.all_ap) else 0.0\n+\n+    def mean_results(self):\n+        \"\"\"Mean of results, return mp, mr, map50, map\"\"\"\n+        return (self.mp, self.mr, self.map50, self.map)\n+\n+    def class_result(self, i):\n+        \"\"\"class-aware result, return p[i], r[i], ap50[i], ap[i]\"\"\"\n+        return (self.p[i], self.r[i], self.ap50[i], self.ap[i])\n+\n+    def get_maps(self, nc):\n+        maps = np.zeros(nc) + self.map\n+        for i, c in enumerate(self.ap_class_index):\n+            maps[c] = self.ap[i]\n+        return maps\n+\n+    def update(self, results):\n+        \"\"\"\n+        Args:\n+            results: tuple(p, r, ap, f1, ap_class)\n+        \"\"\"\n+        p, r, all_ap, f1, ap_class_index = results\n+        self.p = p\n+        self.r = r\n+        self.all_ap = all_ap\n+        self.f1 = f1\n+        self.ap_class_index = ap_class_index\n+\n+\n+class Metrics:\n+    \"\"\"Metric for boxes and masks.\"\"\"\n+\n+    def __init__(self) -> None:\n+        self.metric_box = Metric()\n+        self.metric_mask = Metric()\n+\n+    def update(self, results):\n+        \"\"\"\n+        Args:\n+            results: Dict{'boxes': Dict{}, 'masks': Dict{}}\n+        \"\"\"\n+        self.metric_box.update(list(results[\"boxes\"].values()))\n+        self.metric_mask.update(list(results[\"masks\"].values()))\n+\n+    def mean_results(self):\n+        return self.metric_box.mean_results() + self.metric_mask.mean_results()\n+\n+    def class_result(self, i):\n+        return self.metric_box.class_result(i) + self.metric_mask.class_result(i)\n+\n+    def get_maps(self, nc):\n+        return self.metric_box.get_maps(nc) + self.metric_mask.get_maps(nc)\n+\n+    @property\n+    def ap_class_index(self):\n+        # boxes and masks have the same ap_class_index\n+        return self.metric_box.ap_class_index\n+\n+\n+KEYS = [\n+    \"train/box_loss\",\n+    \"train/seg_loss\",  # train loss\n+    \"train/obj_loss\",\n+    \"train/cls_loss\",\n+    \"metrics/precision(B)\",\n+    \"metrics/recall(B)\",\n+    \"metrics/mAP_0.5(B)\",\n+    \"metrics/mAP_0.5:0.95(B)\",  # metrics\n+    \"metrics/precision(M)\",\n+    \"metrics/recall(M)\",\n+    \"metrics/mAP_0.5(M)\",\n+    \"metrics/mAP_0.5:0.95(M)\",  # metrics\n+    \"val/box_loss\",\n+    \"val/seg_loss\",  # val loss\n+    \"val/obj_loss\",\n+    \"val/cls_loss\",\n+    \"x/lr0\",\n+    \"x/lr1\",\n+    \"x/lr2\",]\n+\n+BEST_KEYS = [\n+    \"best/epoch\",\n+    \"best/precision(B)\",\n+    \"best/recall(B)\",\n+    \"best/mAP_0.5(B)\",\n+    \"best/mAP_0.5:0.95(B)\",\n+    \"best/precision(M)\",\n+    \"best/recall(M)\",\n+    \"best/mAP_0.5(M)\",\n+    \"best/mAP_0.5:0.95(M)\",]\ndiff --git a/utils/segment/plots.py b/utils/segment/plots.py\nnew file mode 100644\nindex 000000000000..e882c14390f0\n--- /dev/null\n+++ b/utils/segment/plots.py\n@@ -0,0 +1,143 @@\n+import contextlib\n+import math\n+from pathlib import Path\n+\n+import cv2\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import pandas as pd\n+import torch\n+\n+from .. import threaded\n+from ..general import xywh2xyxy\n+from ..plots import Annotator, colors\n+\n+\n+@threaded\n+def plot_images_and_masks(images, targets, masks, paths=None, fname='images.jpg', names=None):\n+    # Plot image grid with labels\n+    if isinstance(images, torch.Tensor):\n+        images = images.cpu().float().numpy()\n+    if isinstance(targets, torch.Tensor):\n+        targets = targets.cpu().numpy()\n+    if isinstance(masks, torch.Tensor):\n+        masks = masks.cpu().numpy().astype(int)\n+\n+    max_size = 1920  # max image size\n+    max_subplots = 16  # max image subplots, i.e. 4x4\n+    bs, _, h, w = images.shape  # batch size, _, height, width\n+    bs = min(bs, max_subplots)  # limit plot images\n+    ns = np.ceil(bs ** 0.5)  # number of subplots (square)\n+    if np.max(images[0]) <= 1:\n+        images *= 255  # de-normalise (optional)\n+\n+    # Build Image\n+    mosaic = np.full((int(ns * h), int(ns * w), 3), 255, dtype=np.uint8)  # init\n+    for i, im in enumerate(images):\n+        if i == max_subplots:  # if last batch has fewer images than we expect\n+            break\n+        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n+        im = im.transpose(1, 2, 0)\n+        mosaic[y:y + h, x:x + w, :] = im\n+\n+    # Resize (optional)\n+    scale = max_size / ns / max(h, w)\n+    if scale < 1:\n+        h = math.ceil(scale * h)\n+        w = math.ceil(scale * w)\n+        mosaic = cv2.resize(mosaic, tuple(int(x * ns) for x in (w, h)))\n+\n+    # Annotate\n+    fs = int((h + w) * ns * 0.01)  # font size\n+    annotator = Annotator(mosaic, line_width=round(fs / 10), font_size=fs, pil=True, example=names)\n+    for i in range(i + 1):\n+        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n+        annotator.rectangle([x, y, x + w, y + h], None, (255, 255, 255), width=2)  # borders\n+        if paths:\n+            annotator.text((x + 5, y + 5 + h), text=Path(paths[i]).name[:40], txt_color=(220, 220, 220))  # filenames\n+        if len(targets) > 0:\n+            idx = targets[:, 0] == i\n+            ti = targets[idx]  # image targets\n+\n+            boxes = xywh2xyxy(ti[:, 2:6]).T\n+            classes = ti[:, 1].astype('int')\n+            labels = ti.shape[1] == 6  # labels if no conf column\n+            conf = None if labels else ti[:, 6]  # check for confidence presence (label vs pred)\n+\n+            if boxes.shape[1]:\n+                if boxes.max() <= 1.01:  # if normalized with tolerance 0.01\n+                    boxes[[0, 2]] *= w  # scale to pixels\n+                    boxes[[1, 3]] *= h\n+                elif scale < 1:  # absolute coords need scale if image scales\n+                    boxes *= scale\n+            boxes[[0, 2]] += x\n+            boxes[[1, 3]] += y\n+            for j, box in enumerate(boxes.T.tolist()):\n+                cls = classes[j]\n+                color = colors(cls)\n+                cls = names[cls] if names else cls\n+                if labels or conf[j] > 0.25:  # 0.25 conf thresh\n+                    label = f'{cls}' if labels else f'{cls} {conf[j]:.1f}'\n+                    annotator.box_label(box, label, color=color)\n+\n+            # Plot masks\n+            if len(masks):\n+                if masks.max() > 1.0:  # mean that masks are overlap\n+                    image_masks = masks[[i]]  # (1, 640, 640)\n+                    nl = len(ti)\n+                    index = np.arange(nl).reshape(nl, 1, 1) + 1\n+                    image_masks = np.repeat(image_masks, nl, axis=0)\n+                    image_masks = np.where(image_masks == index, 1.0, 0.0)\n+                else:\n+                    image_masks = masks[idx]\n+\n+                im = np.asarray(annotator.im).copy()\n+                for j, box in enumerate(boxes.T.tolist()):\n+                    if labels or conf[j] > 0.25:  # 0.25 conf thresh\n+                        color = colors(classes[j])\n+                        mh, mw = image_masks[j].shape\n+                        if mh != h or mw != w:\n+                            mask = image_masks[j].astype(np.uint8)\n+                            mask = cv2.resize(mask, (w, h))\n+                            mask = mask.astype(np.bool)\n+                        else:\n+                            mask = image_masks[j].astype(np.bool)\n+                        with contextlib.suppress(Exception):\n+                            im[y:y + h, x:x + w, :][mask] = im[y:y + h, x:x + w, :][mask] * 0.4 + np.array(color) * 0.6\n+                annotator.fromarray(im)\n+    annotator.im.save(fname)  # save\n+\n+\n+def plot_results_with_masks(file=\"path/to/results.csv\", dir=\"\", best=True):\n+    # Plot training results.csv. Usage: from utils.plots import *; plot_results('path/to/results.csv')\n+    save_dir = Path(file).parent if file else Path(dir)\n+    fig, ax = plt.subplots(2, 8, figsize=(18, 6), tight_layout=True)\n+    ax = ax.ravel()\n+    files = list(save_dir.glob(\"results*.csv\"))\n+    assert len(files), f\"No results.csv files found in {save_dir.resolve()}, nothing to plot.\"\n+    for f in files:\n+        try:\n+            data = pd.read_csv(f)\n+            index = np.argmax(0.9 * data.values[:, 8] + 0.1 * data.values[:, 7] + 0.9 * data.values[:, 12] +\n+                              0.1 * data.values[:, 11])\n+            s = [x.strip() for x in data.columns]\n+            x = data.values[:, 0]\n+            for i, j in enumerate([1, 2, 3, 4, 5, 6, 9, 10, 13, 14, 15, 16, 7, 8, 11, 12]):\n+                y = data.values[:, j]\n+                # y[y == 0] = np.nan  # don't show zero values\n+                ax[i].plot(x, y, marker=\".\", label=f.stem, linewidth=2, markersize=2)\n+                if best:\n+                    # best\n+                    ax[i].scatter(index, y[index], color=\"r\", label=f\"best:{index}\", marker=\"*\", linewidth=3)\n+                    ax[i].set_title(s[j] + f\"\\n{round(y[index], 5)}\")\n+                else:\n+                    # last\n+                    ax[i].scatter(x[-1], y[-1], color=\"r\", label=\"last\", marker=\"*\", linewidth=3)\n+                    ax[i].set_title(s[j] + f\"\\n{round(y[-1], 5)}\")\n+                # if j in [8, 9, 10]:  # share train and val loss y axes\n+                #     ax[i].get_shared_y_axes().join(ax[i], ax[i - 5])\n+        except Exception as e:\n+            print(f\"Warning: Plotting error for {f}: {e}\")\n+    ax[1].legend()\n+    fig.savefig(save_dir / \"results.png\", dpi=200)\n+    plt.close()\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The proposed changes in this PR highlight a few key areas. First, allowing `train.py` to accept a `--deterministic` argument is useful, especially since CUDA's bilinear interpolation isn't deterministic, which needs addressing. Merging `non_max_suppression_masks()` with `non_max_suppression()` seems practical for maintainability. Removing the `edict` dependency is a solid move; transitioning to native dicts is straightforward. Finally, profiling results reveal notable CPU to GPU latency affecting performance, suggesting further optimization should be considered. Overall, these adjustments will help streamline the codebase while improving training efficiency."
      }
    ],
    "token_estimation": 30680.25
  },
  {
    "index": 79,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/utils/loggers/mlflow/mlflow_utils.py b/utils/loggers/mlflow/mlflow_utils.py\nnew file mode 100644\nindex 000000000000..aa96b4b78d26\n--- /dev/null\n+++ b/utils/loggers/mlflow/mlflow_utils.py\n@@ -0,0 +1,134 @@\n+\"\"\"Utilities and tools for tracking runs with Mlflow.\"\"\"\n+\n+import sys\n+from argparse import Namespace\n+from pathlib import Path\n+from typing import Any, Dict\n+\n+FILE = Path(__file__).resolve()\n+ROOT = FILE.parents[3]\n+if str(ROOT) not in sys.path:\n+    sys.path.append(str(ROOT))\n+\n+from utils.general import LOGGER, colorstr\n+\n+try:\n+    import mlflow\n+    assert hasattr(mlflow, \"__version__\")\n+except (ImportError, AssertionError):\n+    mlflow = None\n+\n+from collections.abc import MutableMapping\n+\n+\n+class MlflowLogger:\n+    \"\"\"Log training run, artifacts, parameters, and metrics to Mlflow.\n+\n+    This logger expects that Mlflow is setup by the user.\n+    \"\"\"\n+\n+    def __init__(self, opt: Namespace) -> None:\n+        \"\"\"Initializes the MlflowLogger\n+\n+        Args:\n+            opt (Namespace): Commandline arguments for this run\n+        \"\"\"\n+        prefix = colorstr(\"Mlflow: \")\n+        try:\n+            self.mlflow, self.mlflow_active_run = mlflow, None if not mlflow else mlflow.start_run()\n+            if self.mlflow_active_run is not None:\n+                self.run_id = self.mlflow_active_run.info.run_id\n+                LOGGER.info(f\"{prefix}Using run_id({self.run_id})\")\n+                self.setup(opt)\n+        except Exception as err:\n+            LOGGER.error(f\"{prefix}Failing init - {repr(err)}\")\n+            LOGGER.warning(f\"{prefix}Continuining without Mlflow\")\n+            self.mlflow = None\n+            self.mlflow_active_run = None\n+\n+    def setup(self, opt: Namespace) -> None:\n+        if opt.weights is not None and str(opt.weights).strip() != \"\":\n+            model_name = Path(opt.weights).stem\n+        else:\n+            model_name = \"yolov5\"\n+        self.model_name = model_name\n+        self.weights = Path(opt.weights)\n+        self.client = mlflow.tracking.MlflowClient()\n+        self.log_params(vars(opt))\n+        self.log_metrics(vars(opt), is_param=True)\n+\n+    @staticmethod\n+    def _flatten_params(params_dict, parent_key=\"\", sep=\"/\"):\n+        \"\"\"Static method to flatten configs for logging to mlflow\"\"\"\n+        items = []\n+        for key, value in params_dict.items():\n+            new_key = parent_key + sep + key if parent_key else key\n+            if isinstance(value, MutableMapping):\n+                items.extend(MlflowLogger._flatten_params(value, new_key, sep).items())\n+            else:\n+                items.append((new_key, value))\n+        return dict(items)\n+\n+    def log_artifacts(self, artifact: Path, relpath: str = None) -> None:\n+        \"\"\"Member function to log artifacts (either directory or single item).\n+\n+        Args:\n+            artifact (Path): File or folder to be logged\n+            relpath (str): Name (or path) relative to experiment for logging artifact in mlflow\n+        \"\"\"\n+        if not isinstance(artifact, Path):\n+            artifact = Path(artifact)\n+        if artifact.is_dir():\n+            self.mlflow.log_artifacts(f\"{artifact.resolve()}/\", artifact_path=str(artifact.stem))\n+        else:\n+            self.mlflow.log_artifact(str(artifact.resolve()), artifact_path=relpath)\n+\n+    def log_model(self, model_path: Path, model_name: str = None) -> None:\n+        \"\"\"Member function to log model as an Mlflow model.\n+\n+        Args:\n+            model_path: Path to the model .pt being logged\n+            model_name: Name (or path) relative to experiment for logging model in mlflow\n+        \"\"\"\n+        self.mlflow.pyfunc.log_model(artifact_path=self.model_name if model_name is None else model_name,\n+                                     code_path=[str(ROOT.resolve())],\n+                                     artifacts={\"model_path\": str(model_path.resolve())},\n+                                     python_model=self.mlflow.pyfunc.PythonModel())\n+\n+    def log_params(self, params: Dict[str, Any]) -> None:\n+        \"\"\"Member funtion to log parameters.\n+        Mlflow doesn't have mutable parameters and so this function is used\n+        only to log initial training parameters.\n+\n+        Args:\n+            params (Dict[str, Any]): Parameters as dict\n+        \"\"\"\n+        try:\n+            flattened_params = MlflowLogger._flatten_params(params_dict=params)\n+            run = self.client.get_run(run_id=self.run_id)\n+            logged_params = run.data.params\n+            [\n+                self.mlflow.log_param(key=k, value=v) for k, v in flattened_params.items()\n+                if k not in logged_params and v is not None and str(v).strip() != \"\"]\n+        except Exception as err:\n+            LOGGER.warning(f\"Mlflow: failed to log all params because - {err}\")\n+\n+    def log_metrics(self, metrics: Dict[str, float], epoch: int = None, is_param: bool = False) -> None:\n+        \"\"\"Member function to log metrics.\n+        Mlflow requires metrics to be floats.\n+\n+        Args:\n+            metrics (Dict[str, float]): Dictionary with metric names and values\n+            epoch (int, optional): Training epoch. Defaults to None.\n+            is_param (bool, optional): Set it to True to log keys with a prefix \"params/\". Defaults to False.\n+        \"\"\"\n+        prefix = \"param/\" if is_param else \"\"\n+        metrics_dict = {\n+            f\"{prefix}{k.replace(':','-')}\": float(v)\n+            for k, v in metrics.items() if (isinstance(v, float) or isinstance(v, int))}\n+        self.mlflow.log_metrics(metrics=metrics_dict, step=epoch)\n+\n+    def finish_run(self) -> None:\n+        \"\"\"Member function to end mlflow run.\n+        \"\"\"\n+        self.mlflow.end_run()\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The integration of MLflow in your code is progressing well, but you need to ensure that the `on_pretrain_routine_end` method in `utils/loggers/__init__.py` properly logs relevant artifacts. It’s good to see you addressed the empty weights issue in training; ensure this fix is tested thoroughly. Also, adding `mlflow.set_tracking_uri` in `train.py` will make your logging to the database more transparent. Keep an eye on the version discrepancies; MLflow 1.27 can introduce unexpected behaviors."
      }
    ],
    "token_estimation": 1554.0
  },
  {
    "index": 81,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/utils/wandb_logging/wandb_utils.py b/utils/wandb_logging/wandb_utils.py\nindex 264cd4840e3c..c9a32f5b6026 100644\n--- a/utils/wandb_logging/wandb_utils.py\n+++ b/utils/wandb_logging/wandb_utils.py\n@@ -22,87 +27,183 @@ def remove_prefix(from_string, prefix):\n     return from_string[len(prefix):]\n \n \n+def check_wandb_config_file(data_config_file):\n+    wandb_config = '_wandb.'.join(data_config_file.rsplit('.', 1))  # updated data.yaml path\n+    if Path(wandb_config).is_file():\n+        return wandb_config\n+    return data_config_file\n+\n+\n+def resume_and_get_id(opt):\n+    # It's more elegant to stick to 1 wandb.init call, but as useful config data is overwritten in the WandbLogger's wandb.init call\n+    if isinstance(opt.resume, str):\n+        if opt.resume.startswith(WANDB_ARTIFACT_PREFIX):\n+            run_path = Path(remove_prefix(opt.resume, WANDB_ARTIFACT_PREFIX))\n+            run_id = run_path.stem\n+            project = run_path.parent.stem\n+            model_artifact_name = WANDB_ARTIFACT_PREFIX + 'run_' + run_id + '_model'\n+            assert wandb, 'install wandb to resume wandb runs'\n+            # Resume wandb-artifact:// runs here| workaround for not overwriting wandb.config\n+            run = wandb.init(id=run_id, project=project, resume='allow')\n+            opt.resume = model_artifact_name\n+            return run\n+    return None\n+\n+\n class WandbLogger():\n     def __init__(self, opt, name, run_id, data_dict, job_type='Training'):\n-        self.wandb = wandb\n-        self.wandb_run = wandb.init(config=opt, resume=\"allow\",\n-                                    project='YOLOv5' if opt.project == 'runs/train' else Path(opt.project).stem,\n-                                    name=name,\n-                                    job_type=job_type,\n-                                    id=run_id) if self.wandb else None\n-\n-        if job_type == 'Training':\n-            self.setup_training(opt, data_dict)\n-            if opt.bbox_interval == -1:\n-                opt.bbox_interval = (opt.epochs // 10) if opt.epochs > 10 else opt.epochs\n-            if opt.save_period == -1:\n-                opt.save_period = (opt.epochs // 10) if opt.epochs > 10 else opt.epochs\n+        # Pre-training routine --\n+        self.job_type = job_type\n+        self.wandb, self.wandb_run, self.data_dict = wandb, None if not wandb else wandb.run, data_dict\n+        if self.wandb:\n+            self.wandb_run = wandb.init(config=opt,\n+                                        resume=\"allow\",\n+                                        project='YOLOv5' if opt.project == 'runs/train' else Path(opt.project).stem,\n+                                        name=name,\n+                                        job_type=job_type,\n+                                        id=run_id) if not wandb.run else wandb.run\n+            if self.job_type == 'Training':\n+                if not opt.resume:\n+                    wandb_data_dict = self.check_and_upload_dataset(opt) if opt.upload_dataset else data_dict\n+                    # Info useful for resuming from artifacts\n+                    self.wandb_run.config.opt = vars(opt)\n+                    self.wandb_run.config.data_dict = wandb_data_dict\n+                self.data_dict = self.setup_training(opt, data_dict)\n+            if self.job_type == 'Dataset Creation':\n+                self.data_dict = self.check_and_upload_dataset(opt)\n+\n+    def check_and_upload_dataset(self, opt):\n+        assert wandb, 'Install wandb to upload dataset'\n+        check_dataset(self.data_dict)\n+        config_path = self.log_dataset_artifact(opt.data,\n+                                                   opt.single_cls,\n+                                                   'YOLOv5' if opt.project == 'runs/train' else Path(opt.project).stem)\n+        print(\"Created dataset config file \", config_path)\n+        with open(config_path) as f:\n+            wandb_data_dict = yaml.load(f, Loader=yaml.SafeLoader)\n+        return wandb_data_dict\n \n     def setup_training(self, opt, data_dict):\n-        self.log_dict = {}\n-        self.train_artifact_path, self.trainset_artifact = \\\n-            self.download_dataset_artifact(data_dict['train'], opt.artifact_alias)\n-        self.test_artifact_path, self.testset_artifact = \\\n-            self.download_dataset_artifact(data_dict['val'], opt.artifact_alias)\n-        self.result_artifact, self.result_table, self.weights = None, None, None\n-        if self.train_artifact_path is not None:\n-            train_path = Path(self.train_artifact_path) / 'data/images/'\n-            data_dict['train'] = str(train_path)\n-        if self.test_artifact_path is not None:\n-            test_path = Path(self.test_artifact_path) / 'data/images/'\n-            data_dict['val'] = str(test_path)\n+        self.log_dict, self.current_epoch, self.log_imgs = {}, 0, 16  # Logging Constants\n+        self.bbox_interval = opt.bbox_interval\n+        if isinstance(opt.resume, str):\n+            modeldir, _ = self.download_model_artifact(opt)\n+            if modeldir:\n+                self.weights = Path(modeldir) / \"last.pt\"\n+                config = self.wandb_run.config\n+                opt.weights, opt.save_period, opt.batch_size, opt.bbox_interval, opt.epochs, opt.hyp = str(\n+                    self.weights), config.save_period, config.total_batch_size, config.bbox_interval, config.epochs, \\\n+                                                                                                       config.opt['hyp']\n+            data_dict = dict(self.wandb_run.config.data_dict)  # eliminates the need for config file to resume\n+        if 'val_artifact' not in self.__dict__:  # If --upload_dataset is set, use the existing artifact, don't download\n+            self.train_artifact_path, self.train_artifact = self.download_dataset_artifact(data_dict.get('train'),\n+                                                                                           opt.artifact_alias)\n+            self.val_artifact_path, self.val_artifact = self.download_dataset_artifact(data_dict.get('val'),\n+                                                                                       opt.artifact_alias)\n+            self.result_artifact, self.result_table, self.val_table, self.weights = None, None, None, None\n+            if self.train_artifact_path is not None:\n+                train_path = Path(self.train_artifact_path) / 'data/images/'\n+                data_dict['train'] = str(train_path)\n+            if self.val_artifact_path is not None:\n+                val_path = Path(self.val_artifact_path) / 'data/images/'\n+                data_dict['val'] = str(val_path)\n+                self.val_table = self.val_artifact.get(\"val\")\n+                self.map_val_table_path()\n+        if self.val_artifact is not None:\n             self.result_artifact = wandb.Artifact(\"run_\" + wandb.run.id + \"_progress\", \"evaluation\")\n             self.result_table = wandb.Table([\"epoch\", \"id\", \"prediction\", \"avg_confidence\"])\n-        if opt.resume_from_artifact:\n-            modeldir, _ = self.download_model_artifact(opt.resume_from_artifact)\n-            if modeldir:\n-                self.weights = Path(modeldir) / \"best.pt\"\n-                opt.weights = self.weights\n+        if opt.bbox_interval == -1:\n+            self.bbox_interval = opt.bbox_interval = (opt.epochs // 10) if opt.epochs > 10 else 1\n+        return data_dict\n \n     def download_dataset_artifact(self, path, alias):\n         if path.startswith(WANDB_ARTIFACT_PREFIX):\n             dataset_artifact = wandb.use_artifact(remove_prefix(path, WANDB_ARTIFACT_PREFIX) + \":\" + alias)\n             assert dataset_artifact is not None, \"'Error: W&B dataset artifact doesn\\'t exist'\"\n             datadir = dataset_artifact.download()\n-            labels_zip = Path(datadir) / \"data/labels.zip\"\n-            shutil.unpack_archive(labels_zip, Path(datadir) / 'data/labels', 'zip')\n-            print(\"Downloaded dataset to : \", datadir)\n             return datadir, dataset_artifact\n         return None, None\n \n-    def download_model_artifact(self, name):\n-        model_artifact = wandb.use_artifact(name + \":latest\")\n-        assert model_artifact is not None, 'Error: W&B model artifact doesn\\'t exist'\n-        modeldir = model_artifact.download()\n-        print(\"Downloaded model to : \", modeldir)\n-        return modeldir, model_artifact\n+    def download_model_artifact(self, opt):\n+        if opt.resume.startswith(WANDB_ARTIFACT_PREFIX):\n+            model_artifact = wandb.use_artifact(remove_prefix(opt.resume, WANDB_ARTIFACT_PREFIX) + \":latest\")\n+            assert model_artifact is not None, 'Error: W&B model artifact doesn\\'t exist'\n+            modeldir = model_artifact.download()\n+            epochs_trained = model_artifact.metadata.get('epochs_trained')\n+            total_epochs = model_artifact.metadata.get('total_epochs')\n+            assert epochs_trained < total_epochs, 'training to %g epochs is finished, nothing to resume.' % (\n+                total_epochs)\n+            return modeldir, model_artifact\n+        return None, None\n \n-    def log_model(self, path, opt, epoch):\n-        datetime_suffix = datetime.today().strftime('%Y-%m-%d-%H-%M-%S')\n+    def log_model(self, path, opt, epoch, fitness_score, best_model=False):\n         model_artifact = wandb.Artifact('run_' + wandb.run.id + '_model', type='model', metadata={\n             'original_url': str(path),\n-            'epoch': epoch + 1,\n+            'epochs_trained': epoch + 1,\n             'save period': opt.save_period,\n             'project': opt.project,\n-            'datetime': datetime_suffix\n+            'total_epochs': opt.epochs,\n+            'fitness_score': fitness_score\n         })\n         model_artifact.add_file(str(path / 'last.pt'), name='last.pt')\n-        model_artifact.add_file(str(path / 'best.pt'), name='best.pt')\n-        wandb.log_artifact(model_artifact)\n+        wandb.log_artifact(model_artifact,\n+                           aliases=['latest', 'epoch ' + str(self.current_epoch), 'best' if best_model else ''])\n         print(\"Saving model artifact on epoch \", epoch + 1)\n \n-    def log_dataset_artifact(self, dataset, class_to_id, name='dataset'):\n+    def log_dataset_artifact(self, data_file, single_cls, project, overwrite_config=False):\n+        with open(data_file) as f:\n+            data = yaml.load(f, Loader=yaml.SafeLoader)  # data dict\n+        nc, names = (1, ['item']) if single_cls else (int(data['nc']), data['names'])\n+        names = {k: v for k, v in enumerate(names)}  # to index dictionary\n+        self.train_artifact = self.create_dataset_table(LoadImagesAndLabels(\n+            data['train']), names, name='train') if data.get('train') else None\n+        self.val_artifact = self.create_dataset_table(LoadImagesAndLabels(\n+            data['val']), names, name='val') if data.get('val') else None\n+        if data.get('train'):\n+            data['train'] = WANDB_ARTIFACT_PREFIX + str(Path(project) / 'train')\n+        if data.get('val'):\n+            data['val'] = WANDB_ARTIFACT_PREFIX + str(Path(project) / 'val')\n+        path = data_file if overwrite_config else '_wandb.'.join(data_file.rsplit('.', 1))  # updated data.yaml path\n+        data.pop('download', None)\n+        with open(path, 'w') as f:\n+            yaml.dump(data, f)\n+\n+        if self.job_type == 'Training':  # builds correct artifact pipeline graph\n+            self.wandb_run.use_artifact(self.val_artifact)\n+            self.wandb_run.use_artifact(self.train_artifact)\n+            self.val_artifact.wait()\n+            self.val_table = self.val_artifact.get('val')\n+            self.map_val_table_path()\n+        else:\n+            self.wandb_run.log_artifact(self.train_artifact)\n+            self.wandb_run.log_artifact(self.val_artifact)\n+        return path\n+\n+    def map_val_table_path(self):\n+        self.val_table_map = {}\n+        print(\"Mapping dataset\")\n+        for i, data in enumerate(tqdm(self.val_table.data)):\n+            self.val_table_map[data[3]] = data[0]\n+\n+    def create_dataset_table(self, dataset, class_to_id, name='dataset'):\n+        # TODO: Explore multiprocessing to slpit this loop parallely| This is essential for speeding up the the logging\n         artifact = wandb.Artifact(name=name, type=\"dataset\")\n-        image_path = dataset.path\n-        artifact.add_dir(image_path, name='data/images')\n-        table = wandb.Table(columns=[\"id\", \"train_image\", \"Classes\"])\n+        for img_file in tqdm([dataset.path]) if Path(dataset.path).is_dir() else tqdm(dataset.img_files):\n+            if Path(img_file).is_dir():\n+                artifact.add_dir(img_file, name='data/images')\n+                labels_path = 'labels'.join(dataset.path.rsplit('images', 1))\n+                artifact.add_dir(labels_path, name='data/labels')\n+            else:\n+                artifact.add_file(img_file, name='data/images/' + Path(img_file).name)\n+                label_file = Path(img2label_paths([img_file])[0])\n+                artifact.add_file(str(label_file),\n+                                  name='data/labels/' + label_file.name) if label_file.exists() else None\n+        table = wandb.Table(columns=[\"id\", \"train_image\", \"Classes\", \"name\"])\n         class_set = wandb.Classes([{'id': id, 'name': name} for id, name in class_to_id.items()])\n-        for si, (img, labels, paths, shapes) in enumerate(dataset):\n+        for si, (img, labels, paths, shapes) in enumerate(tqdm(dataset)):\n             height, width = shapes[0]\n-            labels[:, 2:] = (xywh2xyxy(labels[:, 2:].view(-1, 4)))\n-            labels[:, 2:] *= torch.Tensor([width, height, width, height])\n-            box_data = []\n-            img_classes = {}\n+            labels[:, 2:] = (xywh2xyxy(labels[:, 2:].view(-1, 4))) * torch.Tensor([width, height, width, height])\n+            box_data, img_classes = [], {}\n             for cls, *xyxy in labels[:, 1:].tolist():\n                 cls = int(cls)\n                 box_data.append({\"position\": {\"minX\": xyxy[0], \"minY\": xyxy[1], \"maxX\": xyxy[2], \"maxY\": xyxy[3]},\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The proposed changes in this PR are focused on streamlining the dataset and resume functionality. Instead of hardcoding dataset paths, using a check for the existence of specified files is recommended. Adding an `--upload-dataset` argument will simplify dataset logging, while removing `--log-imgs` makes the code cleaner. The suggested resume command improves readability, but ensure it handles cases with modified data or architecture gracefully. Consider logging model checkpoints by default, as this offers more flexibility for users, particularly in fault-prone environments. Test thoroughly to confirm robustness."
      }
    ],
    "token_estimation": 3678.75
  },
  {
    "index": 82,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/.github/workflows/ci-testing.yml b/.github/workflows/ci-testing.yml\nnew file mode 100644\nindex 000000000000..3bfb6f2768ea\n--- /dev/null\n+++ b/.github/workflows/ci-testing.yml\n@@ -0,0 +1,81 @@\n+name: CI CPU testing\n+\n+# see: https://help.github.com/en/actions/reference/events-that-trigger-workflows\n+on: [push, pull_request]\n+\n+jobs:\n+  cpu-tests:\n+\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        os: [ubuntu-latest]  #, macOS-10.15, windows-2019\n+        python-version: [3.7, 3.8]\n+        yolo5-model: [\"yolov5s\", \"yolov5m\", \"yolov5l\", \"yolov5x\"]\n+\n+    # Timeout: https://stackoverflow.com/a/59076067/4521646\n+    timeout-minutes: 50\n+    steps:\n+    - uses: actions/checkout@v2\n+    - name: Set up Python ${{ matrix.python-version }}\n+      uses: actions/setup-python@v2\n+      with:\n+        python-version: ${{ matrix.python-version }}\n+\n+    # Note: This uses an internal pip API and may not always work\n+    # https://github.com/actions/cache/blob/master/examples.md#multiple-oss-in-a-workflow\n+    - name: Get pip cache\n+      id: pip-cache\n+      run: |\n+        python -c \"from pip._internal.locations import USER_CACHE_DIR; print('::set-output name=dir::' + USER_CACHE_DIR)\"\n+\n+    - name: Cache pip\n+      uses: actions/cache@v1\n+      with:\n+        path: ${{ steps.pip-cache.outputs.dir }}\n+        key: ${{ runner.os }}-${{ matrix.python-version }}-pip-${{ hashFiles('requirements.txt') }}\n+        restore-keys: |\n+          ${{ runner.os }}-${{ matrix.python-version }}-pip-\n+\n+    - name: Install dependencies\n+      run: |\n+        python -m pip install --upgrade pip\n+        pip install -q numpy  # for cocoapi proper install\n+        pip install -qr requirements.txt -f https://download.pytorch.org/whl/cpu/torch_stable.html\n+        pip install -q onnx\n+        python --version\n+        pip --version\n+        pip list\n+      shell: bash\n+\n+    - name: Download data\n+      run: |\n+        python -c \"from utils.google_utils import * ; gdrive_download('1n_oKgR81BJtqk75b00eAjdv03qVCQn2f', 'coco128.zip')\"\n+        mv ./coco128 ../\n+\n+    - name: Download weights\n+      run: |\n+        bash weights/download_weights.sh\n+\n+    - name: Tests workflow\n+      run: |\n+        # to run *.py. files in subdirectories\n+        export PYTHONPATH=\"$PWD\"\n+        # define device\n+        di=cpu # inference devices\n+        # train\n+        python train.py --weights weights/${{ matrix.yolo5-model }}.pt --cfg models/${{ matrix.yolo5-model }}.yaml --epochs 1 --img 320 --device $di --batch-size 2\n+        # detect official\n+        python detect.py --weights weights/${{ matrix.yolo5-model }}.pt --device $di\n+        # detect custom\n+        python detect.py --weights runs/exp0/weights/last.pt --device $di\n+        # test official\n+        python test.py --weights weights/${{ matrix.yolo5-model }}.pt --device $di --batch-size 1\n+        # test custom\n+        python test.py --weights runs/exp0/weights/last.pt --device $di  --batch-size 1\n+        # inspect\n+        python models/yolo.py --cfg models/${{ matrix.yolo5-model }}.yaml\n+        # export\n+        python models/export.py --weights weights/${{ matrix.yolo5-model }}.pt --img 640 --batch 1\n+      shell: bash\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR looks promising, especially the CI addition, but we need to limit its scope to just the `ci-testing.yml` file. The renaming of `test.py` and other files could confuse users, as `test.py` has specific implications in pytest. We also need to be cautious with dependencies, particularly related to numpy and pycocotools, which might cause further issues. Please close this PR and submit a new one focused solely on the CI addition, keeping existing workflows intact."
      }
    ],
    "token_estimation": 931.5
  },
  {
    "index": 83,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/.github/workflows/ci-testing-setup-install.yml b/.github/workflows/ci-testing-setup-install.yml\nnew file mode 100644\nindex 000000000000..d9654ac708a4\n--- /dev/null\n+++ b/.github/workflows/ci-testing-setup-install.yml\n@@ -0,0 +1,80 @@\n+name: CI CPU testing\n+\n+on:  # https://help.github.com/en/actions/reference/events-that-trigger-workflows\n+  push:\n+    branches: [ master, develop ]\n+  pull_request:\n+    # The branches below must be a subset of the branches above\n+    branches: [ master, develop ]\n+\n+jobs:\n+  cpu-tests:\n+\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        os: [ubuntu-latest, macos-latest, windows-latest]\n+        python-version: [3.6, 3.7, 3.8, 3.9]  # temporarily to check compatibility with different versions of python\n+        model: ['yolov5s']  # models to test\n+\n+    # Timeout: https://stackoverflow.com/a/59076067/4521646\n+    timeout-minutes: 50\n+    steps:\n+      - uses: actions/checkout@v2\n+      - name: Set up Python ${{ matrix.python-version }}\n+        uses: actions/setup-python@v2\n+        with:\n+          python-version: ${{ matrix.python-version }}\n+\n+      # Note: This uses an internal pip API and may not always work\n+      # https://github.com/actions/cache/blob/master/examples.md#multiple-oss-in-a-workflow\n+      - name: Get pip cache\n+        id: pip-cache\n+        run: |\n+          python -c \"from pip._internal.locations import USER_CACHE_DIR; print('::set-output name=dir::' + USER_CACHE_DIR)\"\n+\n+      - name: Cache pip\n+        uses: actions/cache@v1\n+        with:\n+          path: ${{ steps.pip-cache.outputs.dir }}\n+          key: ${{ runner.os }}-${{ matrix.python-version }}-pip-${{ hashFiles('requirements.txt') }}\n+          restore-keys: |\n+            ${{ runner.os }}-${{ matrix.python-version }}-pip-\n+\n+      - name: Install dependencies\n+        run: |\n+          python -m pip install --upgrade pip\n+          pip install -e .\n+          python --version\n+          pip --version\n+          pip list\n+        shell: bash\n+\n+      - name: Download data\n+        run: |\n+          # curl -L -o tmp.zip https://github.com/ultralytics/yolov5/releases/download/v1.0/coco128.zip\n+          # unzip -q tmp.zip -d ../\n+          # rm tmp.zip\n+\n+      - name: Tests workflow\n+        run: |\n+          di=cpu # inference devices  # define device\n+\n+          # train\n+          python -m yolov5.train --img 128 --batch 16 --weights weights/${{ matrix.model }}.pt --cfg models/${{ matrix.model }}.yaml --epochs 1 --device $di\n+          # detect\n+          python -m yolov5.detect --weights weights/${{ matrix.model }}.pt --device $di\n+          python -m yolov5.detect --weights runs/train/exp/weights/last.pt --device $di\n+          # test\n+          python -m yolov5.test --img 128 --batch 16 --weights weights/${{ matrix.model }}.pt --device $di\n+          python -m yolov5.test --img 128 --batch 16 --weights runs/train/exp/weights/last.pt --device $di\n+\n+          # hub\n+          python hubconf.py\n+          # inspect\n+          python -m yolov5.models.yolo --cfg models/${{ matrix.model }}.yaml\n+          # export\n+          pip install -e .[export]\n+          python -m yolov5.models.export --img 128 --batch 1 --weights weights/${{ matrix.model }}.pt\n+        shell: bash\ndiff --git a/setup.py b/setup.py\nnew file mode 100644\nindex 000000000000..243a1fa507a4\n--- /dev/null\n+++ b/setup.py\n@@ -0,0 +1,81 @@\n+import pathlib\n+\n+import setuptools\n+\n+root_directory = pathlib.Path(__file__).parent\n+long_description = (root_directory / \"README.md\").read_text(encoding=\"utf-8\")\n+\n+setuptools.setup(\n+    name=\"ultralytics-yolov5\",\n+    version=\"0.0.2.dev\",\n+    description=\"Ultralytics YOLOv5 🚀 Python package, https://ultralytics.com\",\n+    python_requires=\">=3.6.2\",\n+    long_description=long_description,\n+    long_description_content_type=\"text/markdown\",\n+    url=\"https://github.com/ultralytics/yolov5\",\n+    author=\"Ultralytics\",\n+    author_email='glenn.jocher@ultralytics.com',\n+    license=\"GPLv3\",\n+    packages=[\"yolov5\"],\n+    include_package_data=True,\n+    install_requires=[\n+        \"matplotlib>=3.2.2\",\n+        \"numpy>=1.18.5\",\n+        \"opencv-python>=4.1.2\",\n+        \"Pillow\",\n+        \"PyYAML>=5.3.1\",\n+        \"scipy>=1.4.1\",\n+        \"torch>=1.7.0\",\n+        \"torchvision>=0.8.1\",\n+        \"tqdm>=4.41.0\",\n+        \"tensorboard>=2.4.1\",\n+        \"seaborn>=0.11.0\",\n+        \"pandas\"\n+    ],\n+    extras_require={\n+        \"tests\": [\n+            \"pytest\",\n+        ],\n+        \"export\": [\n+            \"coremltools>=4.1\",\n+            \"onnx>=1.9.0\",\n+            \"scikit-learn>=0.24\"\n+        ],\n+        \"extras\": [\n+            \"Cython\",\n+            \"pycocotools>=2.0\",\n+            \"thop\"\n+        ]\n+    },\n+    classifiers=[\n+        \"Intended Audience :: Developers\",\n+        \"Intended Audience :: Science/Research\",\n+        \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n+        \"Programming Language :: Python :: 3\",\n+        \"Programming Language :: Python :: 3.6\",\n+        \"Programming Language :: Python :: 3.7\",\n+        \"Programming Language :: Python :: 3.8\",\n+        \"Programming Language :: Python :: 3.9\",\n+        \"Topic :: Software Development\",\n+        \"Topic :: Scientific/Engineering\",\n+        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n+        \"Topic :: Scientific/Engineering :: Image Recognition\",\n+        \"Operating System :: Microsoft :: Windows\",\n+        \"Operating System :: POSIX\",\n+        \"Operating System :: Unix\",\n+        \"Operating System :: MacOS\"\n+    ],\n+    project_urls={\n+        'Bug Reports': 'https://github.com/ultralytics/yolov5/issues',\n+        'Funding': 'https://ultralytics.com',\n+        'Source': 'https://github.com/ultralytics/yolov5/',\n+    },\n+    entry_points={\n+        'console_scripts': [\n+            'yolov5_train=yolov5.train:main',\n+            'yolov5_test=yolov5.test:main',\n+            'yolov5_detect=yolov5.detect:main',\n+            'yolov5_export=yolov5.models.export:main'\n+        ],\n+    }\n+)\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR introduces significant changes but highlights issues with model deserialization due to directory restructuring. You're correctly addressing `yolov5_in_syspath`, yet using `sys.path.append` can create interference, which should be avoided. Instead, leveraging `entry_points` in `setup.py` for command execution is a cleaner solution. Additionally, it’s crucial to remove `requirements.txt` to prevent user confusion. Updating the README with clear instructions will aid usability. Cleaning up the approach ensures compatibility and minimizes potential breaks for end-users."
      }
    ],
    "token_estimation": 1663.75
  },
  {
    "index": 84,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/utils/wandb_logging/wandb_utils.py b/utils/wandb_logging/wandb_utils.py\nnew file mode 100644\nindex 000000000000..264cd4840e3c\n--- /dev/null\n+++ b/utils/wandb_logging/wandb_utils.py\n@@ -0,0 +1,145 @@\n+import json\n+import shutil\n+import sys\n+from datetime import datetime\n+from pathlib import Path\n+\n+import torch\n+\n+sys.path.append(str(Path(__file__).parent.parent.parent))  # add utils/ to path\n+from utils.general import colorstr, xywh2xyxy\n+\n+try:\n+    import wandb\n+except ImportError:\n+    wandb = None\n+    print(f\"{colorstr('wandb: ')}Install Weights & Biases for YOLOv5 logging with 'pip install wandb' (recommended)\")\n+\n+WANDB_ARTIFACT_PREFIX = 'wandb-artifact://'\n+\n+\n+def remove_prefix(from_string, prefix):\n+    return from_string[len(prefix):]\n+\n+\n+class WandbLogger():\n+    def __init__(self, opt, name, run_id, data_dict, job_type='Training'):\n+        self.wandb = wandb\n+        self.wandb_run = wandb.init(config=opt, resume=\"allow\",\n+                                    project='YOLOv5' if opt.project == 'runs/train' else Path(opt.project).stem,\n+                                    name=name,\n+                                    job_type=job_type,\n+                                    id=run_id) if self.wandb else None\n+\n+        if job_type == 'Training':\n+            self.setup_training(opt, data_dict)\n+            if opt.bbox_interval == -1:\n+                opt.bbox_interval = (opt.epochs // 10) if opt.epochs > 10 else opt.epochs\n+            if opt.save_period == -1:\n+                opt.save_period = (opt.epochs // 10) if opt.epochs > 10 else opt.epochs\n+\n+    def setup_training(self, opt, data_dict):\n+        self.log_dict = {}\n+        self.train_artifact_path, self.trainset_artifact = \\\n+            self.download_dataset_artifact(data_dict['train'], opt.artifact_alias)\n+        self.test_artifact_path, self.testset_artifact = \\\n+            self.download_dataset_artifact(data_dict['val'], opt.artifact_alias)\n+        self.result_artifact, self.result_table, self.weights = None, None, None\n+        if self.train_artifact_path is not None:\n+            train_path = Path(self.train_artifact_path) / 'data/images/'\n+            data_dict['train'] = str(train_path)\n+        if self.test_artifact_path is not None:\n+            test_path = Path(self.test_artifact_path) / 'data/images/'\n+            data_dict['val'] = str(test_path)\n+            self.result_artifact = wandb.Artifact(\"run_\" + wandb.run.id + \"_progress\", \"evaluation\")\n+            self.result_table = wandb.Table([\"epoch\", \"id\", \"prediction\", \"avg_confidence\"])\n+        if opt.resume_from_artifact:\n+            modeldir, _ = self.download_model_artifact(opt.resume_from_artifact)\n+            if modeldir:\n+                self.weights = Path(modeldir) / \"best.pt\"\n+                opt.weights = self.weights\n+\n+    def download_dataset_artifact(self, path, alias):\n+        if path.startswith(WANDB_ARTIFACT_PREFIX):\n+            dataset_artifact = wandb.use_artifact(remove_prefix(path, WANDB_ARTIFACT_PREFIX) + \":\" + alias)\n+            assert dataset_artifact is not None, \"'Error: W&B dataset artifact doesn\\'t exist'\"\n+            datadir = dataset_artifact.download()\n+            labels_zip = Path(datadir) / \"data/labels.zip\"\n+            shutil.unpack_archive(labels_zip, Path(datadir) / 'data/labels', 'zip')\n+            print(\"Downloaded dataset to : \", datadir)\n+            return datadir, dataset_artifact\n+        return None, None\n+\n+    def download_model_artifact(self, name):\n+        model_artifact = wandb.use_artifact(name + \":latest\")\n+        assert model_artifact is not None, 'Error: W&B model artifact doesn\\'t exist'\n+        modeldir = model_artifact.download()\n+        print(\"Downloaded model to : \", modeldir)\n+        return modeldir, model_artifact\n+\n+    def log_model(self, path, opt, epoch):\n+        datetime_suffix = datetime.today().strftime('%Y-%m-%d-%H-%M-%S')\n+        model_artifact = wandb.Artifact('run_' + wandb.run.id + '_model', type='model', metadata={\n+            'original_url': str(path),\n+            'epoch': epoch + 1,\n+            'save period': opt.save_period,\n+            'project': opt.project,\n+            'datetime': datetime_suffix\n+        })\n+        model_artifact.add_file(str(path / 'last.pt'), name='last.pt')\n+        model_artifact.add_file(str(path / 'best.pt'), name='best.pt')\n+        wandb.log_artifact(model_artifact)\n+        print(\"Saving model artifact on epoch \", epoch + 1)\n+\n+    def log_dataset_artifact(self, dataset, class_to_id, name='dataset'):\n+        artifact = wandb.Artifact(name=name, type=\"dataset\")\n+        image_path = dataset.path\n+        artifact.add_dir(image_path, name='data/images')\n+        table = wandb.Table(columns=[\"id\", \"train_image\", \"Classes\"])\n+        class_set = wandb.Classes([{'id': id, 'name': name} for id, name in class_to_id.items()])\n+        for si, (img, labels, paths, shapes) in enumerate(dataset):\n+            height, width = shapes[0]\n+            labels[:, 2:] = (xywh2xyxy(labels[:, 2:].view(-1, 4)))\n+            labels[:, 2:] *= torch.Tensor([width, height, width, height])\n+            box_data = []\n+            img_classes = {}\n+            for cls, *xyxy in labels[:, 1:].tolist():\n+                cls = int(cls)\n+                box_data.append({\"position\": {\"minX\": xyxy[0], \"minY\": xyxy[1], \"maxX\": xyxy[2], \"maxY\": xyxy[3]},\n+                                 \"class_id\": cls,\n+                                 \"box_caption\": \"%s\" % (class_to_id[cls]),\n+                                 \"scores\": {\"acc\": 1},\n+                                 \"domain\": \"pixel\"})\n+                img_classes[cls] = class_to_id[cls]\n+            boxes = {\"ground_truth\": {\"box_data\": box_data, \"class_labels\": class_to_id}}  # inference-space\n+            table.add_data(si, wandb.Image(paths, classes=class_set, boxes=boxes), json.dumps(img_classes))\n+        artifact.add(table, name)\n+        labels_path = 'labels'.join(image_path.rsplit('images', 1))\n+        zip_path = Path(labels_path).parent / (name + '_labels.zip')\n+        if not zip_path.is_file():  # make_archive won't check if file exists\n+            shutil.make_archive(zip_path.with_suffix(''), 'zip', labels_path)\n+        artifact.add_file(str(zip_path), name='data/labels.zip')\n+        wandb.log_artifact(artifact)\n+        print(\"Saving data to W&B...\")\n+\n+    def log(self, log_dict):\n+        if self.wandb_run:\n+            for key, value in log_dict.items():\n+                self.log_dict[key] = value\n+\n+    def end_epoch(self):\n+        if self.wandb_run and self.log_dict:\n+            wandb.log(self.log_dict)\n+        self.log_dict = {}\n+\n+    def finish_run(self):\n+        if self.wandb_run:\n+            if self.result_artifact:\n+                print(\"Add Training Progress Artifact\")\n+                self.result_artifact.add(self.result_table, 'result')\n+                train_results = wandb.JoinedTable(self.testset_artifact.get(\"val\"), self.result_table, \"id\")\n+                self.result_artifact.add(train_results, 'joined_result')\n+                wandb.log_artifact(self.result_artifact)\n+            if self.log_dict:\n+                wandb.log(self.log_dict)\n+            wandb.run.finish()\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR showed a failure in a test that seems unrelated to the current changes. It may be beneficial to implement automated CI reruns to handle intermittent failures. Additionally, the top-level directory should remain clean, and moving new functionality to `utils/wandb_utils.py` or creating a `utils/wandb` directory would help with organization. Numerous code improvements were also suggested, including using `Path()` for file paths and eliminating redundancy, which you’ve mostly addressed. Clarification is needed regarding compatibility with the `--nosave` option in `train.py`."
      }
    ],
    "token_estimation": 1958.25
  },
  {
    "index": 85,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/models/common.py b/models/common.py\nindex 75cc4e97bbc7..521551f273d0 100644\n--- a/models/common.py\n+++ b/models/common.py\n@@ -881,3 +881,165 @@ def forward(self, x):\n         if isinstance(x, list):\n             x = torch.cat(x, 1)\n         return self.linear(self.drop(self.pool(self.conv(x)).flatten(1)))\n+\n+\n+# contributed by @aash1999\n+class ChannelAttention(nn.Module):\n+\n+    def __init__(self, in_planes, ratio=16):\n+        \"\"\"\n+        Initialize the Channel Attention module.\n+\n+        Args:\n+            in_planes (int): Number of input channels.\n+            ratio (int): Reduction ratio for the hidden channels in the channel attention block.\n+        \"\"\"\n+        super().__init__()\n+        self.avg_pool = nn.AdaptiveAvgPool2d(1)\n+        self.max_pool = nn.AdaptiveMaxPool2d(1)\n+        self.f1 = nn.Conv2d(in_planes, in_planes // ratio, 1, bias=False)\n+        self.relu = nn.ReLU()\n+        self.f2 = nn.Conv2d(in_planes // ratio, in_planes, 1, bias=False)\n+        self.sigmoid = nn.Sigmoid()\n+\n+    def forward(self, x):\n+        \"\"\"\n+        Forward pass of the Channel Attention module.\n+\n+        Args:\n+            x (torch.Tensor): Input tensor.\n+\n+        Returns:\n+            out (torch.Tensor): Output tensor after applying channel attention.\n+        \"\"\"\n+        with warnings.catch_warnings():\n+            warnings.simplefilter('ignore')\n+            avg_out = self.f2(self.relu(self.f1(self.avg_pool(x))))\n+            max_out = self.f2(self.relu(self.f1(self.max_pool(x))))\n+            out = self.sigmoid(avg_out + max_out)\n+            return out\n+\n+\n+# contributed by @aash1999\n+class SpatialAttention(nn.Module):\n+\n+    def __init__(self, kernel_size=7):\n+        \"\"\"\n+        Initialize the Spatial Attention module.\n+\n+        Args:\n+            kernel_size (int): Size of the convolutional kernel for spatial attention.\n+        \"\"\"\n+        super().__init__()\n+        assert kernel_size in (3, 7), 'kernel size must be 3 or 7'\n+        padding = 3 if kernel_size == 7 else 1\n+        self.conv = nn.Conv2d(2, 1, kernel_size, padding=padding, bias=False)\n+        self.sigmoid = nn.Sigmoid()\n+\n+    def forward(self, x):\n+        \"\"\"\n+        Forward pass of the Spatial Attention module.\n+\n+        Args:\n+            x (torch.Tensor): Input tensor.\n+\n+        Returns:\n+            out (torch.Tensor): Output tensor after applying spatial attention.\n+        \"\"\"\n+        with warnings.catch_warnings():\n+            warnings.simplefilter('ignore')\n+            avg_out = torch.mean(x, dim=1, keepdim=True)\n+            max_out, _ = torch.max(x, dim=1, keepdim=True)\n+            x = torch.cat([avg_out, max_out], dim=1)\n+            x = self.conv(x)\n+            return self.sigmoid(x)\n+\n+\n+# contributed by @aash1999\n+class CBAM(nn.Module):\n+    # ch_in, ch_out, shortcut, groups, expansion, ratio, kernel_size\n+    def __init__(self, c1, c2, kernel_size=3, shortcut=True, g=1, e=0.5, ratio=16):\n+        \"\"\"\n+        Initialize the CBAM (Convolutional Block Attention Module) .\n+\n+        Args:\n+            c1 (int): Number of input channels.\n+            c2 (int): Number of output channels.\n+            kernel_size (int): Size of the convolutional kernel.\n+            shortcut (bool): Whether to use a shortcut connection.\n+            g (int): Number of groups for grouped convolutions.\n+            e (float): Expansion factor for hidden channels.\n+            ratio (int): Reduction ratio for the hidden channels in the channel attention block.\n+        \"\"\"\n+        super().__init__()\n+        c_ = int(c2 * e)  # hidden channels\n+        self.cv1 = Conv(c1, c_, 1, 1)\n+        self.cv2 = Conv(c_, c2, 3, 1, g=g)\n+        self.add = shortcut and c1 == c2\n+        self.channel_attention = ChannelAttention(c2, ratio)\n+        self.spatial_attention = SpatialAttention(kernel_size)\n+\n+    def forward(self, x):\n+        \"\"\"\n+        Forward pass of the CBAM .\n+\n+        Args:\n+            x (torch.Tensor): Input tensor.\n+\n+        Returns:\n+            out (torch.Tensor): Output tensor after applying the CBAM bottleneck.\n+        \"\"\"\n+        with warnings.catch_warnings():\n+            warnings.simplefilter('ignore')\n+            x2 = self.cv2(self.cv1(x))\n+            out = self.channel_attention(x2) * x2\n+            out = self.spatial_attention(out) * out\n+            return x + out if self.add else out\n+\n+\n+# contributed by @aash1999\n+class Involution(nn.Module):\n+\n+    def __init__(self, c1, c2, kernel_size, stride):\n+        \"\"\"\n+        Initialize the Involution module.\n+\n+        Args:\n+            c1 (int): Number of input channels.\n+            c2 (int): Number of output channels.\n+            kernel_size (int): Size of the involution kernel.\n+            stride (int): Stride for the involution operation.\n+        \"\"\"\n+        super().__init__()\n+        self.kernel_size = kernel_size\n+        self.stride = stride\n+        self.c1 = c1\n+        reduction_ratio = 1\n+        self.group_channels = 16\n+        self.groups = self.c1 // self.group_channels\n+        self.conv1 = Conv(c1, c1 // reduction_ratio, 1)\n+        self.conv2 = Conv(c1 // reduction_ratio, kernel_size ** 2 * self.groups, 1, 1)\n+\n+        if stride > 1:\n+            self.avgpool = nn.AvgPool2d(stride, stride)\n+        self.unfold = nn.Unfold(kernel_size, 1, (kernel_size - 1) // 2, stride)\n+\n+    def forward(self, x):\n+        \"\"\"\n+        Forward pass of the Involution module.\n+\n+        Args:\n+            x (torch.Tensor): Input tensor.\n+\n+        Returns:\n+            out (torch.Tensor): Output tensor after applying the involution operation.\n+        \"\"\"\n+        with warnings.catch_warnings():\n+            warnings.simplefilter('ignore')\n+            weight = self.conv2(x)\n+            b, c, h, w = weight.shape\n+            weight = weight.view(b, self.groups, self.kernel_size ** 2, h, w).unsqueeze(2)\n+            out = self.unfold(x).view(b, self.groups, self.group_channels, self.kernel_size ** 2, h, w)\n+            out = (weight * out).sum(dim=3).view(b, self.c1, h, w)\n+\n+            return out\ndiff --git a/models/hub/yolov5s-cbam-involution.yaml b/models/hub/yolov5s-cbam-involution.yaml\nnew file mode 100644\nindex 000000000000..9ac132e1cd78\n--- /dev/null\n+++ b/models/hub/yolov5s-cbam-involution.yaml\n@@ -0,0 +1,60 @@\n+# YOLOv5 🚀 by Ultralytics, GPL-3.0 license\n+\n+# Parameters\n+nc: 10  # number of classes\n+depth_multiple: 0.33  # model depth multiple\n+width_multiple: 0.50  # layer channel multiple\n+anchors:\n+  - [2.9434,4.0435, 3.8626,8.5592, 6.8534, 5.9391]\n+  - [10,13, 16,30, 33,23]  # P3/8\n+  - [30,61, 62,45, 59,119]  # P4/16\n+  - [116,90, 156,198, 373,326]  # P5/32\n+\n+# YOLOv5 v6.0 backbone\n+backbone:\n+  # [from, number, module, args]\n+  [[-1, 1, Conv, [64, 6, 2, 2]],  # 0-P1/2\n+   [-1, 1, Conv, [128, 3, 2]],  # 1-P2/4\n+   [-1, 3, C3, [128]],\n+   [-1, 1, Conv, [256, 3, 2]],  # 3-P3/8\n+   [-1, 6, C3, [256]],\n+   [-1, 1, Conv, [512, 3, 2]],  # 5-P4/16\n+   [-1, 9, C3, [512]],\n+   [-1, 1, Conv, [1024, 3, 2]],  # 7-P5/32\n+   [-1, 3, C3, [1024]],\n+   [-1, 3, CBAM, [1024, 3]],\n+   [-1, 1, SPPF, [1024, 5]],  # 10\n+  ]\n+\n+# YOLOv5 v6.0 head\n+head:\n+  [[-1, 1, Involution, [1024, 1, 1]],\n+   [-1, 1, Conv, [512, 1, 1]],\n+   [-1, 1, nn.Upsample, [None, 2, 'nearest']],\n+   [[-1, 6], 1, Concat, [1]],  # cat backbone P4\n+   [-1, 3, C3, [512, False]],  # 15\n+\n+   [-1, 1, Conv, [512, 1, 1]],\n+   [-1, 1, nn.Upsample, [None, 2, 'nearest']],\n+   [[-1, 4], 1, Concat, [1]],  # cat backbone P3\n+   [-1, 3, C3, [512, False]],  # 19\n+\n+   [-1, 1, Conv, [256, 1, 1]],\n+   [-1, 1, nn.Upsample, [None, 2, 'nearest']],\n+   [[-1, 2], 1, Concat, [1]],\n+   [-1, 3, C3, [256, False]], # 23 160*160  p2 head\n+\n+   [-1, 1, Conv, [256, 3, 2]],\n+   [[-1, 19], 1, Concat, [1]],\n+   [-1, 3, C3, [512, False]],  # 26  80*80 p3 head\n+\n+   [-1, 1, Conv, [256, 3, 2]],\n+   [[-1, 15], 1, Concat, [1]],\n+   [-1, 3, C3, [256, False]], # 29 40*40 p4 head\n+\n+   [-1, 1, Conv, [512, 3, 2]],\n+   [[-1, 11], 1, Concat, [1]],\n+   [-1, 3, C3, [1024, False]],  # 32 20*20 p5 head\n+\n+   [[23, 26, 29, 32], 1, Detect, [nc, anchors]],  # Detect(P2, P3, P4, P5)\n+  ]\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR introduces the integration of CBAM and Involution modules into the YOLOv5 model, along with two configuration files, which appear well-documented and aligned with performance enhancement goals. While the modifications are promising, ensure all open issues are resolved and that tests pass successfully before merging. The user also encountered checks failing due to trailing whitespace and yapf formatting—removing unnecessary spaces and running the yapf formatter should resolve these issues. Overall, solid work, but focus on these cleanup tasks."
      }
    ],
    "token_estimation": 2172.25
  },
  {
    "index": 88,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/models/yolov4.yaml b/models/yolov4.yaml\nnew file mode 100644\nindex 000000000000..6d2e4327cb4a\n--- /dev/null\n+++ b/models/yolov4.yaml\n@@ -0,0 +1,53 @@\n+# parameters\n+nc: 80  # number of classes\n+depth_multiple: 1.0  # model depth multiple\n+width_multiple: 1.0  # layer channel multiple\n+\n+# anchors\n+anchors:\n+  - [10,13, 16,30, 33,23]  # P3/8\n+  - [30,61, 62,45, 59,119]  # P4/16\n+  - [116,90, 156,198, 373,326]  # P5/32\n+\n+# CSPDarknet-53 backbone\n+backbone:\n+  # [from, number, module, args]\n+  [[-1, 1, Conv, [32, 3, 1]],  # 0\n+   [-1, 1, Conv, [64, 3, 2]],  # 1-P1/2\n+   [-1, 1, BottleneckCSP, [64]],\n+   [-1, 1, Conv, [128, 3, 2]],  # 3-P2/4\n+   [-1, 2, BottleneckCSP, [128]],\n+   [-1, 1, Conv, [256, 3, 2]],  # 5-P3/8\n+   [-1, 8, BottleneckCSP, [256]],\n+   [-1, 1, Conv, [512, 3, 2]],  # 7-P4/16\n+   [-1, 8, BottleneckCSP, [512]],\n+   [-1, 1, Conv, [1024, 3, 2]], # 9-P5/32\n+   [-1, 4, BottleneckCSP, [1024]],  # 10\n+  ]\n+\n+# YOLOv3-SPP head\n+\n+head:\n+  [[-1, 1, Bottleneck, [1024, False]],  # 11\n+   [-1, 1, Conv, [512, 1, 1]],\n+   [-1, 1, SPP, [512, [5, 9, 13]]],\n+   [-1, 1, Bottleneck, [1024, False]],\n+   [-1, 1, Bottleneck, [1024, False]],\n+   [-1, 1, nn.Conv2d, [na * (nc + 5), 1, 1]],  # 12 (P5/32-large)\n+\n+   [-3, 1, Conv, [256, 1, 1]],\n+   [-1, 1, nn.Upsample, [None, 2, \"nearest\"]],\n+   [[-1, 8], 1, Concat, [1]],  # concat backbone P4\n+   [-1, 1, Bottleneck, [512, False]],\n+   [-1, 2, Bottleneck, [512, False]],\n+   [-1, 1, nn.Conv2d, [na * (nc + 5), 1, 1]],  # 18 (P4/16-medium)\n+\n+   [-3, 1, Conv, [128, 1, 1]],\n+   [-1, 1, nn.Upsample, [None, 2, \"nearest\"]],\n+   [[-1, 6], 1, Concat, [1]],  # concat backbone P3\n+   [-1, 1, Bottleneck, [256, False]],\n+   [-1, 2, Bottleneck, [256, False]],\n+   [-1, 1, nn.Conv2d, [na * (nc + 5), 1, 1]],  # 24 (P3/8-small)\n+\n+   [[], 1, Detect, [nc, anchors]],   # Detect(P3, P4, P5)\n+  ]\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The analysis shows that PANet improves performance over FPN, especially for small and medium objects, which aligns with the findings from COCO. The AP and AR metrics indicate meaningful enhancements, particularly in precision for small objects. However, you should validate the object sizes in your custom dataset, as small object definitions may differ. Additionally, ensure your architecture configurations match the number of classes to prevent runtime errors. It’s essential to optimize your YAML settings to address the channel mismatch when training. Overall, results can vary based on configurations, so careful tuning is necessary."
      }
    ],
    "token_estimation": 624.5
  },
  {
    "index": 89,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/utils/metrics.py b/utils/metrics.py\nindex 5646f40e9860..c95af58c714c 100644\n--- a/utils/metrics.py\n+++ b/utils/metrics.py\n@@ -123,6 +124,171 @@ def compute_ap(recall, precision):\n     return ap, mpre, mrec\n \n \n+class AUROC:\n+    \"\"\" Compute the auroc scores, given the auc for each class.\n+    \"\"\"\n+\n+    def __init__(self, nc, conf=0.25, iou_thres=0.45):\n+        \"\"\"\n+        different thresholds (like prediction confidence, Iou) will have a great impact on the results of AUC.\n+        Default: conf=0.25, iou_thres=0.45\n+        \"\"\"\n+        self.auc_scores = np.zeros(nc)  # Store the AUROC score for each cls\n+        self.nc = nc  # number of cls\n+        self.conf = conf  # confidence threshold\n+        self.iou_thres = iou_thres  # IoU threshold\n+\n+        self.pred = [[] for _ in range(nc)]  # list to store model predictions for each class\n+        self.true = [[] for _ in range(nc)]  # list to store ground truth labels for each class\n+\n+        import subprocess\n+        subprocess.check_call(['pip', 'install', 'scikit-learn'])\n+        subprocess.check_call(['pip', 'install', 'plotly', 'kaleido'])\n+\n+    def process_batch(self, detections, labels):\n+        \"\"\"\n+        Return /\n+        Both sets of boxes are expected to be in (x1, y1, x2, y2) format.\n+        Arguments:\n+            detections (Array[N, 6]), x1, y1, x2, y2, conf, class\n+            labels (Array[M, 5]), class, x1, y1, x2, y2\n+        Returns:\n+            None, updates pred[list] and true[list] accordingly\n+        \"\"\"\n+        if detections is None:\n+            # If there is no prediction result, all ground truths are considered to be negative samples,\n+            # Ignored during calculating auc\n+            return\n+\n+        t = 0\n+\n+        detections = detections[detections[:, 4] > self.conf]\n+        # Filter out prediction db boxes with low confidence (similar to nms)\n+        gt_classes = labels[:, 0].int()  # All gt box categories (int) cls, may be repeated\n+        detection_classes = detections[:, 5].int()  # All pred box cls (int) categories, may repeat positive + negative\n+        iou = box_iou(labels[:, 1:], detections[:, :4])  # # Find the iou of all gt boxes and all pred boxes\n+\n+        x = torch.where(iou > self.iou_thres)  # Filtered by iou threshold\n+\n+        if x[0].shape[0]:  # When have iou > iou threshold\n+            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()\n+            # cat gt_index+pred_index+iou\n+            if x[0].shape[0] > 1:\n+                matches = matches[matches[:, 2].argsort()[::-1]]\n+                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n+                matches = matches[matches[:, 2].argsort()[::-1]]\n+                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n+                # finally get the one with the largest iou of each db pred and all db gt (greater than the iou_thres)\n+                # Each db gt will only correspond to the only one db pred. The filtered preds are all positive samples _> (tp or fp)\n+        else:\n+            matches = np.zeros((0, 3))\n+\n+        n = matches.shape[0] > 0\n+        m0, m1, _ = matches.transpose().astype(int)\n+        for class_id in range(self.nc):\n+            for i, gc in enumerate(gt_classes):\n+                if gc == class_id:\n+                    j = m0 == i\n+                    if n and sum(j) == 1:\n+                        if detection_classes[m1[j]] == gc:\n+                            # same cls -> True Positive\n+                            self.pred[class_id].append(detections[m1[j], 4].item())  # save conf\n+                            self.true[class_id].append(1)  # True Positive set 1\n+                        else:\n+                            # diff cls -> False Positive\n+                            self.pred[class_id].append(detections[m1[j], 4].item())  # save conf\n+                            self.true[class_id].append(0)  # False Positive set 0\n+                        t = t + 1\n+                    '''\n+                    # Ignored during calculating auc\n+                    else:\n+                        self.pred[class_id].append(0.0)\n+                        self.true[class_id].append(-1)\n+                    '''\n+\n+    def out(self):\n+        '''\n+        Computes the AUROC score for each category and returns it.\n+        '''\n+        from sklearn.metrics import roc_auc_score, roc_curve\n+        auc_scores = np.zeros(self.nc)\n+        fpr_ = [[] for _ in range(self.nc)]\n+        tpr_ = [[] for _ in range(self.nc)]\n+\n+        for class_id in range(self.nc):\n+            labels = self.true[class_id]\n+            preds = self.pred[class_id]\n+            try:\n+                fpr_class, tpr_class, _ = roc_curve(labels, preds)\n+                auc_scores[class_id] = roc_auc_score(labels, preds)\n+                fpr_[class_id] = fpr_class\n+                tpr_[class_id] = tpr_class\n+\n+            except ValueError:\n+                # No pred = set auc to 0\n+                # print('No pred db for cls ' + str(class_id) + ', Set the auc value to 0 ...')\n+                auc_scores[class_id] = 0\n+\n+        return auc_scores, fpr_, tpr_\n+\n+    def plot_polar_chart(self, auc_scores, save_dir='', names=()):\n+        '''\n+        Generate polar_chart for auc scores.\n+        auc_scores : [dict] auc_scores\n+        names : [list] cls names\n+        return None\n+        save img at Path(save_dir) / 'polar_chart.png'\n+        '''\n+        import plotly.graph_objects as go\n+        mauc = auc_scores.mean()\n+        auc_scores_name = dict(zip(names, auc_scores))\n+        auc_scores_name['mAUC'] = mauc\n+        df = pd.DataFrame.from_dict(auc_scores_name, orient='index')\n+        columns = list(df.index)\n+        fig = go.Figure(\n+            data=[go.Scatterpolar(r=(df[0] * 100).round(0), fill='toself', name='diseases', theta=columns)],\n+            layout=go.Layout(\n+                # title=go.layout.Title(text='Class AUC'),\n+                polar={\n+                    'radialaxis': {\n+                        'range': [0, 100],\n+                        'tickvals': [0, 25, 50, 75, 100],\n+                        'ticktext': ['0%', '25%', '50%', '75%', '100%'],\n+                        'visible': True, }},\n+                showlegend=True,\n+                template='plotly_dark',\n+            ),\n+        )\n+        file_name = Path(save_dir) / 'polar_chart.png'\n+        fig.write_image(file_name)\n+        # print('plot_polar_chart DONE')\n+\n+    def plot_auroc_curve(self, fpr_, tpr_, auc_scores, save_dir='', names=()):\n+        # AUROC curve\n+        fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n+\n+        if 0 < len(names) < 21:  # display per-class legend if < 21 classes\n+            for i in range(len(names)):\n+                ax.plot(fpr_[i], tpr_[i], linewidth=1, label=f'{names[i]} {auc_scores[i]:.3f}')  # plot(F_PR, T_PR)\n+        else:\n+            for i in range(len(names)):\n+                ax.plot(fpr_[i], tpr_[i], linewidth=1, color='grey')  # plot(F_PR, T_PR)\n+\n+        ax.plot([0, 1], [0, 1], linestyle='--', color='black', linewidth=1)  # diagonal line\n+        ax.set_xlabel('False Positive Rate')\n+        ax.set_ylabel('True Positive Rate')\n+        ax.set_xlim(0, 1)\n+        ax.set_ylim(0, 1)\n+        ax.legend(bbox_to_anchor=(1.04, 1), loc='upper left')\n+        ax.set_title('AUROC Curve')\n+        if save_dir:\n+            save_path = Path(save_dir) / 'auroc_curve.png'\n+            fig.savefig(save_path, dpi=250)\n+            # print(f'Saved AUROC curve at: {save_path}')\n+        plt.close(fig)\n+        # print('plot_auroc_curve DONE')\n+\n+\n class ConfusionMatrix:\n     # Updated version of https://github.com/kaanakan/object_detection_confusion_matrix\n     def __init__(self, nc, conf=0.25, iou_thres=0.45):\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The MAUC score being 0 across iterations suggests potential dataset issues or errors in the calculation logic. Check the confusion matrix; a zero true negative count indicates problems, especially with imbalanced datasets or single-class detection. Before adjusting hyperparameters, ensure AUC calculation aligns with expectations—refer to the AUROC class in metrics.py for details. Also, to match the research paper, update all occurrences of the IOU threshold in the code. Adjustments in dataset handling might be necessary for better class segmentation."
      }
    ],
    "token_estimation": 2103.0
  },
  {
    "index": 90,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/gpt_engineer/chat_to_files.py b/gpt_engineer/chat_to_files.py\nindex 8e251cbdfd..0223a18fd1 100644\n--- a/gpt_engineer/chat_to_files.py\n+++ b/gpt_engineer/chat_to_files.py\n@@ -40,3 +41,57 @@ def to_files(chat, workspace):\n     files = parse_chat(chat)\n     for file_name, file_content in files:\n         workspace[file_name] = file_content\n+\n+\n+def overwrite_files(chat, dbs, replace_files):\n+    \"\"\"\n+    Replace the AI files to the older local files.\n+    \"\"\"\n+    dbs.workspace[\"all_output.txt\"] = chat\n+\n+    files = parse_chat(chat)\n+    for file_name, file_content in files:\n+        # Verify if the file created by the AI agent was in the input list\n+        if file_name in replace_files:\n+            # If the AI created a file from our input list, we replace it.\n+            with open(replace_files[file_name], \"w\") as text_file:\n+                text_file.write(file_content)\n+        else:\n+            # If the AI create a new file I don't know where to put it yet\n+            # maybe we can think in a smarter solution for this in the future\n+            # like asking the AI where to put it.\n+            #\n+            # by now, just add this to the workspace inside .gpteng folder\n+            print(\n+                f\"Could not find file path for '{file_name}', creating file in workspace\"\n+            )\n+            dbs.workspace[file_name] = file_content\n+\n+\n+def get_code_strings(input) -> dict[str, str]:\n+    \"\"\"\n+    Read file_list.txt and return file names and its content.\n+    \"\"\"\n+    files_paths = input[\"file_list.txt\"].strip().split(\"\\n\")\n+    files_dict = {}\n+    for file_path in files_paths:\n+        file_data = \"\"\n+        with open(file_path, \"r\") as file:\n+            file_data = file.read()\n+        if file_data:\n+            file_name = os.path.basename(file_path).split(\"/\")[-1]\n+            files_dict[file_name] = file_data\n+    return files_dict\n+\n+\n+def format_file_to_input(file_name: str, file_content: str) -> str:\n+    \"\"\"\n+    Format a file string to use as input to AI agent\n+    \"\"\"\n+    file_str = f\"\"\"\n+    {file_name}\n+    ```\n+    {file_content}\n+    ```\n+    \"\"\"\n+    return file_str\ndiff --git a/gpt_engineer/file_selector.py b/gpt_engineer/file_selector.py\nnew file mode 100644\nindex 0000000000..357b8f9094\n--- /dev/null\n+++ b/gpt_engineer/file_selector.py\n@@ -0,0 +1,318 @@\n+import os\n+import re\n+import sys\n+import tkinter as tk\n+import tkinter.filedialog as fd\n+\n+from pathlib import Path\n+from typing import List, Union\n+\n+\n+class DisplayablePath(object):\n+    \"\"\"\n+    A class representing a displayable path in a file explorer.\n+    \"\"\"\n+\n+    display_filename_prefix_middle = \"├── \"\n+    display_filename_prefix_last = \"└── \"\n+    display_parent_prefix_middle = \"    \"\n+    display_parent_prefix_last = \"│   \"\n+\n+    def __init__(\n+        self, path: Union[str, Path], parent_path: \"DisplayablePath\", is_last: bool\n+    ):\n+        \"\"\"\n+        Initialize a DisplayablePath object.\n+\n+        Args:\n+            path (Union[str, Path]): The path of the file or directory.\n+            parent_path (DisplayablePath): The parent path of the file or directory.\n+            is_last (bool): Whether the file or directory is the last child of its parent.\n+        \"\"\"\n+        self.depth: int = 0\n+        self.path = Path(str(path))\n+        self.parent = parent_path\n+        self.is_last = is_last\n+        if self.parent:\n+            self.depth = self.parent.depth + 1\n+\n+    @property\n+    def display_name(self) -> str:\n+        \"\"\"\n+        Get the display name of the file or directory.\n+\n+        Returns:\n+            str: The display name.\n+        \"\"\"\n+        if self.path.is_dir():\n+            return self.path.name + \"/\"\n+        return self.path.name\n+\n+    @classmethod\n+    def make_tree(cls, root: Union[str, Path], parent=None, is_last=False, criteria=None):\n+        \"\"\"\n+        Generate a tree of DisplayablePath objects.\n+\n+        Args:\n+            root: The root path of the tree.\n+            parent: The parent path of the root path. Defaults to None.\n+            is_last: Whether the root path is the last child of its parent.\n+            criteria: The criteria function to filter the paths. Defaults to None.\n+\n+        Yields:\n+            DisplayablePath: The DisplayablePath objects in the tree.\n+        \"\"\"\n+        root = Path(str(root))\n+        criteria = criteria or cls._default_criteria\n+\n+        displayable_root = cls(root, parent, is_last)\n+        yield displayable_root\n+\n+        children = sorted(\n+            list(path for path in root.iterdir() if criteria(path)),\n+            key=lambda s: str(s).lower(),\n+        )\n+        count = 1\n+        for path in children:\n+            is_last = count == len(children)\n+            if path.is_dir():\n+                yield from cls.make_tree(\n+                    path, parent=displayable_root, is_last=is_last, criteria=criteria\n+                )\n+            else:\n+                yield cls(path, displayable_root, is_last)\n+            count += 1\n+\n+    @classmethod\n+    def _default_criteria(cls, path: Path) -> bool:\n+        \"\"\"\n+        The default criteria function to filter the paths.\n+\n+        Args:\n+            path: The path to check.\n+\n+        Returns:\n+            bool: True if the path should be included, False otherwise.\n+        \"\"\"\n+        return True\n+\n+    def displayable(self) -> str:\n+        \"\"\"\n+        Get the displayable string representation of the file or directory.\n+\n+        Returns:\n+            str: The displayable string representation.\n+        \"\"\"\n+        if self.parent is None:\n+            return self.display_name\n+\n+        _filename_prefix = (\n+            self.display_filename_prefix_last\n+            if self.is_last\n+            else self.display_filename_prefix_middle\n+        )\n+\n+        parts = [\"{!s} {!s}\".format(_filename_prefix, self.display_name)]\n+\n+        parent = self.parent\n+        while parent and parent.parent is not None:\n+            parts.append(\n+                self.display_parent_prefix_middle\n+                if parent.is_last\n+                else self.display_parent_prefix_last\n+            )\n+            parent = parent.parent\n+\n+        return \"\".join(reversed(parts))\n+\n+\n+class TerminalFileSelector:\n+    def __init__(self, root_folder_path: Path) -> None:\n+        self.number_of_selectable_items = 0\n+        self.selectable_file_paths: dict[int, str] = {}\n+        self.file_path_list: list = []\n+        self.db_paths = DisplayablePath.make_tree(\n+            root_folder_path, parent=None, criteria=self.is_in_ignoring_extensions\n+        )\n+\n+    def display(self):\n+        \"\"\"\n+        Select files from a directory and display the selected files.\n+        \"\"\"\n+        count = 0\n+        file_path_enumeration = {}\n+        file_path_list = []\n+        for path in self.db_paths:\n+            n_digits = len(str(count))\n+            n_spaces = 3 - n_digits\n+            if n_spaces < 0:\n+                # We can only print 1000 aligned files. I think it is decent enough\n+                n_spaces = 0\n+            spaces_str = \" \" * n_spaces\n+            if not path.path.is_dir():\n+                print(f\"{count}. {spaces_str}{path.displayable()}\")\n+                file_path_enumeration[count] = path.path\n+                file_path_list.append(path.path)\n+                count += 1\n+            else:\n+                # By now we do not accept selecting entire dirs.\n+                # But could add that in the future. Just need to add more functions\n+                # and remove this else block...\n+                number_space = \" \" * n_digits\n+                print(f\"{number_space}  {spaces_str}{path.displayable()}\")\n+\n+        self.number_of_selectable_items = count\n+        self.file_path_list = file_path_list\n+        self.selectable_file_paths = file_path_enumeration\n+\n+    def ask_for_selection(self) -> List[str]:\n+        \"\"\"\n+        Ask user to select files from the terminal after displaying it\n+\n+        Returns:\n+            List[str]: list of selected paths\n+        \"\"\"\n+        user_input = input(\n+            \"\\nSelect files by entering the numbers separated by commas/spaces or \"\n+            + \"specify range with a dash. \"\n+            + \"Example: 1,2,3-5,7,9,13-15,18,20 (enter 'all' to select everything)\"\n+            + \"\\n\\nSelect files:\"\n+        )\n+        selected_paths = []\n+        regex = r\"\\d+(-\\d+)?([, ]\\d+(-\\d+)?)*\"\n+\n+        if user_input.lower() == \"all\":\n+            selected_paths = self.file_path_list\n+        elif re.match(regex, user_input):\n+            try:\n+                user_input = (\n+                    user_input.replace(\"\", \",\") if \" \" in user_input else user_input\n+                )\n+                selected_files = user_input.split(\",\")\n+                for file_number_str in selected_files:\n+                    if \"-\" in file_number_str:\n+                        start_str, end_str = file_number_str.split(\"-\")\n+                        start = int(start_str)\n+                        end = int(end_str)\n+                        for num in range(start, end + 1):\n+                            selected_paths.append(str(self.selectable_file_paths[num]))\n+                    else:\n+                        num = int(file_number_str)\n+                        selected_paths.append(str(self.selectable_file_paths[num]))\n+\n+            except ValueError:\n+                pass\n+        else:\n+            print(\"Please use a valid number/series of numbers.\\n\")\n+            sys.exit(1)\n+\n+        return selected_paths\n+\n+    def is_in_ignoring_extensions(self, path: Path) -> bool:\n+        \"\"\"\n+        Check if a path is not hidden or in the __pycache__ directory.\n+\n+        Args:\n+            path: The path to check.\n+\n+        Returns:\n+            bool: True if the path is not in ignored rules. False otherwise.\n+        \"\"\"\n+        is_hidden = not path.name.startswith(\".\")\n+        is_pycache = \"__pycache__\" not in path.name\n+        return is_hidden and is_pycache\n+\n+\n+def ask_for_files(db_input) -> dict[str, str]:\n+    \"\"\"\n+    Ask user to select files to improve.\n+    It can be done by terminal, gui, or using the old selection.\n+\n+    Returns:\n+        dict[str, str]: Dictionary where key = file name and value = file path\n+    \"\"\"\n+    use_last_string = \"\"\n+    selection_number = 0\n+    is_valid_selection = False\n+    can_use_last = False\n+    if \"file_list.txt\" in db_input:\n+        can_use_last = True\n+        use_last_string = (\n+            \"2. Use previous file list (available at \"\n+            + f\"{os.path.join(db_input.path, 'file_list.txt')})\\n\"\n+        )\n+    selection_str = f\"\"\"How do you want to select the files?\n+\n+0. Use Command-Line.\n+1. Use File explorer.\n+{use_last_string if len(use_last_string) > 1 else \"\"}\n+Select option and press Enter (default={selection_number}): \"\"\"\n+    file_path_list = []\n+    selected_number_str = input(selection_str)\n+    if selected_number_str:\n+        try:\n+            selection_number = int(selected_number_str)\n+        except ValueError:\n+            print(\"Invalid number. Select a number from the list above.\\n\")\n+            sys.exit(1)\n+    if selection_number == 0:\n+        # Open terminal selection\n+        file_path_list = terminal_file_selector()\n+        is_valid_selection = True\n+    elif selection_number == 1:\n+        # Open GUI selection\n+        file_path_list = gui_file_selector()\n+        is_valid_selection = True\n+    else:\n+        if can_use_last and selection_number == 2:\n+            # Use previous file list\n+            is_valid_selection = True\n+    if not is_valid_selection:\n+        print(\"Invalid number. Select a number from the list above.\\n\")\n+        sys.exit(1)\n+\n+    file_list_string = \"\"\n+    file_path_info = {}\n+    if not selection_number == 2:\n+        # New files\n+        for file_path in file_path_list:\n+            file_list_string += str(file_path) + \"\\n\"\n+            # Return a dict with key=file_name and value=file_path\n+            file_path_info[os.path.basename(file_path).split(\"/\")[-1]] = file_path\n+        # Write in file_list so the user can edit and remember what was done\n+        db_input[\"file_list.txt\"] = file_list_string\n+    else:\n+        # If using the the previous file list, we don't need to write file_list.txt\n+        file_list_string = db_input[\"file_list.txt\"]\n+        for file_path in file_path_list:\n+            # Return a dict with key=file_name and value=file_path\n+            file_path_info[os.path.basename(file_path).split(\"/\")[-1]] = file_path\n+\n+    return file_path_info\n+\n+\n+def gui_file_selector() -> List[str]:\n+    \"\"\"\n+    Display a tkinter file selection window to select context files.\n+    \"\"\"\n+    root = tk.Tk()\n+    root.withdraw()\n+    root.call(\"wm\", \"attributes\", \".\", \"-topmost\", True)\n+    file_list = list(\n+        fd.askopenfilenames(\n+            parent=root,\n+            initialdir=os.getcwd(),\n+            title=\"Select files to improve (or give context):\",\n+        )\n+    )\n+    return file_list\n+\n+\n+def terminal_file_selector() -> List[str]:\n+    \"\"\"\n+    Display a terminal file selection to select context files.\n+    \"\"\"\n+    file_selector = TerminalFileSelector(Path(os.getcwd()))\n+    file_selector.display()\n+    selected_list = file_selector.ask_for_selection()\n+    return selected_list\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR offers a solid enhancement, but it lacks unit tests and integration tests to ensure new functionality. Consider adding exception handling in file operations to prevent crashes due to file permission issues. The `ask_for_files` function should be refactored for clarity, and `improve_existing_code` would benefit from modular decomposition. Lastly, simplify user prompts and streamline directory usage to enhance user experience. Great progress overall; just a few refinements needed before merging."
      }
    ],
    "token_estimation": 3468.25
  },
  {
    "index": 91,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/gpt_engineer/core/chat_to_files.py b/gpt_engineer/core/chat_to_files.py\nindex 385d941bdc..2a166fabac 100644\n--- a/gpt_engineer/core/chat_to_files.py\n+++ b/gpt_engineer/core/chat_to_files.py\n@@ -199,3 +203,75 @@ def format_file_to_input(file_name: str, file_content: str) -> str:\n     ```\n     \"\"\"\n     return file_str\n+\n+\n+def overwrite_files_with_edits(chat: str, dbs: DBs):\n+    edits = parse_edits(chat)\n+    apply_edits(edits, dbs.workspace)\n+\n+\n+@dataclass\n+class Edit:\n+    filename: str\n+    before: str\n+    after: str\n+\n+\n+def parse_edits(llm_response):\n+    def parse_one_edit(lines):\n+        HEAD = \"<<<<<<< HEAD\"\n+        DIVIDER = \"=======\"\n+        UPDATE = \">>>>>>> updated\"\n+\n+        filename = lines.pop(0)\n+        text = \"\\n\".join(lines)\n+        splits = text.split(DIVIDER)\n+        if len(splits) != 2:\n+            raise ValueError(f\"Could not parse following text as code edit: \\n{text}\")\n+        before, after = splits\n+\n+        before = before.replace(HEAD, \"\").strip()\n+        after = after.replace(UPDATE, \"\").strip()\n+\n+        return Edit(filename, before, after)\n+\n+    def parse_all_edits(txt):\n+        edits = []\n+        current_edit = []\n+        in_fence = False\n+\n+        for line in txt.split(\"\\n\"):\n+            if line.startswith(\"```\") and in_fence:\n+                edits.append(parse_one_edit(current_edit))\n+                current_edit = []\n+                in_fence = False\n+                continue\n+            elif line.startswith(\"```\") and not in_fence:\n+                in_fence = True\n+                continue\n+\n+            if in_fence:\n+                current_edit.append(line)\n+\n+        return edits\n+\n+    return parse_all_edits(llm_response)\n+\n+\n+def apply_edits(edits: List[Edit], workspace: DB):\n+    for edit in edits:\n+        filename = edit.filename\n+        if edit.before == \"\":\n+            if workspace.get(filename) is not None:\n+                logger.warn(\n+                    f\"The edit to be applied wants to create a new file `{filename}`, but that already exists. The file will be overwritten. See `.gpteng/memory` for previous version.\"\n+                )\n+            workspace[filename] = edit.after  # new file\n+        else:\n+            if workspace[filename].count(edit.before) > 1:\n+                logger.warn(\n+                    f\"While applying an edit to `{filename}`, the code block to be replaced was found multiple times. All instances will be replaced.\"\n+                )\n+            workspace[filename] = workspace[filename].replace(\n+                edit.before, edit.after\n+            )  # existing file\ndiff --git a/gpt_engineer/preprompts/improve b/gpt_engineer/preprompts/improve\nindex 4f51f25b8f..95f2a03548 100644\n--- a/gpt_engineer/preprompts/improve\n+++ b/gpt_engineer/preprompts/improve\n@@ -1,12 +1,78 @@\n-You are a expert developer.\n-You will receive some (but not all) relevant files in the existing codebase to work on.\n-Based on a request, you need to comprehend what needs to be modified by understanding the implementation of the received code and the interconnections between each file, function and classes.\n+Act as an expert software developer.\n+Always use best practices when coding.\n+When you edit or add code, respect and use existing conventions, libraries, etc.\n \n-Think step by step and reason yourself to correct decisions to make sure we get it right.\n+Take requests for changes to the supplied code, and then you MUST\n+1. (planning) Think step-by-step and explain the needed changes. Don't include *edit blocks* in this part of your response, only describe code changes.\n+2. (output) Describe each change with an *edit block* per the example below.\n \n-Adapt to the style and frameworks used in the existing codebase.\n-Make sure that code in different files are compatible with each other.\n-Ensure to implement the requested modification, if you are unsure, write a plausible implementation.\n-Before you finish, double check that all parts of the necessary architecture for the request is present in the files.\n+You MUST format EVERY code change with an *edit block* like this:\n+```python\n+some/dir/example.py\n+<<<<<<< HEAD\n+    # some comment\n+    # Func to multiply\n+    def mul(a,b)\n+=======\n+    # updated comment\n+    # Function to add\n+    def add(a,b):\n+>>>>>>> updated\n+```\n+Remember, you can use multiple *edit blocks* per file.\n \n-FILE_FORMAT\n+Here is an example reponse:\n+---\n+PLANNING:\n+We need to change ... because ..., therefore I will add the line `a=a+1` to the function `add_one`.\n+Also, in the class `DB`, we need to update the ...\n+\n+OUTPUT:\n+```python\n+some/dir/example_1.py\n+<<<<<<< HEAD\n+    def mul(a,b)\n+=======\n+    def add(a,b):\n+>>>>>>> updated\n+```\n+\n+```python\n+some/dir/example_1.py\n+<<<<<<< HEAD\n+    def add_one(a,b):\n+        a = a+2\n+=======\n+    def add_one(a,b):\n+        a = a+1\n+>>>>>>> updated\n+```\n+\n+```python\n+some/dir/example_2.py\n+<<<<<<< HEAD\n+    class DBS:\n+        db = 'aaa'\n+=======\n+    class DBS:\n+        db = 'bbb'\n+>>>>>>> updated\n+```\n+---\n+\n+A program will parse the edit blocks you generate and replace the `HEAD` lines with the `updated` lines.\n+So edit blocks must be precise and unambiguous!\n+\n+Every *edit block* must be fenced with ```...``` with the correct code language.\n+\n+The `HEAD` section must be an *exact set of sequential lines* from the file! This is very important. Otherwise the parser won't work.\n+NEVER SKIP LINES in the `HEAD` section!\n+NEVER ELIDE LINES AND REPLACE THEM WITH A COMMENT!\n+NEVER OMIT ANY WHITESPACE in the `HEAD` section!\n+\n+Edits to different parts of a file each need their own *edit block*.\n+\n+If you want to put code in a new file, use an edit block with:\n+- A new file path, including dir name if needed\n+- An empty `HEAD` section\n+- The new file's contents in the `updated` section\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "It's crucial to test with `gpt3.5-turbo` since outputs may vary, affecting your logic. I recommend consolidating the parsing logic in `parse_all_edits` by reusing `parse_chat` to maintain clean code. Also, consider how existing files interact with new features; the model should add new files without wiping the workspace. Lastly, address error handling for additional outputs like bash commands to avoid `ValueError`. Ensure clarity on expectations for multiple suggested edits—currently, only the first is processed."
      }
    ],
    "token_estimation": 1587.75
  },
  {
    "index": 92,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/gpt_engineer/applications/cli/file_selector.py b/gpt_engineer/applications/cli/file_selector.py\nindex dad72dbcc5..c98e4c77fd 100644\n--- a/gpt_engineer/applications/cli/file_selector.py\n+++ b/gpt_engineer/applications/cli/file_selector.py\n@@ -1,86 +1,267 @@\n \"\"\"\n-This module provides functionalities for selecting files from both a graphical file\n-explorer and terminal-based file explorer.\n-\n-It allows the user to choose files for the purpose of context improvement. This module\n-provides a tree-based display in the terminal to enable file selection with support for\n-navigating through directories and ignoring specified directories.\n-\n-Features:\n-    - Supports both graphical (using `tkinter`) and terminal-based file selection.\n-    - Provides a tree-based display of directories and files.\n-    - Allows for custom filtering of displayed files and directories.\n-    - Support to reuse a previous file selection list.\n-    - Option to ignore specific directories (e.g. \"site-packages\", \"node_modules\", \"venv\").\n-\n-Classes:\n-    - DisplayablePath: Represents a displayable path in a file explorer, allowing for a\n-      tree structure display in the terminal.\n-    - TerminalFileSelector: Enables terminal-based file selection.\n-\n-Functions:\n-    - is_in_ignoring_extensions: Checks if a path should be ignored based on predefined rules.\n-    - ask_for_files: Asks user to select files from either GUI or terminal or uses a previous\n-      file list.\n-    - gui_file_selector: Displays a GUI for file selection.\n-    - terminal_file_selector: Displays a terminal interface for file selection.\n-\n-Dependencies:\n-    - os\n-    - re\n-    - sys\n-    - tkinter\n-    - pathlib\n-    - typing\n-\n-Note:\n-    This module is built on top of `gpt_engineer.core.db` and assumes existence and\n-    functionalities provided by DB and DBs classes.\n+file_selector.py\n+\n+This module offers interactive file selection for projects. Leveraging a terminal-based,\n+tree-structured display, users can navigate and select files for editing or processing.\n+It integrates with system editors for direct file modification and supports saving\n+selections for later use. Designed for efficient workflow enhancement in file-intensive\n+environments, it offers customizable file filtering and seamless editor integration.\n+\n+Key Components:\n+- FileSelector: Manages file selection and interaction.\n+- DisplayablePath: Provides a structured view of file paths.\n+\n+Usage:\n+Typically used in project setup or management phases for selecting specific files.\n+It operates within the GPT-Engineer environment, relying on core functionalities for\n+file handling and persistence.\n+\n \"\"\"\n \n import os\n-import re\n-import sys\n-import tkinter as tk\n-import tkinter.filedialog as fd\n+import subprocess\n \n from pathlib import Path\n-from typing import List, Union\n+from typing import Any, Dict, List, Union\n+\n+import toml\n \n from gpt_engineer.core.default.disk_memory import DiskMemory\n from gpt_engineer.core.default.paths import metadata_path\n from gpt_engineer.core.files_dict import FilesDict\n \n-IGNORE_FOLDERS = {\"site-packages\", \"node_modules\", \"venv\"}\n-FILE_LIST_NAME = \"file_list.txt\"\n+\n+class FileSelector:\n+    def __init__(self, project_path: Union[str, Path]):\n+        self.IGNORE_FOLDERS = {\"site-packages\", \"node_modules\", \"venv\", \".gpteng\"}\n+        self.FILE_LIST_NAME = \"file_selection.toml\"\n+        self.COMMENT = (\n+            \"# Change 'selected' from false to true to include files in the edit. \"\n+            \"GPT-engineer can only read and edit the files that set to true. \"\n+            \"Including irrelevant files will degrade coding performance, \"\n+            \"cost additional tokens and potentially lead to violations \"\n+            \"of the token limit, resulting in runtime errors.\\n\\n\"\n+        )\n+\n+        self.project_path = project_path\n+        self.metadata_db = DiskMemory(metadata_path(self.project_path))\n+        self.toml_path = self.metadata_db.path / self.FILE_LIST_NAME\n+\n+    def ask_for_files(self) -> FilesDict:\n+        \"\"\"\n+        Asks the user to select files for the purpose of context improvement.\n+        It supports selection from the terminal or using a previously saved list.\n+        \"\"\"\n+        if os.getenv(\"GPTE_TEST_MODE\"):\n+            # In test mode, retrieve files from a predefined TOML configuration\n+            assert self.FILE_LIST_NAME in self.metadata_db\n+            selected_files = self.get_files_from_toml(self.project_path, self.toml_path)\n+        else:\n+            # Otherwise, use the editor file selector for interactive selection\n+            if self.FILE_LIST_NAME in self.metadata_db:\n+                print(\n+                    f\"File list detected at {self.toml_path}. Edit or delete it if you want to select new files.\"\n+                )\n+                selected_files = self.editor_file_selector(self.project_path, False)\n+            else:\n+                selected_files = self.editor_file_selector(self.project_path, True)\n+\n+        content_dict = {}\n+        for file_path in selected_files:\n+            # selected files contains paths that are relative to the project path\n+            try:\n+                # to open the file we need the path from the cwd\n+                with open(Path(self.project_path) / file_path, \"r\") as content:\n+                    content_dict[str(file_path)] = content.read()\n+            except FileNotFoundError:\n+                print(f\"Warning: File not found {file_path}\")\n+        return FilesDict(content_dict)\n+\n+    def editor_file_selector(self, input_path: str, init: bool = True) -> List[str]:\n+        \"\"\"\n+        Provides an interactive file selection interface by generating a tree representation in a .toml file.\n+        Allows users to select or deselect files for the context improvement process.\n+        \"\"\"\n+        root_path = Path(input_path)\n+        tree_dict = {\n+            \"files\": {}\n+        }  # Initialize the dictionary to hold file selection state\n+        toml_file = DiskMemory(metadata_path(input_path)).path / \"file_selection.toml\"\n+        # Define the toml file path\n+\n+        # Initialize .toml file with file tree if in initial state\n+        if init:\n+            for path in DisplayablePath.make_tree(\n+                root_path\n+            ):  # Create a tree structure from the root path\n+                if path.path.is_dir() or not self.is_utf8(path.path):\n+                    continue\n+                relative_path = os.path.relpath(\n+                    path.path, input_path\n+                )  # Get the relative path of the file\n+                tree_dict[\"files\"][relative_path] = {\n+                    \"selected\": False\n+                }  # Initialize file selection as False\n+\n+            # Write instructions and file selection states to .toml file\n+\n+            with open(toml_file, \"w\") as f:\n+                f.write(self.COMMENT)\n+                toml.dump(tree_dict, f)\n+        else:\n+            # Load existing files from the .toml configuration\n+            with open(toml_file, \"r\") as file:\n+                existing_files = toml.load(file)\n+                merged_files = self.merge_file_lists(\n+                    existing_files[\"files\"], self.get_current_files(root_path)\n+                )\n+\n+            # Write the merged list back to the .toml for user review and modification\n+            with open(toml_file, \"w\") as file:\n+                file.write(self.COMMENT)  # Ensure to write the comment\n+                toml.dump({\"files\": merged_files}, file)\n+\n+        print(\n+            \"Please select(true) and deselect(false) files, save it, and close it to continue...\"\n+        )\n+        self.open_with_default_editor(\n+            toml_file\n+        )  # Open the .toml file in the default editor for user modification\n+        return self.get_files_from_toml(\n+            input_path, toml_file\n+        )  # Return the list of selected files after user edits\n+\n+    def open_with_default_editor(self, file_path):\n+        \"\"\"\n+        Attempts to open the specified file using the system's default text editor or a common fallback editor.\n+        \"\"\"\n+        editors = [\n+            \"gedit\",\n+            \"notepad\",\n+            \"write\",\n+            \"nano\",\n+            \"vim\",\n+            \"emacs\",\n+        ]  # Putting the beginner-friendly text editor forward\n+        chosen_editor = os.environ.get(\"EDITOR\")\n+\n+        # Try the preferred editor first, then fallback to common editors\n+        if chosen_editor:\n+            try:\n+                subprocess.run([chosen_editor, file_path])\n+                return\n+            except Exception:\n+                pass\n+\n+        for editor in editors:\n+            try:\n+                subprocess.run([editor, file_path])\n+                return\n+            except Exception:\n+                continue\n+        print(\"No suitable text editor found. Please edit the file manually.\")\n+\n+    def is_utf8(self, file_path):\n+        \"\"\"\n+        Determines if the file is UTF-8 encoded by trying to read and decode it.\n+        Useful for ensuring that files are in a readable and compatible format.\n+        \"\"\"\n+        try:\n+            with open(file_path, \"rb\") as file:\n+                file.read().decode(\"utf-8\")\n+                return True\n+        except UnicodeDecodeError:\n+            return False\n+\n+    def get_files_from_toml(self, input_path, toml_file):\n+        \"\"\"\n+        Retrieves the list of files selected by the user from a .toml configuration file.\n+        This function parses the .toml file and returns the list of selected files.\n+        \"\"\"\n+        selected_files = []\n+        edited_tree = toml.load(toml_file)  # Load the edited .toml file\n+\n+        # Iterate through the files in the .toml and append selected files to the list\n+        for file, properties in edited_tree[\"files\"].items():\n+            if properties.get(\"selected\", False):  # Check if the file is selected\n+                selected_files.append(file)\n+\n+        # Ensure that at least one file is selected, or raise an exception\n+        if not selected_files:\n+            raise Exception(\n+                \"No files were selected. Please select at least one file to proceed.\"\n+            )\n+\n+        print(f\"\\nYou have selected the following files:\\n{input_path}\")\n+\n+        project_path = Path(input_path).resolve()\n+        all_paths = set(\n+            project_path.joinpath(file).resolve(strict=False) for file in selected_files\n+        )\n+\n+        try:\n+            for displayable_path in DisplayablePath.make_tree(project_path):\n+                if displayable_path.path in all_paths:\n+                    print(displayable_path.displayable())\n+        except FileNotFoundError:\n+            print(\"Specified path does not exist: \", project_path)\n+        except Exception as e:\n+            print(\"An error occurred while trying to display the file tree:\", e)\n+\n+        print(\"\\n\")\n+        return selected_files\n+\n+    def merge_file_lists(\n+        self, existing_files: Dict[str, Any], new_files: Dict[str, Any]\n+    ) -> Dict[str, Any]:\n+        \"\"\"\n+        Merges the new files list with the existing one, preserving the selection status.\n+        \"\"\"\n+        # Update the existing files with any new files or changes\n+        for file, properties in new_files.items():\n+            if file not in existing_files:\n+                existing_files[file] = properties  # Add new files as unselected\n+            # If you want to update other properties of existing files, you can do so here\n+\n+        return existing_files\n+\n+    def get_current_files(self, project_path: Union[str, Path]) -> Dict[str, Any]:\n+        \"\"\"\n+        Generates a dictionary of all files in the project directory\n+        with their selection status set to False by default.\n+        \"\"\"\n+        all_files = {}\n+        project_path = Path(\n+            project_path\n+        ).resolve()  # Ensure path is absolute and resolved\n+\n+        for path in project_path.glob(\"**/*\"):  # Recursively list all files\n+            if path.is_file():\n+                # Normalize and compare each part of the path\n+                if not any(\n+                    part in self.IGNORE_FOLDERS\n+                    for part in path.relative_to(project_path).parts\n+                ) and not path.name.startswith(\".\"):\n+                    relative_path = str(\n+                        path.relative_to(project_path)\n+                    )  # Store relative paths\n+                    all_files[relative_path] = {\"selected\": False}\n+        return all_files\n+\n+    def is_in_ignoring_extensions(self, path: Path) -> bool:\n+        \"\"\"\n+        Check if a path is not hidden or in the '__pycache__' directory.\n+        Helps in filtering out unnecessary files during file selection.\n+        \"\"\"\n+        is_hidden = not path.name.startswith(\".\")\n+        is_pycache = \"__pycache__\" not in path.name\n+        return is_hidden and is_pycache\n \n \n class DisplayablePath(object):\n     \"\"\"\n-    A class that represents a path in a file system and provides functionality\n-    to display it in a tree-like structure similar to that of a file explorer.\n-\n-    Class Attributes:\n-        - display_filename_prefix_middle (str): Prefix for filenames in the middle of a list.\n-        - display_filename_prefix_last (str): Prefix for filenames at the end of a list.\n-        - display_parent_prefix_middle (str): Prefix for parent directories in the middle of a list.\n-        - display_parent_prefix_last (str): Prefix for parent directories at the end of a list.\n-\n-    Attributes:\n-        - depth (int): Depth of the path in relation to the root.\n-        - path (Path): The actual path object.\n-        - parent (DisplayablePath): Parent path. None if it's the root.\n-        - is_last (bool): Flag to check if the current path is the last child of its parent.\n-\n-    Methods:\n-        - display_name: Return the display name for the path, with directories having a trailing '/'.\n-        - make_tree: Class method to generate a tree of DisplayablePath objects for the given root.\n-        - _default_criteria: Default criteria for filtering paths.\n-        - displayable: Generate the displayable string representation of the file or directory.\n-\n-    Note:\n-        It is assumed that the global constant IGNORE_FOLDERS is defined elsewhere,\n-        which lists the folder names to ignore during the tree generation.\n+    Represents a path in a file system and displays it in a tree-like structure.\n+    Useful for displaying file and directory structures like in a file explorer.\n     \"\"\"\n \n     display_filename_prefix_middle = \"├── \"\n@@ -195,253 +347,4 @@ def displayable(self) -> str:\n             )\n             parent = parent.parent\n \n-        return \"\".join(reversed(parts))\n-\n-\n-class TerminalFileSelector:\n-    \"\"\"\n-    A terminal-based file selector for navigating and selecting files from a specified root folder.\n-\n-    Attributes:\n-        number_of_selectable_items (int): The number of items (files) that can be selected.\n-        selectable_file_paths (dict[int, str]): A mapping from index number to the corresponding file path.\n-        file_path_list (list): A list containing paths of the displayed files.\n-        db_paths: A structured representation of all paths (both files and directories) within the root folder.\n-\n-    Args:\n-        root_folder_path (Path): The root folder path from where files are to be listed and selected.\n-\n-    Methods:\n-        display(): Prints the list of files and directories to the terminal, allowing files to be selectable by number.\n-        ask_for_selection() -> List[str]: Prompts the user to select files by providing index numbers and returns the list of selected file paths.\n-    \"\"\"\n-\n-    def __init__(self, root_folder_path: Path) -> None:\n-        self.number_of_selectable_items = 0\n-        self.selectable_file_paths: dict[int, str] = {}\n-        self.file_path_list: list = []\n-        self.db_paths = DisplayablePath.make_tree(\n-            root_folder_path, parent=None, criteria=is_in_ignoring_extensions\n-        )\n-        self.root_folder_path = root_folder_path\n-\n-    def display(self):\n-        \"\"\"\n-        Displays a list of files from the root folder in the terminal. Files are enumerated for selection,\n-        while directories are simply listed (currently non-selectable).\n-        \"\"\"\n-        count = 0\n-        file_path_enumeration = {}\n-        file_path_list = []\n-        for path in self.db_paths:\n-            n_digits = len(str(count))\n-            n_spaces = 3 - n_digits\n-            if n_spaces < 0:\n-                # We can only print 1000 aligned files. I think it is decent enough\n-                n_spaces = 0\n-            spaces_str = \" \" * n_spaces\n-            if not path.path.is_dir():\n-                print(f\"{count}. {spaces_str}{path.displayable()}\")\n-                file_path_enumeration[count] = path.path\n-                file_path_list.append(path.path)\n-                count += 1\n-            else:\n-                # By now we do not accept selecting entire dirs.\n-                # But could add that in the future. Just need to add more functions\n-                # and remove this else block...\n-                number_space = \" \" * n_digits\n-                print(f\"{number_space}  {spaces_str}{path.displayable()}\")\n-\n-        self.number_of_selectable_items = count\n-        self.file_path_list = file_path_list\n-        self.selectable_file_paths = file_path_enumeration\n-\n-    def ask_for_selection(self, all: bool = False) -> List[str]:\n-        \"\"\"\n-        Prompts the user to select files by providing a series of index numbers, ranges, or 'all' to select everything.\n-\n-        Returns:\n-            List[str]: A list of selected file paths based on user's input.\n-\n-        Notes:\n-            - Users can select files by entering index numbers separated by commas or spaces.\n-            - Ranges can be specified using a dash.\n-            - Example input: 1,2,3-5,7,9,13-15,18,20\n-            - Users can also input 'all' to select all displayed files.\n-        \"\"\"\n-        if all:\n-            user_input = \"all\"\n-        else:\n-            user_input = input(\n-                \"\\n\".join(\n-                    [\n-                        \"Select files by entering the numbers separated by commas/spaces or\",\n-                        \"specify range with a dash. \",\n-                        \"Example: 1,2,3-5,7,9,13-15,18,20 (enter 'all' to select everything)\",\n-                        \"\\n\\nSelect files:\",\n-                    ]\n-                )\n-            )\n-        selected_paths = []\n-        regex = r\"\\d+(-\\d+)?([, ]\\d+(-\\d+)?)*\"\n-\n-        if user_input.lower() == \"all\":\n-            selected_paths = self.file_path_list\n-        elif re.match(regex, user_input):\n-            try:\n-                user_input = (\n-                    user_input.replace(\" \", \",\") if \" \" in user_input else user_input\n-                )\n-                selected_files = user_input.split(\",\")\n-                for file_number_str in selected_files:\n-                    if \"-\" in file_number_str:\n-                        start_str, end_str = file_number_str.split(\"-\")\n-                        start = int(start_str)\n-                        end = int(end_str)\n-                        for num in range(start, end + 1):\n-                            selected_paths.append(str(self.selectable_file_paths[num]))\n-                    else:\n-                        num = int(file_number_str)\n-                        selected_paths.append(str(self.selectable_file_paths[num]))\n-\n-            except ValueError:\n-                pass\n-        else:\n-            print(\"Please use a valid number/series of numbers.\\n\")\n-            sys.exit(1)\n-\n-        return selected_paths\n-\n-\n-def is_in_ignoring_extensions(path: Path) -> bool:\n-    \"\"\"\n-    Check if a path is not hidden or in the __pycache__ directory.\n-\n-    Args:\n-        path: The path to check.\n-\n-    Returns:\n-        bool: True if the path is not in ignored rules. False otherwise.\n-    \"\"\"\n-    is_hidden = not path.name.startswith(\".\")\n-    is_pycache = \"__pycache__\" not in path.name\n-    return is_hidden and is_pycache\n-\n-\n-def ask_for_files(project_path: Union[str, Path]) -> FilesDict:\n-    \"\"\"\n-    Ask user to select files to improve.\n-    It can be done by terminal, gui, or using the old selection.\n-\n-    Returns:\n-        dict[str, str]: Dictionary where key = file name and value = file path\n-    \"\"\"\n-    metadata_db = DiskMemory(metadata_path(project_path))\n-    if FILE_LIST_NAME in metadata_db:\n-        print(\n-            f\"File list detected at {metadata_db.path / FILE_LIST_NAME}. \"\n-            \"Edit or delete it if you want to select new files.\"\n-        )\n-    else:\n-        use_last_string = \"\"\n-        if FILE_LIST_NAME in metadata_db:\n-            use_last_string = (\n-                \"3. Use previous file list (available at \"\n-                + f\"{os.path.join(metadata_db.path, FILE_LIST_NAME)})\\n\"\n-            )\n-            selection_number = 3\n-        else:\n-            selection_number = 1\n-        selection_str = \"\\n\".join(\n-            [\n-                \"How do you want to select the files?\",\n-                \"\",\n-                \"1. Use File explorer.\",\n-                \"2. Use Command-Line.\",\n-                use_last_string if len(use_last_string) > 1 else \"\",\n-                f\"Select option and press Enter (default={selection_number}): \",\n-            ]\n-        )\n-\n-        file_path_list = []\n-        selected_number_str = input(selection_str)\n-        if selected_number_str:\n-            try:\n-                selection_number = int(selected_number_str)\n-            except ValueError:\n-                print(\"Invalid number. Select a number from the list above.\\n\")\n-                sys.exit(1)\n-\n-        if selection_number == 1:\n-            # Open GUI selection\n-            file_path_list = gui_file_selector(project_path)\n-        elif selection_number == 2:\n-            # Open terminal selection\n-            file_path_list = terminal_file_selector(project_path)\n-        if (\n-            selection_number <= 0\n-            or selection_number > 3\n-            or (selection_number == 3 and not use_last_string)\n-        ):\n-            print(\"Invalid number. Select a number from the list above.\\n\")\n-            sys.exit(1)\n-\n-        # ToDO: Replace this hack that makes all file_path relative to the right thing\n-        file_path_list = [\n-            os.path.relpath(file_path.strip(), project_path)\n-            for file_path in file_path_list\n-        ]\n-\n-        if not selection_number == 3:\n-            metadata_db[FILE_LIST_NAME] = \"\\n\".join(\n-                str(file_path) for file_path in file_path_list\n-            )\n-    content_dict = dict()\n-    with open(metadata_db.path / FILE_LIST_NAME, \"r\") as file_list:\n-        for file in file_list:\n-            with open(os.path.join(project_path, file.strip()), \"r\") as content:\n-                content_dict[file.strip()] = content.read()\n-    return FilesDict(content_dict)\n-\n-\n-def get_all_code(project_path: str) -> FilesDict:\n-    file_selection = terminal_file_selector(project_path, all=True)\n-    # ToDO: Replace this hack that makes all file_path relative to the right thing\n-    file_selection = [\n-        os.path.relpath(str(file_path).strip(), project_path)\n-        for file_path in file_selection\n-    ]\n-    content_dict = dict()\n-\n-    for file in file_selection:\n-        with open(os.path.join(project_path, file.strip()), \"r\") as content:\n-            content_dict[file.strip()] = content.read()\n-    return FilesDict(content_dict)\n-\n-\n-def gui_file_selector(input_path: str) -> List[str]:\n-    \"\"\"\n-    Display a tkinter file selection window to select context files.\n-    \"\"\"\n-    root = tk.Tk()\n-    root.withdraw()\n-    root.call(\"wm\", \"attributes\", \".\", \"-topmost\", True)\n-    file_list = list(\n-        fd.askopenfilenames(\n-            parent=root,\n-            initialdir=input_path,\n-            title=\"Select files to improve (or give context):\",\n-        )\n-    )\n-    # ensure right path type\n-    return [str(path) for path in file_list]\n-\n-\n-def terminal_file_selector(input_path: str, all: bool = False) -> List[str]:\n-    \"\"\"\n-    Display a terminal file selection to select context files.\n-    \"\"\"\n-    file_selector = TerminalFileSelector(Path(input_path))\n-    file_selector.display()\n-    file_list = file_selector.ask_for_selection(all=all)\n-    return [str(path) for path in file_list]\n+        return \"\".join(reversed(parts))  # Assemble the parts into the final string\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "Great effort on the improvements! However, I noted a few points for refinement:\n\n1. The `open_with_default_editor` should cycle through a list of potential editors for better usability. \n2. Modify the `.toml` default to `false` for small projects, improving user experience.\n3. Consider filtering files by decoding with \"utf-8\" instead of relying solely on `_is_in_ignoring_extensions_`.\n4. Persist the `.toml` and remove `file_list.txt` to streamline workflows. \n\nThese tweaks can greatly enhance functionality and user experience. Keep up the good work!"
      }
    ],
    "token_estimation": 6313.75
  },
  {
    "index": 93,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/gpt_engineer/chat_to_files.py b/gpt_engineer/chat_to_files.py\nindex a043eae5a9..d73765775c 100644\n--- a/gpt_engineer/chat_to_files.py\n+++ b/gpt_engineer/chat_to_files.py\n@@ -1,5 +1,72 @@\n+import json\n import re\n \n+from typing import List, Tuple\n+\n+import openai\n+\n+\n+def openai_func_call(\n+    model: str, messages: List, functions: List, function_call: dict\n+) -> dict:\n+    # TODO(junlin): reuse AI class\n+    # ref: https://platform.openai.com/docs/api-reference/chat/create\n+    response = openai.ChatCompletion.create(\n+        model=model, messages=messages, functions=functions, function_call=function_call\n+    )\n+    message = response[\"choices\"][0][\"message\"]\n+    func_call = message[\"function_call\"]\n+    func_call_args = json.loads(func_call[\"arguments\"])\n+    return func_call_args\n+\n+\n+def parse_files_by_ai(chat, model=\"gpt-3.5-turbo-0613\"):  # -> List[Tuple[str, str]]:\n+    func_call_args = openai_func_call(\n+        model=model,\n+        messages=[\n+            {\n+                \"role\": \"user\",\n+                \"content\": \"you are an AI file writer, \"\n+                \"please write the following file to disk: \" + chat,\n+            },\n+        ],\n+        functions=[\n+            {\n+                \"name\": \"write_files\",\n+                \"description\": \"Write the file to the disk based on \"\n+                \"the given file filename and content.\",\n+                \"parameters\": {\n+                    \"type\": \"object\",\n+                    \"properties\": {\n+                        \"files\": {\n+                            \"type\": \"array\",\n+                            \"description\": \"an array of file which \"\n+                            \"contains filename and content\",\n+                            \"items\": {\n+                                \"type\": \"object\",\n+                                \"properties\": {\n+                                    \"filename\": {\n+                                        \"type\": \"string\",\n+                                        \"description\": \"the relative path to the file\",\n+                                    },\n+                                    \"content\": {\n+                                        \"type\": \"string\",\n+                                        \"description\": \"the full content of the file\",\n+                                    },\n+                                },\n+                                \"required\": [\"filename\", \"content\"],\n+                            },\n+                        }\n+                    },\n+                },\n+            }\n+        ],\n+        function_call={\"name\": \"write_files\"},\n+    )\n+\n+    files = func_call_args[\"files\"]\n+    return list(map(lambda f: (f[\"filename\"], f[\"content\"]), files))\n+\n \n def parse_chat(chat):  # -> List[Tuple[str, str]]:\n     # Get all ``` blocks and preceding filenames\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The current PR outlines a solid MVC architecture for the Snake game, but there are issues with the `execute_workspace` functionality due to recent upstream changes. I appreciate the proposed enhancements, especially the `write_files` function for improved file handling, as it simplifies the process significantly. However, concerns about forcing function calls via prompts are valid; leveraging OpenAI's function calling will likely yield more consistent results than regex parsing. Let's ensure we address these technical concerns before merging to avoid unnecessary complications. Consider rebasing once more to incorporate upstream updates."
      }
    ],
    "token_estimation": 869.75
  },
  {
    "index": 94,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/gpt_engineer/core/chat_to_files.py b/gpt_engineer/core/chat_to_files.py\nindex 3f5fe7e6c6..af2f715c67 100644\n--- a/gpt_engineer/core/chat_to_files.py\n+++ b/gpt_engineer/core/chat_to_files.py\n@@ -1,196 +1,250 @@\n \"\"\"\n-This module provides utilities to handle and process chat content, especially for extracting code blocks\n-and managing them within a specified GPT Engineer project (\"workspace\"). It offers functionalities like parsing chat messages to\n-retrieve code blocks, storing these blocks into a workspace, and overwriting workspace content based on\n-new chat messages. Moreover, it aids in formatting and reading file content for an AI agent's input.\n+This module provides advanced utilities for processing and managing chat content,\n+specifically in GPT Engineer projects (\"workspaces\"). Its main focus is on the extraction\n+and manipulation of code blocks from chat messages. Key functionalities include parsing chat\n+content to identify and extract code blocks, then integrating them into workspaces.\n \n Key Features:\n-- Parse and extract code blocks from chat messages.\n-- Store and overwrite files within a workspace based on chat content.\n-- Format files to be used as inputs for AI agents.\n-- Retrieve files and their content based on a provided list.\n+- Efficient extraction of code blocks from chat messages for workspace integration.\n+- Dynamic updating of workspace files with new chat content.\n+- Automated formatting of files for AI agent processing.\n+- Retrieval of specific files and content for detailed analysis.\n \n Dependencies:\n-- `os` and `pathlib`: For handling OS-level operations and path manipulations.\n-- `re`: For regex-based parsing of chat content.\n-- `gpt_engineer.core.db`: Database handling functionalities for the workspace.\n-- `gpt_engineer.cli.file_selector`: Constants related to file selection.\n-\n-Functions:\n-- parse_chat: Extracts code blocks from chat messages.\n-- to_files_and_memory: Saves chat content to memory and adds extracted files to a workspace.\n-- to_files: Adds extracted files to a workspace.\n-- get_code_strings: Retrieves file names and their content.\n-- format_file_to_input: Formats file content for AI input.\n-- overwrite_files_with_edits: Overwrites workspace files based on parsed edits from chat.\n-- apply_edits: Applies file edits to a workspace.\n+- `os` and `pathlib`: Handle file system operations and path manipulations.\n+- `re`: Employed for regex-based parsing to extract code blocks and edits.\n+- `gpt_engineer.core.db`: Database functionalities for workspace management.\n+- `gpt_engineer.cli.file_selector`: Constants and utilities for file selection.\n+\n+Core Functions:\n+- chat_to_files_dict: Extracts code blocks and organizes them for access.\n+- overwrite_code_with_edits: Updates workspace files with chat-derived edits.\n+- parse_edits: Parses and structures code edits from chats.\n+- apply_edits: Applies edits to workspace files, maintaining their relevance.\n \"\"\"\n \n import logging\n import re\n \n-from dataclasses import dataclass\n-from typing import List\n+from collections import Counter\n \n from gpt_engineer.core.files_dict import FilesDict\n \n+# Configure logging for the module\n logger = logging.getLogger(__name__)\n \n \n def chat_to_files_dict(chat) -> FilesDict:\n     \"\"\"\n-    Extracts all code blocks from a chat and returns them\n-    as a list of (filename, codeblock) tuples.\n+    Extracts code blocks from a chat string and returns a FilesDict object containing\n+    (filename, codeblock) pairs.\n \n     Parameters\n     ----------\n     chat : str\n-        The chat to extract code blocks from.\n+        The chat string to extract code blocks from.\n \n     Returns\n     -------\n-    List[Tuple[str, str]]\n-        A list of tuples, where each tuple contains a filename and a code block.\n+    FilesDict\n+        A FilesDict object with filenames as keys and their respective code blocks as values.\n     \"\"\"\n-    # Get all ``` blocks and preceding filenames\n+    # Regular expression pattern to identify code blocks and preceding filenames\n     regex = r\"(\\S+)\\n\\s*```[^\\n]*\\n(.+?)```\"\n     matches = re.finditer(regex, chat, re.DOTALL)\n \n     files_dict = FilesDict()\n     for match in matches:\n-        # Strip the filename of any non-allowed characters and convert / to \\\n+        # Clean and standardize the file path\n         path = re.sub(r'[\\:<>\"|?*]', \"\", match.group(1))\n-\n-        # Remove leading and trailing brackets\n         path = re.sub(r\"^\\[(.*)\\]$\", r\"\\1\", path)\n-\n-        # Remove leading and trailing backticks\n         path = re.sub(r\"^`(.*)`$\", r\"\\1\", path)\n-\n-        # Remove trailing ]\n         path = re.sub(r\"[\\]\\:]$\", \"\", path)\n \n-        # Get the code\n+        # Extract and clean the code content\n         content = match.group(2)\n \n-        # Add the file to the list\n+        # Add the cleaned path and content to the FilesDict\n         files_dict[path.strip()] = content.strip()\n \n-    return FilesDict(files_dict)\n+    return files_dict\n \n \n def overwrite_code_with_edits(chat: str, files_dict: FilesDict):\n     \"\"\"\n-    Overwrite code with edits extracted from chat.\n-\n-    This function takes a chat string, parses it for edits, and applies those edits\n-    to the provided code object.\n+    Parses edits from a chat and applies them to the provided FilesDict object.\n \n     Parameters\n     ----------\n     chat : str\n         The chat content containing code edits.\n     files_dict : FilesDict\n-        The code object to apply edits to.\n+        The FilesDict object to apply edits to.\n     \"\"\"\n-    edits = parse_edits(chat)\n-    apply_edits(edits, files_dict)\n+    parse_edits(chat)\n+    # apply_edits(files_dict, edits)\n \n \n-@dataclass\n-class Edit:\n-    filename: str\n-    before: str\n-    after: str\n+def parse_edits(chat: str) -> list[dict]:\n+    edits = []\n+    diff_blocks = re.findall(r\"```diff\\n([\\s\\S]*?)\\n```\", chat)\n+    for diff_block in diff_blocks:\n+        lines = diff_block.split(\"\\n\")\n+        file_name = lines[0][4:]  # Using the filename directly\n+        start_line_num = int(lines[2][4:].split(\",\")[0])\n+        current_line_num = start_line_num - 1\n+\n+        edit = []\n+        for line in lines[3:]:\n+            current_line_num += 1  # Increment line number\n+            if line.startswith(\"-\"):\n+                line_data = {\n+                    \"filename\": file_name,\n+                    \"line_number\": str(current_line_num),\n+                    \"change_type\": \"-\",  # Denote removal\n+                }\n+                edit.append(line_data)\n+\n+            elif line.startswith(\"+\"):\n+                current_line_num -= 1  # follow last line\n+                line_data = {\n+                    \"filename\": file_name,\n+                    \"line_number\": str(\n+                        current_line_num\n+                    ),  # Keep the current line number for '+' lines\n+                    \"change_type\": \"+\",  # Denote addition\n+                }\n+                edit.append(line_data)\n+                # Do not increment the line number here for '+' lines\n+\n+        edits.append(edit)\n+    [print(f\"\\n{edit}\") for edit in edits]\n+    return edits\n \n \n-def parse_edits(chat: str):\n+# @dataclass\n+# class Edit:\n+#     filename: str\n+#     line_number: int\n+#     content: str\n+#     is_before: bool\n+#\n+#\n+# def parse_edits(chat: str):\n+#     \"\"\"\n+#     Parses edits from a chat string while preserving indentation, returning a list of Edit objects.\n+#\n+#     Parameters\n+#     ----------\n+#     chat : str\n+#         The chat string containing edits.\n+#\n+#     Returns\n+#     -------\n+#     List[Edit]\n+#         A list of Edit objects representing the parsed edits.\n+#     \"\"\"\n+#     edits = []\n+#     lines = chat.split(\"\\n\")\n+#     filename = \"\"\n+#     for line in lines:\n+#         if line.startswith(\"File:\"):\n+#             filename = line.split(\":\")[1].strip()\n+#         else:\n+#             # Extract line number, edit type, and content with leading spaces\n+#             match = re.match(r\"(\\d+) ([-+])\\s?(.*\\S.*)\", line)\n+#             if match:\n+#                 line_number, symbol, content = match.groups()\n+#                 line_number = int(line_number)\n+#                 is_before = symbol == \"-\"\n+#                 edits.append(Edit(filename, line_number, content, is_before))\n+#\n+#     # Sort edits for sequential application\n+#     edits.sort(key=lambda edit: (edit.filename, not edit.is_before, edit.line_number))\n+#     return edits\n+#\n+#\n+def is_similar(str1, str2):\n     \"\"\"\n-    Parse edits from a chat string.\n-\n-    This function extracts code edits from a chat string and returns them as a list\n-    of Edit objects.\n+    Compares two strings for similarity, ignoring spaces and case.\n \n     Parameters\n     ----------\n-    chat : str\n-        The chat content containing code edits.\n+    str1, str2 : str\n+        The strings to compare.\n \n     Returns\n     -------\n-    List[Edit]\n-        A list of Edit objects representing the parsed code edits.\n-    \"\"\"\n-\n-    def parse_one_edit(lines):\n-        HEAD = \"<<<<<<< HEAD\"\n-        DIVIDER = \"\\n=======\\n\"\n-        UPDATE = \">>>>>>> updated\"\n-\n-        filename = lines.pop(0)\n-        text = \"\\n\".join(lines)\n-        splits = text.split(DIVIDER)\n-        if len(splits) != 2:\n-            raise ValueError(f\"Could not parse following text as code edit: \\n{text}\")\n-        before, after = splits\n-\n-        before = before.replace(HEAD, \"\").strip()\n-        after = after.replace(UPDATE, \"\").strip()\n-\n-        return Edit(filename, before, after)\n-\n-    edits = []\n-    current_edit = []\n-    in_fence = False\n-\n-    for line in chat.split(\"\\n\"):\n-        if line.startswith(\"```\") and in_fence:\n-            edits.append(parse_one_edit(current_edit))\n-            current_edit = []\n-            in_fence = False\n-            continue\n-        elif line.startswith(\"```\") and not in_fence:\n-            in_fence = True\n-            continue\n-\n-        if in_fence:\n-            current_edit.append(line)\n-\n-    return edits\n-\n-\n-def apply_edits(edits: List[Edit], files_dict: FilesDict):\n-    \"\"\"\n-    Apply a list of edits to the given code.\n-\n-    This function takes a list of Edit objects and applies each edit to the code object.\n-    It handles the creation of new files and the modification of existing files based on the edits.\n-\n-    Parameters\n-    ----------\n-    edits : List[Edit]\n-        A list of Edit objects representing the code edits to apply.\n-    files_dict : FilesDict\n-        The code object to apply edits to.\n+    bool\n+        True if the strings are similar, False otherwise.\n     \"\"\"\n-    for edit in edits:\n-        filename = edit.filename\n-        if edit.before == \"\":\n-            if filename in files_dict:\n-                logger.warning(\n-                    f\"The edit to be applied wants to create a new file `{filename}`, but that already exists. The file will be overwritten. See `.gpteng/memory` for previous version.\"\n-                )\n-            files_dict[filename] = edit.after  # new file\n-        else:\n-            occurrences_cnt = files_dict[filename].count(edit.before)\n-            if occurrences_cnt == 0:\n-                logger.warning(\n-                    f\"While applying an edit to `{filename}`, the code block to be replaced was not found. No instances will be replaced.\"\n-                )\n-            if occurrences_cnt > 1:\n-                logger.warning(\n-                    f\"While applying an edit to `{filename}`, the code block to be replaced was found multiple times. All instances will be replaced.\"\n-                )\n-            files_dict[filename] = files_dict[filename].replace(\n-                edit.before, edit.after\n-            )  # existing file\n+    str1, str2 = str1.replace(\" \", \"\").lower(), str2.replace(\" \", \"\").lower()\n+\n+    counter1, counter2 = Counter(str1), Counter(str2)\n+    intersection = sum((counter1 & counter2).values())\n+    longer_length = max(len(str1), len(str2))\n+\n+    return intersection >= 0.9 * longer_length\n+\n+\n+#\n+#\n+# def apply_edits(edits: List[Edit], files_dict: FilesDict):\n+#     \"\"\"\n+#     Applies a list of Edit objects to the provided FilesDict object.\n+#\n+#     Parameters\n+#     ----------\n+#     edits : List[Edit]\n+#         The list of edits to apply.\n+#     files_dict : FilesDict\n+#         The FilesDict object to be modified.\n+#     \"\"\"\n+#     for edit in edits:\n+#         filename = edit.filename\n+#         if filename not in files_dict:\n+#             files_dict[filename] = \"\"\n+#             logger.warning(f\"Created new file: {filename}\")\n+#\n+#         lines = files_dict[filename].split(\"\\n\")\n+#         line_number = min(edit.line_number - 1, len(lines))\n+#\n+#         if line_number < len(lines):\n+#             if edit.is_before:  # Deletion\n+#                 if is_similar(lines[line_number], edit.content):\n+#                     lines[line_number] = \"# Line deleted line by GPT\"\n+#                     logger.warning(\n+#                         f\"Deleted from {filename}, line {edit.line_number}: '{edit.content}'\"\n+#                     )\n+#                 else:\n+#                     logger.warning(\n+#                         f\"line {edit.line_number}: '{edit.content}' not found in {filename} where should be '{lines[line_number]}'\"\n+#                     )\n+#             else:  # Addition\n+#                 if (\n+#                     lines[line_number] == \"# Line deleted line by GPT\"\n+#                     or lines[line_number] == \"\"\n+#                     or len(files_dict[filename]) == 0\n+#                 ):\n+#                     lines[line_number] = edit.content\n+#                     logger.warning(\n+#                         f\"Added to {filename}, line {edit.line_number}: '{edit.content.strip()}'\"\n+#                     )\n+#                 else:\n+#                     logger.warning(\n+#                         f\"The addition of {edit.content} is discarded for wrong line number\"\n+#                     )\n+#         else:\n+#             if not edit.is_before:\n+#                 lines.append(edit.content)\n+#                 logger.warning(\n+#                     f\"Added to {filename}, line {edit.line_number}: '{edit.content.strip()}'\"\n+#                 )\n+#\n+#         files_dict[filename] = \"\\n\".join(lines)\n+#\n+#     # Remove deletion tag\n+#     for filename in files_dict.keys():\n+#         lines = files_dict[filename].split(\"\\n\")\n+#         lines = [line for line in lines if line.strip() != \"# Line deleted line by GPT\"]\n+#         files_dict[filename] = \"\\n\".join(lines)\ndiff --git a/gpt_engineer/preprompts/improve b/gpt_engineer/preprompts/improve\nindex e588e55083..38a7835e7e 100644\n--- a/gpt_engineer/preprompts/improve\n+++ b/gpt_engineer/preprompts/improve\n@@ -1,80 +1,30 @@\n-You are an expert software developer.\n-Respect existing conventions, libraries, etc.\n-\n-You MUST\n-1. (planning) Think step-by-step and explain the needed changes. Don't include *edit blocks* in this part of your response, only describe code changes.\n-2. (output) Describe each change with an *edit block* per the example below.\n-\n-You MUST format EVERY code change with an *edit block* like this:\n-```python\n-example.py\n-<<<<<<< HEAD\n-    # some comment\n-    # Func to multiply\n-    def mul(a,b)\n-=======\n-    # updated comment\n-    # Function to add\n-    def add(a,b):\n->>>>>>> updated\n-```\n-Remember, you can use multiple *edit blocks* per file.\n-\n-Here is an example response:\n----\n-PLANNING:\n-We need to change \"SOMETHING\" because \"SOMETHING\", therefore I will add the line `a=a+1` to the function `add_one`.\n-Also, in the class `DB`, we need to update the \"SOMETHING\"\n-\n-OUTPUT:\n-```python\n-example_1.py\n-<<<<<<< HEAD\n-    def mul(a,b)\n-=======\n-    def add(a,b):\n->>>>>>> updated\n-```\n-\n-```python\n-example_2.py\n-<<<<<<< HEAD\n-    def add_one(a,b):\n-        a = a+2\n-=======\n-    def add_one(a,b):\n-        a = a+1\n->>>>>>> updated\n+Act as an expert software developer.\n+Always use best practices when coding.\n+When you edit or add code, respect and use existing conventions, libraries, etc.\n+\n+Take requests for changes to the supplied code, and then you MUST\n+1. (planning) Think step-by-step and explain the needed changes. Don't include *block*s in this part of your response, only describe code changes.\n+2. (generate patches) Use \"git diff\" syntax to write changes to the code; each \"git diff\" must only contain one hunk\n+3. (check) Make sure the line numbers and code match the original file; add file headers\n+\n+Patches example:\n+```diff\n+--- a.py\n++++ a.py\n+\ndiff --git a/tests/core/test_chat_to_files.py b/tests/core/test_chat_to_files.py\nindex ee1ed0e86e..63f5fdace8 100644\n--- a/tests/core/test_chat_to_files.py\n+++ b/tests/core/test_chat_to_files.py\n@@ -1,219 +1,270 @@\n-import logging\n-\n import pytest\n \n-from gpt_engineer.core.chat_to_files import (\n-    Edit,\n-    apply_edits,\n-    chat_to_files_dict,\n-    logger as parse_logger,\n-    parse_edits,\n-)\n-\n-\n-def test_standard_input():\n-    chat = \"\"\"\n-    Some text describing the code\n-file1.py\n-```python\n-print(\"Hello, World!\")\n-```\n-\n-file2.py\n-```python\n-def add(a, b):\n-    return a + b\n-```\n-    \"\"\"\n-    expected = {\n-        \"file1.py\": 'print(\"Hello, World!\")',\n-        \"file2.py\": \"def add(a, b):\\n    return a + b\",\n-    }\n-    assert chat_to_files_dict(chat) == expected\n-\n-\n-def test_no_code_blocks():\n-    chat = \"Just some regular chat without code.\"\n-    expected = {}\n-    assert chat_to_files_dict(chat) == expected\n-\n-\n-def test_special_characters_in_filename():\n-    chat = \"\"\"\n-    file[1].py\n-    ```python\n-    print(\"File 1\")\n-    ```\n-\n-    file`2`.py\n-    ```python\n-    print(\"File 2\")\n-    ```\n-    \"\"\"\n-    expected = {\"file[1].py\": 'print(\"File 1\")', \"file`2`.py\": 'print(\"File 2\")'}\n-    parsed = chat_to_files_dict(chat)\n-    assert parsed == expected\n-\n-\n-def test_empty_code_blocks():\n-    chat = \"\"\"\n-    empty.py\n-    ```\n-    ```\n-    \"\"\"\n-    expected = {\"empty.py\": \"\"}\n-    assert chat_to_files_dict(chat) == expected\n-\n-\n-def test_mixed_content():\n-    chat = \"\"\"\n-    script.sh\n-    ```bash\n-    echo \"Hello\"\n-    ```\n-\n-    script.py\n-    ```python\n-    print(\"World\")\n-    ```\n-    \"\"\"\n-    expected = {\"script.sh\": 'echo \"Hello\"', \"script.py\": 'print(\"World\")'}\n-    assert chat_to_files_dict(chat) == expected\n-\n-\n-def test_filename_line_break():\n-    chat = \"\"\"\n-    file1.py\n-\n-    ```python\n-    print(\"Hello, World!\")\n-    ```\n-    \"\"\"\n-    expected = {\"file1.py\": 'print(\"Hello, World!\")'}\n-    assert chat_to_files_dict(chat) == expected\n-\n-\n-def test_filename_in_backticks():\n-    chat = \"\"\"\n-    `file1.py`\n-    ```python\n-    print(\"Hello, World!\")\n-    ```\n-    \"\"\"\n-    expected = {\"file1.py\": 'print(\"Hello, World!\")'}\n-    assert chat_to_files_dict(chat) == expected\n-\n-\n-def test_filename_with_file_tag():\n-    chat = \"\"\"\n-    [FILE: file1.py]\n-    ```python\n-    print(\"Hello, World!\")\n-    ```\n-    \"\"\"\n-    expected = {\"file1.py\": 'print(\"Hello, World!\")'}\n-    assert chat_to_files_dict(chat) == expected\n-\n-\n-def test_filename_with_different_extension():\n-    chat = \"\"\"\n-    [id].jsx\n-    ```javascript\n-    console.log(\"Hello, World!\")\n-    ```\n-    \"\"\"\n-    expected = {\"[id].jsx\": 'console.log(\"Hello, World!\")'}\n-    assert chat_to_files_dict(chat) == expected\n-\n-\n-# Helper function to capture log messages\n-@pytest.fixture\n-def log_capture():\n-    class LogCaptureHandler(logging.Handler):\n-        def __init__(self):\n-            super().__init__()\n-            self.messages = []\n-\n-        def emit(self, record):\n-            self.messages.append(record.getMessage())\n-\n-    handler = LogCaptureHandler()\n-    parse_logger.addHandler(handler)\n-    yield handler\n-    parse_logger.removeHandler(handler)\n-\n-\n-def test_parse_with_additional_text():\n-    chat = \"\"\"\n-Some introductory text.\n-\n-```python\n-some/dir/example_1.py\n-<<<<<<< HEAD\n-    def mul(a,b)\n-=======\n-    def add(a,b):\n->>>>>>> updated\n-```\n-\n-Text between patches.\n-\n-```python\n-some/dir/example_2.py\n-<<<<<<< HEAD\n-    class DBS:\n-        db = 'aaa'\n-=======\n-    class DBS:\n-        db = 'bbb'\n->>>>>>> updated\n-```\n-\n-Ending text.\n-    \"\"\"\n-    expected = [\n-        Edit(\"some/dir/example_1.py\", \"def mul(a,b)\", \"def add(a,b):\"),\n-        Edit(\n-            \"some/dir/example_2.py\",\n-            \"class DBS:\\n        db = 'aaa'\",\n-            \"class DBS:\\n        db = 'bbb'\",\n-        ),\n-    ]\n-    parsed = parse_edits(chat)\n-    assert parsed == expected\n-\n-\n-def test_apply_overwrite_existing_file(log_capture):\n-    edits = [Edit(\"existing_file.py\", \"\", \"print('Hello, World!')\")]\n-    code = {\"existing_file.py\": \"some content\"}\n-    apply_edits(edits, code)\n-    assert code == {\"existing_file.py\": \"print('Hello, World!')\"}\n-    assert \"file will be overwritten\" in log_capture.messages[0]\n-\n-\n-def test_apply_edit_new_file(log_capture):\n-    edits = [Edit(\"new_file.py\", \"\", \"print('Hello, World!')\")]\n-    code = {}\n-    apply_edits(edits, code)\n-    assert code == {\"new_file.py\": \"print('Hello, World!')\"}\n-\n-\n-def test_apply_edit_no_match(log_capture):\n-    edits = [Edit(\"file.py\", \"non-existent content\", \"new content\")]\n-    code = {\"file.py\": \"some content\"}\n-    apply_edits(edits, code)\n-    assert code == {\"file.py\": \"some content\"}  # No change\n-    assert \"code block to be replaced was not found\" in log_capture.messages[0]\n-\n-\n-def test_apply_edit_multiple_matches(log_capture):\n-    edits = [Edit(\"file.py\", \"repeat\", \"new\")]\n-    code = {\"file.py\": \"repeat repeat repeat\"}\n-    apply_edits(edits, code)\n-    assert code == {\"file.py\": \"new new new\"}\n-    assert (\n-        \"code block to be replaced was found multiple times\" in log_capture.messages[0]\n-    )\n+# def test_standard_input():\n+#     chat = \"\"\"\n+#     Some text describing the code\n+# file1.py\n+# ```python\n+# 1 + print(\"Hello, World!\")\n+# ```\n+#\n+# file2.py\n+# ```python\n+# 1 + def add(a, b):\n+# 2 +    return a + b\n+# ```\n+#     \"\"\"\n+#     expected = {\n+#         \"file1.py\": '1 + print(\"Hello, World!\")',\n+#         \"file2.py\": \"1 + def add(a, b):\\n2 +    return a + b\",\n+#     }\n+#     assert chat_to_files_dict(chat) == expected\n+#\n+#\n+# def test_no_code_blocks():\n+#     chat = \"Just some regular chat without code.\"\n+#     expected = {}\n+#     assert chat_to_files_dict(chat) == expected\n+#\n+#\n+# def test_special_characters_in_filename():\n+#     chat = \"\"\"\n+#     file[1].py\n+#     ```python\n+#     1 + print(\"File 1\")\n+#     ```\n+#\n+#     file`2`.py\n+#     ```python\n+#     1 + print(\"File 2\")\n+#     ```\n+#     \"\"\"\n+#     expected = {\n+#         \"file[1].py\": '1 + print(\"File 1\")',\n+#         \"file`2`.py\": '1 + print(\"File 2\")',\n+#     }\n+#     parsed = chat_to_files_dict(chat)\n+#     assert parsed == expected\n+#\n+#\n+# def test_empty_code_blocks():\n+#     chat = \"\"\"\n+#     empty.py\n+#     ```\n+#     ```\n+#     \"\"\"\n+#     expected = {\"empty.py\": \"\"}\n+#     assert chat_to_files_dict(chat) == expected\n+#\n+#\n+# def test_mixed_content():\n+#     chat = \"\"\"\n+#     script.sh\n+#     ```bash\n+#     1 + echo \"Hello\"\n+#     ```\n+#\n+#     script.py\n+#     ```python\n+#     1 + print(\"World\")\n+#     ```\n+#     \"\"\"\n+#     expected = {\"script.sh\": '1 + echo \"Hello\"', \"script.py\": '1 + print(\"World\")'}\n+#     assert chat_to_files_dict(chat) == expected\n+#\n+#\n+# def test_filename_line_break():\n+#     chat = \"\"\"\n+#     file1.py\n+#\n+#     ```python\n+#     1 + print(\"Hello, World!\")\n+#     ```\n+#     \"\"\"\n+#     expected = {\"file1.py\": '1 + print(\"Hello, World!\")'}\n+#     assert chat_to_files_dict(chat) == expected\n+#\n+#\n+# def test_filename_in_backticks():\n+#     chat = \"\"\"\n+#     `file1.py`\n+#     ```python\n+#     1 + print(\"Hello, World!\")\n+#     ```\n+#     \"\"\"\n+#     expected = {\"file1.py\": '1 + print(\"Hello, World!\")'}\n+#     assert chat_to_files_dict(chat) == expected\n+#\n+#\n+# def test_filename_with_file_tag():\n+#     chat = \"\"\"\n+#     [FILE: file1.py]\n+#     ```python\n+#     1 + print(\"Hello, World!\")\n+#     ```\n+#     \"\"\"\n+#     expected = {\"file1.py\": '1 + print(\"Hello, World!\")'}\n+#     assert chat_to_files_dict(chat) == expected\n+#\n+#\n+# def test_filename_with_different_extension():\n+#     chat = \"\"\"\n+#     [id].jsx\n+#     ```javascript\n+#     1 + console.log(\"Hello, World!\")\n+#     ```\n+#     \"\"\"\n+#     expected = {\"[id].jsx\": '1 + console.log(\"Hello, World!\")'}\n+#     assert chat_to_files_dict(chat) == expected\n+#\n+#\n+# # Helper function to capture log messages\n+# @pytest.fixture\n+# def log_capture():\n+#     class LogCaptureHandler(logging.Handler):\n+#         def __init__(self):\n+#             super().__init__()\n+#             self.messages = []\n+#\n+#         def emit(self, record):\n+#             self.messages.append(record.getMessage())\n+#\n+#     handler = LogCaptureHandler()\n+#     parse_logger.addHandler(handler)\n+#     yield handler\n+#     parse_logger.removeHandler(handler)\n+#\n+#\n+# def test_parse_with_additional_text():\n+#     chat = \"\"\"\n+# Some introductory text.\n+#\n+# ```python\n+# File: some/dir/example_1.py\n+# 1 -     def mul(a,b)\n+# 1 +     def add(a,b):\n+# ```\n+#\n+# Text between patches.\n+#\n+# ```python\n+# File: some/dir/example_2.py\n+# 1 -     class DBS:\n+# 2 -         db = 'aaa'\n+# 1 +     class DBS:\n+# 2 +        db = 'bbb'\n+# ```\n+#\n+# Ending text.\n+#     \"\"\"\n+#     expected = [\n+#         Edit(\n+#             filename=\"some/dir/example_1.py\",\n+#             line_number=1,\n+#             content=\"    def mul(a,b)\",\n+#             is_before=True,\n+#         ),\n+#         Edit(\n+#             filename=\"some/dir/example_1.py\",\n+#             line_number=1,\n+#             content=\"    def add(a,b):\",\n+#             is_before=False,\n+#         ),\n+#         Edit(\n+#             filename=\"some/dir/example_2.py\",\n+#             line_number=1,\n+#             content=\"    class DBS:\",\n+#             is_before=True,\n+#         ),\n+#         Edit(\n+#             filename=\"some/dir/example_2.py\",\n+#             line_number=1,\n+#             content=\"    class DBS:\",\n+#             is_before=False,\n+#         ),\n+#         Edit(\n+#             filename=\"some/dir/example_2.py\",\n+#             line_number=2,\n+#             content=\"        db = 'aaa'\",\n+#             is_before=True,\n+#         ),\n+#         Edit(\n+#             filename=\"some/dir/example_2.py\",\n+#             line_number=2,\n+#             content=\"       db = 'bbb'\",\n+#             is_before=False,\n+#         ),\n+#     ]\n+#     parsed = parse_edits(chat)\n+#     assert parsed == expected\n+#\n+#\n+# def test_apply_overwrite_existing_file(log_capture):\n+#     edits = [\n+#         Edit(filename=\"existing_file.py\", line_number=1, content=\"\", is_before=True),\n+#         Edit(\n+#             filename=\"existing_file.py\",\n+#             line_number=1,\n+#             content=\"print('Hello, World!')\",\n+#             is_before=False,\n+#         ),\n+#     ]\n+#     code = {\"existing_file.py\": \"some content\"}\n+#     apply_edits(edits, code)\n+#     assert code == {\"existing_file.py\": \"some content\"}\n+#     assert \"not found in existing_file.py where should be\" in log_capture.messages[0]\n+#     assert \"is discarded for wrong line number\" in log_capture.messages[1]\n+#\n+#\n+# def test_apply_edit_new_file(log_capture):\n+#     edits = [\n+#         Edit(filename=\"new_file.py\", line_number=1, content=\"\", is_before=True),\n+#         Edit(\n+#             filename=\"new_file.py\",\n+#             line_number=1,\n+#             content=\"print('Hello, World!')\",\n+#             is_before=False,\n+#         ),\n+#     ]\n+#     code = {}\n+#     apply_edits(edits, code)\n+#     assert code == {\"new_file.py\": \"print('Hello, World!')\"}\n+#\n+#\n+# def test_apply_edit_no_match(log_capture):\n+#     edits = [\n+#         Edit(\n+#             filename=\"file.py\",\n+#             line_number=1,\n+#             content=\"non-existent content\",\n+#             is_before=True,\n+#         ),\n+#         Edit(filename=\"file.py\", line_number=1, content=\"new content\", is_before=False),\n+#     ]\n+#     code = {\"file.py\": \"some content\"}\n+#     apply_edits(edits, code)\n+#     assert code == {\"file.py\": \"some content\"}  # No change\n+#     assert \"not found\" in log_capture.messages[0]\n+#\n+#\n+# def test_basic_similarity():\n+#     assert is_similar(\"abc\", \"cab\")\n+#     assert not is_similar(\"abc\", \"def\")\n+#\n+#\n+# def test_case_insensitivity_and_whitespace():\n+#     assert is_similar(\"A b C\", \"c a b\")\n+#     assert not is_similar(\"Abc\", \"D e F\")\n+#\n+#\n+# def test_length_and_character_frequency():\n+#     assert is_similar(\"aabbc\", \"bacba\")\n+#     assert not is_similar(\"aabbcc\", \"abbcc\")\n+#\n+#\n+# def test_edge_cases():\n+#     assert not is_similar(\"\", \"a\")\n+#     assert is_similar(\"a\", \"a\")\n \n \n if __name__ == \"__main__\":\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The updates to `file_dict` and `improve` function are showing promise, especially with error corrections and the new `main.py` implementation. However, issues remain with parsing chat content back into the file structure. The editing process is unreliable, possibly due to the recent commit's changes. I suggest refining the logic for validating edits—focus on line numbers rather than exact content matches to reduce inconsistencies. Also, consider using Black for formatting across the board to tackle indentation issues. Let’s set up a separate PR for that integration."
      }
    ],
    "token_estimation": 7288.0
  },
  {
    "index": 95,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/lib/ModelAE.py b/lib/ModelAE.py\ndeleted file mode 100644\nindex 78658ca81b..0000000000\n--- a/lib/ModelAE.py\n+++ /dev/null\n@@ -1,91 +0,0 @@\n-# AutoEncoder base classes\r\n-\r\n-import time\r\n-import numpy\r\n-from lib.training_data import TrainingDataGenerator, stack_images\r\n-\r\n-encoderH5 = 'encoder.h5'\r\n-decoder_AH5 = 'decoder_A.h5'\r\n-decoder_BH5 = 'decoder_B.h5'\r\n-\r\n-class ModelAE:\r\n-    def __init__(self, model_dir):\r\n-        self.model_dir = model_dir\r\n-\r\n-        self.encoder = self.Encoder()\r\n-        self.decoder_A = self.Decoder()\r\n-        self.decoder_B = self.Decoder()\r\n-\r\n-        self.initModel()\r\n-\r\n-    def load(self, swapped):\r\n-        (face_A,face_B) = (decoder_AH5, decoder_BH5) if not swapped else (decoder_BH5, decoder_AH5)\r\n-\r\n-        try:\r\n-            self.encoder.load_weights(str(self.model_dir / encoderH5))\r\n-            self.decoder_A.load_weights(str(self.model_dir / face_A))\r\n-            self.decoder_B.load_weights(str(self.model_dir / face_B))\r\n-            print('loaded model weights')\r\n-            return True\r\n-        except Exception as e:\r\n-            print('Failed loading existing training data.')\r\n-            print(e)\r\n-            return False\r\n-\r\n-    def save_weights(self):\r\n-        self.encoder.save_weights(str(self.model_dir / encoderH5))\r\n-        self.decoder_A.save_weights(str(self.model_dir / decoder_AH5))\r\n-        self.decoder_B.save_weights(str(self.model_dir / decoder_BH5))\r\n-        print('saved model weights')\r\n-\r\n-class TrainerAE():\r\n-    random_transform_args = {\r\n-        'rotation_range': 10,\r\n-        'zoom_range': 0.05,\r\n-        'shift_range': 0.05,\r\n-        'random_flip': 0.4,\r\n-    }\r\n-\r\n-    def __init__(self, model, fn_A, fn_B, batch_size=64):\r\n-        self.batch_size = batch_size\r\n-        self.model = model\r\n-\r\n-        generator = TrainingDataGenerator(self.random_transform_args, 160)\r\n-        self.images_A = generator.minibatchAB(fn_A, self.batch_size)\r\n-        self.images_B = generator.minibatchAB(fn_B, self.batch_size)\r\n-\r\n-    def train_one_step(self, iter, viewer):\r\n-        epoch, warped_A, target_A = next(self.images_A)\r\n-        epoch, warped_B, target_B = next(self.images_B)\r\n-\r\n-        loss_A = self.model.autoencoder_A.train_on_batch(warped_A, target_A)\r\n-        loss_B = self.model.autoencoder_B.train_on_batch(warped_B, target_B)\r\n-        print(\"[{0}] [#{1:05d}] loss_A: {2:.5f}, loss_B: {3:.5f}\".format(time.strftime(\"%H:%M:%S\"), iter, loss_A, loss_B),\r\n-            end='\\r')\r\n-\r\n-        if viewer is not None:\r\n-            viewer(self.show_sample(target_A[0:14], target_B[0:14]), \"training\")\r\n-\r\n-    def show_sample(self, test_A, test_B):\r\n-        figure_A = numpy.stack([\r\n-            test_A,\r\n-            self.model.autoencoder_A.predict(test_A),\r\n-            self.model.autoencoder_B.predict(test_A),\r\n-        ], axis=1)\r\n-        figure_B = numpy.stack([\r\n-            test_B,\r\n-            self.model.autoencoder_B.predict(test_B),\r\n-            self.model.autoencoder_A.predict(test_B),\r\n-        ], axis=1)\r\n-\r\n-        if test_A.shape[0] % 2 == 1:\r\n-            figure_A = numpy.concatenate ([figure_A, numpy.expand_dims(figure_A[0],0) ])\r\n-            figure_B = numpy.concatenate ([figure_B, numpy.expand_dims(figure_B[0],0) ])\r\n-        \r\n-        figure = numpy.concatenate([figure_A, figure_B], axis=0)\r\n-        w = 4\r\n-        h = int( figure.shape[0] / w)        \r\n-        figure = figure.reshape((w, h) + figure.shape[1:])        \r\n-        figure = stack_images(figure)\r\n-        \r\n-        return numpy.clip(figure * 255, 0, 255).astype('uint8')\r\ndiff --git a/plugins/Convert_Masked.py b/plugins/Convert_Masked.py\nindex d2f6fc2c22..22918069b2 100644\n--- a/plugins/Convert_Masked.py\n+++ b/plugins/Convert_Masked.py\n@@ -51,21 +53,77 @@ def apply_new_face(self, image, new_face, image_mask, mat, image_size, size):\n               masky = int(minx+(lenx//2))\r\n               maskx = int(miny+(leny//2))\r\n               outimage = cv2.seamlessClone(new_image.astype(numpy.uint8),base_image.astype(numpy.uint8),unitMask,(masky,maskx) , cv2.NORMAL_CLONE )\r\n-              \r\n+\r\n               return outimage\r\n-              \r\n+\r\n         foreground = cv2.multiply(image_mask, new_image.astype(float))\r\n         background = cv2.multiply(1.0 - image_mask, base_image.astype(float))\r\n         outimage = cv2.add(foreground, background)\r\n \r\n         return outimage\r\n \r\n+    def hist_match(self, source, template, mask=None):\r\n+        # Code borrowed from:\r\n+        # https://stackoverflow.com/questions/32655686/histogram-matching-of-two-images-in-python-2-x\r\n+        masked_source = source\r\n+        masked_template = template\r\n+\r\n+        if mask is not None:\r\n+            masked_source = source * mask\r\n+            masked_template = template * mask\r\n+\r\n+        oldshape = source.shape\r\n+        source = source.ravel()\r\n+        template = template.ravel()\r\n+        masked_source = masked_source.ravel()\r\n+        masked_template = masked_template.ravel()\r\n+        s_values, bin_idx, s_counts = numpy.unique(source, return_inverse=True,\r\n+                                                return_counts=True)\r\n+        t_values, t_counts = numpy.unique(template, return_counts=True)\r\n+        ms_values, mbin_idx, ms_counts = numpy.unique(source, return_inverse=True,\r\n+                                                return_counts=True)\r\n+        mt_values, mt_counts = numpy.unique(template, return_counts=True)\r\n+\r\n+        s_quantiles = numpy.cumsum(s_counts).astype(numpy.float64)\r\n+        s_quantiles /= s_quantiles[-1]\r\n+        t_quantiles = numpy.cumsum(t_counts).astype(numpy.float64)\r\n+        t_quantiles /= t_quantiles[-1]\r\n+        interp_t_values = numpy.interp(s_quantiles, t_quantiles, t_values)\r\n+\r\n+        return interp_t_values[bin_idx].reshape(oldshape)\r\n+\r\n+    def color_hist_match(self, src_im, tar_im, mask):\r\n+        matched_R = self.hist_match(src_im[:,:,0], tar_im[:,:,0], mask)\r\n+        matched_G = self.hist_match(src_im[:,:,1], tar_im[:,:,1], mask)\r\n+        matched_B = self.hist_match(src_im[:,:,2], tar_im[:,:,2], mask)\r\n+        matched = numpy.stack((matched_R, matched_G, matched_B), axis=2).astype(src_im.dtype)\r\n+        return matched\r\n+\r\n     def get_new_face(self, image, mat, size):\r\n         face = cv2.warpAffine( image, mat, (size,size) )\r\n         face = numpy.expand_dims( face, 0 )\r\n-        new_face = self.encoder( face / 255.0 )[0]\r\n-\r\n-        return numpy.clip( new_face * 255, 0, 255 ).astype( image.dtype )\r\n+        face_clipped = numpy.clip(face[0], 0, 255).astype( image.dtype )\r\n+        new_face = None\r\n+        mask = None\r\n+\r\n+        if \"GAN\" not in self.trainer:\r\n+            normalized_face = face / 255.0\r\n+            new_face = self.encoder(normalized_face)[0]\r\n+            new_face = numpy.clip( new_face * 255, 0, 255 ).astype( image.dtype )\r\n+        else:\r\n+            normalized_face = face / 255.0 * 2 - 1\r\n+            fake_output = self.encoder(normalized_face)\r\n+            if \"128\" in self.trainer: # TODO: Another hack to switch between 64 and 128\r\n+                fake_output = fake_output[0]\r\n+            mask = fake_output[:,:,:, :1]\r\n+            new_face = fake_output[:,:,:, 1:]\r\n+            new_face = mask * new_face + (1 - mask) * normalized_face\r\n+            new_face = numpy.clip((new_face[0] + 1) * 255 / 2, 0, 255).astype( image.dtype )\r\n+\r\n+        if self.match_histogram:\r\n+            new_face = self.color_hist_match(new_face, face_clipped, mask)\r\n+\r\n+        return new_face\r\n \r\n     def get_image_mask(self, image, new_face, face_detected, mat, image_size):\r\n \r\ndiff --git a/plugins/Model_GAN/Trainer.py b/plugins/Model_GAN/Trainer.py\nindex 01b16dd56a..0c270430ec 100644\n--- a/plugins/Model_GAN/Trainer.py\n+++ b/plugins/Model_GAN/Trainer.py\n@@ -14,140 +20,241 @@ def color_adjust(self, img):\n class Trainer():\r\n     random_transform_args = {\r\n         'rotation_range': 20,\r\n-        'zoom_range': 0.05,\r\n+        'zoom_range': 0.1,\r\n         'shift_range': 0.05,\r\n         'random_flip': 0.5,\r\n         }\r\n \r\n-    def __init__(self, model, fn_A, fn_B, batch_size):\r\n+    def __init__(self, model, fn_A, fn_B, batch_size, perceptual_loss):\r\n+        K.set_learning_phase(1)\r\n+\r\n         assert batch_size % 2 == 0, \"batch_size must be an even number\"\r\n         self.batch_size = batch_size\r\n         self.model = model\r\n-        \r\n+\r\n+        self.use_lsgan = True\r\n         self.use_mixup = True\r\n         self.mixup_alpha = 0.2\r\n+        self.use_perceptual_loss = perceptual_loss\r\n+        self.use_instancenorm = False\r\n \r\n-        generator = GANTrainingDataGenerator(self.random_transform_args, 220)\r\n+        self.lrD = 1e-4 # Discriminator learning rate\r\n+        self.lrG = 1e-4 # Generator learning rate\r\n+\r\n+        generator = GANTrainingDataGenerator(self.random_transform_args, 220, 6, 1)\r\n         self.train_batchA = generator.minibatchAB(fn_A, batch_size)\r\n         self.train_batchB = generator.minibatchAB(fn_B, batch_size)\r\n-    \r\n+\r\n+        self.avg_counter = self.errDA_sum = self.errDB_sum = self.errGA_sum = self.errGB_sum = 0\r\n+\r\n+        self.setup()\r\n+\r\n+    def setup(self):\r\n+        distorted_A, fake_A, mask_A, self.path_A, self.path_mask_A, self.path_abgr_A, self.path_bgr_A = self.cycle_variables(self.model.netGA)\r\n+        distorted_B, fake_B, mask_B, self.path_B, self.path_mask_B, self.path_abgr_B, self.path_bgr_B = self.cycle_variables(self.model.netGB)\r\n+        real_A = Input(shape=self.model.img_shape)\r\n+        real_B = Input(shape=self.model.img_shape)\r\n+\r\n+        if self.use_lsgan:\r\n+            self.loss_fn = lambda output, target : K.mean(K.abs(K.square(output-target)))\r\n+        else:\r\n+            self.loss_fn = lambda output, target : -K.mean(K.log(output+1e-12)*target+K.log(1-output+1e-12)*(1-target))\r\n+\r\n+        # ========== Define Perceptual Loss Model==========\r\n+        if self.use_perceptual_loss:\r\n+            from keras.models import Model\r\n+            from keras_vggface.vggface import VGGFace\r\n+            vggface = VGGFace(include_top=False, model='resnet50', input_shape=(224, 224, 3))\r\n+            vggface.trainable = False\r\n+            out_size55 = vggface.layers[36].output\r\n+            out_size28 = vggface.layers[78].output\r\n+            out_size7 = vggface.layers[-2].output\r\n+            vggface_feat = Model(vggface.input, [out_size55, out_size28, out_size7])\r\n+            vggface_feat.trainable = False\r\n+        else:\r\n+            vggface_feat = None\r\n+\r\n+        #TODO check \"Tips for mask refinement (optional after >15k iters)\" => https://render.githubusercontent.com/view/ipynb?commit=87d6e7a28ce754acd38d885367b6ceb0be92ec54&enc_url=68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f7368616f616e6c752f66616365737761702d47414e2f383764366537613238636537353461636433386438383533363762366365623062653932656335342f46616365537761705f47414e5f76325f737a3132385f747261696e2e6970796e62&nwo=shaoanlu%2Ffaceswap-GAN&path=FaceSwap_GAN_v2_sz128_train.ipynb&repository_id=115182783&repository_type=Repository#Tips-for-mask-refinement-(optional-after-%3E15k-iters)\r\n+        loss_DA, loss_GA = self.define_loss(self.model.netDA, real_A, fake_A, distorted_A, vggface_feat)\r\n+        loss_DB, loss_GB = self.define_loss(self.model.netDB, real_B, fake_B, distorted_B, vggface_feat)\r\n+\r\n+        loss_GA += 1e-3 * K.mean(K.abs(mask_A))\r\n+        loss_GB += 1e-3 * K.mean(K.abs(mask_B))\r\n+\r\n+        w_fo = 0.01\r\n+        loss_GA += w_fo * K.mean(self.first_order(mask_A, axis=1))\r\n+        loss_GA += w_fo * K.mean(self.first_order(mask_A, axis=2))\r\n+        loss_GB += w_fo * K.mean(self.first_order(mask_B, axis=1))\r\n+        loss_GB += w_fo * K.mean(self.first_order(mask_B, axis=2))\r\n+\r\n+        weightsDA = self.model.netDA.trainable_weights\r\n+        weightsGA = self.model.netGA.trainable_weights\r\n+        weightsDB = self.model.netDB.trainable_weights\r\n+        weightsGB = self.model.netGB.trainable_weights\r\n+\r\n+        # Adam(..).get_updates(...)\r\n+        training_updates = Adam(lr=self.lrD, beta_1=0.5).get_updates(weightsDA,[],loss_DA)\r\n+        self.netDA_train = K.function([distorted_A, real_A],[loss_DA], training_updates)\r\n+        training_updates = Adam(lr=self.lrG, beta_1=0.5).get_updates(weightsGA,[], loss_GA)\r\n+        self.netGA_train = K.function([distorted_A, real_A], [loss_GA], training_updates)\r\n+\r\n+        training_updates = Adam(lr=self.lrD, beta_1=0.5).get_updates(weightsDB,[],loss_DB)\r\n+        self.netDB_train = K.function([distorted_B, real_B],[loss_DB], training_updates)\r\n+        training_updates = Adam(lr=self.lrG, beta_1=0.5).get_updates(weightsGB,[], loss_GB)\r\n+        self.netGB_train = K.function([distorted_B, real_B], [loss_GB], training_updates)\r\n+\r\n+    def first_order(self, x, axis=1):\r\n+        img_nrows = x.shape[1]\r\n+        img_ncols = x.shape[2]\r\n+        if axis == 1:\r\n+            return K.abs(x[:, :img_nrows - 1, :img_ncols - 1, :] - x[:, 1:, :img_ncols - 1, :])\r\n+        elif axis == 2:\r\n+            return K.abs(x[:, :img_nrows - 1, :img_ncols - 1, :] - x[:, :img_nrows - 1, 1:, :])\r\n+        else:\r\n+            return None\r\n+\r\n     def train_one_step(self, iter, viewer):\r\n         # ---------------------\r\n         #  Train Discriminators\r\n         # ---------------------\r\n \r\n         # Select a random half batch of images\r\n-        epoch, warped_A, target_A = next(self.train_batchA) \r\n-        epoch, warped_B, target_B = next(self.train_batchB) \r\n-\r\n-        # Generate a half batch of new images\r\n-        gen_alphasA, gen_imgsA = self.model.netGA.predict(warped_A)\r\n-        gen_alphasB, gen_imgsB = self.model.netGB.predict(warped_B)\r\n-        #gen_masked_imgsA = gen_alphasA * gen_imgsA + (1 - gen_alphasA) * warped_A\r\n-        #gen_masked_imgsB = gen_alphasB * gen_imgsB + (1 - gen_alphasB) * warped_B\r\n-        gen_masked_imgsA = np.array([gen_alphasA[i] * gen_imgsA[i] + (1 - gen_alphasA[i]) * warped_A[i] \r\n-                                     for i in range(self.batch_size)])\r\n-        gen_masked_imgsB = np.array([gen_alphasB[i] * gen_imgsB[i] + (1 - gen_alphasB[i]) * warped_B[i]\r\n-                                     for i in range (self.batch_size)])\r\n-\r\n-        valid = np.ones((self.batch_size, ) + self.model.netDA.output_shape[1:])\r\n-        fake = np.zeros((self.batch_size, ) + self.model.netDA.output_shape[1:])\r\n-\r\n-        concat_real_inputA = np.array([np.concatenate([target_A[i], warped_A[i]], axis=-1) \r\n-                                       for i in range(self.batch_size)])\r\n-        concat_real_inputB = np.array([np.concatenate([target_B[i], warped_B[i]], axis=-1) \r\n-                                       for i in range(self.batch_size)])\r\n-        concat_fake_inputA = np.array([np.concatenate([gen_masked_imgsA[i], warped_A[i]], axis=-1) \r\n-                                       for i in range(self.batch_size)])\r\n-        concat_fake_inputB = np.array([np.concatenate([gen_masked_imgsB[i], warped_B[i]], axis=-1) \r\n-                                       for i in range(self.batch_size)])\r\n-        if self.use_mixup:\r\n-            lam = np.random.beta(self.mixup_alpha, self.mixup_alpha)\r\n-            mixup_A = lam * concat_real_inputA + (1 - lam) * concat_fake_inputA\r\n-            mixup_B = lam * concat_real_inputB + (1 - lam) * concat_fake_inputB\r\n+        epoch, warped_A, target_A = next(self.train_batchA)\r\n+        epoch, warped_B, target_B = next(self.train_batchB)\r\n \r\n-        # Train the discriminators\r\n-        #print (\"Train the discriminators.\")\r\n-        if self.use_mixup:\r\n-            d_lossA = self.model.netDA.train_on_batch(mixup_A, lam * valid)\r\n-            d_lossB = self.model.netDB.train_on_batch(mixup_B, lam * valid)\r\n-        else:\r\n-            d_lossA = self.model.netDA.train_on_batch(np.concatenate([concat_real_inputA, concat_fake_inputA], axis=0), \r\n-                                                np.concatenate([valid, fake], axis=0))\r\n-            d_lossB = self.model.netDB.train_on_batch(np.concatenate([concat_real_inputB, concat_fake_inputB], axis=0),\r\n-                                                np.concatenate([valid, fake], axis=0))\r\n+        # Train dicriminators for one batch\r\n+        errDA  = self.netDA_train([warped_A, target_A])\r\n+        errDB  = self.netDB_train([warped_B, target_B])\r\n \r\n-        # ---------------------\r\n-        #  Train Generators\r\n-        # ---------------------\r\n+        # Train generators for one batch\r\n+        errGA = self.netGA_train([warped_A, target_A])\r\n+        errGB = self.netGB_train([warped_B, target_B])\r\n+\r\n+        # For calculating average losses\r\n+        self.errDA_sum += errDA[0]\r\n+        self.errDB_sum += errDB[0]\r\n+        self.errGA_sum += errGA[0]\r\n+        self.errGB_sum += errGB[0]\r\n+        self.avg_counter += 1\r\n \r\n-        # Train the generators\r\n-        #print (\"Train the generators.\")\r\n-        g_lossA = self.model.adversarial_autoencoderA.train_on_batch(warped_A, [target_A, valid])\r\n-        g_lossB = self.model.adversarial_autoencoderB.train_on_batch(warped_B, [target_B, valid])            \r\n-        \r\n         print('[%s] [%d/%s][%d] Loss_DA: %f Loss_DB: %f Loss_GA: %f Loss_GB: %f'\r\n-              % (time.strftime(\"%H:%M:%S\"), epoch, \"num_epochs\", iter, d_lossA[0], d_lossB[0], g_lossA[0], g_lossB[0]),\r\n+              % (time.strftime(\"%H:%M:%S\"), epoch, \"num_epochs\", iter, self.errDA_sum/self.avg_counter, self.errDB_sum/self.avg_counter, self.errGA_sum/self.avg_counter, self.errGB_sum/self.avg_counter),\r\n               end='\\r')\r\n-        \r\n+\r\n         if viewer is not None:\r\n             self.show_sample(viewer)\r\n-    \r\n+\r\n+    def cycle_variables(self, netG):\r\n+        distorted_input = netG.inputs[0]\r\n+        fake_output = netG.outputs[0]\r\n+        alpha = Lambda(lambda x: x[:,:,:, :1])(fake_output)\r\n+        rgb = Lambda(lambda x: x[:,:,:, 1:])(fake_output)\r\n+\r\n+        masked_fake_output = alpha * rgb + (1-alpha) * distorted_input\r\n+\r\n+        fn_generate = K.function([distorted_input], [masked_fake_output])\r\n+        fn_mask = K.function([distorted_input], [concatenate([alpha, alpha, alpha])])\r\n+        fn_abgr = K.function([distorted_input], [concatenate([alpha, rgb])])\r\n+        fn_bgr = K.function([distorted_input], [rgb])\r\n+        return distorted_input, fake_output, alpha, fn_generate, fn_mask, fn_abgr, fn_bgr\r\n+\r\n+    def define_loss(self, netD, real, fake_argb, distorted, vggface_feat=None):\r\n+        alpha = Lambda(lambda x: x[:,:,:, :1])(fake_argb)\r\n+        fake_rgb = Lambda(lambda x: x[:,:,:, 1:])(fake_argb)\r\n+        fake = alpha * fake_rgb + (1-alpha) * distorted\r\n+\r\n+        if self.use_mixup:\r\n+            dist = Beta(self.mixup_alpha, self.mixup_alpha)\r\n+            lam = dist.sample()\r\n+            # ==========\r\n+            mixup = lam * concatenate([real, distorted]) + (1 - lam) * concatenate([fake, distorted])\r\n+            # ==========\r\n+            output_mixup = netD(mixup)\r\n+            loss_D = self.loss_fn(output_mixup, lam * K.ones_like(output_mixup))\r\n+            output_fake = netD(concatenate([fake, distorted])) # dummy\r\n+            loss_G = .5 * self.loss_fn(output_mixup, (1 - lam) * K.ones_like(output_mixup))\r\n+        else:\r\n+            output_real = netD(concatenate([real, distorted])) # positive sample\r\n+            output_fake = netD(concatenate([fake, distorted])) # negative sample\r\n+            loss_D_real = self.loss_fn(output_real, K.ones_like(output_real))\r\n+            loss_D_fake = self.loss_fn(output_fake, K.zeros_like(output_fake))\r\n+            loss_D = loss_D_real + loss_D_fake\r\n+            loss_G = .5 * self.loss_fn(output_fake, K.ones_like(output_fake))\r\n+        # ==========\r\n+        loss_G += K.mean(K.abs(fake_rgb - real))\r\n+        # ==========\r\n+\r\n+        # Edge loss (similar with total variation loss)\r\n+        loss_G += 1 * K.mean(K.abs(self.first_order(fake_rgb, axis=1) - self.first_order(real, axis=1)))\r\n+        loss_G += 1 * K.mean(K.abs(self.first_order(fake_rgb, axis=2) - self.first_order(real, axis=2)))\r\n+\r\n+\r\n+        # Perceptual Loss\r\n+        if not vggface_feat is None:\r\n+            def preprocess_vggface(x):\r\n+                x = (x + 1)/2 * 255 # channel order: BGR\r\n+                #x[..., 0] -= 93.5940\r\n+                #x[..., 1] -= 104.7624\r\n+                #x[..., 2] -= 129.\r\n+                x -= [91.4953, 103.8827, 131.0912]\r\n+                return x\r\n+            pl_params = (0.011, 0.11, 0.1919)\r\n+            real_sz224 = tf.image.resize_images(real, [224, 224])\r\n+            real_sz224 = Lambda(preprocess_vggface)(real_sz224)\r\n+            # ==========\r\n+            fake_sz224 = tf.image.resize_images(fake_rgb, [224, 224])\r\n+            fake_sz224 = Lambda(preprocess_vggface)(fake_sz224)\r\n+            # ==========\r\n+            real_feat55, real_feat28, real_feat7 = vggface_feat(real_sz224)\r\n+            fake_feat55, fake_feat28, fake_feat7  = vggface_feat(fake_sz224)\r\n+            loss_G += pl_params[0] * K.mean(K.abs(fake_feat7 - real_feat7))\r\n+            loss_G += pl_params[1] * K.mean(K.abs(fake_feat28 - real_feat28))\r\n+            loss_G += pl_params[2] * K.mean(K.abs(fake_feat55 - real_feat55))\r\n+\r\n+        return loss_D, loss_G\r\n+\r\n     def show_sample(self, display_fn):\r\n         _, wA, tA = next(self.train_batchA)\r\n         _, wB, tB = next(self.train_batchB)\r\n-        self.showG(tA, tB, display_fn)\r\n-\r\n-    def showG(self, test_A, test_B, display_fn):\r\n-        def display_fig(name, figure_A, figure_B):\r\n-            figure = np.concatenate([figure_A, figure_B], axis=0 )\r\n-            columns = 4\r\n-            elements = figure.shape[0]\r\n-            figure = figure.reshape((columns,(elements//columns)) + figure.shape[1:])\r\n-            figure = stack_images(figure)\r\n-            figure = np.clip((figure + 1) * 255 / 2, 0, 255).astype('uint8')\r\n-            display_fn(figure, name)\r\n-\r\n-        out_test_A_netGA = self.model.netGA.predict(test_A)\r\n-        out_test_A_netGB = self.model.netGB.predict(test_A)\r\n-        out_test_B_netGA = self.model.netGA.predict(test_B)\r\n-        out_test_B_netGB = self.model.netGB.predict(test_B)\r\n+        display_fn(self.showG(tA, tB, self.path_A, self.path_B), \"raw\")\r\n+        display_fn(self.showG(tA, tB, self.path_bgr_A, self.path_bgr_B), \"masked\")\r\n+        display_fn(self.showG_mask(tA, tB, self.path_mask_A, self.path_mask_B), \"mask\")\r\n+        # Reset the averages\r\n+        self.errDA_sum = self.errDB_sum = self.errGA_sum = self.errGB_sum = 0\r\n+        self.avg_counter = 0\r\n \r\n+    def showG(self, test_A, test_B, path_A, path_B):\r\n         figure_A = np.stack([\r\n             test_A,\r\n-            out_test_A_netGA[1],\r\n-            out_test_A_netGB[1],\r\n+            np.squeeze(np.array([path_A([test_A[i:i+1]]) for i in range(test_A.shape[0])])),\r\n+            np.squeeze(np.array([path_B([test_A[i:i+1]]) for i in range(test_A.shape[0])])),\r\n             ], axis=1 )\r\n         figure_B = np.stack([\r\n             test_B,\r\n-            out_test_B_netGB[1],\r\n-            out_test_B_netGA[1],\r\n+            np.squeeze(np.array([path_B([test_B[i:i+1]]) for i in range(test_B.shape[0])])),\r\n+            np.squeeze(np.array([path_A([test_B[i:i+1]]) for i in range(test_B.shape[0])])),\r\n             ], axis=1 )\r\n-        \r\n-        display_fig(\"raw\", figure_A, figure_B)       \r\n \r\n-        figure_A = np.stack([\r\n-            test_A,\r\n-            np.tile(out_test_A_netGA[0],3) * 2 - 1,\r\n-            np.tile(out_test_A_netGB[0],3) * 2 - 1,\r\n-            ], axis=1 )\r\n-        figure_B = np.stack([\r\n-            test_B,\r\n-            np.tile(out_test_B_netGB[0],3) * 2 - 1,\r\n-            np.tile(out_test_B_netGA[0],3) * 2 - 1,\r\n-            ], axis=1 )\r\n-\r\n-        display_fig(\"alpha_masks\", figure_A, figure_B)\r\n+        figure = np.concatenate([figure_A, figure_B], axis=0 )\r\n+        figure = figure.reshape((4,self.batch_size // 2) + figure.shape[1:])\r\n+        figure = stack_images(figure)\r\n+        figure = np.clip((figure + 1) * 255 / 2, 0, 255).astype('uint8')\r\n+        return figure\r\n \r\n+    def showG_mask(self, test_A, test_B, path_A, path_B):\r\n         figure_A = np.stack([\r\n             test_A,\r\n-            out_test_A_netGA[0] * out_test_A_netGA[1] + (1 - out_test_A_netGA[0]) * test_A,\r\n-            out_test_A_netGB[0] * out_test_A_netGB[1] + (1 - out_test_A_netGB[0]) * test_A,\r\n+            (np.squeeze(np.array([path_A([test_A[i:i+1]]) for i in range(test_A.shape[0])])))*2-1,\r\n+            (np.squeeze(np.array([path_B([test_A[i:i+1]]) for i in range(test_A.shape[0])])))*2-1,\r\n             ], axis=1 )\r\n         figure_B = np.stack([\r\n             test_B,\r\n-            out_test_B_netGB[0] * out_test_B_netGB[1] + (1 - out_test_B_netGB[0]) * test_B,\r\n-            out_test_B_netGA[0] * out_test_B_netGA[1] + (1 - out_test_B_netGA[0]) * test_B,\r\n+            (np.squeeze(np.array([path_B([test_B[i:i+1]]) for i in range(test_B.shape[0])])))*2-1,\r\n+            (np.squeeze(np.array([path_A([test_B[i:i+1]]) for i in range(test_B.shape[0])])))*2-1,\r\n             ], axis=1 )\r\n-        \r\n-        display_fig(\"masked\", figure_A, figure_B)\r\n+\r\n+        figure = np.concatenate([figure_A, figure_B], axis=0 )\r\n+        figure = figure.reshape((4,self.batch_size // 2) + figure.shape[1:])\r\n+        figure = stack_images(figure)\r\n+        figure = np.clip((figure + 1) * 255 / 2, 0, 255).astype('uint8')\r\n+        return figure\r\ndiff --git a/plugins/Model_GAN/instance_normalization.py b/plugins/Model_GAN/instance_normalization.py\nnew file mode 100644\nindex 0000000000..9c0616af27\n--- /dev/null\n+++ b/plugins/Model_GAN/instance_normalization.py\n@@ -0,0 +1,145 @@\n+from keras.engine import Layer, InputSpec\n+from keras import initializers, regularizers, constraints\n+from keras import backend as K\n+from keras.utils.generic_utils import get_custom_objects\n+\n+import numpy as np\n+\n+\n+class InstanceNormalization(Layer):\n+    \"\"\"Instance normalization layer (Lei Ba et al, 2016, Ulyanov et al., 2016).\n+    Normalize the activations of the previous layer at each step,\n+    i.e. applies a transformation that maintains the mean activation\n+    close to 0 and the activation standard deviation close to 1.\n+    # Arguments\n+        axis: Integer, the axis that should be normalized\n+            (typically the features axis).\n+            For instance, after a `Conv2D` layer with\n+            `data_format=\"channels_first\"`,\n+            set `axis=1` in `InstanceNormalization`.\n+            Setting `axis=None` will normalize all values in each instance of the batch.\n+            Axis 0 is the batch dimension. `axis` cannot be set to 0 to avoid errors.\n+        epsilon: Small float added to variance to avoid dividing by zero.\n+        center: If True, add offset of `beta` to normalized tensor.\n+            If False, `beta` is ignored.\n+        scale: If True, multiply by `gamma`.\n+            If False, `gamma` is not used.\n+            When the next layer is linear (also e.g. `nn.relu`),\n+            this can be disabled since the scaling\n+            will be done by the next layer.\n+        beta_initializer: Initializer for the beta weight.\n+        gamma_initializer: Initializer for the gamma weight.\n+        beta_regularizer: Optional regularizer for the beta weight.\n+        gamma_regularizer: Optional regularizer for the gamma weight.\n+        beta_constraint: Optional constraint for the beta weight.\n+        gamma_constraint: Optional constraint for the gamma weight.\n+    # Input shape\n+        Arbitrary. Use the keyword argument `input_shape`\n+        (tuple of integers, does not include the samples axis)\n+        when using this layer as the first layer in a model.\n+    # Output shape\n+        Same shape as input.\n+    # References\n+        - [Layer Normalization](https://arxiv.org/abs/1607.06450)\n+        - [Instance Normalization: The Missing Ingredient for Fast Stylization](https://arxiv.org/abs/1607.08022)\n+    \"\"\"\n+    def __init__(self,\n+                 axis=None,\n+                 epsilon=1e-3,\n+                 center=True,\n+                 scale=True,\n+                 beta_initializer='zeros',\n+                 gamma_initializer='ones',\n+                 beta_regularizer=None,\n+                 gamma_regularizer=None,\n+                 beta_constraint=None,\n+                 gamma_constraint=None,\n+                 **kwargs):\n+        super(InstanceNormalization, self).__init__(**kwargs)\n+        self.supports_masking = True\n+        self.axis = axis\n+        self.epsilon = epsilon\n+        self.center = center\n+        self.scale = scale\n+        self.beta_initializer = initializers.get(beta_initializer)\n+        self.gamma_initializer = initializers.get(gamma_initializer)\n+        self.beta_regularizer = regularizers.get(beta_regularizer)\n+        self.gamma_regularizer = regularizers.get(gamma_regularizer)\n+        self.beta_constraint = constraints.get(beta_constraint)\n+        self.gamma_constraint = constraints.get(gamma_constraint)\n+\n+    def build(self, input_shape):\n+        ndim = len(input_shape)\n+        if self.axis == 0:\n+            raise ValueError('Axis cannot be zero')\n+\n+        if (self.axis is not None) and (ndim == 2):\n+            raise ValueError('Cannot specify axis for rank 1 tensor')\n+\n+        self.input_spec = InputSpec(ndim=ndim)\n+\n+        if self.axis is None:\n+            shape = (1,)\n+        else:\n+            shape = (input_shape[self.axis],)\n+\n+        if self.scale:\n+            self.gamma = self.add_weight(shape=shape,\n+                                         name='gamma',\n+                                         initializer=self.gamma_initializer,\n+                                         regularizer=self.gamma_regularizer,\n+                                         constraint=self.gamma_constraint)\n+        else:\n+            self.gamma = None\n+        if self.center:\n+            self.beta = self.add_weight(shape=shape,\n+                                        name='beta',\n+                                        initializer=self.beta_initializer,\n+                                        regularizer=self.beta_regularizer,\n+                                        constraint=self.beta_constraint)\n+        else:\n+            self.beta = None\n+        self.built = True\n+\n+    def call(self, inputs, training=None):\n+        input_shape = K.int_shape(inputs)\n+        reduction_axes = list(range(0, len(input_shape)))\n+\n+        if (self.axis is not None):\n+            del reduction_axes[self.axis]\n+\n+        del reduction_axes[0]\n+\n+        mean = K.mean(inputs, reduction_axes, keepdims=True)\n+        stddev = K.std(inputs, reduction_axes, keepdims=True) + self.epsilon\n+        normed = (inputs - mean) / stddev\n+\n+        broadcast_shape = [1] * len(input_shape)\n+        if self.axis is not None:\n+            broadcast_shape[self.axis] = input_shape[self.axis]\n+\n+        if self.scale:\n+            broadcast_gamma = K.reshape(self.gamma, broadcast_shape)\n+            normed = normed * broadcast_gamma\n+        if self.center:\n+            broadcast_beta = K.reshape(self.beta, broadcast_shape)\n+            normed = normed + broadcast_beta\n+        return normed\n+\n+    def get_config(self):\n+        config = {\n+            'axis': self.axis,\n+            'epsilon': self.epsilon,\n+            'center': self.center,\n+            'scale': self.scale,\n+            'beta_initializer': initializers.serialize(self.beta_initializer),\n+            'gamma_initializer': initializers.serialize(self.gamma_initializer),\n+            'beta_regularizer': regularizers.serialize(self.beta_regularizer),\n+            'gamma_regularizer': regularizers.serialize(self.gamma_regularizer),\n+            'beta_constraint': constraints.serialize(self.beta_constraint),\n+            'gamma_constraint': constraints.serialize(self.gamma_constraint)\n+        }\n+        base_config = super(InstanceNormalization, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+\n+get_custom_objects().update({'InstanceNormalization': InstanceNormalization})\ndiff --git a/plugins/Model_GAN128/Model.py b/plugins/Model_GAN128/Model.py\nnew file mode 100644\nindex 0000000000..9d14850101\n--- /dev/null\n+++ b/plugins/Model_GAN128/Model.py\n@@ -0,0 +1,177 @@\n+# Based on the https://github.com/shaoanlu/faceswap-GAN repo \r\n+# source : https://github.com/shaoanlu/faceswap-GAN/blob/master/FaceSwap_GAN_v2_sz128_train.ipynbtemp/faceswap_GAN_keras.ipynb\r\n+\r\n+from keras.models import Model\r\n+from keras.layers import *\r\n+from keras.layers.advanced_activations import LeakyReLU\r\n+from keras.activations import relu\r\n+from keras.initializers import RandomNormal\r\n+from keras.applications import *\r\n+from keras.optimizers import Adam\r\n+\r\n+from lib.PixelShuffler import PixelShuffler\r\n+from .instance_normalization import InstanceNormalization\r\n+\r\n+netGAH5 = 'netGA_GAN128.h5'\r\n+netGBH5 = 'netGB_GAN128.h5'\r\n+netDAH5 = 'netDA_GAN128.h5'\r\n+netDBH5 = 'netDB_GAN128.h5'\r\n+\r\n+def __conv_init(a):\r\n+    print(\"conv_init\", a)\r\n+    k = RandomNormal(0, 0.02)(a) # for convolution kernel\r\n+    k.conv_weight = True    \r\n+    return k\r\n+\r\n+#def batchnorm():\r\n+#    return BatchNormalization(momentum=0.9, axis=channel_axis, epsilon=1.01e-5, gamma_initializer = gamma_init)\r\n+\r\n+def inst_norm():\r\n+    return InstanceNormalization()\r\n+\r\n+conv_init = RandomNormal(0, 0.02)\r\n+gamma_init = RandomNormal(1., 0.02) # for batch normalization\r\n+\r\n+class GANModel():\r\n+    img_size = 128\r\n+    channels = 3\r\n+    img_shape = (img_size, img_size, channels)\r\n+    encoded_dim = 1024\r\n+    nc_in = 3 # number of input channels of generators\r\n+    nc_D_inp = 6 # number of input channels of discriminators\r\n+\r\n+    def __init__(self, model_dir):\r\n+        self.model_dir = model_dir\r\n+\r\n+        optimizer = Adam(1e-4, 0.5)\r\n+\r\n+        # Build and compile the discriminator\r\n+        self.netDA, self.netDB = self.build_discriminator()\r\n+\r\n+        # Build and compile the generator\r\n+        self.netGA, self.netGB = self.build_generator()\r\n+\r\n+    def converter(self, swap):\r\n+        predictor = self.netGB if not swap else self.netGA\r\n+        return lambda img: predictor.predict(img)\r\n+\r\n+    def build_generator(self):\r\n+\r\n+        def conv_block(input_tensor, f, use_instance_norm=True):\r\n+            x = input_tensor\r\n+            x = SeparableConv2D(f, kernel_size=3, strides=2, kernel_initializer=conv_init, use_bias=False, padding=\"same\")(x)\r\n+            if use_instance_norm:\r\n+                x = inst_norm()(x)\r\n+            x = Activation(\"relu\")(x)\r\n+            return x\r\n+\r\n+        def res_block(input_tensor, f, dilation=1):\r\n+            x = input_tensor\r\n+            x = Conv2D(f, kernel_size=3, kernel_initializer=conv_init, use_bias=False, padding=\"same\", dilation_rate=dilation)(x)\r\n+            x = LeakyReLU(alpha=0.2)(x)\r\n+            x = Conv2D(f, kernel_size=3, kernel_initializer=conv_init, use_bias=False, padding=\"same\", dilation_rate=dilation)(x)\r\n+            x = add([x, input_tensor])\r\n+            #x = LeakyReLU(alpha=0.2)(x)\r\n+            return x\r\n+\r\n+        def upscale_ps(filters, use_instance_norm=True):\r\n+            def block(x, use_instance_norm=use_instance_norm):\r\n+                x = Conv2D(filters*4, kernel_size=3, use_bias=False, kernel_initializer=RandomNormal(0, 0.02), padding='same')(x)\r\n+                if use_instance_norm:\r\n+                    x = inst_norm()(x)\r\n+                x = LeakyReLU(0.1)(x)\r\n+                x = PixelShuffler()(x)\r\n+                return x\r\n+            return block\r\n+\r\n+        def Encoder(nc_in=3, input_size=128):\r\n+            inp = Input(shape=(input_size, input_size, nc_in))\r\n+            x = Conv2D(32, kernel_size=5, kernel_initializer=conv_init, use_bias=False, padding=\"same\")(inp)\r\n+            x = conv_block(x,64, use_instance_norm=False)\r\n+            x = conv_block(x,128)\r\n+            x = conv_block(x,256)\r\n+            x = conv_block(x,512) \r\n+            x = conv_block(x,1024)\r\n+            x = Dense(1024)(Flatten()(x))\r\n+            x = Dense(4*4*1024)(x)\r\n+            x = Reshape((4, 4, 1024))(x)\r\n+            out = upscale_ps(512)(x)\r\n+            return Model(inputs=inp, outputs=out)\r\n+\r\n+        def Decoder_ps(nc_in=512, input_size=8):\r\n+            input_ = Input(shape=(input_size, input_size, nc_in))\r\n+            x = input_\r\n+            x = upscale_ps(256)(x)\r\n+            x = upscale_ps(128)(x)    \r\n+            x = upscale_ps(64)(x)\r\n+            x = res_block(x, 64, dilation=2)      \r\n+            \r\n+            out64 = Conv2D(64, kernel_size=3, padding='same')(x)\r\n+            out64 = LeakyReLU(alpha=0.1)(out64)\r\n+            out64 = Conv2D(3, kernel_size=5, padding='same', activation=\"tanh\")(out64)\r\n+            \r\n+            x = upscale_ps(32)(x)\r\n+            x = res_block(x, 32)\r\n+            x = res_block(x, 32)\r\n+            alpha = Conv2D(1, kernel_size=5, padding='same', activation=\"sigmoid\")(x)\r\n+            rgb = Conv2D(3, kernel_size=5, padding='same', activation=\"tanh\")(x)\r\n+            out = concatenate([alpha, rgb])\r\n+            return Model(input_, [out, out64] )\r\n+        \r\n+        encoder = Encoder()\r\n+        decoder_A = Decoder_ps()\r\n+        decoder_B = Decoder_ps()\r\n+        x = Input(shape=self.img_shape)\r\n+        netGA = Model(x, decoder_A(encoder(x)))\r\n+        netGB = Model(x, decoder_B(encoder(x)))\r\n+        try:\r\n+            netGA.load_weights(str(self.model_dir / netGAH5))\r\n+            netGB.load_weights(str(self.model_dir / netGBH5))\r\n+            print (\"Generator models loaded.\")\r\n+        except:\r\n+            print (\"Generator weights files not found.\")\r\n+            pass\r\n+        return netGA, netGB\r\n+\r\n+    def build_discriminator(self):\r\n+        def conv_block_d(input_tensor, f, use_instance_norm=True):\r\n+            x = input_tensor\r\n+            x = Conv2D(f, kernel_size=4, strides=2, kernel_initializer=conv_init, use_bias=False, padding=\"same\")(x)\r\n+            if use_instance_norm:\r\n+                x = inst_norm()(x)\r\n+            x = LeakyReLU(alpha=0.2)(x)\r\n+            return x\r\n+\r\n+        def Discriminator(nc_in, input_size=128):\r\n+            inp = Input(shape=(input_size, input_size, nc_in))\r\n+            #x = GaussianNoise(0.05)(inp)\r\n+            x = conv_block_d(inp, 64, False)\r\n+            x = conv_block_d(x, 128, True)\r\n+            x = conv_block_d(x, 256, True)\r\n+            x = conv_block_d(x, 512, True)\r\n+            out = Conv2D(1, kernel_size=4, kernel_initializer=conv_init, use_bias=False, padding=\"same\", activation=\"sigmoid\")(x)   \r\n+            return Model(inputs=[inp], outputs=out)\r\n+        \r\n+        netDA = Discriminator(self.nc_D_inp)\r\n+        netDB = Discriminator(self.nc_D_inp)\r\n+        try:\r\n+            netDA.load_weights(str(self.model_dir / netDAH5))\r\n+            netDB.load_weights(str(self.model_dir / netDBH5))\r\n+            print (\"Discriminator models loaded.\")\r\n+        except:\r\n+            print (\"Discriminator weights files not found.\")\r\n+            pass\r\n+        return netDA, netDB    \r\n+    \r\n+    def load(self, swapped):\r\n+        if swapped:\r\n+            print(\"swapping not supported on GAN\")\r\n+            # TODO load is done in __init__ => look how to swap if possible\r\n+        return True\r\n+    \r\n+    def save_weights(self):\r\n+        self.netGA.save_weights(str(self.model_dir / netGAH5))\r\n+        self.netGB.save_weights(str(self.model_dir / netGBH5))\r\n+        self.netDA.save_weights(str(self.model_dir / netDAH5))\r\n+        self.netDB.save_weights(str(self.model_dir / netDBH5))\r\n+        print (\"Models saved.\")\n\\ No newline at end of file\ndiff --git a/plugins/Model_GAN128/Trainer.py b/plugins/Model_GAN128/Trainer.py\nnew file mode 100644\nindex 0000000000..87aeb8b9f8\n--- /dev/null\n+++ b/plugins/Model_GAN128/Trainer.py\n@@ -0,0 +1,253 @@\n+import time\r\n+import cv2\r\n+import numpy as np\r\n+\r\n+from keras.layers import *\r\n+from tensorflow.contrib.distributions import Beta\r\n+import tensorflow as tf\r\n+from keras.optimizers import Adam\r\n+from keras import backend as K\r\n+\r\n+from lib.training_data import TrainingDataGenerator, stack_images\r\n+\r\n+class GANTrainingDataGenerator(TrainingDataGenerator):\r\n+    def __init__(self, random_transform_args, coverage, scale, zoom):\r\n+        super().__init__(random_transform_args, coverage, scale, zoom)\r\n+\r\n+    def color_adjust(self, img):\r\n+        return img / 255.0 * 2 - 1\r\n+\r\n+class Trainer():\r\n+    random_transform_args = {\r\n+        'rotation_range': 20,\r\n+        'zoom_range': 0.1,\r\n+        'shift_range': 0.05,\r\n+        'random_flip': 0.5,\r\n+        }\r\n+\r\n+    def __init__(self, model, fn_A, fn_B, batch_size, perceptual_loss):\r\n+        K.set_learning_phase(1)\r\n+\r\n+        assert batch_size % 2 == 0, \"batch_size must be an even number\"\r\n+        self.batch_size = batch_size\r\n+        self.model = model\r\n+\r\n+        self.use_lsgan = True\r\n+        self.use_mixup = True\r\n+        self.mixup_alpha = 0.2\r\n+        self.use_perceptual_loss = perceptual_loss\r\n+\r\n+        self.lrD = 1e-4 # Discriminator learning rate\r\n+        self.lrG = 1e-4 # Generator learning rate\r\n+\r\n+        generator = GANTrainingDataGenerator(self.random_transform_args, 220, 6, 2)\r\n+        self.train_batchA = generator.minibatchAB(fn_A, batch_size)\r\n+        self.train_batchB = generator.minibatchAB(fn_B, batch_size)\r\n+\r\n+        self.avg_counter = self.errDA_sum = self.errDB_sum = self.errGA_sum = self.errGB_sum = 0\r\n+\r\n+        self.setup()\r\n+\r\n+    def setup(self):\r\n+        distorted_A, fake_A, fake_sz64_A, mask_A, self.path_A, self.path_mask_A, self.path_abgr_A, self.path_bgr_A = self.cycle_variables(self.model.netGA)\r\n+        distorted_B, fake_B, fake_sz64_B, mask_B, self.path_B, self.path_mask_B, self.path_abgr_B, self.path_bgr_B = self.cycle_variables(self.model.netGB)\r\n+        real_A = Input(shape=self.model.img_shape)\r\n+        real_B = Input(shape=self.model.img_shape)\r\n+\r\n+        if self.use_lsgan:\r\n+            self.loss_fn = lambda output, target : K.mean(K.abs(K.square(output-target)))\r\n+        else:\r\n+            self.loss_fn = lambda output, target : -K.mean(K.log(output+1e-12)*target+K.log(1-output+1e-12)*(1-target))\r\n+\r\n+        # ========== Define Perceptual Loss Model==========\r\n+        if self.use_perceptual_loss:\r\n+            from keras.models import Model\r\n+            from keras_vggface.vggface import VGGFace\r\n+            vggface = VGGFace(include_top=False, model='resnet50', input_shape=(224, 224, 3))\r\n+            vggface.trainable = False\r\n+            out_size55 = vggface.layers[36].output\r\n+            out_size28 = vggface.layers[78].output\r\n+            out_size7 = vggface.layers[-2].output\r\n+            vggface_feat = Model(vggface.input, [out_size55, out_size28, out_size7])\r\n+            vggface_feat.trainable = False\r\n+        else:\r\n+            vggface_feat = None\r\n+\r\n+        #TODO check \"Tips for mask refinement (optional after >15k iters)\" => https://render.githubusercontent.com/view/ipynb?commit=87d6e7a28ce754acd38d885367b6ceb0be92ec54&enc_url=68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f7368616f616e6c752f66616365737761702d47414e2f383764366537613238636537353461636433386438383533363762366365623062653932656335342f46616365537761705f47414e5f76325f737a3132385f747261696e2e6970796e62&nwo=shaoanlu%2Ffaceswap-GAN&path=FaceSwap_GAN_v2_sz128_train.ipynb&repository_id=115182783&repository_type=Repository#Tips-for-mask-refinement-(optional-after-%3E15k-iters)\r\n+        loss_DA, loss_GA = self.define_loss(self.model.netDA, real_A, fake_A, fake_sz64_A, distorted_A, vggface_feat)\r\n+        loss_DB, loss_GB = self.define_loss(self.model.netDB, real_B, fake_B, fake_sz64_B, distorted_B, vggface_feat)\r\n+\r\n+        loss_GA += 3e-3 * K.mean(K.abs(mask_A))\r\n+        loss_GB += 3e-3 * K.mean(K.abs(mask_B))\r\n+\r\n+        w_fo = 0.01\r\n+        loss_GA += w_fo * K.mean(self.first_order(mask_A, axis=1))\r\n+        loss_GA += w_fo * K.mean(self.first_order(mask_A, axis=2))\r\n+        loss_GB += w_fo * K.mean(self.first_order(mask_B, axis=1))\r\n+        loss_GB += w_fo * K.mean(self.first_order(mask_B, axis=2))\r\n+\r\n+        weightsDA = self.model.netDA.trainable_weights\r\n+        weightsGA = self.model.netGA.trainable_weights\r\n+        weightsDB = self.model.netDB.trainable_weights\r\n+        weightsGB = self.model.netGB.trainable_weights\r\n+\r\n+        # Adam(..).get_updates(...)\r\n+        training_updates = Adam(lr=self.lrD, beta_1=0.5).get_updates(weightsDA,[],loss_DA)\r\n+        self.netDA_train = K.function([distorted_A, real_A],[loss_DA], training_updates)\r\n+        training_updates = Adam(lr=self.lrG, beta_1=0.5).get_updates(weightsGA,[], loss_GA)\r\n+        self.netGA_train = K.function([distorted_A, real_A], [loss_GA], training_updates)\r\n+\r\n+        training_updates = Adam(lr=self.lrD, beta_1=0.5).get_updates(weightsDB,[],loss_DB)\r\n+        self.netDB_train = K.function([distorted_B, real_B],[loss_DB], training_updates)\r\n+        training_updates = Adam(lr=self.lrG, beta_1=0.5).get_updates(weightsGB,[], loss_GB)\r\n+        self.netGB_train = K.function([distorted_B, real_B], [loss_GB], training_updates)\r\n+\r\n+    def first_order(self, x, axis=1):\r\n+        img_nrows = x.shape[1]\r\n+        img_ncols = x.shape[2]\r\n+        if axis == 1:\r\n+            return K.abs(x[:, :img_nrows - 1, :img_ncols - 1, :] - x[:, 1:, :img_ncols - 1, :])\r\n+        elif axis == 2:\r\n+            return K.abs(x[:, :img_nrows - 1, :img_ncols - 1, :] - x[:, :img_nrows - 1, 1:, :])\r\n+        else:\r\n+            return None\r\n+\r\n+    def train_one_step(self, iter, viewer):\r\n+        # ---------------------\r\n+        #  Train Discriminators\r\n+        # ---------------------\r\n+\r\n+        # Select a random half batch of images\r\n+        epoch, warped_A, target_A = next(self.train_batchA)\r\n+        epoch, warped_B, target_B = next(self.train_batchB)\r\n+\r\n+        # Train dicriminators for one batch\r\n+        errDA  = self.netDA_train([warped_A, target_A])\r\n+        errDB  = self.netDB_train([warped_B, target_B])\r\n+\r\n+        # Train generators for one batch\r\n+        errGA = self.netGA_train([warped_A, target_A])\r\n+        errGB = self.netGB_train([warped_B, target_B])\r\n+\r\n+        # For calculating average losses\r\n+        self.errDA_sum += errDA[0]\r\n+        self.errDB_sum += errDB[0]\r\n+        self.errGA_sum += errGA[0]\r\n+        self.errGB_sum += errGB[0]\r\n+        self.avg_counter += 1\r\n+\r\n+        print('[%s] [%d/%s][%d] Loss_DA: %f Loss_DB: %f Loss_GA: %f Loss_GB: %f'\r\n+              % (time.strftime(\"%H:%M:%S\"), epoch, \"num_epochs\", iter, self.errDA_sum/self.avg_counter, self.errDB_sum/self.avg_counter, self.errGA_sum/self.avg_counter, self.errGB_sum/self.avg_counter),\r\n+              end='\\r')\r\n+\r\n+        if viewer is not None:\r\n+            self.show_sample(viewer)\r\n+\r\n+    def cycle_variables(self, netG):\r\n+        distorted_input = netG.inputs[0]\r\n+        fake_output = netG.outputs[0]\r\n+        fake_output64 = netG.outputs[1]\r\n+        alpha = Lambda(lambda x: x[:,:,:, :1])(fake_output)\r\n+        rgb = Lambda(lambda x: x[:,:,:, 1:])(fake_output)\r\n+\r\n+        masked_fake_output = alpha * rgb + (1-alpha) * distorted_input\r\n+\r\n+        fn_generate = K.function([distorted_input], [masked_fake_output])\r\n+        fn_mask = K.function([distorted_input], [concatenate([alpha, alpha, alpha])])\r\n+        fn_abgr = K.function([distorted_input], [concatenate([alpha, rgb])])\r\n+        fn_bgr = K.function([distorted_input], [rgb])\r\n+        return distorted_input, fake_output, fake_output64, alpha, fn_generate, fn_mask, fn_abgr, fn_bgr\r\n+\r\n+    def define_loss(self, netD, real, fake_argb, fake_sz64, distorted, vggface_feat=None):\r\n+        alpha = Lambda(lambda x: x[:,:,:, :1])(fake_argb)\r\n+        fake_rgb = Lambda(lambda x: x[:,:,:, 1:])(fake_argb)\r\n+        fake = alpha * fake_rgb + (1-alpha) * distorted\r\n+\r\n+        if self.use_mixup:\r\n+            dist = Beta(self.mixup_alpha, self.mixup_alpha)\r\n+            lam = dist.sample()\r\n+            # ==========\r\n+            mixup = lam * concatenate([real, distorted]) + (1 - lam) * concatenate([fake, distorted])\r\n+            # ==========\r\n+            output_mixup = netD(mixup)\r\n+            loss_D = self.loss_fn(output_mixup, lam * K.ones_like(output_mixup))\r\n+            #output_fake = netD(concatenate([fake, distorted])) # dummy\r\n+            loss_G = 1 * self.loss_fn(output_mixup, (1 - lam) * K.ones_like(output_mixup))\r\n+        else:\r\n+            output_real = netD(concatenate([real, distorted])) # positive sample\r\n+            output_fake = netD(concatenate([fake, distorted])) # negative sample\r\n+            loss_D_real = self.loss_fn(output_real, K.ones_like(output_real))\r\n+            loss_D_fake = self.loss_fn(output_fake, K.zeros_like(output_fake))\r\n+            loss_D = loss_D_real + loss_D_fake\r\n+            loss_G = 1 * self.loss_fn(output_fake, K.ones_like(output_fake))\r\n+        # ==========\r\n+        loss_G += K.mean(K.abs(fake_rgb - real))\r\n+        loss_G += K.mean(K.abs(fake_sz64 - tf.image.resize_images(real, [64, 64])))\r\n+        # ==========\r\n+\r\n+        # Perceptual Loss\r\n+        if not vggface_feat is None:\r\n+            def preprocess_vggface(x):\r\n+                x = (x + 1)/2 * 255 # channel order: BGR\r\n+                x -= [93.5940, 104.7624, 129.]\r\n+                return x\r\n+            pl_params = (0.02, 0.3, 0.5)\r\n+            real_sz224 = tf.image.resize_images(real, [224, 224])\r\n+            real_sz224 = Lambda(preprocess_vggface)(real_sz224)\r\n+            # ==========\r\n+            fake_sz224 = tf.image.resize_images(fake_rgb, [224, 224])\r\n+            fake_sz224 = Lambda(preprocess_vggface)(fake_sz224)\r\n+            # ==========\r\n+            real_feat55, real_feat28, real_feat7 = vggface_feat(real_sz224)\r\n+            fake_feat55, fake_feat28, fake_feat7  = vggface_feat(fake_sz224)\r\n+            loss_G += pl_params[0] * K.mean(K.abs(fake_feat7 - real_feat7))\r\n+            loss_G += pl_params[1] * K.mean(K.abs(fake_feat28 - real_feat28))\r\n+            loss_G += pl_params[2] * K.mean(K.abs(fake_feat55 - real_feat55))\r\n+\r\n+        return loss_D, loss_G\r\n+\r\n+    def show_sample(self, display_fn):\r\n+        _, wA, tA = next(self.train_batchA)\r\n+        _, wB, tB = next(self.train_batchB)\r\n+        display_fn(self.showG(tA, tB, self.path_A, self.path_B), \"raw\")\r\n+        display_fn(self.showG(tA, tB, self.path_bgr_A, self.path_bgr_B), \"masked\")\r\n+        display_fn(self.showG_mask(tA, tB, self.path_mask_A, self.path_mask_B), \"mask\")\r\n+        # Reset the averages\r\n+        self.errDA_sum = self.errDB_sum = self.errGA_sum = self.errGB_sum = 0\r\n+        self.avg_counter = 0\r\n+\r\n+    def showG(self, test_A, test_B, path_A, path_B):\r\n+        figure_A = np.stack([\r\n+            test_A,\r\n+            np.squeeze(np.array([path_A([test_A[i:i+1]]) for i in range(test_A.shape[0])])),\r\n+            np.squeeze(np.array([path_B([test_A[i:i+1]]) for i in range(test_A.shape[0])])),\r\n+            ], axis=1 )\r\n+        figure_B = np.stack([\r\n+            test_B,\r\n+            np.squeeze(np.array([path_B([test_B[i:i+1]]) for i in range(test_B.shape[0])])),\r\n+            np.squeeze(np.array([path_A([test_B[i:i+1]]) for i in range(test_B.shape[0])])),\r\n+            ], axis=1 )\r\n+\r\n+        figure = np.concatenate([figure_A, figure_B], axis=0 )\r\n+        figure = figure.reshape((4,self.batch_size // 2) + figure.shape[1:])\r\n+        figure = stack_images(figure)\r\n+        figure = np.clip((figure + 1) * 255 / 2, 0, 255).astype('uint8')\r\n+        return figure\r\n+\r\n+    def showG_mask(self, test_A, test_B, path_A, path_B):\r\n+        figure_A = np.stack([\r\n+            test_A,\r\n+            (np.squeeze(np.array([path_A([test_A[i:i+1]]) for i in range(test_A.shape[0])])))*2-1,\r\n+            (np.squeeze(np.array([path_B([test_A[i:i+1]]) for i in range(test_A.shape[0])])))*2-1,\r\n+            ], axis=1 )\r\n+        figure_B = np.stack([\r\n+            test_B,\r\n+            (np.squeeze(np.array([path_B([test_B[i:i+1]]) for i in range(test_B.shape[0])])))*2-1,\r\n+            (np.squeeze(np.array([path_A([test_B[i:i+1]]) for i in range(test_B.shape[0])])))*2-1,\r\n+            ], axis=1 )\r\n+\r\n+        figure = np.concatenate([figure_A, figure_B], axis=0 )\r\n+        figure = figure.reshape((4,self.batch_size // 2) + figure.shape[1:])\r\n+        figure = stack_images(figure)\r\n+        figure = np.clip((figure + 1) * 255 / 2, 0, 255).astype('uint8')\r\n+        return figure\r\ndiff --git a/plugins/Model_GAN128/instance_normalization.py b/plugins/Model_GAN128/instance_normalization.py\nnew file mode 100644\nindex 0000000000..9c0616af27\n--- /dev/null\n+++ b/plugins/Model_GAN128/instance_normalization.py\n@@ -0,0 +1,145 @@\n+from keras.engine import Layer, InputSpec\n+from keras import initializers, regularizers, constraints\n+from keras import backend as K\n+from keras.utils.generic_utils import get_custom_objects\n+\n+import numpy as np\n+\n+\n+class InstanceNormalization(Layer):\n+    \"\"\"Instance normalization layer (Lei Ba et al, 2016, Ulyanov et al., 2016).\n+    Normalize the activations of the previous layer at each step,\n+    i.e. applies a transformation that maintains the mean activation\n+    close to 0 and the activation standard deviation close to 1.\n+    # Arguments\n+        axis: Integer, the axis that should be normalized\n+            (typically the features axis).\n+            For instance, after a `Conv2D` layer with\n+            `data_format=\"channels_first\"`,\n+            set `axis=1` in `InstanceNormalization`.\n+            Setting `axis=None` will normalize all values in each instance of the batch.\n+            Axis 0 is the batch dimension. `axis` cannot be set to 0 to avoid errors.\n+        epsilon: Small float added to variance to avoid dividing by zero.\n+        center: If True, add offset of `beta` to normalized tensor.\n+            If False, `beta` is ignored.\n+        scale: If True, multiply by `gamma`.\n+            If False, `gamma` is not used.\n+            When the next layer is linear (also e.g. `nn.relu`),\n+            this can be disabled since the scaling\n+            will be done by the next layer.\n+        beta_initializer: Initializer for the beta weight.\n+        gamma_initializer: Initializer for the gamma weight.\n+        beta_regularizer: Optional regularizer for the beta weight.\n+        gamma_regularizer: Optional regularizer for the gamma weight.\n+        beta_constraint: Optional constraint for the beta weight.\n+        gamma_constraint: Optional constraint for the gamma weight.\n+    # Input shape\n+        Arbitrary. Use the keyword argument `input_shape`\n+        (tuple of integers, does not include the samples axis)\n+        when using this layer as the first layer in a model.\n+    # Output shape\n+        Same shape as input.\n+    # References\n+        - [Layer Normalization](https://arxiv.org/abs/1607.06450)\n+        - [Instance Normalization: The Missing Ingredient for Fast Stylization](https://arxiv.org/abs/1607.08022)\n+    \"\"\"\n+    def __init__(self,\n+                 axis=None,\n+                 epsilon=1e-3,\n+                 center=True,\n+                 scale=True,\n+                 beta_initializer='zeros',\n+                 gamma_initializer='ones',\n+                 beta_regularizer=None,\n+                 gamma_regularizer=None,\n+                 beta_constraint=None,\n+                 gamma_constraint=None,\n+                 **kwargs):\n+        super(InstanceNormalization, self).__init__(**kwargs)\n+        self.supports_masking = True\n+        self.axis = axis\n+        self.epsilon = epsilon\n+        self.center = center\n+        self.scale = scale\n+        self.beta_initializer = initializers.get(beta_initializer)\n+        self.gamma_initializer = initializers.get(gamma_initializer)\n+        self.beta_regularizer = regularizers.get(beta_regularizer)\n+        self.gamma_regularizer = regularizers.get(gamma_regularizer)\n+        self.beta_constraint = constraints.get(beta_constraint)\n+        self.gamma_constraint = constraints.get(gamma_constraint)\n+\n+    def build(self, input_shape):\n+        ndim = len(input_shape)\n+        if self.axis == 0:\n+            raise ValueError('Axis cannot be zero')\n+\n+        if (self.axis is not None) and (ndim == 2):\n+            raise ValueError('Cannot specify axis for rank 1 tensor')\n+\n+        self.input_spec = InputSpec(ndim=ndim)\n+\n+        if self.axis is None:\n+            shape = (1,)\n+        else:\n+            shape = (input_shape[self.axis],)\n+\n+        if self.scale:\n+            self.gamma = self.add_weight(shape=shape,\n+                                         name='gamma',\n+                                         initializer=self.gamma_initializer,\n+                                         regularizer=self.gamma_regularizer,\n+                                         constraint=self.gamma_constraint)\n+        else:\n+            self.gamma = None\n+        if self.center:\n+            self.beta = self.add_weight(shape=shape,\n+                                        name='beta',\n+                                        initializer=self.beta_initializer,\n+                                        regularizer=self.beta_regularizer,\n+                                        constraint=self.beta_constraint)\n+        else:\n+            self.beta = None\n+        self.built = True\n+\n+    def call(self, inputs, training=None):\n+        input_shape = K.int_shape(inputs)\n+        reduction_axes = list(range(0, len(input_shape)))\n+\n+        if (self.axis is not None):\n+            del reduction_axes[self.axis]\n+\n+        del reduction_axes[0]\n+\n+        mean = K.mean(inputs, reduction_axes, keepdims=True)\n+        stddev = K.std(inputs, reduction_axes, keepdims=True) + self.epsilon\n+        normed = (inputs - mean) / stddev\n+\n+        broadcast_shape = [1] * len(input_shape)\n+        if self.axis is not None:\n+            broadcast_shape[self.axis] = input_shape[self.axis]\n+\n+        if self.scale:\n+            broadcast_gamma = K.reshape(self.gamma, broadcast_shape)\n+            normed = normed * broadcast_gamma\n+        if self.center:\n+            broadcast_beta = K.reshape(self.beta, broadcast_shape)\n+            normed = normed + broadcast_beta\n+        return normed\n+\n+    def get_config(self):\n+        config = {\n+            'axis': self.axis,\n+            'epsilon': self.epsilon,\n+            'center': self.center,\n+            'scale': self.scale,\n+            'beta_initializer': initializers.serialize(self.beta_initializer),\n+            'gamma_initializer': initializers.serialize(self.gamma_initializer),\n+            'beta_regularizer': regularizers.serialize(self.beta_regularizer),\n+            'gamma_regularizer': regularizers.serialize(self.gamma_regularizer),\n+            'beta_constraint': constraints.serialize(self.beta_constraint),\n+            'gamma_constraint': constraints.serialize(self.gamma_constraint)\n+        }\n+        base_config = super(InstanceNormalization, self).get_config()\n+        return dict(list(base_config.items()) + list(config.items()))\n+\n+get_custom_objects().update({'InstanceNormalization': InstanceNormalization})\ndiff --git a/plugins/Model_Original/Trainer.py b/plugins/Model_Original/Trainer.py\nnew file mode 100644\nindex 0000000000..5b1c918f62\n--- /dev/null\n+++ b/plugins/Model_Original/Trainer.py\n@@ -0,0 +1,50 @@\n+\n+import time\n+import numpy\n+from lib.training_data import TrainingDataGenerator, stack_images\n+\n+class Trainer():\n+    random_transform_args = {\n+        'rotation_range': 10,\n+        'zoom_range': 0.05,\n+        'shift_range': 0.05,\n+        'random_flip': 0.4,\n+    }\n+\n+    def __init__(self, model, fn_A, fn_B, batch_size, *args):\n+        self.batch_size = batch_size\n+        self.model = model\n+\n+        generator = TrainingDataGenerator(self.random_transform_args, 160)\n+        self.images_A = generator.minibatchAB(fn_A, self.batch_size)\n+        self.images_B = generator.minibatchAB(fn_B, self.batch_size)\n+\n+    def train_one_step(self, iter, viewer):\n+        epoch, warped_A, target_A = next(self.images_A)\n+        epoch, warped_B, target_B = next(self.images_B)\n+\n+        loss_A = self.model.autoencoder_A.train_on_batch(warped_A, target_A)\n+        loss_B = self.model.autoencoder_B.train_on_batch(warped_B, target_B)\n+        print(\"[{0}] [#{1:05d}] loss_A: {2:.5f}, loss_B: {3:.5f}\".format(time.strftime(\"%H:%M:%S\"), iter, loss_A, loss_B),\n+            end='\\r')\n+\n+        if viewer is not None:\n+            viewer(self.show_sample(target_A[0:14], target_B[0:14]), \"training\")\n+\n+    def show_sample(self, test_A, test_B):\n+        figure_A = numpy.stack([\n+            test_A,\n+            self.model.autoencoder_A.predict(test_A),\n+            self.model.autoencoder_B.predict(test_A),\n+        ], axis=1)\n+        figure_B = numpy.stack([\n+            test_B,\n+            self.model.autoencoder_B.predict(test_B),\n+            self.model.autoencoder_A.predict(test_B),\n+        ], axis=1)\n+\n+        figure = numpy.concatenate([figure_A, figure_B], axis=0)\n+        figure = figure.reshape((4, 7) + figure.shape[1:])\n+        figure = stack_images(figure)\n+\n+        return numpy.clip(figure * 255, 0, 255).astype('uint8')\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The stack trace suggests an issue with the `first_order` function due to a missing `self`. Ensure all method calls include `self` to avoid `NameError`. Your change addresses that, but double-check the implementation across affected classes. The crash may also relate to an outdated Keras version. Since you've confirmed that wasn’t the case, it's worth keeping an eye on package dependencies to prevent compatibility issues. Good job resolving the GPU issue with the TensorFlow reinstall."
      }
    ],
    "token_estimation": 15432.5
  },
  {
    "index": 96,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/plugins/Convert_DFaker.py b/plugins/Convert_DFaker.py\nnew file mode 100644\nindex 0000000000..b1566505b4\n--- /dev/null\n+++ b/plugins/Convert_DFaker.py\n@@ -0,0 +1,263 @@\n+import argparse\n+import cv2\n+import json\n+import numpy\n+from pathlib import Path\n+from tqdm import tqdm\n+from scipy import ndimage\n+# from model import autoencoder_A\n+# from model import autoencoder_B\n+# from model import encoder, decoder_A, decoder_B\n+\n+# encoder  .load_weights( \"models/encoder.h5\"   )\n+# decoder_A.load_weights( \"models/decoder_A.h5\" )\n+# decoder_B.load_weights( \"models/decoder_B.h5\" )\n+import time\n+\n+n=0\n+\n+imageSize = 256\n+croppedSize = 240 \n+\n+import cv2\n+import numpy\n+\n+from lib.aligner import get_align_mat\n+\n+class Convert():\n+    def __init__(self, encoder, trainer, blur_size=2, seamless_clone=False, mask_type=\"facehullandrect\", erosion_kernel_size=None, match_histogram=False, sharpen_image=None, double_pass=None, **kwargs):\n+        self.encoder_A = encoder(False)\n+        self.encoder_B = encoder(True)\n+        self.trainer = trainer\n+        self.erosion_kernel = None\n+        self.erosion_kernel_size = erosion_kernel_size\n+        if erosion_kernel_size is not None:\n+            self.erosion_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(abs(erosion_kernel_size),abs(erosion_kernel_size)))\n+        self.blur_size = blur_size\n+        self.seamless_clone = seamless_clone\n+        self.sharpen_image = sharpen_image\n+        self.match_histogram = match_histogram\n+        self.mask_type = mask_type.lower() # Choose in 'FaceHullAndRect','FaceHull','Rect'\n+        self.double_pass = double_pass\n+\n+    def patch_image( self, image, face_detected, size ):\n+        mat = numpy.array(get_align_mat(face_detected, size, should_align_eyes=False)).reshape(2,3)\n+\n+        global n\n+        n+=1\n+        size = 64\n+        image_size = image.shape[1], image.shape[0]\n+\n+        sourceMat = mat.copy()\n+\n+        sourceMat = sourceMat*(240+(16*2))\n+        sourceMat[:,2] += 48\n+\n+        face = cv2.warpAffine( image, sourceMat, (240+(48+16)*2,240+(48+16)*2) )\n+        \n+        sourceFace = face.copy()\n+        sourceFace = cv2.resize(sourceFace,(128,128),cv2.INTER_CUBIC)\n+        \n+\n+        face = cv2.resize(face,(64,64),cv2.INTER_AREA)\n+        face = numpy.expand_dims( face, 0 )\n+\n+        new_face_rgb,new_face_m = self.encoder_A( face / 255.0 )\n+\n+        if self.double_pass:\n+            #feed the original prediction back into the network for a second round.\n+            new_face_rgb = new_face_rgb.reshape((128, 128, 3))\n+            new_face_rgb = cv2.resize( new_face_rgb , (64,64))\n+            new_face_rgb = numpy.expand_dims( new_face_rgb, 0 )\n+            new_face_rgb,_ = self.encoder_A( new_face_rgb )\n+\n+        _,other_face_m = self.encoder_B( face / 255.0 ) # NOTE: we get the image from other autoencoder!\n+\n+        new_face_m = numpy.maximum(new_face_m, other_face_m )\n+\n+\n+        new_face_rgb = numpy.clip( new_face_rgb[0] * 255, 0, 255 ).astype( image.dtype )\n+        new_face_m   = numpy.clip( new_face_m[0]  , 0, 1 ).astype( float ) * numpy.ones((new_face_m.shape[0],new_face_m.shape[1],3))\n+\n+\n+        base_image = numpy.copy( image )\n+        new_image = numpy.copy( image ) \n+\n+        transmat =  mat * (64-16) *2\n+        transmat[::,2] += 8*2\n+\n+        self.adjust_avg_color(sourceFace,new_face_rgb)\n+\n+        cv2.warpAffine( new_face_rgb, transmat, image_size, new_image, cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC, cv2.BORDER_TRANSPARENT )\n+        \n+\n+        image_mask = numpy.zeros_like(new_image, dtype=float)\n+\n+\n+        cv2.warpAffine( new_face_m, transmat, image_size, image_mask, cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC, cv2.BORDER_TRANSPARENT )\n+        \n+\n+        #slightly enlarge the mask area\n+        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3))\n+        image_mask = cv2.dilate(image_mask,kernel,iterations = 1)\n+\n+        if self.seamless_clone:\n+\n+            unitMask = numpy.clip( image_mask * 365, 0, 255 ).astype(numpy.uint8)\n+\n+            maxregion = numpy.argwhere(unitMask==255)\n+\n+            if maxregion.size > 0:\n+\n+                miny,minx = maxregion.min(axis=0)[:2]\n+                maxy,maxx = maxregion.max(axis=0)[:2]\n+                lenx = maxx - minx;\n+                leny = maxy - miny;\n+                masky = int(minx+(lenx//2))\n+                maskx = int(miny+(leny//2))\n+\n+                new_image = cv2.seamlessClone(new_image.astype(numpy.uint8),base_image.astype(numpy.uint8),unitMask,(masky,maskx) , cv2.NORMAL_CLONE )\n+\n+\n+        image_mask = cv2.GaussianBlur(image_mask,(11,11),0)\n+\n+        foreground = cv2.multiply(image_mask, new_image.astype(float))\n+        background = cv2.multiply(1.0 - image_mask, base_image.astype(float))\n+        \n+        output = numpy.add(background,foreground)\n+\n+        # cv2.imshow(\"output\", output.astype(numpy.uint8) )\n+\n+        # if cv2.waitKey(1)==ord('q'):\n+        #   exit()\n+        return output\n+\n+    def adjust_avg_color(self, img_old,img_new):\n+        w,h,c = img_new.shape\n+        for i in range(img_new.shape[-1]):\n+            old_avg = img_old[:, :, i].mean()\n+            new_avg = img_new[:, :, i].mean()\n+            diff_int = (int)(old_avg - new_avg)\n+            for m in range(img_new.shape[0]):\n+                for n in range(img_new.shape[1]):\n+                    temp = (img_new[m,n,i] + diff_int)\n+                    if temp < 0:\n+                        img_new[m,n,i] = 0\n+                    elif temp > 255:\n+                        img_new[m,n,i] = 255\n+                    else:\n+                        img_new[m,n,i] = temp\n+\n+    # def transfer_avg_color(self, img_old,img_new):\n+    #     assert(img_old.shape==img_new.shape) \n+    #     source = cv2.cvtColor(img_old, cv2.COLOR_BGR2LAB).astype(\"float32\")\n+    #     target = cv2.cvtColor(img_new, cv2.COLOR_BGR2LAB).astype(\"float32\")\n+\n+    #     (lMeanSrc, lStdSrc, aMeanSrc, aStdSrc, bMeanSrc, bStdSrc) = self.image_stats(source)\n+    #     (lMeanTar, lStdTar, aMeanTar, aStdTar, bMeanTar, bStdTar) = self.image_stats(target)\n+\n+    #     (l, a, b) = cv2.split(target)\n+\n+    #     l -= lMeanTar\n+    #     a -= aMeanTar\n+    #     b -= bMeanTar\n+\n+    #     l = (lStdTar / lStdSrc) * l\n+    #     a = (aStdTar / aStdSrc) * a\n+    #     b = (bStdTar / bStdSrc) * b\n+\n+    #     l += lMeanSrc\n+    #     a += aMeanSrc\n+    #     b += bMeanSrc\n+\n+    #     l = numpy.clip(l, 0, 255)\n+    #     a = numpy.clip(a, 0, 255)\n+    #     b = numpy.clip(b, 0, 255)\n+\n+    #     transfer = cv2.merge([l, a, b])\n+    #     transfer = cv2.cvtColor(transfer.astype(\"uint8\"), cv2.COLOR_LAB2BGR)\n+\n+    #     return transfer\n+\n+    # def image_stats(self, image):\n+    #     (l, a, b) = cv2.split(image)\n+    #     (lMean, lStd) = (l.mean(), l.std())\n+    #     (aMean, aStd) = (a.mean(), a.std())\n+    #     (bMean, bStd) = (b.mean(), b.std())\n+\n+    #     return (lMean, lStd, aMean, aStd, bMean, bStd)\n+\n+# def main( args ):\n+\n+\n+#     input_dir = Path( args.input_dir )\n+#     assert input_dir.is_dir()\n+\n+#     alignments = input_dir / args.alignments\n+#     with alignments.open() as f:\n+#         alignments = json.load(f)\n+\n+#     output_dir = input_dir / args.output_dir\n+#     output_dir.mkdir( parents=True, exist_ok=True )\n+\n+#     args.direction = 'AtoB'\n+#     if args.direction == 'AtoB': autoencoder,otherautoencoder = autoencoder_B,autoencoder_A\n+#     if args.direction == 'BtoA': autoencoder,otherautoencoder = autoencoder_A,autoencoder_B\n+    \n+#     if args.blurSize % 2 == 0:\n+#       args.blurSize+=1\n+\n+#     if args.erosionKernelSize>0:\n+#       erosion_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(args.erosionKernelSize,args.erosionKernelSize))\n+#     else:\n+#       erosion_kernel = None\n+\n+#     for e in alignments:    \n+#       if len(e)<4:\n+#         raise LookupError('This script expects new format json files with face points included.')\n+\n+\n+#     for image_file, face_file, mat,facepoints in tqdm( alignments[args.startframe::args.frameSkip] ):\n+#         image = cv2.imread( str( input_dir / image_file ) )\n+#         face  = cv2.imread( str( input_dir / face_file  ) )\n+\n+\n+#         mat = numpy.array(mat).reshape(2,3)\n+\n+#         if image is None: continue\n+#         if face  is None: continue\n+\n+\n+#         new_image = convert_one_image( autoencoder, otherautoencoder, image, mat, facepoints, erosion_kernel, args.blurSize, args.seamlessClone, args.maskType, args.doublePass)\n+\n+#         output_file = output_dir / Path(image_file).name\n+#         cv2.imwrite( str(output_file), new_image )\n+\n+# def str2bool(v):\n+#   if v.lower() in ('yes', 'true', 't', 'y', '1'):\n+#     return True\n+#   elif v.lower() in ('no', 'false', 'f', 'n', '0'):\n+#     return False\n+#   else:\n+#     raise argparse.ArgumentTypeError('Boolean value expected.')\n+\n+# if __name__ == '__main__':\n+#     parser = argparse.ArgumentParser()\n+#     parser.add_argument( \"input_dir\", type=str, nargs='?' )\n+#     parser.add_argument( \"alignments\", type=str, nargs='?', default='alignments.json' )\n+#     parser.add_argument( \"output_dir\", type=str, nargs='?', default='merged' )\n+\n+#     parser.add_argument(\"--seamlessClone\", type=str2bool, nargs='?', const=False, default='False', help=\"Attempt to use opencv seamlessClone.\")\n+\n+#     parser.add_argument(\"--doublePass\", type=str2bool, nargs='?', const=False, default='False', help=\"Pass the original prediction output back through for a second pass.\")\n+\n+\n+#     parser.add_argument('--maskType', type=str, default='FaceHullAndRect' ,choices=['FaceHullAndRect','FaceHull','Rect'], help=\"The type of masking to use around the face.\")\n+\n+#     parser.add_argument( \"--startframe\",        type=int, default='0' )\n+#     parser.add_argument( \"--frameSkip\",        type=int, default='1' )\n+#     parser.add_argument( \"--blurSize\",          type=int, default='4' )\n+#     parser.add_argument( \"--erosionKernelSize\", type=int, default='2' )\n+#     parser.add_argument( \"--direction\",         type=str, default=\"AtoB\", choices=[\"AtoB\", \"BtoA\"])\n+#     main( parser.parse_args() )\n+\ndiff --git a/plugins/Model_DFaker/Model.py b/plugins/Model_DFaker/Model.py\nnew file mode 100644\nindex 0000000000..c24f92c581\n--- /dev/null\n+++ b/plugins/Model_DFaker/Model.py\n@@ -0,0 +1,173 @@\n+from keras.models import Model as KerasModel\n+from keras.layers import Input, Dense, Flatten, Reshape, Dropout, Add,Concatenate, Lambda\n+from keras.layers.advanced_activations import LeakyReLU\n+from keras.layers.convolutional import Conv2D\n+from keras.initializers import RandomNormal\n+from keras.optimizers import Adam\n+\n+from .AutoEncoder import AutoEncoder\n+from lib.PixelShuffler import PixelShuffler\n+\n+import tensorflow as tf\n+\n+from keras_contrib.losses import DSSIMObjective\n+from keras import losses\n+\n+from keras.utils import multi_gpu_model\n+import numpy\n+\n+class penalized_loss(object):\n+\n+  def __init__(self,mask,lossFunc,maskProp= 1.0):\n+    self.mask = mask\n+    self.lossFunc=lossFunc\n+    self.maskProp = maskProp\n+    self.maskaskinvProp = 1-maskProp  \n+\n+  def __call__(self,y_true, y_pred):\n+\n+    tro, tgo, tbo = tf.split(y_true,3, 3 )\n+    pro, pgo, pbo = tf.split(y_pred,3, 3 )\n+\n+    tr = tro\n+    tg = tgo\n+    tb = tbo\n+\n+    pr = pro\n+    pg = pgo\n+    pb = pbo\n+    m  = self.mask \n+\n+    m   = m*self.maskProp\n+    m  += self.maskaskinvProp\n+    tr *= m\n+    tg *= m\n+    tb *= m\n+\n+    pr *= m\n+    pg *= m\n+    pb *= m\n+\n+\n+    y = tf.concat([tr, tg, tb],3)\n+    p = tf.concat([pr, pg, pb],3)\n+\n+    #yo = tf.stack([tro,tgo,tbo],3)\n+    #po = tf.stack([pro,pgo,pbo],3)\n+\n+    return self.lossFunc(y,p)\n+\n+IMAGE_SHAPE = (64,64,3)\n+\n+ENCODER_DIM = 1024\n+conv_init = RandomNormal(0, 0.02)\n+gamma_init = RandomNormal(1., 0.02)\n+\n+def __conv_init(a):\n+    print(\"conv_init\", a)\n+    k = RandomNormal(0, 0.02)(a) # for convolution kernel\n+    k.conv_weight = True    \n+    return k\n+\n+class Model(AutoEncoder):\n+    def initModel(self):\n+        optimizer = Adam( lr=5e-5, beta_1=0.5, beta_2=0.999 )\n+\n+        # print(self.encoder.summary()) \n+        # print(self.decoder_A.summary())\n+        # print(self.decoder_B.summary())\n+\n+        x1 = Input( shape=IMAGE_SHAPE )\n+        x2 = Input( shape=IMAGE_SHAPE )\n+        m1 = Input( shape=(64*2,64*2,1) )\n+        m2 = Input( shape=(64*2,64*2,1) )\n+\n+        self.autoencoder_A = KerasModel( [x1,m1], self.decoder_A( self.encoder(x1) ) )\n+        self.autoencoder_B = KerasModel( [x2,m2], self.decoder_B( self.encoder(x2) ) )\n+\n+        # print(self.autoencoder_A.summary())\n+        # print(self.autoencoder_B.summary())\n+\n+        if self.gpus > 1:\n+            self.autoencoder_A = multi_gpu_model( self.autoencoder_A ,self.gpus)\n+            self.autoencoder_B = multi_gpu_model( self.autoencoder_B ,self.gpus)\n+\n+        # o1,om1  = self.decoder_A( self.encoder(x1))\n+        # o2,om2  = self.decoder_B( self.encoder(x2))\n+\n+        DSSIM = DSSIMObjective()\n+        self.autoencoder_A.compile( optimizer=optimizer, loss=[ penalized_loss(m1, DSSIM),'mse'] )\n+        self.autoencoder_B.compile( optimizer=optimizer, loss=[ penalized_loss(m2, DSSIM),'mse'] )\n+\n+    def converter(self, swap):\n+        zmask = numpy.zeros((1,128, 128,1),float)\n+        autoencoder = self.autoencoder_B if not swap else self.autoencoder_A \n+        return lambda img: autoencoder.predict([img, zmask])\n+\n+    # def upscale_ps(self, filters, use_norm=True):\n+    #     def block(x):\n+    #         x = Conv2D(filters*4, kernel_size=3, use_bias=False, kernel_initializer=RandomNormal(0, 0.02), padding='same' )(x)\n+    #         x = LeakyReLU(0.1)(x)\n+    #         x = PixelShuffler()(x)\n+    #         return x\n+    #     return block\n+\n+    def res_block(self, input_tensor, f):\n+        x = input_tensor\n+        x = Conv2D(f, kernel_size=3, kernel_initializer=conv_init, use_bias=False, padding=\"same\")(x)\n+        x = LeakyReLU(alpha=0.2)(x)\n+        x = Conv2D(f, kernel_size=3, kernel_initializer=conv_init, use_bias=False, padding=\"same\")(x)\n+        x = Add()([x, input_tensor])\n+        x = LeakyReLU(alpha=0.2)(x)\n+        return x\n+\n+    def conv( self, filters ):\n+        def block(x):\n+            x = Conv2D( filters, kernel_size=5, strides=2, padding='same' )(x)\n+            x = LeakyReLU(0.1)(x)\n+            return x\n+        return block\n+\n+    def upscale( self, filters ):\n+        def block(x):\n+            x = Conv2D( filters*4, kernel_size=3, padding='same' )(x)\n+            x = LeakyReLU(0.1)(x)\n+            x = PixelShuffler()(x)\n+            return x\n+        return block\n+\n+    def Encoder(self):\n+        input_ = Input( shape=IMAGE_SHAPE )\n+        x = self.conv( 128)(input_)\n+        x = self.conv( 256)(x)\n+        x = self.conv( 512)(x)\n+\n+        x = self.conv(1024)(x)\n+        x = Dense( ENCODER_DIM )( Flatten()(x) )\n+        x = Dense(4*4*1024)(x)\n+        x = Reshape((4,4,1024))(x)\n+        x = self.upscale(512)(x)\n+        return KerasModel( input_, [x] )\n+\n+    def Decoder(self, name):\n+        input_ = Input( shape=(8,8,512) )\n+        #skip_in = Input( shape=(8,8,512) )\n+\n+        x = input_\n+        x = self.upscale(512)(x)\n+        x = self.res_block(x, 512)\n+        x = self.upscale(256)(x)\n+        x = self.res_block(x, 256)\n+        x = self.upscale(128)(x)\n+        x = self.res_block(x, 128)\n+        x = self.upscale(64)(x)\n+        x = Conv2D( 3, kernel_size=5, padding='same', activation='sigmoid' )(x)\n+\n+        y = input_\n+        y = self.upscale(512)(y)\n+        y = self.upscale(256)(y)\n+        y = self.upscale(128)(y)\n+        y = self.upscale(64)(y)\n+        y = Conv2D( 1, kernel_size=5, padding='same', activation='sigmoid' )(y)\n+\n+        return KerasModel( [input_], outputs=[x,y] )\ndiff --git a/plugins/Model_DFaker/Trainer.py b/plugins/Model_DFaker/Trainer.py\nnew file mode 100644\nindex 0000000000..ea5927eedf\n--- /dev/null\n+++ b/plugins/Model_DFaker/Trainer.py\n@@ -0,0 +1,143 @@\n+import cv2\r\n+import time\r\n+import numpy\r\n+import random\r\n+\r\n+from lib.utils import BackgroundGenerator\r\n+from lib.training_data import TrainingDataGenerator, stack_images\r\n+from .image_augmentation import random_transform, random_warp_src_dest\r\n+from .utils import load_images_aligned\r\n+\r\n+class DFTrainingDataGenerator(TrainingDataGenerator):\r\n+    def __init__(self, random_transform_args, coverage):\r\n+        super().__init__(random_transform_args, coverage)\r\n+\r\n+    def minibatchAB(self, images, srcPoints, dstPoints, batch_size ):\r\n+        batch = BackgroundGenerator(self.minibatch(images, srcPoints, dstPoints, batch_size), 1)\r\n+        return batch.iterator()\r\n+\r\n+    def minibatch(self, images, srcPoints, dstPoints, batch_size):\r\n+        epoch = 0\r\n+        while True:\r\n+            epoch+=1\r\n+            indices = numpy.random.choice(range(0,images.shape[0]),size=batch_size,replace=False)\r\n+            for i,index in enumerate(indices):\r\n+                image = images[index]\r\n+                image = random_transform( image, **self.random_transform_args )\r\n+\r\n+                closest = ( numpy.mean(numpy.square(srcPoints[index]-dstPoints),axis=(1,2)) ).argsort()[:10]\r\n+                closest = numpy.random.choice(closest)\r\n+                warped_img, target_img, mask_image = random_warp_src_dest( image,srcPoints[index],dstPoints[ closest ] )\r\n+        \r\n+                if numpy.random.random() < 0.5:\r\n+                    warped_img = warped_img[:,::-1]\r\n+                    target_img = target_img[:,::-1]\r\n+                    mask_image = mask_image[:,::-1]\r\n+\r\n+                if i == 0:\r\n+                    warped_images = numpy.empty( (batch_size,) + warped_img.shape, warped_img.dtype )\r\n+                    target_images = numpy.empty( (batch_size,) + target_img.shape, warped_img.dtype )\r\n+                    mask_images = numpy.empty( (batch_size,)   + mask_image.shape, mask_image.dtype )\r\n+\r\n+                warped_images[i] = warped_img\r\n+                target_images[i] = target_img\r\n+                mask_images[i]   = mask_image\r\n+\r\n+            yield epoch, warped_images, target_images, mask_images\r\n+\r\n+class Trainer():\r\n+    random_transform_args = {\r\n+        'rotation_range': 10,\r\n+        'zoom_range': 0.05,\r\n+        'shift_range': 0.05,\r\n+        'random_flip': 0.0,\r\n+        }\r\n+\r\n+    def __init__(self, model, fn_A, fn_B, batch_size, *args):\r\n+        self.batch_size = batch_size\r\n+        self.model = model\r\n+\r\n+        generator = DFTrainingDataGenerator(self.random_transform_args, 160)\r\n+        \r\n+        minImages = 2000#min(len(fn_A),len(fn_B))*20\r\n+\r\n+        random.shuffle(fn_A)\r\n+        random.shuffle(fn_B)\r\n+\r\n+        #NOTE this loads all images so it may be memory intensive! (cumber of images is maxed to 'minImages')\r\n+        images_A, landmarks_A = load_images_aligned(fn_A[:minImages])\r\n+        images_B, landmarks_B = load_images_aligned(fn_B[:minImages])\r\n+\r\n+        images_A = images_A/255.0\r\n+        images_B = images_B/255.0\r\n+\r\n+        images_A[:,:,:3] += images_B[:,:,:3].mean( axis=(0,1,2) ) - images_A[:,:,:3].mean( axis=(0,1,2) )\r\n+\r\n+        self.images_A = generator.minibatchAB(images_A, landmarks_A, landmarks_B, self.batch_size)\r\n+        self.images_B = generator.minibatchAB(images_B, landmarks_B, landmarks_A, self.batch_size)\r\n+\r\n+    def train_one_step(self, iter, viewer):\r\n+        epoch, warped_A, target_A, mask_A = next(self.images_A)\r\n+        epoch, warped_B, target_B, mask_B = next(self.images_B)\r\n+      \r\n+        #omask = numpy.ones((target_A.shape[0],64,64,1),float)\r\n+\r\n+        loss_A = self.model.autoencoder_A.train_on_batch([warped_A,mask_A], [target_A,mask_A])\r\n+        loss_B = self.model.autoencoder_B.train_on_batch([warped_B,mask_B], [target_B,mask_B])\r\n+\r\n+        print(\"Loss A [{}] Loss B [{}]\".format(loss_A,loss_B),\r\n+            end='\\r')\r\n+\r\n+        if viewer is not None:\r\n+            viewer(self.show_sample(target_A[0:8,:,:,:3], target_B[0:8,:,:,:3]), \"training\")\r\n+            viewer(self.show_warped(warped_A[:6],warped_B[:6]), \"warped\")\r\n+\r\n+    def show_warped(self, warped_A, warped_B):\r\n+        figWarped = numpy.stack([warped_A, warped_B],axis=0 )\r\n+        figWarped = numpy.clip( figWarped * 255, 0, 255 ).astype('uint8')\r\n+        figWarped = stack_images( figWarped )\r\n+        return figWarped\r\n+\r\n+    def show_sample(self, test_A, test_B):\r\n+        test_A_i = []\r\n+        test_B_i = []\r\n+        \r\n+        for i in test_A:\r\n+            test_A_i.append(cv2.resize(i,(64,64),cv2.INTER_AREA))\r\n+        test_A_i = numpy.array(test_A_i).reshape((-1,64,64,3))\r\n+\r\n+        for i in test_B:\r\n+            test_B_i.append(cv2.resize(i,(64,64),cv2.INTER_AREA))\r\n+        test_B_i = numpy.array(test_B_i).reshape((-1,64,64,3))\r\n+        \r\n+        zmask = numpy.zeros((test_A.shape[0],128,128,1),float)\r\n+\r\n+        pred_a_a,pred_a_a_m = self.model.autoencoder_A.predict([test_A_i,zmask])\r\n+        pred_b_a,pred_b_a_m = self.model.autoencoder_B.predict([test_A_i,zmask])\r\n+\r\n+        pred_a_b,pred_a_b_m = self.model.autoencoder_A.predict([test_B_i,zmask])\r\n+        pred_b_b,pred_b_b_m = self.model.autoencoder_B.predict([test_B_i,zmask])\r\n+\r\n+        pred_a_a = pred_a_a[0:18,:,:,:3]\r\n+        pred_a_b = pred_a_b[0:18,:,:,:3]\r\n+        pred_b_a = pred_b_a[0:18,:,:,:3]\r\n+        pred_b_b = pred_b_b[0:18,:,:,:3]\r\n+\r\n+        figure_A = numpy.stack([\r\n+            test_A,\r\n+            pred_a_a,\r\n+            pred_b_a,\r\n+            ], axis=1 )\r\n+        figure_B = numpy.stack([\r\n+            test_B,\r\n+            pred_b_b,\r\n+            pred_a_b,\r\n+            ], axis=1 )\r\n+\r\n+\r\n+        figure = numpy.concatenate( [ figure_A, figure_B ], axis=0 )\r\n+        figure = figure.reshape( (4,4) + figure.shape[1:] )\r\n+        figure = stack_images( figure )\r\n+\r\n+        return numpy.clip( figure * 255, 0, 255 ).astype('uint8')\r\n+\r\ndiff --git a/plugins/Model_DFaker/image_augmentation.py b/plugins/Model_DFaker/image_augmentation.py\nnew file mode 100644\nindex 0000000000..636ce65876\n--- /dev/null\n+++ b/plugins/Model_DFaker/image_augmentation.py\n@@ -0,0 +1,106 @@\n+import cv2\n+import numpy\n+\n+from lib.umeyama import umeyama\n+\n+def random_transform( image, rotation_range, zoom_range, shift_range, random_flip ):\n+    h,w = image.shape[0:2]\n+    rotation = numpy.random.uniform( -rotation_range, rotation_range )\n+    scale = numpy.random.uniform( 1 - zoom_range, 1 + zoom_range )\n+    tx = numpy.random.uniform( -shift_range, shift_range ) * w\n+    ty = numpy.random.uniform( -shift_range, shift_range ) * h\n+    mat = cv2.getRotationMatrix2D( (w//2,h//2), rotation, scale )\n+    mat[:,2] += (tx,ty)\n+    result = cv2.warpAffine( image, mat, (w,h), borderMode=cv2.BORDER_REPLICATE )\n+    if numpy.random.random() < random_flip:\n+        result = result[:,::-1]\n+    return result\n+\n+maskColour = numpy.array([127,127,127])/255.0\n+\n+\n+from scipy.interpolate import griddata\n+\n+\n+grid_x, grid_y = numpy.mgrid[0:255:256j, 0:255:256j]\n+edgeAnchors = [ (0,0), (0,255), (255,255), (255,0), (127,0), (127,255), (255,127), (0,127) ]\n+\n+def random_warp_src_dest( in_image,srcPoints,destPoints ):\n+\n+  source = srcPoints\n+  destination = (destPoints.copy().astype('float')+numpy.random.normal( size=(destPoints.shape), scale= 2 ))\n+  destination = destination.astype('uint8')\n+\n+  faceCore =cv2.convexHull( numpy.concatenate([source[17:],destination[17:]], axis=0).astype(int) )\n+\n+  source = [(y,x) for x,y in source]+edgeAnchors\n+  destination = [(y,x) for x,y in destination]+edgeAnchors\n+\n+\n+  indeciesToRemove = set()\n+  for fpl in source,destination:\n+    for i,(y,x) in enumerate(fpl):\n+      if i>17:\n+        break\n+      elif cv2.pointPolygonTest(faceCore,(y,x),False) >= 0:\n+        indeciesToRemove.add(i)\n+\n+  for i in sorted(indeciesToRemove,reverse=True):\n+    source.pop(i)\n+    destination.pop(i)\n+\n+  grid_z = griddata( destination,source, (grid_x, grid_y), method='linear')\n+  map_x = numpy.append([], [ar[:,1] for ar in grid_z]).reshape(256,256)\n+  map_y = numpy.append([], [ar[:,0] for ar in grid_z]).reshape(256,256)\n+  map_x_32 = map_x.astype('float32')\n+  map_y_32 = map_y.astype('float32')\n+\n+  warped = cv2.remap(in_image[:,:,:3], map_x_32, map_y_32, cv2.INTER_LINEAR,cv2.BORDER_TRANSPARENT )\n+\n+  target_mask = in_image[:,:,3].reshape((256,256,1))\n+  target_image = in_image[:,:,:3]\n+\n+  warped       = cv2.resize( warped[ 128-120:128+120,128-120:128+120,:]         ,(64,64),cv2.INTER_AREA)\n+  target_image = cv2.resize( target_image[ 128-120:128+120,128-120:128+120,: ]  ,(64*2,64*2),cv2.INTER_AREA)\n+  target_mask  = cv2.resize( target_mask[ 128-120:128+120,128-120:128+120,: ]   ,(64*2,64*2),cv2.INTER_AREA).reshape((64*2,64*2,1))\n+\n+  return warped,target_image,target_mask\n+\n+# # get pair of random warped images from aligened face image\n+# def random_warp( in_image ):\n+#     assert in_image.shape[:2] == (256,256)\n+\n+#     image = in_image.copy()\n+\n+\n+#     scale = 5\n+\n+#     range_ = numpy.linspace( 128-120, 128+120, scale )\n+#     mapx = numpy.broadcast_to( range_, (scale,scale) )\n+#     mapy = mapx.T\n+\n+#     mapx = mapx + numpy.random.normal( size=(scale,scale), scale= 6 )\n+#     mapy = mapy + numpy.random.normal( size=(scale,scale), scale= 6 )\n+\n+#     interp_mapx = cv2.resize( mapx, (80,80) )[8:72,8:72].astype('float32')\n+#     interp_mapy = cv2.resize( mapy, (80,80) )[8:72,8:72].astype('float32')\n+\n+#     warped_image = cv2.remap( image[:,:,:3], interp_mapx, interp_mapy, cv2.INTER_CUBIC )\n+\n+#     src_points = numpy.stack( [ mapx.ravel(), mapy.ravel() ], axis=-1 )\n+#     dst_points = numpy.mgrid[0:65:16,0:65:16].T.reshape(-1,2)\n+#     mat = umeyama( src_points, dst_points, True )[0:2]\n+\n+#     target_image = cv2.warpAffine( image, mat, (64,64) )\n+\n+#     target_mask = target_image[:,:,3].reshape((64,64,1))\n+#     target_image = target_image[:,:,:3]\n+\n+\n+#     if len(target_image.shape)>2:\n+#       return ( warped_image, \n+#                target_image, \n+#                target_mask )\n+#     else:\n+#       return ( warped_image, \n+#                target_image )\n\\ No newline at end of file\ndiff --git a/plugins/Model_DFaker/utils.py b/plugins/Model_DFaker/utils.py\nnew file mode 100644\nindex 0000000000..016c234ab0\n--- /dev/null\n+++ b/plugins/Model_DFaker/utils.py\n@@ -0,0 +1,62 @@\n+import cv2\n+import numpy\n+import os\n+import json\n+\n+from lib.faces_detect import DetectedFace\n+\n+from tqdm import tqdm\n+from lib.aligner import get_align_mat\n+#guideShades = numpy.linspace(20,250,68)\n+\n+def load_images_aligned(image_paths):\n+  basePath = os.path.split(image_paths[0])[0]\n+  alignments = os.path.join(basePath,'alignments.json')\n+  alignments = json.loads( open(alignments).read() )\n+\n+  all_images    = []\n+  landmarks     = []\n+\n+\n+  pbar = tqdm(alignments)\n+  for original in pbar:\n+    faces = alignments[original]\n+    for rawface in faces:\n+        detected_face = DetectedFace(**rawface)\n+        cropped = detected_face.cropped\n+        points = detected_face.landmarksXY\n+        mat = get_align_mat( detected_face, 0, False )\n+        if os.path.exists(cropped):\n+            image, facepoints = load_image( cropped, mat, points )\n+            all_images.append( image  )\n+            landmarks.append( facepoints )\n+\n+  return numpy.array(all_images),numpy.array(landmarks)\n+\n+def load_image(cropped, mat, points):\n+    cropped = cv2.imread(cropped).astype(float)\n+\n+    mat = numpy.array(mat).reshape(2,3)\n+    points = numpy.array(points).reshape((-1,2))\n+\n+    mat = mat*160\n+    mat[:,2] += 42\n+\n+    facepoints = numpy.array( points ).reshape((-1,2))\n+\n+    mask = numpy.zeros_like(cropped,dtype=numpy.uint8)\n+\n+    hull = cv2.convexHull( facepoints.astype(int) )\n+    hull = cv2.transform( hull.reshape(1,-1,2) , mat).reshape(-1,2).astype(int)\n+\n+    cv2.fillConvexPoly( mask,hull,(255,255,255) )\n+\n+    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(15,15))\n+\n+    mask = cv2.dilate(mask,kernel,iterations = 1,borderType=cv2.BORDER_REFLECT )\n+\n+    facepoints = cv2.transform( numpy.array( points ).reshape((1,-1,2)) , mat).reshape(-1,2).astype(int)\n+\n+    mask = mask[:,:,0]\n+\n+    return numpy.dstack([cropped,mask]).astype(numpy.uint8), facepoints\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "You're running into multiple issues while training. First, the `ModuleNotFoundError` for `keras_contrib` suggests a missing dependency. Ensure that this package is installed as it's critical. The syntax error in `Trainer.py` indicates a missing colon in the `show_warped` method; fix it to resolve that issue. \n\nRegarding the OOM errors during extraction, it seems that the resize code might have been removed, leading to a lack of memory management compared to the master branch. Lastly, check why the alignment files are not found; it seems essential for training."
      }
    ],
    "token_estimation": 7177.0
  },
  {
    "index": 97,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/plugins/ConvertVideo_BoundingBox.py b/plugins/ConvertVideo_BoundingBox.py\nnew file mode 100644\nindex 0000000000..1b014563d6\n--- /dev/null\n+++ b/plugins/ConvertVideo_BoundingBox.py\n@@ -0,0 +1,133 @@\n+# Based on the https://github.com/shaoanlu/faceswap-GAN repo (master/FaceSwap_GAN_v2_train.ipynb)\r\n+\r\n+# # 12. Make video clips\r\n+# \r\n+# Given a video as input, the following cells will detect face for each frame using dlib's cnn model. And use trained GAN model to transform detected face into target face. Then output a video with swapped faces.\r\n+\r\n+# Download ffmpeg if need, which is required by moviepy.\r\n+\r\n+#import imageio\r\n+#imageio.plugins.ffmpeg.download()\r\n+\r\n+# # 13. Make video clips w/o face alignment\r\n+\r\n+\r\n+import face_recognition\r\n+from moviepy.editor import VideoFileClip\r\n+\r\n+use_smoothed_mask = True\r\n+use_smoothed_bbox = True\r\n+\r\n+def get_smoothed_coord(x0, x1, y0, y1):\r\n+    global prev_x0, prev_x1, prev_y0, prev_y1\r\n+    x0 = int(0.65*prev_x0 + 0.35*x0)\r\n+    x1 = int(0.65*prev_x1 + 0.35*x1)\r\n+    y1 = int(0.65*prev_y1 + 0.35*y1)\r\n+    y0 = int(0.65*prev_y0 + 0.35*y0)\r\n+    return x0, x1, y0, y1    \r\n+    \r\n+def set_global_coord(x0, x1, y0, y1):\r\n+    global prev_x0, prev_x1, prev_y0, prev_y1\r\n+    prev_x0 = x0\r\n+    prev_x1 = x1\r\n+    prev_y1 = y1\r\n+    prev_y0 = y0\r\n+\r\n+def process_video(input_img):   \r\n+    # modify this line to reduce input size\r\n+    #input_img = input_img[:, input_img.shape[1]//3:2*input_img.shape[1]//3,:] \r\n+    image = input_img\r\n+    faces = face_recognition.face_locations(image, model=\"cnn\")\r\n+    \r\n+    if len(faces) == 0:\r\n+        comb_img = np.zeros([input_img.shape[0], input_img.shape[1]*2,input_img.shape[2]])\r\n+        comb_img[:, :input_img.shape[1], :] = input_img\r\n+        comb_img[:, input_img.shape[1]:, :] = input_img\r\n+        triple_img = np.zeros([input_img.shape[0], input_img.shape[1]*3,input_img.shape[2]])\r\n+        triple_img[:, :input_img.shape[1], :] = input_img\r\n+        triple_img[:, input_img.shape[1]:input_img.shape[1]*2, :] = input_img      \r\n+        triple_img[:, input_img.shape[1]*2:, :] = (input_img * .15).astype('uint8')\r\n+    \r\n+    mask_map = np.zeros_like(image)\r\n+    \r\n+    global prev_x0, prev_x1, prev_y0, prev_y1\r\n+    global frames    \r\n+    for (x0, y1, x1, y0) in faces:\r\n+        h = x1 - x0\r\n+        w = y1 - y0\r\n+        \r\n+        # smoothing bounding box\r\n+        if use_smoothed_bbox:\r\n+            if frames != 0:\r\n+                x0, x1, y0, y1 = get_smoothed_coord(x0, x1, y0, y1)\r\n+                set_global_coord(x0, x1, y0, y1)\r\n+            else:\r\n+                set_global_coord(x0, x1, y0, y1)\r\n+                frames += 1\r\n+            \r\n+        cv2_img = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)\r\n+        roi_image = cv2_img[x0+h//15:x1-h//15,y0+w//15:y1-w//15,:]\r\n+        roi_size = roi_image.shape  \r\n+        \r\n+        # smoothing mask\r\n+        if use_smoothed_mask:\r\n+            mask = np.zeros_like(roi_image)\r\n+            mask[h//15:-h//15,w//15:-w//15,:] = 255\r\n+            mask = cv2.GaussianBlur(mask,(15,15),10)\r\n+            orig_img = cv2.cvtColor(roi_image, cv2.COLOR_BGR2RGB)\r\n+        \r\n+        ae_input = cv2.resize(roi_image, (64,64))/255. * 2 - 1        \r\n+        result = np.squeeze(np.array([path_abgr_A([[ae_input]])])) # Change path_A/path_B here\r\n+        result_a = result[:,:,0] * 255\r\n+        result_bgr = np.clip( (result[:,:,1:] + 1) * 255 / 2, 0, 255 )\r\n+        result_a = cv2.GaussianBlur(result_a ,(7,7),6)\r\n+        result_a = np.expand_dims(result_a, axis=2)\r\n+        result = (result_a/255 * result_bgr + (1 - result_a/255) * ((ae_input + 1) * 255 / 2)).astype('uint8')\r\n+        result = cv2.cvtColor(result, cv2.COLOR_BGR2RGB)\r\n+        \r\n+        mask_map[x0+h//15:x1-h//15, y0+w//15:y1-w//15,:] = np.expand_dims(cv2.resize(result_a, (roi_size[1],roi_size[0])), axis=2)\r\n+        mask_map = np.clip(mask_map + .15 * input_img, 0, 255 )\r\n+        \r\n+        result = cv2.resize(result, (roi_size[1],roi_size[0]))\r\n+        comb_img = np.zeros([input_img.shape[0], input_img.shape[1]*2,input_img.shape[2]])\r\n+        comb_img[:, :input_img.shape[1], :] = input_img\r\n+        comb_img[:, input_img.shape[1]:, :] = input_img\r\n+        \r\n+        if use_smoothed_mask:\r\n+            comb_img[x0+h//15:x1-h//15, input_img.shape[1]+y0+w//15:input_img.shape[1]+y1-w//15,:] = mask/255*result + (1-mask/255)*orig_img\r\n+        else:\r\n+            comb_img[x0+h//15:x1-h//15, input_img.shape[1]+y0+w//15:input_img.shape[1]+y1-w//15,:] = result\r\n+            \r\n+        triple_img = np.zeros([input_img.shape[0], input_img.shape[1]*3,input_img.shape[2]])\r\n+        triple_img[:, :input_img.shape[1]*2, :] = comb_img\r\n+        triple_img[:, input_img.shape[1]*2:, :] = mask_map\r\n+    \r\n+    # ========== Change rthe following line to ==========\r\n+    # return comb_img[:, input_img.shape[1]:, :]  # return only result image\r\n+    # return comb_img  # return input and result image combined as one\r\n+    return triple_img #return input,result and mask heatmap image combined as one\r\n+\r\n+\r\n+# In[ ]:\r\n+\r\n+\r\n+# Variables for smoothing bounding box\r\n+global prev_x0, prev_x1, prev_y0, prev_y1\r\n+global frames\r\n+prev_x0 = prev_x1 = prev_y0 = prev_y1 = 0\r\n+frames = 0\r\n+\r\n+output = 'OUTPUT_VIDEO.mp4'\r\n+clip1 = VideoFileClip(\"INPUT_VIDEO.mp4\")\r\n+clip = clip1.fl_image(process_video)#.subclip(11, 13) #NOTE: this function expects color images!!\r\n+get_ipython().run_line_magic('time', 'clip.write_videofile(output, audio=False)')\r\n+\r\n+\r\n+# ### gc.collect() sometimes solves memory error\r\n+\r\n+# In[103]:\r\n+\r\n+\r\n+import gc\r\n+gc.collect()\r\n+\r\ndiff --git a/plugins/Model_GAN/Model.py b/plugins/Model_GAN/Model.py\nnew file mode 100644\nindex 0000000000..df86693b72\n--- /dev/null\n+++ b/plugins/Model_GAN/Model.py\n@@ -0,0 +1,178 @@\n+# Based on the https://github.com/shaoanlu/faceswap-GAN repo (master/temp/faceswap_GAN_keras.ipynb)\r\n+\r\n+from keras.models import Model\r\n+from keras.layers import *\r\n+from keras.layers.advanced_activations import LeakyReLU\r\n+from keras.activations import relu\r\n+from keras.initializers import RandomNormal\r\n+from keras.applications import *\r\n+from keras.optimizers import Adam\r\n+\r\n+from lib.PixelShuffler import PixelShuffler\r\n+\r\n+netGAH5 = '/netGA_GAN.h5'\r\n+netGBH5 = '/netGB_GAN.h5'\r\n+netDAH5 = '/netDA_GAN.h5'\r\n+netDBH5 = '/netDB_GAN.h5'\r\n+\r\n+class GANModel():\r\n+    img_size = 64 \r\n+    channels = 3\r\n+    img_shape = (img_size, img_size, channels)\r\n+    encoded_dim = 1024\r\n+    \r\n+    def __init__(self, model_dir):\r\n+        self.model_dir = model_dir\r\n+\r\n+        optimizer = Adam(1e-4, 0.5)\r\n+\r\n+        # Build and compile the discriminator\r\n+        self.netDA, self.netDB = self.build_discriminator()\r\n+        self.netDA.compile(loss='mse', optimizer=optimizer, metrics=['accuracy'])\r\n+        self.netDB.compile(loss='mse', optimizer=optimizer, metrics=['accuracy'])\r\n+\r\n+        # Build and compile the generator\r\n+        self.netGA, self.netGB = self.build_generator()\r\n+        self.netGA.compile(loss=['mae', 'mse'], optimizer=optimizer)\r\n+        self.netGB.compile(loss=['mae', 'mse'], optimizer=optimizer)\r\n+\r\n+        img = Input(shape=self.img_shape)\r\n+        alphaA, reconstructed_imgA = self.netGA(img)\r\n+        alphaB, reconstructed_imgB = self.netGB(img)\r\n+\r\n+        # For the adversarial_autoencoder model we will only train the generator\r\n+        self.netDA.trainable = False\r\n+        self.netDB.trainable = False\r\n+\r\n+        def one_minus(x): return 1 - x\r\n+        # masked_img = alpha * reconstructed_img + (1 - alpha) * img\r\n+        masked_imgA = add([multiply([alphaA, reconstructed_imgA]), multiply([Lambda(one_minus)(alphaA), img])])\r\n+        masked_imgB = add([multiply([alphaB, reconstructed_imgB]), multiply([Lambda(one_minus)(alphaB), img])])\r\n+        out_discriminatorA = self.netDA(concatenate([masked_imgA, img], axis=-1))\r\n+        out_discriminatorB = self.netDB(concatenate([masked_imgB, img], axis=-1))\r\n+\r\n+        # The adversarial_autoencoder model  (stacked generator and discriminator) takes\r\n+        # img as input => generates encoded represenation and reconstructed image => determines validity \r\n+        self.adversarial_autoencoderA = Model(img, [reconstructed_imgA, out_discriminatorA])\r\n+        self.adversarial_autoencoderB = Model(img, [reconstructed_imgB, out_discriminatorB])\r\n+        self.adversarial_autoencoderA.compile(loss=['mae', 'mse'],\r\n+                                              loss_weights=[1, 0.5],\r\n+                                              optimizer=optimizer)\r\n+        self.adversarial_autoencoderB.compile(loss=['mae', 'mse'],\r\n+                                              loss_weights=[1, 0.5],\r\n+                                              optimizer=optimizer)\r\n+\r\n+    def converter(self, swap):\r\n+        predictor = self.netGB if not swap else self.netGA\r\n+        return lambda img: predictor.predict(img)[1] #Warning! GAN converter returns an image + a mask TODO handle mask in convert!\r\n+\r\n+    def build_generator(self):\r\n+        def conv_block(input_tensor, f):\r\n+            x = input_tensor\r\n+            x = Conv2D(f, kernel_size=3, strides=2, kernel_initializer=RandomNormal(0, 0.02), \r\n+                       use_bias=False, padding=\"same\")(x)\r\n+            x = LeakyReLU(alpha=0.2)(x)\r\n+            return x\r\n+\r\n+        def res_block(input_tensor, f):\r\n+            x = input_tensor\r\n+            x = Conv2D(f, kernel_size=3, kernel_initializer=RandomNormal(0, 0.02), \r\n+                       use_bias=False, padding=\"same\")(x)\r\n+            x = LeakyReLU(alpha=0.2)(x)\r\n+            x = Conv2D(f, kernel_size=3, kernel_initializer=RandomNormal(0, 0.02), \r\n+                       use_bias=False, padding=\"same\")(x)\r\n+            x = add([x, input_tensor])\r\n+            x = LeakyReLU(alpha=0.2)(x)\r\n+            return x\r\n+\r\n+        def upscale_ps(filters, use_norm=True):\r\n+            def block(x):\r\n+                x = Conv2D(filters*4, kernel_size=3, use_bias=False, \r\n+                           kernel_initializer=RandomNormal(0, 0.02), padding='same' )(x)\r\n+                x = LeakyReLU(0.1)(x)\r\n+                x = PixelShuffler()(x)\r\n+                return x\r\n+            return block\r\n+\r\n+        def Encoder(img_shape):\r\n+            inp = Input(shape=img_shape)\r\n+            x = Conv2D(64, kernel_size=5, kernel_initializer=RandomNormal(0, 0.02), \r\n+                       use_bias=False, padding=\"same\")(inp)\r\n+            x = conv_block(x,128)\r\n+            x = conv_block(x,256)\r\n+            x = conv_block(x,512) \r\n+            x = conv_block(x,1024)\r\n+            x = Dense(1024)(Flatten()(x))\r\n+            x = Dense(4*4*1024)(x)\r\n+            x = Reshape((4, 4, 1024))(x)\r\n+            out = upscale_ps(512)(x)\r\n+            return Model(inputs=inp, outputs=out)\r\n+\r\n+        def Decoder_ps(img_shape):\r\n+            nc_in = 512\r\n+            input_size = img_shape[0]//8\r\n+            inp = Input(shape=(input_size, input_size, nc_in))\r\n+            x = inp\r\n+            x = upscale_ps(256)(x)\r\n+            x = upscale_ps(128)(x)\r\n+            x = upscale_ps(64)(x)\r\n+            x = res_block(x, 64)\r\n+            x = res_block(x, 64)\r\n+            alpha = Conv2D(1, kernel_size=5, padding='same', activation=\"sigmoid\")(x)\r\n+            rgb = Conv2D(3, kernel_size=5, padding='same', activation=\"tanh\")(x)\r\n+            return Model(inp, [alpha, rgb])\r\n+        \r\n+        encoder = Encoder(self.img_shape)\r\n+        decoder_A = Decoder_ps(self.img_shape)\r\n+        decoder_B = Decoder_ps(self.img_shape)    \r\n+        x = Input(shape=self.img_shape)\r\n+        netGA = Model(x, decoder_A(encoder(x)))\r\n+        netGB = Model(x, decoder_B(encoder(x)))           \r\n+        try:\r\n+            netGA.load_weights(self.model_dir + netGAH5)\r\n+            netGB.load_weights(self.model_dir + netGBH5)\r\n+            print (\"Generator models loaded.\")\r\n+        except:\r\n+            print (\"Generator weights files not found.\")\r\n+            pass\r\n+        return netGA, netGB, \r\n+\r\n+    def build_discriminator(self):  \r\n+        def conv_block_d(input_tensor, f, use_instance_norm=True):\r\n+            x = input_tensor\r\n+            x = Conv2D(f, kernel_size=4, strides=2, kernel_initializer=RandomNormal(0, 0.02), \r\n+                       use_bias=False, padding=\"same\")(x)\r\n+            x = LeakyReLU(alpha=0.2)(x)\r\n+            return x   \r\n+        def Discriminator(img_shape):\r\n+            inp = Input(shape=(img_shape[0], img_shape[1], img_shape[2]*2))\r\n+            x = conv_block_d(inp, 64, False)\r\n+            x = conv_block_d(x, 128, False)\r\n+            x = conv_block_d(x, 256, False)\r\n+            out = Conv2D(1, kernel_size=4, kernel_initializer=RandomNormal(0, 0.02), \r\n+                         use_bias=False, padding=\"same\", activation=\"sigmoid\")(x)   \r\n+            return Model(inputs=[inp], outputs=out) \r\n+        \r\n+        netDA = Discriminator(self.img_shape)\r\n+        netDB = Discriminator(self.img_shape)        \r\n+        try:\r\n+            netDA.load_weights(self.model_dir + netDAH5) \r\n+            netDB.load_weights(self.model_dir + netDBH5) \r\n+            print (\"Discriminator models loaded.\")\r\n+        except:\r\n+            print (\"Discriminator weights files not found.\")\r\n+            pass\r\n+        return netDA, netDB    \r\n+    \r\n+    def load(self, swapped):\r\n+        if swapped:\r\n+            print(\"swapping not supported on GAN\")\r\n+            # TODO load is done in __init__ => look how to swap if possible\r\n+        return True\r\n+    \r\n+    def save_weights(self):\r\n+        self.netGA.save_weights(self.model_dir + netGAH5)\r\n+        self.netGB.save_weights(self.model_dir + netGBH5)\r\n+        self.netDA.save_weights(self.model_dir + netDAH5)\r\n+        self.netDB.save_weights(self.model_dir + netDBH5)\r\n+        print (\"Models saved.\")\n\\ No newline at end of file\ndiff --git a/plugins/Model_GAN/Trainer.py b/plugins/Model_GAN/Trainer.py\nnew file mode 100644\nindex 0000000000..190c6f37ef\n--- /dev/null\n+++ b/plugins/Model_GAN/Trainer.py\n@@ -0,0 +1,142 @@\n+import time\r\n+import cv2\r\n+import numpy as np\r\n+\r\n+from lib.training_data import minibatchAB, stack_images\r\n+\r\n+class Trainer():\r\n+    random_transform_args = {\r\n+        'rotation_range': 20,\r\n+        'zoom_range': 0.05,\r\n+        'shift_range': 0.05,\r\n+        'random_flip': 0.5,\r\n+        }\r\n+    def __init__(self, model, fn_A, fn_B, batch_size=8):\r\n+        assert batch_size % 2 == 0, \"batch_size must be an even number\"\r\n+        self.model = model\r\n+        self.train_batchA = minibatchAB(fn_A, batch_size, self.random_transform_args)\r\n+        self.train_batchB = minibatchAB(fn_B, batch_size, self.random_transform_args)\r\n+        self.batch_size = batch_size\r\n+        \r\n+        self.use_mixup = True\r\n+        self.mixup_alpha = 0.2\r\n+    \r\n+    def train_one_step(self, iter, viewer):\r\n+        # ---------------------\r\n+        #  Train Discriminators\r\n+        # ---------------------\r\n+\r\n+        # Select a random half batch of images\r\n+        epoch, warped_A, target_A = next(self.train_batchA) \r\n+        epoch, warped_B, target_B = next(self.train_batchB) \r\n+\r\n+        # Generate a half batch of new images\r\n+        gen_alphasA, gen_imgsA = self.model.netGA.predict(warped_A)\r\n+        gen_alphasB, gen_imgsB = self.model.netGB.predict(warped_B)\r\n+        #gen_masked_imgsA = gen_alphasA * gen_imgsA + (1 - gen_alphasA) * warped_A\r\n+        #gen_masked_imgsB = gen_alphasB * gen_imgsB + (1 - gen_alphasB) * warped_B\r\n+        gen_masked_imgsA = np.array([gen_alphasA[i] * gen_imgsA[i] + (1 - gen_alphasA[i]) * warped_A[i] \r\n+                                     for i in range(self.batch_size)])\r\n+        gen_masked_imgsB = np.array([gen_alphasB[i] * gen_imgsB[i] + (1 - gen_alphasB[i]) * warped_B[i]\r\n+                                     for i in range (self.batch_size)])\r\n+\r\n+        valid = np.ones((self.batch_size, ) + self.model.netDA.output_shape[1:])\r\n+        fake = np.zeros((self.batch_size, ) + self.model.netDA.output_shape[1:])\r\n+\r\n+        concat_real_inputA = np.array([np.concatenate([target_A[i], warped_A[i]], axis=-1) \r\n+                                       for i in range(self.batch_size)])\r\n+        concat_real_inputB = np.array([np.concatenate([target_B[i], warped_B[i]], axis=-1) \r\n+                                       for i in range(self.batch_size)])\r\n+        concat_fake_inputA = np.array([np.concatenate([gen_masked_imgsA[i], warped_A[i]], axis=-1) \r\n+                                       for i in range(self.batch_size)])\r\n+        concat_fake_inputB = np.array([np.concatenate([gen_masked_imgsB[i], warped_B[i]], axis=-1) \r\n+                                       for i in range(self.batch_size)])\r\n+        if self.use_mixup:\r\n+            lam = np.random.beta(self.mixup_alpha, self.mixup_alpha)\r\n+            mixup_A = lam * concat_real_inputA + (1 - lam) * concat_fake_inputA\r\n+            mixup_B = lam * concat_real_inputB + (1 - lam) * concat_fake_inputB\r\n+\r\n+        # Train the discriminators\r\n+        #print (\"Train the discriminators.\")\r\n+        if self.use_mixup:\r\n+            d_lossA = self.model.netDA.train_on_batch(mixup_A, lam * valid)\r\n+            d_lossB = self.model.netDB.train_on_batch(mixup_B, lam * valid)\r\n+        else:\r\n+            d_lossA = self.model.netDA.train_on_batch(np.concatenate([concat_real_inputA, concat_fake_inputA], axis=0), \r\n+                                                np.concatenate([valid, fake], axis=0))\r\n+            d_lossB = self.model.netDB.train_on_batch(np.concatenate([concat_real_inputB, concat_fake_inputB], axis=0),\r\n+                                                np.concatenate([valid, fake], axis=0))\r\n+\r\n+        # ---------------------\r\n+        #  Train Generators\r\n+        # ---------------------\r\n+\r\n+        # Train the generators\r\n+        #print (\"Train the generators.\")\r\n+        g_lossA = self.model.adversarial_autoencoderA.train_on_batch(warped_A, [target_A, valid])\r\n+        g_lossB = self.model.adversarial_autoencoderB.train_on_batch(warped_B, [target_B, valid])            \r\n+        \r\n+        print('[%s] [%d/%s][%d] Loss_DA: %f Loss_DB: %f Loss_GA: %f Loss_GB: %f'\r\n+              % (time.strftime(\"%H:%M:%S\"), epoch, \"num_epochs\", iter, d_lossA[0], d_lossB[0], g_lossA[0], g_lossB[0]))\r\n+        \r\n+        if viewer is not None:\r\n+            self.show_sample(viewer)\r\n+    \r\n+    def show_sample(self, display_fn):\r\n+        _, wA, tA = next(self.train_batchA)\r\n+        _, wB, tB = next(self.train_batchB)\r\n+        self.showG(tA, tB, display_fn)\r\n+\r\n+    def showG(self, test_A, test_B, display_fn):\r\n+        def display_fig(name, figure_A, figure_B):\r\n+            figure = np.concatenate([figure_A, figure_B], axis=0 )\r\n+            columns = 4\r\n+            elements = figure.shape[0]\r\n+            figure = figure.reshape((columns,(elements//columns)) + figure.shape[1:])\r\n+            figure = stack_images(figure)\r\n+            figure = np.clip((figure + 1) * 255 / 2, 0, 255).astype('uint8')\r\n+            display_fn(figure, name)\r\n+\r\n+        out_test_A_netGA = self.model.netGA.predict(test_A)\r\n+        out_test_A_netGB = self.model.netGB.predict(test_A)\r\n+        out_test_B_netGA = self.model.netGA.predict(test_B)\r\n+        out_test_B_netGB = self.model.netGB.predict(test_B)\r\n+\r\n+        figure_A = np.stack([\r\n+            test_A,\r\n+            out_test_A_netGA[0] * out_test_A_netGA[1] + (1 - out_test_A_netGA[0]) * test_A,\r\n+            out_test_A_netGB[0] * out_test_A_netGB[1] + (1 - out_test_A_netGB[0]) * test_A,\r\n+            ], axis=1 )\r\n+        figure_B = np.stack([\r\n+            test_B,\r\n+            out_test_B_netGB[0] * out_test_B_netGB[1] + (1 - out_test_B_netGB[0]) * test_B,\r\n+            out_test_B_netGA[0] * out_test_B_netGA[1] + (1 - out_test_B_netGA[0]) * test_B,\r\n+            ], axis=1 )\r\n+        \r\n+        display_fig(\"masked\", figure_A, figure_B)\r\n+\r\n+        figure_A = np.stack([\r\n+            test_A,\r\n+            out_test_A_netGA[1],\r\n+            out_test_A_netGB[1],\r\n+            ], axis=1 )\r\n+        figure_B = np.stack([\r\n+            test_B,\r\n+            out_test_B_netGB[1],\r\n+            out_test_B_netGA[1],\r\n+            ], axis=1 )\r\n+        \r\n+        display_fig(\"raw\", figure_A, figure_B)       \r\n+\r\n+        figure_A = np.stack([\r\n+            test_A,\r\n+            np.tile(out_test_A_netGA[0],3) * 2 - 1,\r\n+            np.tile(out_test_A_netGB[0],3) * 2 - 1,\r\n+            ], axis=1 )\r\n+        figure_B = np.stack([\r\n+            test_B,\r\n+            np.tile(out_test_B_netGB[0],3) * 2 - 1,\r\n+            np.tile(out_test_B_netGA[0],3) * 2 - 1,\r\n+            ], axis=1 )\r\n+\r\n+        display_fig(\"alpha_masks\", figure_A, figure_B)\n\\ No newline at end of file\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "While the plugin architecture enhances concurrency, adherence to its formal structure is crucial for maintainability. The exception you're encountering arises from improperly defined parameters in your `minibatch` function. Ensure that it accepts three arguments as expected. Additionally, the `random_transform_args` needs proper definition to resolve the `NameError`. I recommend validating your changes against a test script to catch errors before pushing. Finally, address the warning about trainable weights by ensuring you call `model.compile` after setting `model.trainable`. Consider forking for better compatibility and collaboration."
      }
    ],
    "token_estimation": 5352.5
  },
  {
    "index": 98,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/lib/Serializer.py b/lib/Serializer.py\nnew file mode 100644\nindex 0000000000..aafef801a2\n--- /dev/null\n+++ b/lib/Serializer.py\n@@ -0,0 +1,83 @@\n+import json, pickle\n+class Serializer(object):\n+    ext = \"wtf\"\n+    woptions = \"????\"\n+    roptions = \"????\"\n+\n+    @classmethod\n+    def marshal(cls, input_data):\n+        raise NotImplementedError()\n+\n+    @classmethod\n+    def unmarshal(cls, input_string):\n+        raise NotImplementedError()\n+\n+\n+class YAMLSerializer(Serializer):\n+    ext = \"yml\"\n+    woptions = \"w\"\n+    roptions = \"r\"\n+\n+    @classmethod\n+    def marshal(cls, input_data):\n+        try:\n+            import yaml\n+        except ImportError:\n+            print(\"You must have PyYAML installed to use YAMLSerializer\")\n+        return yaml.dump(input_data, default_flow_style=False)\n+\n+    @classmethod\n+    def unmarshal(cls, input_string):\n+        try:\n+            import yaml\n+        except ImportError:\n+            print(\"You must have PyYAML installed to use YAMLSerializer\")\n+        return yaml.load(input_string)\n+\n+\n+\n+class JSONSerializer(Serializer):\n+    ext = \"json\"\n+    woptions = \"w\"\n+    roptions = \"r\"\n+\n+    @classmethod\n+    def marshal(cls, input_data):\n+        return json.dumps(input_data, indent=2)\n+\n+    @classmethod\n+    def unmarshal(cls, input_string):\n+        return json.loads(input_string)\n+\n+\n+class PickleSerializer(Serializer):\n+    ext = \"p\"\n+    woptions = \"wb\"\n+    roptions = \"rb\"\n+\n+    @classmethod\n+    def marshal(cls, input_data):\n+        return pickle.dumps(input_data)\n+\n+    @classmethod\n+    def unmarshal(cls, input_bytes):\n+        return pickle.loads(input_bytes)\n+\n+def get_serializer(serializer):\n+    if serializer == \"yaml\":\n+        return YAMLSerializer\n+    if serializer == \"json\":\n+        return JSONSerializer\n+    if serializer == \"pickle\":\n+        return PickleSerializer\n+    raise NotImplementedError()\n+\n+\n+def get_serializer_fromext(ext):\n+    if ext in (\".yaml\", \".yml\"):\n+        return YAMLSerializer\n+    if ext == \".json\":\n+        return JSONSerializer\n+    if ext == \".p\":\n+        return PickleSerializer\n+    raise NotImplementedError(\"No serializer matching that file type.\")\ndiff --git a/lib/cli.py b/lib/cli.py\nindex 2cfe23f4f0..848ee2234c 100644\n--- a/lib/cli.py\n+++ b/lib/cli.py\n@@ -49,27 +61,81 @@ def process_arguments(self, arguments):\n         self.filter = self.load_filter()\n         self.process()\n         self.finalize()\n-        \n+\n+    def read_alignments(self):\n+\n+        fn = os.path.join(str(self.arguments.input_dir),\"alignments.{}\".format(self.serializer.ext))\n+        if self.arguments.alignments_path is not None:\n+            fn = self.arguments.alignments_path\n+\n+        try:\n+            print(\"Reading alignments from: {}\".format(fn))\n+            with open(fn, self.serializer.roptions) as f:\n+                self.faces_detected = self.serializer.unmarshal(f.read())\n+        except Exception as e:\n+            print(\"{} not read!\".format(fn))\n+            print(str(e))\n+            self.faces_detected = dict()\n+\n+    def write_alignments(self):\n+\n+        fn = os.path.join(str(self.arguments.input_dir), \"alignments.{}\".format(self.serializer.ext))\n+        if self.arguments.alignments_path is not None:\n+            fn = self.arguments.alignments_path\n+        try:\n+            print(\"Writing alignments to: {}\".format(fn))\n+            with open(fn, self.serializer.woptions) as fh:\n+                fh.write(self.serializer.marshal(self.faces_detected))\n+        except Exception as e:\n+            print(\"{} not written!\".format(fn))\n+            print(str(e))\n+            self.faces_detected = dict()\n+\n     def read_directory(self):\n         self.images_found = len(self.input_dir)\n         return self.input_dir\n-    \n-    def get_faces(self, image):\n+\n+    def have_face(self, filename):\n+        return os.path.basename(filename) in self.faces_detected\n+\n+    def have_alignments(self):\n+        fn = os.path.join(str(self.arguments.input_dir), \"alignments.{}\".format(self.serializer.ext))\n+        return os.path.exists(fn)\n+\n+    def get_faces_alignments(self, filename, image):\n         faces_count = 0\n-        for face in detect_faces(image, self.arguments.detector):\n+        faces = self.faces_detected[os.path.basename(filename)]\n+        for rawface in faces:\n+            face = DetectedFace(**rawface)\n+            face.image = image[face.y : face.y + face.h, face.x : face.x + face.w]\n             if self.filter is not None and not self.filter.check(face):\n                 print('Skipping not recognized face!')\n                 continue\n \n             yield faces_count, face\n+            self.num_faces_detected += 1\n+            faces_count += 1\n+        if faces_count > 1 and self.arguments.verbose:\n+            print('Note: Found more than one face in an image!')\n+            self.verify_output = True\n+\n+    def get_faces(self, image):\n+        faces_count = 0\n+        faces = detect_faces(image, self.arguments.detector)\n+\n+        for face in faces:\n+            if self.filter is not None and not self.filter.check(face):\n+                print('Skipping not recognized face!')\n+                continue\n+            yield faces_count, face\n \n-            self.faces_detected = self.faces_detected + 1\n+            self.num_faces_detected += 1\n             faces_count += 1\n-        \n+\n         if faces_count > 1 and self.arguments.verbose:\n             print('Note: Found more than one face in an image!')\n             self.verify_output = True\n-    \n+\n     def load_filter(self):\n         filter_file = self.arguments.filter\n         if Path(filter_file).exists():\n\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR addresses multiple issues, primarily around the handling of paths and image processing using OpenCV. The type error with `join()` on 'WindowsPath' can be resolved by converting paths to strings. The `convert` function raises an assertion error due to image dimensions, which seems linked to the use of `alignments.json`. It works correctly only with the \"Masked\" converter. Additionally, the implementation misses the `face.image` field required for certain converters. Suggested fixes improve face alignment handling, but further attention is needed on memory usage with the CNN detector on GPU."
      }
    ],
    "token_estimation": 1566.0
  },
  {
    "index": 99,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/lib/gpu_stats/apple_silicon.py b/lib/gpu_stats/apple_silicon.py\nnew file mode 100644\nindex 0000000000..7dc39b106c\n--- /dev/null\n+++ b/lib/gpu_stats/apple_silicon.py\n@@ -0,0 +1,126 @@\n+#!/usr/bin/env python3\n+\"\"\" Collects and returns Information on available Apple Silicon SoCs in Apple Macs. \"\"\"\n+from typing import List\n+\n+import lib.metal as metal\n+\n+from lib.utils import FaceswapError\n+\n+from ._base import GPUStats\n+\n+\n+class AppleSiliconStats(GPUStats):\n+    \"\"\" Holds information and statistics about Apple Silicon SoC(s) available on the currently\n+    running Apple system.\n+\n+    Parameters\n+    ----------\n+    log: bool, optional\n+        Whether the class should output information to the logger. There may be occasions where the\n+        logger has not yet been set up when this class is queried. Attempting to log in these\n+        instances will raise an error. If GPU stats are being queried prior to the logger being\n+        available then this parameter should be set to ``False``. Otherwise set to ``True``.\n+        Default: ``True``\n+    \"\"\"\n+\n+    def _initialize(self) -> None:\n+        \"\"\" Initialize Metal for Apple Silicon SoC(s).\n+\n+        If :attr:`_is_initialized` is ``True`` then this function just returns performing no\n+        action. Otherwise :attr:`is_initialized` is set to ``True`` after successfully\n+        initializing Metal.\n+\n+        Raises\n+        ------\n+        FaceswapError\n+            If the Metal library could not be successfully loaded\n+        \"\"\"\n+        if self._is_initialized:\n+            return\n+        self._log(\"debug\", \"Initializing Metal for Apple Silicon SoC.\")\n+        try:\n+            metal.init()  # pylint:disable=no-member\n+        except RuntimeError as err:\n+            msg = (\"An unhandled exception occured initializing the device via Metal\"\n+                   f\"Library. Original error: {str(err)}\")\n+            raise FaceswapError(msg) from err\n+        super()._initialize()\n+\n+    def _get_device_count(self) -> int:\n+        \"\"\" Detect the number of SoCs attached to the system.\n+\n+        Returns\n+        -------\n+        int\n+            The total number of SoCs available\n+        \"\"\"\n+        retval = metal.get_device_count()  # pylint:disable=no-member\n+        self._log(\"debug\", f\"GPU Device count: {retval}\")\n+        return retval\n+\n+    def _get_handles(self) -> list:\n+        \"\"\" Obtain the device handles for all available Apple Silicon SoCs.\n+\n+        Returns\n+        -------\n+        list\n+            The list of pointers for available Apple Silicon SoCs\n+        \"\"\"\n+        handles = metal.get_handles()  # pylint:disable=no-member\n+        self._log(\"debug\", f\"GPU Handles found: {len(handles)}\")\n+        return handles\n+\n+    def _get_driver(self) -> str:\n+        \"\"\" Obtain the Apple Silicon driver version currently in use.\n+\n+        Returns\n+        -------\n+        str\n+            The current SoC driver version\n+        \"\"\"\n+        driver = metal.get_driver_version()  # pylint:disable=no-member\n+        self._log(\"debug\", f\"GPU Driver: {driver}\")\n+        return driver\n+\n+    def _get_device_names(self) -> List[str]:\n+        \"\"\" Obtain the list of names of available Apple Silicon SoC(s) as identified in :attr:`_handles`.\n+\n+        Returns\n+        -------\n+        list\n+            The list of available Apple Silicon SoC names\n+        \"\"\"\n+        names = metal.get_device_names()\n+        self._log(\"debug\", f\"GPU Devices: {names}\")\n+        return names\n+\n+    def _get_vram(self) -> List[float]:\n+        \"\"\" Obtain the VRAM in Megabytes for each available Apple Silicon SoC(s) as identified in\n+        :attr:`_handles`.\n+\n+        Returns\n+        -------\n+        list\n+            The VRAM in Megabytes for each available Apple Silicon SoC\n+        \"\"\"\n+        vram = [\n+            metal.get_memory_info(i) / (1024 * 1024)\n+            for i in range(self._device_count)]\n+        self._log(\"debug\", f\"GPU VRAM: {vram}\")\n+        return vram\n+\n+    def _get_free_vram(self) -> List[float]:\n+        \"\"\" Obtain the amount of VRAM that is available, in Megabytes, for each available Apple Silicon\n+        SoC.\n+\n+        Returns\n+        -------\n+        list\n+             List of `float`s containing the amount of VRAM available, in Megabytes, for each\n+             available SoC as corresponding to the values in :attr:`_handles\n+        \"\"\"\n+        vram = [\n+            metal.get_memory_info(i) / (1024 * 1024)\n+            for i in range(self._device_count)]\n+        self._log(\"debug\", f\"GPU VRAM free: {vram}\")\n+        return vram\ndiff --git a/lib/metal/__init__.py b/lib/metal/__init__.py\nnew file mode 100644\nindex 0000000000..738353c39b\n--- /dev/null\n+++ b/lib/metal/__init__.py\n@@ -0,0 +1,76 @@\n+from typing import List\n+import os\n+import psutil  # used for getting GPU memory\n+import tensorflow as tf\n+\n+\n+class Constants:\n+    class System:\n+        ARCH = 'arm64'\n+        DEVICE_TYPE = 'GPU'\n+        SET_MEMORY_GROWTH = True\n+\n+    class CUDA:\n+        DRIVER_VERSION_UNSUPPORTED = 0\n+\n+\n+def _dbg_check_mem():\n+    print(\"==========================================\")\n+    print(tf.config.experimental.get_memory_info('GPU:0'))\n+    print(tf.config.list_logical_devices())\n+    print(\"==========================================\")\n+\n+\n+def _validate_metal():\n+    # Validate a GPU exists\n+    assert(len(tf.config.experimental.list_physical_devices('GPU')) > 0)\n+\n+    # Validate Metal device is working\n+    with tf.device('GPU:0'):\n+        assert(tf.math.add(1.0, 2.0) == 3.0)\n+\n+\n+def init(device_type: str = 'GPU') -> None:\n+    # _validate_metal()\n+\n+    os.environ['DISPLAY'] = ':0'\n+    try:\n+        os.system('open -a XQuartz')\n+    except Exception:\n+        pass\n+    Constants.System.DEVICE_TYPE = device_type\n+\n+    # for device in get_devices():\n+    #    tf.config.experimental.set_memory_growth(device, Constants.System.SET_MEMORY_GROWTH)\n+\n+    _dbg_check_mem()\n+\n+\n+def get_devices() -> List[tf.config.PhysicalDevice]:\n+    return tf.config.list_physical_devices(device_type=Constants.System.DEVICE_TYPE)\n+\n+\n+def get_device_count() -> int:\n+    return len(get_devices())\n+\n+\n+def get_handles() -> list:\n+    return list(range(get_device_count()))\n+\n+\n+def get_driver_version() -> int:\n+    # https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART____VERSION.html\n+    return Constants.CUDA.DRIVER_VERSION_UNSUPPORTED\n+\n+\n+def get_device_names() -> List[str]:\n+    return [d.name for d in get_devices()]\n+\n+\n+def get_memory_info(handle: int) -> int:\n+    # Does not work:\n+    #   tf.config.experimental.get_memory_info('GPU:0')\n+    # So, using psutil instead.\n+    # We can just grab the total memory, as it's shared between\n+    # the CPU and the GPU. There is no dedicated VRAM.\n+    return psutil.virtual_memory().total / get_device_count()\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The PR shows promising updates, but it has several PEP 8 violations that need attention. Key issues include lines being too long and missing whitespace around comments in `apple_silicon.py` and `__init__.py`. Additionally, there are inconsistent blank line requirements that should be corrected. While it’s great to see the GPUStats refactor plan, ensure that the code adheres to PEP 8 standards for consistency. Consider using a linter to automate formatting fixes. Also, think about implementing the suggested install script for easier setup."
      }
    ],
    "token_estimation": 1848.75
  },
  {
    "index": 100,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/scripts/convert.py b/scripts/convert.py\nindex 896ed60372..e2b6c3be83 100644\n--- a/scripts/convert.py\n+++ b/scripts/convert.py\n@@ -61,4 +69,88 @@ def process_image(self, filename):\n         except Exception as e:\n             print('Failed to convert image: {}. Reason: {}'.format(filename, e))\n \n+    def get_image_face(self, filename):\n+        try:\n+            image = cv2.imread(filename)\n+            for (idx, face) in enumerate(detect_faces(image)):\n+                if idx > 0 and self.arguments.verbose:\n+                    print('- Found more than one face!')\n+                    self.verify_output = True\n+                return image, face\n+        except Exception as e:\n+            print('Failed to convert image: {}. Reason: {}'.format(filename, e))\n+\n+    def apply_converted_face(self, filename, image, face):\n+        try:\n+            image = self.converter.patch_image(image, face)\n+            self.faces_detected = self.faces_detected + 1\n+            output_file = self.output_dir / Path(filename).name\n+            cv2.imwrite(str(output_file), image)\n+        except Exception as e:\n+            print('Failed to convert image: {}. Reason: {}'.format(filename, e))\n+\n+    def process_directory(self):\n+        # Define some parameters\n+        max_q_size = 30\n+\n+        \"\"\" Use multiprocessing to generate batches in parallel. \"\"\"\n+        try:\n+            queue = multiprocessing.Queue(maxsize=max_q_size)\n+\n+            # define producer (putting items into queue)\n+            def process_image_in_queue(filename, queue):\n+                try:\n+                    img_face = self.get_image_face(filename)\n+                    if self.arguments.verbose:\n+                        print('Preprocessing: {}'.format(os.path.basename(filename)))\n+\n+                    if img_face is not None:\n+                        image, face = img_face\n+                        # Put the data in a queue\n+                        queue.put((filename, image, face))\n+                except Exception as e:\n+                    print('Failed to process image: {}'.format(e))\n+\n+            jobs = []\n+\n+            def process_queue():\n+                from queue import Empty\n+\n+                try:\n+                    while not queue.empty():\n+                        data = queue.get()\n+                        filename, image, face = data\n+                        self.apply_converted_face(filename, image, face)\n+                except Empty:\n+                    pass\n+                except Exception as e:\n+                    print('Error processing a queue: {}'.format(e))\n+\n+            # run as consumer (read items from queue, in current thread)\n+            for filename in self.input_dir:\n+                p = multiprocessing.Process(target=process_image_in_queue, args=(filename, queue,))\n+                jobs.append(p)\n+                p.start()\n+\n+                while len(jobs) >= self.maximum_jobs_count:\n+                    for job in jobs:\n+                        if not job.is_alive():\n+                            jobs.remove(job)\n+                    process_queue()\n+\n+\n+                self.images_processed = self.images_processed + 1\n+\n+            # Process last jobs left in queue\n+            process_queue()\n+\n+\n+        except Exception as e:\n+            print(\"Finishing, exception: {}\".format(e))\n+            for th in jobs:\n+                th.terminate()\n+            queue.close()\n+            raise\n+\n+\n \n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "This PR highlights a significant issue with multi-threaded support in the `convert` function, causing memory errors and CUDA initialization failures. The introduction of the `--jobs -j` argument for core specification is a good enhancement, but there are conflicts with PR #61 that need addressing. The method override in `ExtractTrainingData` lacks correct parameters, which can lead to confusion. Test fixes in Windows also reveal multiprocessing challenges. Consider resolving conflicts and ensuring proper method signatures for a cleaner integration."
      }
    ],
    "token_estimation": 1008.75
  },
  {
    "index": 102,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/requests/packages/__init__.py b/requests/packages/__init__.py\nindex d62c4b7111..ec6a9e0646 100644\n--- a/requests/packages/__init__.py\n+++ b/requests/packages/__init__.py\n@@ -1,3 +1,95 @@\n+\"\"\"\n+Copyright (c) Donald Stufft, pip, and individual contributors\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+\"Software\"), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+\"\"\"\n from __future__ import absolute_import\n \n-from . import urllib3\n+import sys\n+\n+\n+class VendorAlias(object):\n+\n+    def __init__(self):\n+        self._vendor_name = __name__\n+        self._vendor_pkg = self._vendor_name + \".\"\n+\n+    def find_module(self, fullname, path=None):\n+        if fullname.startswith(self._vendor_pkg):\n+            return self\n+\n+    def load_module(self, name):\n+        # Ensure that this only works for the vendored name\n+        if not name.startswith(self._vendor_pkg):\n+            raise ImportError(\n+                \"Cannot import %s, must be a subpackage of '%s'.\" % (\n+                    name, self._vendor_name,\n+                )\n+            )\n+\n+        # Check to see if we already have this item in sys.modules, if we do\n+        # then simply return that.\n+        if name in sys.modules:\n+            return sys.modules[name]\n+\n+        # Check to see if we can import the vendor name\n+        try:\n+            # We do this dance here because we want to try and import this\n+            # module without hitting a recursion error because of a bunch of\n+            # VendorAlias instances on sys.meta_path\n+            real_meta_path = sys.meta_path[:]\n+            try:\n+                sys.meta_path = [\n+                    m for m in sys.meta_path\n+                    if not isinstance(m, VendorAlias)\n+                ]\n+                __import__(name)\n+                module = sys.modules[name]\n+            finally:\n+                # Re-add any additions to sys.meta_path that were made while\n+                # during the import we just did, otherwise things like\n+                # requests.packages.urllib3.poolmanager will fail.\n+                for m in sys.meta_path:\n+                    if m not in real_meta_path:\n+                        real_meta_path.append(m)\n+\n+                # Restore sys.meta_path with any new items.\n+                sys.meta_path = real_meta_path\n+        except ImportError:\n+            # We can't import the vendor name, so we'll try to import the\n+            # \"real\" name.\n+            real_name = name[len(self._vendor_pkg):]\n+            try:\n+                __import__(real_name)\n+                module = sys.modules[real_name]\n+            except ImportError:\n+                raise ImportError(\"No module named '%s'\" % (name,))\n+\n+        # If we've gotten here we've found the module we're looking for, either\n+        # as part of our vendored package, or as the real name, so we'll add\n+        # it to sys.modules as the vendored name so that we don't have to do\n+        # the lookup again.\n+        sys.modules[name] = module\n+\n+        # Finally, return the loaded module\n+        return module\n+\n+\n+sys.meta_path.append(VendorAlias())\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The discussion highlights the complexities of handling unvendoring in the requests library, especially with Debian's SSLv3 support. While it's acknowledged as a downstream issue, there's a consensus on the need for upstream awareness before implementing changes. The proposed patch seems to help align urllib3 imports between projects without breaking user experiences. However, it lacks comprehensive testing, particularly in the requests context. Automated tests are crucial for ensuring stability and maintaining clarity on module imports. More collaboration and feedback from the community are necessary to finalize this approach."
      }
    ],
    "token_estimation": 1175.0
  },
  {
    "index": 103,
    "prompt": [
      {
        "role": "user",
        "content": "diff --git a/requests/structures.py b/requests/structures.py\nindex 8d02ea67b6..bb1f3bc2c0 100644\n--- a/requests/structures.py\n+++ b/requests/structures.py\n@@ -126,3 +126,603 @@ def __getitem__(self, key):\n \n     def get(self, key, default=None):\n         return self.__dict__.get(key, default)\n+\n+# from mitsuihiko/werkzeug\n+BadRequestKeyError = KeyError\n+\n+# from mitsuhiko/werkzeug (slightly altered to use items() instead of iteritems(), and duck-typing for MultiDict)\n+def iter_multi_items(mapping):\n+    \"\"\"Iterates over the items of a mapping yielding keys and values\n+    without dropping any from more complex structures.\n+    \"\"\"\n+    if isinstance(mapping, collections.Mapping):\n+        try:\n+            for item in mapping.items(multi=True):\n+                yield item\n+        except TypeError:\n+            for key, value in mapping.items():\n+                if isinstance(value, (tuple, list)):\n+                    for value in value:\n+                        yield key, value\n+                else:\n+                    yield key, value\n+    else:\n+        for item in mapping:\n+            yield item\n+\n+\n+# from mitsuhiko/werkzeug\n+class _omd_bucket(object):\n+    \"\"\"Wraps values in the :class:`OrderedMultiDict`.  This makes it\n+    possible to keep an order over multiple different keys.  It requires\n+    a lot of extra memory and slows down access a lot, but makes it\n+    possible to access elements in O(1) and iterate in O(n).\n+    \"\"\"\n+    __slots__ = ('prev', 'key', 'value', 'next')\n+\n+    def __init__(self, omd, key, value):\n+        self.prev = omd._last_bucket\n+        self.key = key\n+        self.value = value\n+        self.next = None\n+\n+        if omd._first_bucket is None:\n+            omd._first_bucket = self\n+        if omd._last_bucket is not None:\n+            omd._last_bucket.next = self\n+        omd._last_bucket = self\n+\n+    def unlink(self, omd):\n+        if self.prev:\n+            self.prev.next = self.next\n+        if self.next:\n+            self.next.prev = self.prev\n+        if omd._first_bucket is self:\n+            omd._first_bucket = self.next\n+        if omd._last_bucket is self:\n+            omd._last_bucket = self.prev\n+\n+\n+# from mitsuhiko/werkzeug\n+class _Missing(object):\n+\n+    def __repr__(self):\n+        return 'no value'\n+\n+    def __reduce__(self):\n+        return '_missing'\n+\n+_missing = _Missing()\n+\n+\n+# from mitsuhiko/werkzeug\n+class TypeConversionDict(dict):\n+    \"\"\"Works like a regular dict but the :meth:`get` method can perform\n+    type conversions.  :class:`MultiDict` and :class:`CombinedMultiDict`\n+    are subclasses of this class and provide the same feature.\n+\n+    .. versionadded:: 0.5\n+    \"\"\"\n+\n+    def get(self, key, default=None, type=None):\n+        \"\"\"Return the default value if the requested data doesn't exist.\n+        If `type` is provided and is a callable it should convert the value,\n+        return it or raise a :exc:`ValueError` if that is not possible.  In\n+        this case the function will return the default as if the value was not\n+        found:\n+\n+        >>> d = TypeConversionDict(foo='42', bar='blub')\n+        >>> d.get('foo', type=int)\n+        42\n+        >>> d.get('bar', -1, type=int)\n+        -1\n+\n+        :param key: The key to be looked up.\n+        :param default: The default value to be returned if the key can't\n+                        be looked up.  If not further specified `None` is\n+                        returned.\n+        :param type: A callable that is used to cast the value in the\n+                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n+                     by this callable the default value is returned.\n+        \"\"\"\n+        try:\n+            rv = self[key]\n+            if type is not None:\n+                rv = type(rv)\n+        except (KeyError, ValueError):\n+            rv = default\n+        return rv\n+\n+\n+# from mitsuhiko/werkzeug\n+class MultiDict(TypeConversionDict):\n+    \"\"\"A :class:`MultiDict` is a dictionary subclass customized to deal with\n+    multiple values for the same key which is for example used by the parsing\n+    functions in the wrappers.  This is necessary because some HTML form\n+    elements pass multiple values for the same key.\n+\n+    :class:`MultiDict` implements all standard dictionary methods.\n+    Internally, it saves all values for a key as a list, but the standard dict\n+    access methods will only return the first value for a key. If you want to\n+    gain access to the other values, too, you have to use the `list` methods as\n+    explained below.\n+\n+    Basic Usage:\n+\n+    >>> d = MultiDict([('a', 'b'), ('a', 'c')])\n+    >>> d\n+    MultiDict([('a', 'b'), ('a', 'c')])\n+    >>> d['a']\n+    'b'\n+    >>> d.getlist('a')\n+    ['b', 'c']\n+    >>> 'a' in d\n+    True\n+\n+    It behaves like a normal dict thus all dict functions will only return the\n+    first value when multiple values for one key are found.\n+\n+    From Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\n+    subclass of the :exc:`~exceptions.BadRequest` HTTP exception and will\n+    render a page for a ``400 BAD REQUEST`` if caught in a catch-all for HTTP\n+    exceptions.\n+\n+    A :class:`MultiDict` can be constructed from an iterable of\n+    ``(key, value)`` tuples, a dict, a :class:`MultiDict` or from Werkzeug 0.2\n+    onwards some keyword parameters.\n+\n+    :param mapping: the initial value for the :class:`MultiDict`.  Either a\n+                    regular dict, an iterable of ``(key, value)`` tuples\n+                    or `None`.\n+    \"\"\"\n+\n+    def __init__(self, mapping=None):\n+        if isinstance(mapping, collections.Mapping) and hasattr(mapping, 'iterlists'):\n+            dict.__init__(self, ((k, l[:]) for k, l in mapping.iterlists()))\n+        elif isinstance(mapping, collections.Mapping):\n+            tmp = {}\n+            for key, value in mapping.iteritems():\n+                if isinstance(value, (tuple, list)):\n+                    value = list(value)\n+                else:\n+                    value = [value]\n+                tmp[key] = value\n+            dict.__init__(self, tmp)\n+        else:\n+            tmp = {}\n+            for key, value in mapping or ():\n+                tmp.setdefault(key, []).append(value)\n+            dict.__init__(self, tmp)\n+\n+    def __getstate__(self):\n+        return dict(self.lists())\n+\n+    def __setstate__(self, value):\n+        dict.clear(self)\n+        dict.update(self, value)\n+\n+    def __iter__(self):\n+        return self.iterkeys()\n+\n+    def __getitem__(self, key):\n+        \"\"\"Return the first data value for this key;\n+        raises KeyError if not found.\n+\n+        :param key: The key to be looked up.\n+        :raise KeyError: if the key does not exist.\n+        \"\"\"\n+        if key in self:\n+            return dict.__getitem__(self, key)[0]\n+        raise BadRequestKeyError(key)\n+\n+    def __setitem__(self, key, value):\n+        \"\"\"Like :meth:`add` but removes an existing key first.\n+\n+        :param key: the key for the value.\n+        :param value: the value to set.\n+        \"\"\"\n+        dict.__setitem__(self, key, [value])\n+\n+    def add(self, key, value):\n+        \"\"\"Adds a new value for the key.\n+\n+        .. versionadded:: 0.6\n+\n+        :param key: the key for the value.\n+        :param value: the value to add.\n+        \"\"\"\n+        dict.setdefault(self, key, []).append(value)\n+\n+    def getlist(self, key, type=None):\n+        \"\"\"Return the list of items for a given key. If that key is not in the\n+        `MultiDict`, the return value will be an empty list.  Just as `get`\n+        `getlist` accepts a `type` parameter.  All items will be converted\n+        with the callable defined there.\n+\n+        :param key: The key to be looked up.\n+        :param type: A callable that is used to cast the value in the\n+                     :class:`MultiDict`.  If a :exc:`ValueError` is raised\n+                     by this callable the value will be removed from the list.\n+        :return: a :class:`list` of all the values for the key.\n+        \"\"\"\n+        try:\n+            rv = dict.__getitem__(self, key)\n+        except KeyError:\n+            return []\n+        if type is None:\n+            return list(rv)\n+        result = []\n+        for item in rv:\n+            try:\n+                result.append(type(item))\n+            except ValueError:\n+                pass\n+        return result\n+\n+    def setlist(self, key, new_list):\n+        \"\"\"Remove the old values for a key and add new ones.  Note that the list\n+        you pass the values in will be shallow-copied before it is inserted in\n+        the dictionary.\n+\n+        >>> d = MultiDict()\n+        >>> d.setlist('foo', ['1', '2'])\n+        >>> d['foo']\n+        '1'\n+        >>> d.getlist('foo')\n+        ['1', '2']\n+\n+        :param key: The key for which the values are set.\n+        :param new_list: An iterable with the new values for the key.  Old values\n+                         are removed first.\n+        \"\"\"\n+        dict.__setitem__(self, key, list(new_list))\n+\n+    def setdefault(self, key, default=None):\n+        \"\"\"Returns the value for the key if it is in the dict, otherwise it\n+        returns `default` and sets that value for `key`.\n+\n+        :param key: The key to be looked up.\n+        :param default: The default value to be returned if the key is not\n+                        in the dict.  If not further specified it's `None`.\n+        \"\"\"\n+        if key not in self:\n+            self[key] = default\n+        else:\n+            default = self[key]\n+        return default\n+\n+    def setlistdefault(self, key, default_list=None):\n+        \"\"\"Like `setdefault` but sets multiple values.  The list returned\n+        is not a copy, but the list that is actually used internally.  This\n+        means that you can put new values into the dict by appending items\n+        to the list:\n+\n+        >>> d = MultiDict({\"foo\": 1})\n+        >>> d.setlistdefault(\"foo\").extend([2, 3])\n+        >>> d.getlist(\"foo\")\n+        [1, 2, 3]\n+\n+        :param key: The key to be looked up.\n+        :param default: An iterable of default values.  It is either copied\n+                        (in case it was a list) or converted into a list\n+                        before returned.\n+        :return: a :class:`list`\n+        \"\"\"\n+        if key not in self:\n+            default_list = list(default_list or ())\n+            dict.__setitem__(self, key, default_list)\n+        else:\n+            default_list = dict.__getitem__(self, key)\n+        return default_list\n+\n+    def items(self, multi=True):\n+        \"\"\"Return a list of ``(key, value)`` pairs.\n+\n+        :param multi: If set to `True` the list returned will have a\n+                      pair for each value of each key.  Otherwise it\n+                      will only contain pairs for the first value of\n+                      each key.\n+\n+        :return: a :class:`list`\n+        \"\"\"\n+        return list(self.iteritems(multi))\n+\n+    def lists(self):\n+        \"\"\"Return a list of ``(key, values)`` pairs, where values is the list of\n+        all values associated with the key.\n+\n+        :return: a :class:`list`\n+        \"\"\"\n+        return list(self.iterlists())\n+\n+    def values(self):\n+        \"\"\"Returns a list of the first value on every key's value list.\n+\n+        :return: a :class:`list`.\n+        \"\"\"\n+        return [self[key] for key in self.iterkeys()]\n+\n+    def listvalues(self):\n+        \"\"\"Return a list of all values associated with a key.  Zipping\n+        :meth:`keys` and this is the same as calling :meth:`lists`:\n+\n+        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n+        >>> zip(d.keys(), d.listvalues()) == d.lists()\n+        True\n+\n+        :return: a :class:`list`\n+        \"\"\"\n+        return list(self.iterlistvalues())\n+\n+    def iteritems(self, multi=True):\n+        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n+        for key, values in dict.iteritems(self):\n+            if multi:\n+                for value in values:\n+                    yield key, value\n+            else:\n+                yield key, values[0]\n+\n+    def iterlists(self):\n+        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n+        for key, values in dict.iteritems(self):\n+            yield key, list(values)\n+\n+    def itervalues(self):\n+        \"\"\"Like :meth:`values` but returns an iterator.\"\"\"\n+        for values in dict.itervalues(self):\n+            yield values[0]\n+\n+    def iterlistvalues(self):\n+        \"\"\"Like :meth:`listvalues` but returns an iterator.\"\"\"\n+        return dict.itervalues(self)\n+\n+    def copy(self):\n+        \"\"\"Return a shallow copy of this object.\"\"\"\n+        return self.__class__(self)\n+\n+    def to_dict(self, flat=True):\n+        \"\"\"Return the contents as regular dict.  If `flat` is `True` the\n+        returned dict will only have the first item present, if `flat` is\n+        `False` all values will be returned as lists.\n+\n+        :param flat: If set to `False` the dict returned will have lists\n+                     with all the values in it.  Otherwise it will only\n+                     contain the first value for each key.\n+        :return: a :class:`dict`\n+        \"\"\"\n+        if flat:\n+            return dict(self.iteritems())\n+        return dict(self.lists())\n+\n+    def update(self, other_dict):\n+        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n+        for key, value in iter_multi_items(other_dict):\n+            MultiDict.add(self, key, value)\n+\n+    def pop(self, key, default=_missing):\n+        \"\"\"Pop the first item for a list on the dict.  Afterwards the\n+        key is removed from the dict, so additional values are discarded:\n+\n+        >>> d = MultiDict({\"foo\": [1, 2, 3]})\n+        >>> d.pop(\"foo\")\n+        1\n+        >>> \"foo\" in d\n+        False\n+\n+        :param key: the key to pop.\n+        :param default: if provided the value to return if the key was\n+                        not in the dictionary.\n+        \"\"\"\n+        try:\n+            return dict.pop(self, key)[0]\n+        except KeyError as e:\n+            if default is not _missing:\n+                return default\n+            raise BadRequestKeyError(str(e))\n+\n+    def popitem(self):\n+        \"\"\"Pop an item from the dict.\"\"\"\n+        try:\n+            item = dict.popitem(self)\n+            return (item[0], item[1][0])\n+        except KeyError as e:\n+            raise BadRequestKeyError(str(e))\n+\n+    def poplist(self, key):\n+        \"\"\"Pop the list for a key from the dict.  If the key is not in the dict\n+        an empty list is returned.\n+\n+        .. versionchanged:: 0.5\n+           If the key does no longer exist a list is returned instead of\n+           raising an error.\n+        \"\"\"\n+        return dict.pop(self, key, [])\n+\n+    def popitemlist(self):\n+        \"\"\"Pop a ``(key, list)`` tuple from the dict.\"\"\"\n+        try:\n+            return dict.popitem(self)\n+        except KeyError as e:\n+            raise BadRequestKeyError(str(e))\n+\n+    def __copy__(self):\n+        return self.copy()\n+\n+    def __repr__(self):\n+        return '%s(%r)' % (self.__class__.__name__, self.items(multi=True))\n+\n+\n+# from mitsuhiko/werkzeug (with the exception of all iterators, which default to multi=True, instead of werkzeug's\n+#                          multi=False)\n+class OrderedMultiDict(MultiDict):\n+    \"\"\"Works like a regular :class:`MultiDict` but preserves the\n+    order of the fields.  To convert the ordered multi dict into a\n+    list you can use the :meth:`items` method and pass it ``multi=True``.\n+\n+    In general an :class:`OrderedMultiDict` is an order of magnitude\n+    slower than a :class:`MultiDict`.\n+\n+    .. admonition:: note\n+\n+       Due to a limitation in Python you cannot convert an ordered\n+       multi dict into a regular dict by using ``dict(multidict)``.\n+       Instead you have to use the :meth:`to_dict` method, otherwise\n+       the internal bucket objects are exposed.\n+    \"\"\"\n+\n+    def __init__(self, mapping=None):\n+        dict.__init__(self)\n+        self._first_bucket = self._last_bucket = None\n+        if mapping is not None:\n+            OrderedMultiDict.update(self, mapping)\n+\n+    def __eq__(self, other):\n+        if not hasattr(other, 'iterlists'):\n+            return NotImplemented\n+        if isinstance(other, OrderedMultiDict):\n+            iter1 = self.iteritems(multi=True)\n+            iter2 = other.iteritems(multi=True)\n+            try:\n+                for k1, v1 in iter1:\n+                    k2, v2 = iter2.next()\n+                    if k1 != k2 or v1 != v2:\n+                        return False\n+            except StopIteration:\n+                return False\n+            try:\n+                iter2.next()\n+            except StopIteration:\n+                return True\n+            return False\n+        if len(self) != len(other):\n+            return False\n+        for key, values in self.iterlists():\n+            if other.getlist(key) != values:\n+                return False\n+        return True\n+\n+    def __ne__(self, other):\n+        return not self.__eq__(other)\n+\n+    def __reduce_ex__(self, protocol):\n+        return type(self), (self.items(multi=True),)\n+\n+    def __getstate__(self):\n+        return self.items(multi=True)\n+\n+    def __setstate__(self, values):\n+        dict.clear(self)\n+        for key, value in values:\n+            self.add(key, value)\n+\n+    def __getitem__(self, key):\n+        if key in self:\n+            return dict.__getitem__(self, key)[0].value\n+        raise BadRequestKeyError(key)\n+\n+    def __setitem__(self, key, value):\n+        self.poplist(key)\n+        self.add(key, value)\n+\n+    def __delitem__(self, key):\n+        self.pop(key)\n+\n+    def iterkeys(self):\n+        return (key for key, value in self.iteritems())\n+\n+    def itervalues(self):\n+        return (value for key, value in self.iteritems())\n+\n+    def iteritems(self, multi=True):\n+        ptr = self._first_bucket\n+        if multi:\n+            while ptr is not None:\n+                yield ptr.key, ptr.value\n+                ptr = ptr.next\n+        else:\n+            returned_keys = set()\n+            while ptr is not None:\n+                if ptr.key not in returned_keys:\n+                    returned_keys.add(ptr.key)\n+                    yield ptr.key, ptr.value\n+                ptr = ptr.next\n+\n+    def iterlists(self):\n+        returned_keys = set()\n+        ptr = self._first_bucket\n+        while ptr is not None:\n+            if ptr.key not in returned_keys:\n+                yield ptr.key, self.getlist(ptr.key)\n+                returned_keys.add(ptr.key)\n+            ptr = ptr.next\n+\n+    def iterlistvalues(self):\n+        for key, values in self.iterlists():\n+            yield values\n+\n+    def add(self, key, value):\n+        dict.setdefault(self, key, []).append(_omd_bucket(self, key, value))\n+\n+    def getlist(self, key, type=None):\n+        try:\n+            rv = dict.__getitem__(self, key)\n+        except KeyError:\n+            return []\n+        if type is None:\n+            return [x.value for x in rv]\n+        result = []\n+        for item in rv:\n+            try:\n+                result.append(type(item.value))\n+            except ValueError:\n+                pass\n+        return result\n+\n+    def setlist(self, key, new_list):\n+        self.poplist(key)\n+        for value in new_list:\n+            self.add(key, value)\n+\n+    def setlistdefault(self, key, default_list=None):\n+        raise TypeError('setlistdefault is unsupported for '\n+                        'ordered multi dicts')\n+\n+    def update(self, mapping):\n+        for key, value in iter_multi_items(mapping):\n+            OrderedMultiDict.add(self, key, value)\n+\n+    def poplist(self, key):\n+        buckets = dict.pop(self, key, ())\n+        for bucket in buckets:\n+            bucket.unlink(self)\n+        return [x.value for x in buckets]\n+\n+    def pop(self, key, default=_missing):\n+        try:\n+            buckets = dict.pop(self, key)\n+        except KeyError as e:\n+            if default is not _missing:\n+                return default\n+            raise BadRequestKeyError(str(e))\n+        for bucket in buckets:\n+            bucket.unlink(self)\n+        return buckets[0].value\n+\n+    def popitem(self):\n+        try:\n+            key, buckets = dict.popitem(self)\n+        except KeyError as e:\n+            raise BadRequestKeyError(str(e))\n+        for bucket in buckets:\n+            bucket.unlink(self)\n+        return key, buckets[0].value\n+\n+    def popitemlist(self):\n+        try:\n+            key, buckets = dict.popitem(self)\n+        except KeyError as e:\n+            raise BadRequestKeyError(str(e))\n+        for bucket in buckets:\n+            bucket.unlink(self)\n+        return key, [x.value for x in buckets]\n\\ No newline at end of file\n\n"
      }
    ],
    "completion": [
      {
        "role": "assistant",
        "content": "The implementation of `to_key_val_list` needs adjustments. It mishandles non-standard mappings like `CaseInsensitiveDict` and fails with sequences that don’t contain 2-tuples. Switching from `dict` checks to `collections.Mapping` improves compatibility. I recommend simplifying type checks and utilizing a list comprehension for clarity. Regarding the `.update` method, it should overwrite keys, aligning with expected behavior, rather than adding duplicates. Let’s clarify whether to allow updates for existing session keys while considering potential use case variations."
      }
    ],
    "token_estimation": 5348.75
  }
]